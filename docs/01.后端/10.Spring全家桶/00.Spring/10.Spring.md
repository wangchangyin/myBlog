---
title: Spring
date: 2021-07-19 10:29:37
permalink: /pages/9f1398/
categories: 
  - 后端
  - Spring全家桶
  - Spring
tags: 
  - null
---
# Spring笔记

## 1.IOC底层原理

> IOC底层原理设计：XML解析、工厂模式、反射

### 1.1.以前对象中使用另一个对象的方式

![image-20210719111232144](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719111232144.png)

### 1.2.升级版（工厂模式）

![image-20210719111401913](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719111401913.png)

### 1.3.IOC中调用对象

1. XML文件，注册Bean
2. 创建工程，解析XML文件，获取类路径
3. 通过反射获取对象

![image-20210719111740435](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719111740435.png)

## 2.IOC中的接口

IOC思想基于IOC容器完成，ICO容器底层就是对象工厂；

IOC中提供两大接口：

1. BeanFactory：IOC容器底层使用的就是该接口，不提供开发人员进行使用；在加载配置文件的时候不会创建对象，在获取对象（getBean()）才会去创建对象；

2. ApplicationContext：BeanFactory的子接口，提供更强大的功能，一般由开发人员进行使用；加载配置文件时就会创建对象。（推荐使用，Tomcat启动就会去创建对象）

   ApplicationContext接口的实现：

   - FileSystemXmlApplicationContext：在磁盘了寻找（完整路径）
   - ClassPathXmlApplicationContext：在项目的类路径寻找XML文件

   ![image-20210719113009180](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719113009180.png)

## 3.Bean管理

### 3.1.基于XML管理bean（手动装配）

#### 3.1.1.基于XML文件创建对象

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">
    <bean id="PersonService" class="com.hand.service.impl.PersonServiceImpl"></bean>
</beans>
```

![image-20210719144119398](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719144119398.png)

#### 3.1.2.基于XML文件注入属性（DI）

- 构造器注入：

  提供对象、List、Set、Map、propertys等类型

  ```
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                          http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">
      <bean id="User2" class="com.hand.dto.User">
          <constructor-arg name="name" value="李四"></constructor-arg>
          <constructor-arg name="age" value="22"></constructor-arg>
          <constructor-arg name="testList" >
              <list>
                  <value>list1</value>
                  <value>list2</value>
                  <value>list3</value>
              </list>
          </constructor-arg>
          <constructor-arg name="testSet">
              <set>
                  <value>set1</value>
                  <value>set2</value>
                  <value>set3</value>
              </set>
          </constructor-arg>
          <constructor-arg name="testArrays">
              <array>
                  <value>array1</value>
                  <value>array2</value>
                  <value>array3</value>
              </array>
          </constructor-arg>
          <constructor-arg name="testMap">
              <map>
                  <entry key="key1" value="val1"></entry>
                  <entry key="key2" value="val2"></entry>
                  <entry key="key3" value="val3"></entry>
              </map>
          </constructor-arg>
          <constructor-arg name="testProperties">
              <props>
                  <prop key="key1">val1</prop>
                  <prop key="key2">val2</prop>
                  <prop key="key3">val3</prop>
              </props>
          </constructor-arg>
      </bean>
  </beans>
  ```

- Set注入

  ```
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                          http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">
      <bean id="User" class="com.hand.dto.User">
          <property name="name" value="李四"></property>
          <property name="age" value="21"></property>
          <property name="testList">
              <list>
                  <value>list1</value>
                  <value>list2</value>
                  <value>list3</value>
              </list>
          </property>
          <property name="testArrays">
              <array>
                  <value>array1</value>
                  <value>array2</value>
                  <value>array3</value>
              </array>
          </property>
          <property name="testSet">
              <set>
                  <value>set1</value>
                  <value>set2</value>
                  <value>set3</value>
              </set>
          </property>
          <property name="testMap">
              <map>
                  <entry key="key1" value="val1"></entry>
                  <entry key="key2" value="val2"></entry>
                  <entry key="key3" value="val3"></entry>
              </map>
          </property>
          <property name="testProperties">
              <props>
                  <prop key="key1">val1</prop>
                  <prop key="key2">val2</prop>
                  <prop key="key3">val3</prop>
              </props>
          </property>
      </bean>
  </beans>
  ```

- P命名空间注入（其实就是简化set注入）

  ![image-20210719145421142](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719145421142.png)

#### 3.1.3.注入特殊符号

1. 注入空值

   ```
       <bean id="User2" class="com.hand.dto.User">
           <property name="name">
               <null></null>
           </property>
       </bean>
   ```

2. 注入特殊符号

    方法一：通过转义&lt;&gt;

   ```
       <bean id="User2" class="com.hand.dto.User">
           <property name="name" value="&lt;南京&gt;">
           </property>
       </bean>
   ```

   方法二:CDATA的方式

   ```
       <bean id="User2" class="com.hand.dto.User">
           <property name="name" value="&lt;南京&gt;">
           </property>
           <property name="age" value="<![CDATA[<南京>]]>">
           </property>
       </bean>
   ```

#### 3.1.4.导入外部bean

通过ref导入

![image-20210719150554784](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719150554784.png)

#### 3.1.5.注入内部bean

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">
	<!--注入内部bean-->
    <bean id="User" class="com.hand.dto.User">
        <property name="objectTest">
            <bean>
                <property name="name" value="测试"></property>
            </bean>
        </property>
    </bean>
</beans>
```

### 3.2.工厂Bean

> 返回类型与定义的类型可以不一致

```
package com.hand.factory;

import com.hand.dto.User;
import org.springframework.beans.factory.FactoryBean;

public class MyBean implements FactoryBean<User> {
    //定义返回的类型
    @Override
    public User getObject() throws Exception {
        User user=new User();
        return user;
    }

    @Override
    public Class<?> getObjectType() {
        return null;
    }

    @Override
    public boolean isSingleton() {
        return false;
    }
}

```

配置：

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">

    <bean id="mybean" class="com.hand.factory.MyBean"></bean>
</beans>
```

测试

```
package com.hand;

import com.hand.factory.MyBean;
import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test1 {
    @Test
    public void test1(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        MyBean myBean = (MyBean)applicationContext.getBean(MyBean.class);
        System.out.println(myBean);
    }
}
```

### 3.3.bean的作用域

1. singleton：单例（默认），启动项目后，就会创建bean
2. prototype：原型，每次使用都会创建新的对象
3. request：一次请求中
4. session：一次回话中

### 3.4.bean的生命周期

1. **通过构造方法创建bean的实例**
2. 为bean设置属性值和对其他的bean的引用（调用set方法）
3. 前置通知，在初始化之前执行（需要自己创建）
4. bean的初始化的方法（需要自己创建初始化的方法）
5. 后置通知，在初始化之后执行（需要自己创建）
6. **bean就可以使用了（获取到对象）**
7. 销毁bean（也需要自己创建）

实现：

> 1. **通过构造方法创建bean的实例**
> 2. 为bean设置属性值和对其他的bean的引用（调用set方法）
> 3. 前置通知，在初始化之前执行（需要自己创建）
> 4. bean的初始化的方法（需要自己创建初始化的方法）
> 5. 后置通知，在初始化之后执行（需要自己创建）
> 6. **bean就可以使用了（获取到对象）**
> 7. 销毁bean（也需要自己创建）

1. 创建bean

   ```
   package com.hand.bean;
   
   /**
    * bean的生命周期
    */
   public class BeanCycle {
       private String name;
   
       public String getName() {
           return name;
       }
       public void setName(String name) {
           System.out.println("第二步：bean设置值");
           this.name = name;
       }
   
       public BeanCycle() {
           System.out.println("第一步：构造方法执行");
       }
   
       public void initMethod(){
           System.out.println("第四步：初始化方法");
       }
   
       public void destroyMethod(){
           System.out.println("第七部：bean销毁方法");
       }
   }
   ```

2. 创建后置bean

   ```
   package com.hand.bean;
   
   import org.springframework.beans.BeansException;
   import org.springframework.beans.factory.config.BeanPostProcessor;
   
   /**
    * bean的后置处理
    */
   public class BeanProcess implements BeanPostProcessor {
       @Override
       public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
           System.out.println("第三部：后置方法之前");
           return bean;
       }
   
       @Override
       public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
           System.out.println("第五部：后置方法之后");
           return bean;
       }
   }
   
   ```

3. 注册bean，
   > 注意注意：后置方法 会作用于该文件的所有bean，也就是说所有的bean都会执行该方法

   ```
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:p="http://www.springframework.org/schema/p"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">
       <!--bean生命周期-->
       <bean id="beanCycle" class="com.hand.bean.BeanCycle" init-method="initMethod" destroy-method="destroyMethod">
           <property name="name" value="测试"></property>
       </bean>
       <!--后置方法 该配置文件的所有bean都会执行该后置方法-->
       <bean id="beanProcess" class="com.hand.bean.BeanProcess">
       </bean>
   </beans>
   ```
   
4. 测试：

   ```
   package com.hand;
   
   import com.hand.bean.BeanCycle;
   import org.junit.jupiter.api.Test;
   import org.springframework.context.support.ClassPathXmlApplicationContext;
   
   public class Test1 {
       @Test
       public void test1(){
           ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
           BeanCycle myBean = (BeanCycle)applicationContext.getBean(BeanCycle.class);
           System.out.println("第六步：可以使用bean了");
           applicationContext.close();
           System.out.println("第七步：销毁bean了");
       }
   }
   ```

5. 输出：

   ![image-20210719192841312](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719192841312.png)

### 3.5.自动装配

> 手动装配：注册一个bean时，通过property进行赋值
>
> ```
>     <bean id="beanCycle" class="com.hand.bean.BeanCycle">
>         <property name="name" ref="beanProcess"></property>
>     </bean>
>     <bean id="beanProcess" class="com.hand.bean.BeanProcess">
>     </bean>
> ```
>
> 自动装配：
>
> 1. autowire="byName"：bean的属性名和注册的bean的ID要一致
> 2. autowire="byType"：根据bean的类型匹配
>
> ```
>     <bean id="beanCycle" class="com.hand.bean.BeanCycle" autowire="byName">
>         <property name="name" ref="beanProcess"></property>
>     </bean>
>     <bean id="beanProcess" class="com.hand.bean.BeanProcess">
>     </bean>
> ```

### 3.6.引入外部配置文件（properties文件）

> 常见的就是引入数据库连接池

##### 3.6.1.以前配置连接池信息：

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                        http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/context
                       http://www.springframework.org/schema/context/spring-context.xsd">

    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/userDB"></property>
        <property name="username" value="root"></property>
        <property name="password" value="root"></property>
    </bean>
</beans>
```

##### 3.6.2.新版写法引入外部文件

配置文件：jdbc.properties

```
jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/userDB
jdbc.username=root
jdbc.password=root
```

applicationContext.xml的配置

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                        http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/context
                        http://www.springframework.org/schema/context/spring-context.xsd">
    <!--新版写法-->
    <!--引入外部配置文件-->
    <context:property-placeholder location="jdbc.properties"/>
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driverClassName}"></property>
        <property name="url" value="${jdbc.url}"></property>
        <property name="username" value="${jdbc.username}"></property>
        <property name="password" value="${jdbc.password}"></property>
    </bean>
</beans>
```

### 3.7.基于注解管理bean

#### 3.7.1.创建bean

1. 导入依赖

   ```
       <dependency>
         <groupId>org.springframework</groupId>
         <artifactId>spring-aop</artifactId>
         <version>5.2.6.RELEASE</version>
       </dependency>
   ```

2. 开启组件扫描

   ```
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:aop="http://www.springframework.org/schema/aop"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
       <!--开启包扫描，多个包用逗号隔开-->
   	<context:component-scan base-package="com.hand"></context:component-scan>-->
   </beans>
   ```

   扩展：

   示例一：扫描com.hand包，但是不使用默认的过滤器

   ```
   <context: component-scan base-package="com.hand" use-default-filters="false">
      <!--只扫描注解是Controller的类-->
      <context:include-filter type="annotation"
       expression="org.springframework.stereotype.Controller"/>
   </context:component-scan>
   ```

   示例二：

   ```
   <!--下面配置扫描包所有内容,context:exclude-filter:设置哪些内容不进行扫描-->
   <context:component-scan base package="com.hand">
       <context:exclude-filter type="annotation"
       expression="org.springframework.stereotype.Controller"/>
   </context:component-scan>
   ```

3. 通过@Componet、@service、@Controller、@Repository注入到Spirng中

#### 3.7.2.属性注入

1. @Autowired：根据属性类型注入

   直接引入对象，内部封装了set方法

2. @Qualifier：根据名称注入

   必须配合@Autowired使用

   ```
   @Repository(value="userdaodaodao")
   public UserDao{
   	public void add(){
   		...
   	}
   }
   
   引用：
   public UserService{
   	@Autowired
   	@Qualifier("userdaodaodao")
   	private UserDao userDao;
   	public void add(){
   		userDao.add();
   		...
   	}
   }
   ```

3. @Resourse：可以根据类型注入，也可以根据名称注入

   ```
   @Repository(value="userdaodaodao")
   public UserDao{
   	public void add(){
   		...
   	}
   }
   
   引用：
   public UserService{
   	@Resourse("userdaodaodao")
   	private UserDao userDao;
   	public void add(){
   		userDao.add();
   		...
   	}
   }
   ```

4. @Value

   ```
   public UserService{
   	@Value("abc")
   	private String name;
   	@Resourse("userdaodaodao")
   	private UserDao userDao;
   	public void add(){
   		userDao.add();
   		...
   	}
   }
   ```

### 3.4.全注解开发

配置文件改为配置类：

```
package com.hand.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan("com.hand")  //扫包
@EnableAspectJAutoProxy(proxyTargetClass=true) //开启AOP
public class AopConfig {
}
```

测试：

```
    @Test
    public void test2(){
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AopConfig.class);
        BeanCycle myBean = (BeanCycle)applicationContext.getBean(BeanCycle.class);
    }
```

## 4.AOP

AOP：面向切面编程，是OOP的补充；比如我们可以把权限控制、事务控制、日志管理把这些重复的业务代码抽离出来，通过配置的方式（或注解）引入到需要的地方。

![image-20210719153955006](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719153955006.png)

### 1.JDK动态代理（需要接口）

通过接口创建代理实现类，增强类的方法

![image-20210719154614500](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719154614500.png)

#### 代码实现：

1. service、serviceimpl方法，需要植入到该类的方法中

2. 定义切面

   ```
   package com.hand.aspect;
   
   public class MyAspect {
       public void before(){
           System.out.println("方法执行前。。。。");
       }
       public void after(){
           System.out.println("方法执行后。。。。");
       }
   }
   
   ```

3. 代理类

4. Proxy.newProxyInstance(类加载器，接口，InvocationHandler对象)方法获取代理对象

   ```
   package com.hand.aspect;
   
   import com.hand.service.IPersonService;
   import org.springframework.context.ApplicationContext;
   import org.springframework.context.support.ClassPathXmlApplicationContext;
   
   import java.lang.reflect.InvocationHandler;
   import java.lang.reflect.Method;
   import java.lang.reflect.Proxy;
   
   public class JdkProxy implements InvocationHandler {
       private Object target ;//需要代理的目标对象
       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           MyAspect myAspect=new MyAspect();
           myAspect.before();//方法执行前
           Object result = method.invoke(target, args);
           myAspect.after();//方法执行后
           return result;
       }
       //定义获取代理对象方法
       private Object getJDKProxy(Object targetObject){
           //为目标对象target赋值
           this.target = targetObject;
           //JDK动态代理只能针对实现了接口的类进行代理，newProxyInstance 函数所需参数就可看出
           return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),
                   targetObject.getClass().getInterfaces(),
                   this);
       }
   
       public static void main(String[] args) {
           JdkProxy jdkProxy = new JdkProxy();//实例化JDKProxy对象
           ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
           IPersonService personService = (UserManagerImpl)jdkProxy.getJDKProxy((UserManagerImpl) applicationContext.getBean("UserManagerImpl"));
           personService.add();
       }
   }
   ```

### 2.CGlib动态代理（会创建子类）

![image-20210719154903807](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719154903807.png)

```
package com.hand.aspect;

import com.hand.service.IPersonService;
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.lang.reflect.Method;

public class CglibProxy implements MethodInterceptor {
    private Object target ;//需要代理的目标对象
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        MyAspect myAspect=new MyAspect();
        myAspect.before();//方法执行前
        Object invoke = method.invoke(target, objects);
        myAspect.after();//方法执行后
        return invoke;
    }
    //定义获取代理对象方法
    public Object getCglibProxy(Object objectTarget){
        //为目标对象target赋值
        this.target = objectTarget;
        Enhancer enhancer = new Enhancer();
        //设置父类,因为Cglib是针对指定的类生成一个子类，所以需要指定父类
        enhancer.setSuperclass(objectTarget.getClass());
        enhancer.setCallback(this);// 设置回调
        Object result = enhancer.create();//创建并返回代理对象
        return result;
    }
    public static void main(String[] args) {
        CglibProxy cglibProxy = new CglibProxy();//实例化JDKProxy对象
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        IPersonService personService = (IPersonService)cglibProxy.getCglibProxy((IPersonService) applicationContext.getBean("PersonService"));
        personService.add();
    }
}

```

### 3.JDK动态代理和CGLIB字节码生成的区别？

>  （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类
>  （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法
>   因为是继承，所以该类或方法最好不要声明成final 

### 4.AOP的术语

![image-20210719161149858](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719161149858.png)

### 5.Spring中使用AOP

#### 准备工作：

AspectJ不是Spring的组成部分，独立的AOP框架，一般把AspectJ与Spring一起使用，进行AOP的操作

#### 实现方式

1. 基于XML文件实现
2. 基于注解的方式（常用）

#### 切入点表达式

> execution(【权限控制】【返回类型】【包名】【方法名】（【参数】）)

案列一:com.wcy.add的Person的add方法增强

```
execution(*com.wcy.Person.add(..))
```

案列二:com.wcy.add的Person的所有方法增强

```
execution(*com.wcy.Person.*(..))
```

案列三:com.wcy.add的所有类的所有方法增强

```
xxxxxxxxxx execution(*com.wcy.*.*(..))
```

#### 引入依赖

```
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>5.2.6.RELEASE</version>
    </dependency>
    <!--AOP-->
    <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>1.9.4</version>
    </dependency>
```

#### 注解实现（重点）

1. 定义一个需要增强的类，比如UserService、UserServiceImpl

2. 开启包扫描、开启AOP

   ```
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:aop="http://www.springframework.org/schema/aop"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
       <!--开启包扫描-->
       <context:component-scan base-package="com.hand"></context:component-scan>
       <!--开启AOP-->
       <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
   </beans>
   ```

   可以换成配置类实现：

   ```
   package com.hand.config;
   
   import org.springframework.context.annotation.ComponentScan;
   import org.springframework.context.annotation.Configuration;
   import org.springframework.context.annotation.EnableAspectJAutoProxy;
   
   @Configuration
   @ComponentScan("com.hand")  //扫包
   @EnableAspectJAutoProxy(proxyTargetClass=true) //开启AOP
   public class AopConfig {
   }
   
   ```

   

3. 定义切面，定义通知类型

   - @Before("pointcut()")//前置通知
   - @After("pointcut()")//后置通知 最终通知
   - @AfterReturning("pointcut()")//返回结果才执行  异常不执行
   - @AfterThrowing(value = "pointcut()", throwing = "ex") //异常通知
   -  @Around("pointcut()") //环绕通知 异常执行前半部分

   ```
   package com.hand.aspect;
   
   import org.aspectj.lang.JoinPoint;
   import org.aspectj.lang.ProceedingJoinPoint;
   import org.aspectj.lang.annotation.*;
   import org.springframework.core.annotation.Order;
   import org.springframework.stereotype.Component;
   
   import java.io.PrintWriter;
   import java.io.StringWriter;
   import java.util.Arrays;
   import java.util.List;
   
   @Component
   @Aspect
   @Order(1) //多个切面定义优先级，越小优先级越高
   public class AnnotationProxy {
       @Pointcut("execution(* com.hand.*.*.*(..))")
       public void pointcut() {
   
       }
   
       @Before("pointcut()")//前置通知
       public static void before(JoinPoint joinPoint) {
           //方法名
           String method = joinPoint.getSignature().getName();
           //参数
           List<Object> args = Arrays.asList(joinPoint.getArgs());
   
           System.out.println("方法执行前");
       }
   
       @After("pointcut()")//后置通知 最终通知
       public static void after() {
           System.out.println("方法执行后");
       }
       @AfterReturning("pointcut()")//返回结果才执行  异常不执行
       public static void afterReturning() {
           System.out.println("方法返回后");
       }
   
       //异常执行
       @AfterThrowing(value = "pointcut()", throwing = "ex")
       public static void afterException(Exception ex) {
           StringWriter sw = new StringWriter();
           ex.printStackTrace(new PrintWriter(sw, true));
           System.out.println("异常通知:" + sw.getBuffer().toString());
       }
   
   
       //环绕通知
       @Around("pointcut()")
       public static void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
           System.out.println("环绕之前");
           proceedingJoinPoint.proceed();
           System.out.println("环绕之后");
       }
   }
   
   ```

4. 测试

   ```
   package com.hand;
   
   import com.hand.service.IPersonService;
   import org.junit.jupiter.api.Test;
   import org.springframework.context.ApplicationContext;
   import org.springframework.context.support.ClassPathXmlApplicationContext;
   
   public class Test1 {
       @Test
       public void test1(){
           ApplicationContext applicationContext = new ClassPathXmlApplicationContext("aop.xml");//获取上方的配置的xml文件
           IPersonService personService = (IPersonService)applicationContext.getBean(IPersonService.class);
           personService.add();
       }
   }
   
   ```

   ![image-20210719165556918](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210719165556918.png)

#### XML文件实现

1. 需要增强的类

   ```
   package com.hand.aop.xml;
   
   public class UserService {
       public void add(){
           System.out.println("添加方法");
       }
   }
   
   ```

2. 增强的方法

   ```
   package com.hand.aop.xml;
   
   public class XmlAspect {
       public void before(){
           System.out.println("前置通知");
       }
   }
   
   ```

3. 配置

   ```
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:aop="http://www.springframework.org/schema/aop"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
   
       <bean id="userService" class="com.hand.aop.xml.UserService"></bean>
       <bean id="xmlAspect" class="com.hand.aop.xml.XmlAspect"></bean>
   
       <aop:config>
           <!--切入点-->
           <aop:pointcut id="MyAop" expression="execution(* com.hand.aop.xml.UserService.add(..))"/>
           <!--定义切面 ref增强的类-->
           <aop:aspect ref="xmlAspect">
               <!--哪个切入点-->
               <aop:before method="before" pointcut-ref="MyAop"></aop:before>
           </aop:aspect>
       </aop:config>
   </beans>
   ```

4. 测试

   ```
   package com.hand;
   
   import com.hand.aop.xml.UserService;
   import org.junit.jupiter.api.Test;
   import org.springframework.context.ApplicationContext;
   import org.springframework.context.support.ClassPathXmlApplicationContext;
   
   public class Test1 {
       @Test
       public void test1(){
           ApplicationContext applicationContext = new ClassPathXmlApplicationContext("aop.xml");
           UserService personService = (UserService)applicationContext.getBean(UserService.class);
           personService.add();
       }
   }
   
   ```

## 5.Spring操作JDBC(不推荐)

### 5.1.添加依赖

```
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.hande</groupId>
  <artifactId>SSM_demo</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <name>SSM_demo Maven Webapp</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>

  <dependencies>

    <!--spring核心依赖-->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>5.2.6.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-core</artifactId>
      <version>5.2.6.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-aop</artifactId>
      <version>5.2.6.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-orm</artifactId>
      <version>5.2.6.RELEASE</version>
    </dependency>
    <!--AOP-->
    <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>1.9.4</version>
    </dependency>




    <!--阿里巴巴连接池-->
    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>1.1.10</version>
    </dependency>
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.25</version>
    </dependency>



    <!--junit测试依赖-->
    <dependency>
      <groupId>org.hamcrest</groupId>
      <artifactId>hamcrest-core</artifactId>
      <version>2.2</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-api</artifactId>
      <version>RELEASE</version>
    </dependency>

<!--    <dependency>-->
<!--      <groupId>junit</groupId>-->
<!--      <artifactId>junit</artifactId>-->
<!--      <version>4.11</version>-->
<!--      <scope>test</scope>-->
<!--    </dependency>-->
  </dependencies>

  <build>
    <finalName>SSM_demo</finalName>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.1.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.22.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-war-plugin</artifactId>
          <version>3.2.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>

```

### 5.2.Spring的配置

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
    	 http://www.springframework.org/schema/beans/spring-beans.xsd
     	 http://www.springframework.org/schema/context
         http://www.springframework.org/schema/context/spring-context.xsd
         http://www.springframework.org/schema/aop
         http://www.springframework.org/schema/aop/spring-aop.xsd
         http://www.springframework.org/schema/tx
     	 http://www.springframework.org/schema/tx/spring-tx.xsd">

	<!-- 开启注解 -->
	<context:component-scan
		base-package="com.hand"></context:component-scan>
	<!-- 1. 数据源对象: C3P0连接池 -->
	<bean id="dataSource"
		class="com.alibaba.druid.pool.DruidDataSource">
		<!-- 基本属性 url、user、password -->
		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://192.168.188.128:3306/hand_ceshi?useUnicode=true&amp;characterEncoding=UTF-8" />
		<property name="username" value="root" />
		<property name="password" value="2452952178" />
	</bean>
	
	<!-- 配置jdbc数据源 -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
</beans>
```

### 5.3.测试

```
    @Test
    public void test3(){
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        System.out.println(applicationContext.getBean(JdbcTemplate.class));
    }
```

## 6.Spirng事务

### 6.1.什么是事务？

> 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。

### 6.2.事务特性

1. 原子性：要么都成功，要么都失败
2. 一致性：操作前前后数据一致性
3. 隔离性：多个事务之间不会产生影响
4. 持久性：保存到库中

### 6.3.Spring中进行事务管理

Spring中进行事务管理有两种方式：

1. 编程式事务：硬编码，在代码中添加事务、提交事务等
2. 声明式事务：
   1. **基于注解方式（推荐）**
   2. 基于XML文件方式

> Spring中进行声明式事务是通过AOP来实现的

Spirng中提供PlatformTransactionManager接口来实现事务：

1. DataSourceTransactionManager：默认事务、mybatis也使用该事务
2. HibernateTransactionManager：Hibernate的事务

![2021-07-20_150411](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/2021-07-20_150411.png)

### 6.4.基于注解的方式

@Transactional即可实现事务

> 在service类上面(或者service类里面方法上面)添加事务注解
>
> (1）@Transactional，这个注解添加到类上面，也可以添加方法上面·
>
> (2）如果把这个注解添加类上面，这个类里面所有的方法都添加事务
>
> (3）如果把这个注解添加方法上面，为这个方法添加事务

### 6.5.事务传播行为

![image-20210720155902682](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210720155902682.png)

### 6.6.spring中七大事务传播：

| 传播属性      | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| REQUIRED      | 如果有事务在运行，新方法则就用该方法的事务                   |
| REQUIRES_NEW  | 不管有没有事务，都会另起事务                                 |
| SUPPORTS      | 如果有事务在运行，当前的方法就在这个事务内运行.否则它可以不  |
| NOT_SUPPORTED | 当前方法不应该运行在事务中，如果有运行的事务，把它挂起       |
| MANDATORY     | 当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常 |
| NEVER         | 当前方法不应该运行在事务中，如果有运行的事务，就抛出异常     |
| NESTED        | 如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行 |

### 6.7.Spring中隔离级别

事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题

> 有三个读问题:脏读、不可重复读、虚（幻）读
> (1）脏读:一个未提交事务读取到另一个未提交事务的数据
>
> (2)	不可重复读：两次读取到修改的数据
>
> (3)	幻读：两次读取到添加（或删除）的数据

事务的隔离级别：

|                                      | 脏读 | 不可重复读 | 幻读 |
| ------------------------------------ | ---- | ---------- | ---- |
| READ_UNCOMMITTED（读未提交）         | 有   | 有         | 有   |
| READ_COMMITTED（读提交） oracle默认  | 无   | 有         | 有   |
| REPEATABLE_READ（可重复读）mysql默认 | 无   | 无         | 有   |
| SERIALIZABLE（串行化）               | 无   | 无         | 无   |

Spring设置隔离级别：

Spirng隔离级别默认为数据库的隔离级别，当然也可以修改

```
@Transactional(isolation= Isolation.REPEATABLE_READ)
```

### 6.8.@Transactional其他参数设置

1. timeout：设置超时时间

   > (1)事务需要在一定时间内进行提交，如果不提交进行回滚·
   >
   > (2）默认值是-1，设置时间以秒单位进行计算

2. readOnly：设置只读

   > (1）读:查询操作，写:添加修改删除操作
   > (2) readOnly默认值false，表示可以查询，可以添加修改删除操作
   >
   > (3）设置readOnly值是true，设置成true之后，只能查询

3. rollbackFor：设置哪种异常才回滚

4. noRollbackFor：设置哪种异常不回滚

### 6.9.注解的方式实现

#### 1.引入依赖

```
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.hande</groupId>
  <artifactId>SSM_demo</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <name>SSM_demo Maven Webapp</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>

  <dependencies>

    <!--spring核心依赖-->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>5.2.6.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-core</artifactId>
      <version>5.2.6.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-aop</artifactId>
      <version>5.2.6.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-orm</artifactId>
      <version>5.2.6.RELEASE</version>
    </dependency>
    <!--AOP-->
    <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>1.9.4</version>
    </dependency>



    <!--阿里巴巴连接池-->
    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>1.1.10</version>
    </dependency>
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.25</version>
    </dependency>


    <!--junit测试依赖-->
    <dependency>
      <groupId>org.hamcrest</groupId>
      <artifactId>hamcrest-core</artifactId>
      <version>2.2</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-api</artifactId>
      <version>RELEASE</version>
    </dependency>

  </dependencies>

  <build>
    <finalName>SSM_demo</finalName>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.1.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.22.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-war-plugin</artifactId>
          <version>3.2.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>

```

#### 2.spring配置

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                        http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/context
                        http://www.springframework.org/schema/context/spring-context.xsd
                        http://www.springframework.org/schema/tx
                        http://www.springframework.org/schema/tx/spring-tx.xsd">

    <!-- 开启注解扫包 -->
    <context:component-scan
            base-package="com.hand"></context:component-scan>
        <!-- 数据源 -->    
    <bean id="dataSource"
          class="com.alibaba.druid.pool.DruidDataSource">
        <!-- 基本属性 url、user、password -->
        <property name="driverClassName" value="com.mysql.jdbc.Driver" />
        <property name="url" value="jdbc:mysql://192.168.188.128:3306/hand_ceshi?useUnicode=true&amp;characterEncoding=UTF-8" />
        <property name="username" value="root" />
        <property name="password" value="2452952178" />
    </bean>

    <!-- 配置jdbc数据源 -->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    <!--开启事务注解-->
    <tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>
</beans>
```

#### 3.servicedemo

```
package com.hand.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional
public class TransactionalService {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void transactionalDemo(){
        jdbcTemplate.update("update user set usex=20 where uid=1");
        int a=1/0;
        jdbcTemplate.update("update user set usex=20 where uid=4");
    }
}

```

4.测试

```
    //事务测试
    @Test
    public void test4(){
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        TransactionalService bean = applicationContext.getBean(TransactionalService.class);
        bean.transactionalDemo();
    }
```

### 6.10.XML文件的方式实现

与上方一样，不过spring的配置文件不同：

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                        http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/context
                        http://www.springframework.org/schema/context/spring-context.xsd
                        http://www.springframework.org/schema/tx
                        http://www.springframework.org/schema/tx/spring-tx.xsd
                        http://www.springframework.org/schema/aop
                        http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!-- 开启注解扫包 -->
    <context:component-scan
            base-package="com.hand"></context:component-scan>
    <!-- 1. 数据源对象: C3P0连接池 -->
    <bean id="dataSource"
          class="com.alibaba.druid.pool.DruidDataSource">
        <!-- 基本属性 url、user、password -->
        <property name="driverClassName" value="com.mysql.jdbc.Driver" />
        <property name="url" value="jdbc:mysql://192.168.188.128:3306/hand_ceshi?useUnicode=true&amp;characterEncoding=UTF-8" />
        <property name="username" value="root" />
        <property name="password" value="2452952178" />
    </bean>

    <!-- 配置jdbc数据源 -->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    <!--XML文件的方式-->

    <!--定义增强 对事务进行增强（通知），需要编写切入点和具体执行事务的细节-->
    <tx:advice id="myAdvice">
        <tx:attributes>
            <!-- 给切入点方法添加事务详情，name表示方法名称，*表示任意方法名称，
            propagation用于设置传播行为，read-only表示隔离级别，是否只读 -->
            <tx:method name="find*" propagation="SUPPORTS"
                       rollback-for="Exception" />
            <tx:method name="*" propagation="REQUIRED" isolation="DEFAULT"
                       read-only="false" />
        </tx:attributes>
    </tx:advice>
    <!--aop-->
    <aop:config>
        <!--定义切入点，哪些地方需要被增强-->
        <aop:pointcut id="myPoint" expression="execution(* com.hand.*.*.*(..))"/>
        <!--将切入点与通知(事务)整合-->
        <aop:advisor advice-ref="myAdvice" pointcut-ref="myPoint"></aop:advisor>
    </aop:config>
</beans>
```

### 6.11.完全注解开发

#### 1.spring配置文件换成配置类

注意注意：有可能有多个配置类，一定要注意@ComponentScan(basePackages = "com.hand") 只能注册一定，不然会重复注册bean；

```
package com.hand.config;

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.sql.DataSource;

@Configuration//配置类
@ComponentScan(basePackages = "com.hand")  //扫包
@EnableTransactionManagement //开启事务
public class TransactionalConfig {
    /**
     * 配置数据源
     * @return
     */
    @Bean(name = "dataSource")
    public DataSource getDruidDataSource(){
        DruidDataSource druidDataSource=new DruidDataSource();
        druidDataSource.setDriverClassName("com.mysql.jdbc.Driver");
        druidDataSource.setUrl("jdbc:mysql://192.168.188.128:3306/hand_ceshi?useUnicode=true&amp;characterEncoding=UTF-8");
        druidDataSource.setUsername("root");
        druidDataSource.setPassword("2452952178");
        return druidDataSource;
    }

    /**
     * 配置JdbcTemplate
     * @param dataSource
     * @return
     */
    @Bean
    public JdbcTemplate getJdbcTemplate(DataSource dataSource){
        JdbcTemplate jdbcTemplate=new JdbcTemplate();
        jdbcTemplate.setDataSource(dataSource);
        return jdbcTemplate;
    }

    /**
     * 配置事务管理器
     * @param dataSource
     * @return
     */
    @Bean
    public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource){
        DataSourceTransactionManager transactionManager=new DataSourceTransactionManager();
        transactionManager.setDataSource(dataSource);
        return transactionManager;
    }
}
```

#### 2.测试

```
    //事务全注解测试
    @Test
    public void test5(){
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(TransactionalConfig.class);
        TransactionalService bean = applicationContext.getBean(TransactionalService.class);
        bean.transactionalDemo();

    }
```











