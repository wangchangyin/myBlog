---
title: Oracle基础知识
date: 2021-07-12 11:26:10
permalink: /pages/f1ccdf/
categories:
  - 后端
  - 数据库
  - Oracle
tags:
  - 
---
# Oracle函数

 

\* Oracle 函数分为单行函数和多行函数两大类

 

\* 单行函数

\- 操作数据项

\- 接受参数并返回处理结果

\- 对每一返回行起作用

\- 可修改数据类型

\- 可嵌套使用

 

\* 单行函数分类

\- 字符函数

\- 数值函数

\- 日期函数

\- 转换函数

\- 通用函数

 

 

## **字符函数**

 

\* 字符大小写转换函数

\* 函数  功能  用法   返回结果

\- lower()  转换为小写 lower('John Smith') john smith

\- upper()  转换为大写 upper('John Smith') JOHN SMITH

\- initcap() 单词首字母大写 initcap('JOHN smith') John Smith

 

\* 例:

\- select lower('John Smith') from dual;->(john smith)

\- select upper('John Smith') from dual;->(JOHN SMITH)

\- select initcap('JOHN smith') from dual;->(John Smith)

 

*字符处理函数

\* 函数  功能  用法   返回结果

\- concat() 字符串连接 concat('Hello', 'World') Hello World

\- substr() 截取子串 substr('HelloWorld', 4, 3) loW

\- length() 返回字符串长度 length('Hello World')  11

\- instr()  定位子串 instr('Hello World', 'or') 8

\- lpad()  左侧填充 lpad('Smith', 10, '*')  *****Smith

\- rpad()  右侧填充 rpad('Smith', 10, '*')  Smith*****

\- trim()  过滤首尾空格 trim(' Mr Smith ')  Mr Smith

\- replace() 替换  replace('ABA', 'A', 'C') CBC

 

\* 注意:函数可嵌套使用

\* 例:

\- select concat('Hello', 'World')   from dual;->(HelloWorld)

\- select concat(concat(ename, ' is a '), job) info from emp where empno=7369;->(SMITH is a CLERK)

\- select substr('HelloWorld', 4, 3)   from dual;->(loW)

\- select substr(substr('HelloWorld', 3, 6), 3, 3) from dual->(oWo)

\- select length('Hello World')   from dual;->(11)

\- select instr('Hello World', 'or')   from dual;->(8)

\- select lpad('Smith', 10, '*')   from dual;->(*****Smith)

\- select rpad('Smith', 10, '*')   from dual;->(Smith*****)

\- select trim(' Mr Smith ')   from dual;->(Mr Smith)

\- select replace('ABA', 'A', 'C')   from dual;->(CBC)

 

 

## **数值函数**

 

\* 函数  功能  用法   返回结果

\- abs()  取绝对值 abs(-3.14)  3.14

\- round()  四舍五入 round(3.1415)  3

   round(3.1415, 3) 3.142

   round(314.1592, -2) 300

\- trunc()  截断  trunc(3.1415, 3) 3.141

\- ceil()  向上取整 ceil(3.14)  4

\- floor()  向下取整 floor(3.14)  3

\- sign()  判断数值正负 sign(-3.14)  -1

\- sin()..  三角函数.. sin(3.14)  .001592653

\- power()  幂运算  power(4.5, 2)  20.25

\- sqrt()  开平方根 sqrt(9)   3

\- mod()  取模  mod(10, 3)  1

\- exp()  基数为e的幂运算exp(1)   2.71828183

\- log()  对数运算 log(4, 16.0)  2

\- ln()  自然对数运算 ln(7)   1.94591015

 

\* 例:

\- select abs(-3.14)  from dual;->(3.14)

\- select round(3.1415)  from dual;->(3)

\- select round(3.1415, 3) from dual;->(3.142)

\- select round(314.1592, -2) from dual;->(300)

\- select trunc(3.1415, 3) from dual;->(3.141)

\- select trunc(3.1415, -3) from dual;->(0)

\- select trunc(3.1415, 7) from dual;->(3.1415)

\- select ceil(3.14)  from dual;->(4)

\- select floor(3.14)  from dual;->(3)

\- select sign(-3.14)  from dual;->(-1)

\- select sin(3.14)  from dual;->(.001592653)

\- select power(4.5, 2)  from dual;->(20.25)

\- select sqrt(9)  from dual;->(3)

\- select mod(10, 3)  from dual;->(1)

\- select exp(1)   from dual;->(2.71828183)

\- select log(4, 16.0)  from dual;->(2)

\- select ln(7)   from dual;->(1.94591015)

 

 

## **日期类型**

 

\* 关于日期类型

\- Oracle内部以数字格式存储日期和时间信息:世纪,年,月,日,小时,分钟,秒

\- 缺省的日期格式是DD-MON-YY

\- 可使用sysdate函数获取当前系统日期和时间

 

\* 日期型数据的算术运算

\- 日期型数据可以直接加或减一个数值,结果仍为日期

\- 两个日期型数据可以相减,结果为二者相差多少天

 

\* 查询200-12-25减1991-12-25一共有多少天

\- select to_date('25-12月 -09') - to_date('25-12月-1991') from dual;

 

 

## **日期函数**

\* 函数   功能    用法   返回结果

\- add_months(x, y) 计算在日期x基础上增加y个月后的日期add_months(sysdate, 2)

\- last_day(x)  返回日期x当月最后一天的日期  last_day(sysdate)

\- months_between(x, y) 返回日期x和y之间相差的月数  months_between(sysdate, hiredate)

\- round(x, y)  将日期x四舍五入到y所指定的  round(sysdate, 'month')

   日期单位(月或年)的第一天  round(sysdate, 'year')

\- trunc(x, y)  将日期x截断到y所指定的   trunc(sysdate, 'month')

   日期单位(月或年)的第一天  trunc(sysdate, 'year')

\- next_day  计算指定日期x后的第一个星期几  next_day(sysdate, '星期二')

   (由参数y指定)对应的日期

 

\* 例:

\- select add_months(sysdate, 2)    from dual;->(05-10月-09)

\- select last_day(sysdate)    from dual;->(31-8月-09)

\- select hiredate, months_between(sysdate, hiredate)  from emp;

\- select months_between(sysdate, '17-12月-80')   from dual;->(343.63907)

\- select round(sysdate, 'month')   from dual;->(01-8月-09)

\- select round(to_date('16-8月 -09'), 'month')   from dual;->(01-9月-09)

\- select round(sysdate, 'year')    from dual;->(01-1月-10)

\- select round(to_date('1-7月 -09'), 'year')   from dual;->(01-1月-10)

\- select round(to_date('25-6月 -09'), 'year')   from dual;->(01-9月-09)

\- select trunc(sysdate, 'month')   from dual;->(01-8月-09)

\- select trunc(sysdate, 'year')    from dual;->(01-1月-09)

\- select next_day(sysdate, '星期二')    from dual;->(11-8月-09)

\- select next_day(next_day(sysdate, '星期二'), '星期二') from dual;->(18-8月-09)

 

 

## **转换函数**

 

\* 数据类型转换包括隐含转换和显式转换两方式,建议使用显式的数据类型转换,确保SQL语句的可靠性

 

\* 字符类型 ->数值类型 -> to_number()

\* 字符类型 ->日期类型 -> to_date()

\* 数值类型 ->字符类型 -> to_char()

\* 日期类型 ->字符类型 -> to_char()

 

 

## **日期 \**->\** \**字符串\****

 

\* to_char()函数可以将日期型数值转换为字符串形式

 

\* 格式:

\- to_char(date)   // 缺省转换为'dd-mm-yy'格式

\- to_char(date, 'format_model')  // 转换为模式串指定的格式

 

\* 例:

\- select empno, ename, sal, to_char(hiredate, 'yyyy-mm-dd') from emp;

\- select to_char(sysdate, 'yyyy-mm-dd hh:mi:ss') from dual;

\- select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') from dual;

 

 

## **常用日期格式符**

 

\* 格式符  说明   举列

\- yyyy  年份   2008

\- mm  用数字显示月份  02

\- dd  在当月中是第几天 28

\- day  星期几   星期五

\- am/pm  显示上午/下午  上午

\- hh/hh12/hh24 小时   2:30 14:30

\- mi  分钟   30

\- ss  秒钟   46

 

\* 说明:除上述格式符外,日期模式串中还可直接出现如下字符( - : ; / );

\* 如要显示其它文本字符串则需使用双引号括起来;也可在械串的开头使用"fm"标

\* 记以去掉数字前面的零

 

\* 例:

\- select to_char(sysdate, 'yyyy"年"mm"月"dd"日" day hh24:mi:ss') from dual;

\- select to_char(sysdate, 'fmyyyy"年"mm"月"dd"日" day hh24:mi:ss') from dual;

 

 

## **字符串 \**->\** \**日期\****

 

\* to_date()函数可以将字符串转换为日期型数值形式

 

\* 格式:

\- to_date(char)   // 按缺省格式'dd-mm-yy'进行解析

\- to_date(char, 'format_model')  // 按模式串指定的格式进行解析

 

\* 例:

\- insert into t5 values('BOBO', to_date('2008-02-28', 'yyyy-mm-dd'));

\- select to_date(to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') from dual;

\- select to_char(to_date(to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'), 'dd/mm/yyyy') from dual;

 

 

## **数字**

 

\* to_char()函数可以将数字值转换为字符串形式

 

\* 格式:

\- to_char(number)

\- to_char(number, 'format_model')

 

\* 例:

\- select to_char(12345.678901) from dual;

\- select to_char(12345.678901, '$99,999.0000') from dual;

 

\* 数字模式符:

\* 格式符 说 明

\- 9 代表一位数字

\- 0 代表一位数字,强制显示0

\- $ 放置一个美圆符$

\- L 放置一个本地货币符

\- . 小数点

\- , 千位指示符

 

\* 例:

\- select to_char(12345.6, 'L999,999.0000') from dual;

 

 

## **字符串 \**->\** \**数字\****

 

\* to_number()函数可以将字符串转换为数字值形式

 

\* 格式:

\- to_number(char)

\- to_number(char, 'format_model')

 

\* 例:

\- select to_number('12345.678901') from dual;

\- select to_number('$12,345.6789', '$99,999.0000') from dual;

 **2）如果数字在格式范围内的话，就是正确的，否则就是错误的；如：**

```
$12345.678小数点位数必须小于等于后面规定的格式
select to_number('$12345.678', '$999999.99') from dual;  X
select to_number('$12345.678', '$999999.999') from dual; √
select to_number('$12345.67', '$999999.999') from dual;  √
```

## **通用函数**

 

\* 通用函数适用于任何类型数据(包括空值):

\- nvl()

\- nvl2()

\- nullif()

\- coalesce()

\- case表达式

\- decode()

 

 

## **NVL()\**函数\****

 

\* NVL()函数用于将空值null替换为指定的缺省值,适用于字符,数字,日期等类型数据

 

\* 语法格式:

\- NVL(exp1, exp2)

 

\* 说明:

\- 如果表达式exp1的值为null,则返回exp2的值,否则返回exp1的值

 

\* 用法举例:

\- select empno, ename, sal, comm, sal+nvl(comm, 0) from emp;

\- select empno, ename, hiredate, nvl(hiredate, sysdate) from emp;

\- select empno, ename, job, nvl(job, 'NO job yet') from emp;

 

 

## **NVL2()\**函数\****

 

\* NVL2()函数用于实现条件表达式功能

 

\* 语法格式:

\- NVL2(exp1, exp2, exp3)

 

\* 说明:

\- 如果表达式exp1的值不为null,则返回exp2的值,否则返回exp3的值

 

\* 用法举例:

\- select empno, ename, sal, comm, nvl2(comm, sal+comm, sal) from emp;

 

 

## **NULLIF()\**函数\****

 

\* NULLIF()函数用于数据等价性比较并根据比较结果返回null或其中一个被比较的数值

 

\* 语法格式:

\- NULLIF(exp1, exp2)

 

\* 说明:

\- 如果表达式exp1与exp2的值相等返回null,否则返回exp1的值

 

\* 用法举例:

\- select name 原名, nullif(pen_name, name)化名 from author;

 

 

## **COALESCE()\**函数\****

 

\* COALESCE()函数用于实现数据"接合"功能

 

\* 语法格式:

\- COALESCE(exp1, exp2, ...)

 

\* 说明:

\- 依次考察各参数表达式,遇到非null值即停止并返回该值

 

\* 用法举例:

\- select empno, ename, sal, comm, coalesce(sal+comm, sal, 0) 总收入 from emp;

 

 

## **CASE()\**函数\****

 

\* CASE()表达式用于实现多路分支结构

 

\* 语法格式:

\- CASE exp1 when comparison_exp1 then return_exp1

\-      [when comparison_exp2 then return_exp2

\-      when comparison_expn then return_expn

\-      else esle_exp]

\- end [TempName]

 

\* 说明:

\- 如果 exp1是 comparison_exp1的时候,就返回return_exp1

\-       [ comparison_exp2 的时候,就返回return_exp2

\-        comparison_expn 的时候,就返回return_expn

\-        else 就返回 esle_exp ]

\- end [别名]

 

\* 用法举例:

```
- select empno, ename, sal,

\-     case deptno when 10 then '财务部'

\-           when 20 then '研发部'

\-           when 30 then '销售部'

\-           else '未知部门'

\-     end 部门

\- from emp;
```

**通配符：**

```
select 
JOB_ID,
  case  when JOB_ID like '%AD%' then 'AD'
    when JOB_ID like 'IT_PROG' then 'IT'
    when JOB_ID like '%FI%' then 'FI' 
    else 'No'
  end 部门简称
from employees
```

###  case高阶用法：

```
--case语句的种类:
1.简单case语句
语法:
   case exp when comexp then returnvalue
            ...
            when comexp then returnvalue
            else returnvalue
    end
      
  case到end之间相当于一个具体的值，可以做运算，取别名，嵌套case 等等。
  只要把case到end当作一个运算结果的表达式就可以了。

举例:
   select cust_last_name,
          case credit_limit when 100 then 'low'
                            when 5000 then 'high'
                            else 'medium'
          end
     from customers;
     
2.搜索case语句
语法:
    case when boolean then return value
         ...
         when boolean then return value
         else retur nvalue
     end
     
举例:
select case when id between 1 and 10 then 'low'
            when id between 20 and 30 then 'mid'
            when id between 40 and 50 then 'high'
            else 'unknow'
       end
from product;

--简单case和搜索case之间的区别：
1. 简单case只能是when后面的表达式完全匹配case后的表达式，相当于 =，所以也不能匹配null。
2. searched case可以作为比较条件，那么可以使用like、!=、between ..and、<、=、is null、is not null等，比简单case的使用更加广泛，完全可以替代简单case。

--注意事项:
1.case 表达式返回的是一个确定的value，若前面的都不匹配，则返回else中的项.
2.简单case 中的表达式，when 后面的表达式类型应该全部保持一致.
3.所有的then 后面的return_value类型要保持一致.
4.对于简单case 表达式，也就是case 表达式 when…那么when null 总是取不到。也就是case 后面的表达式如果值为null，不会与when null 匹配，只会与else匹配.
5.对于searched case来说，有自动类型转换，只要条件成立就可以。
如:select case when 1='1' then 1 end from dual; 其中1='1'条件成立

值得一提的是: sql中的case语句与pl/sql中的case语句的不同之处:
前者的else不是必须的，如果没有匹配就返回null;后者的else不写，则报case_not_found异常.

--case中嵌套子查询
Case语句中可以使用子查询，但是必须返回一行，不可以是多行.
如：
select case (select count(*) as s1 from t1 where a = 1)
           when (select count(*) as s2 from t1, t2 where t1.a = t2.a and t2.a = 1) then '相等'
           else '不相等'
       end
  from dual;
```



## **DECODE()\**函数\****

 

\* 和CASE()表达式类似,DECODE()函数也用于实现多路分支结构

 

\* 语法格式:

\- decode(col|expression, search1, result1

\-           [, search2, result2, ...,]

\-           [, default])

 

\* 说明:

\- 如果 col|expression是 search1的时候,就返回result1

\-            [ search2 的时候,就返回result2, ...]

\-            [, default])

\- [别名]

 

\* 用法举例:

\- select empno, ename, sal,

\-     decode(deptno, 10, '财务部',

\-            20, '研发部',

\-            30, '销售部',

\-           '未知部门')

\-     部门

\- from emp;

 

 

## **函数嵌套**

 

\* 单行孙数可以嵌套使用,嵌套层次无限制

 

\* 嵌套函数的执行顺序是由内到外

\- select empno, lpad(initcap(trim(ename)), 10, '*') name, job, sal from emp;

 

 

\##########[ 单行函数小结 ]##########

 

\* 使用系统提供的单行函数可实现如下功能:

\- 对数据进行计算

\- 控制数据的输出格式

\- 设置/改变日期的显示格式

\- 进行数据类型转换

\- 使用NVL函数处理空值

\- 实现IF-THEN-ELSE多路分支逻辑

 

 

# **分组函数**

 

\* 分组函数对一组数据进行运算,针对一组数据(多行记录)只返回一个结果,也称多行函数

 

\* 常用分组函数

\- 函数  功能说明   适用类型

\- avg()  计算平均值   数值型

\- count()  返回查询所行到的记录行数 任何类型数据

\- max()  计算最大值   任何类型数据

\- min()  计算最小值   任何类型数据

\- sun()  求和   数值型

> 1.上述函数除了count(*)会处理null，其他都会忽略null，可用nvl函数处理
>
> 2.备注:MIN,MAX可用于任何数据类型，便AVG， SUM，STDDEV,VARIANCE仅适用于数值型字段。

 

\* 举例:

\- select avg(sal), max(sal), min(sal), sum(sal) from emp;

\- select max(hiredate), min(hiredate) from emp;

 

 

 

## **COUNT()\**函数\****

 

\* count(*) 返回组中总记录数目**包括空行**

 

\* count(exp) 返回表达式exp值**非空**的记录数目

 

\* count(distinct(exp)) 返回表达式exp值不重复的,**非空**的记录数目

 

\* 举例:

\- select count(*) from emp;   ====      select count(*1) from emp; 

\- select count(comm) from emp;

\- select count(distinct(deptno)) from emp;

```
 select count(distinct(deptno)) from emp;
 不用distinct，使用group by改为：
 select count(deptno) from (select deptno from emp group by deptno)
```

 

## **分组函数与空值**

 

\* 分组函数省略列中的空值

\- select avg(comm) from emp;

\- select sum(comm) from emp;

 

\* **可使用NVL()函数强制分组函数处理空值**

\- select avg(nvl(comm, 0)) from emp;

 

 

## **GROUP BY\**子句\****

 

\* GROUP BY 子句将表中数据分成若干小组

 

\* 语法格式

\- select column, group_function(column)

\- from table

\- [where condition]

\- [group by group_by_expression]

\- [order by column]

 

\* 例:

\- select deptno, avg(sal) from emp group by deptno;

\- select deptno, avg(sal) from emp where deptno > 10 group by deptno;

\- select deptno, avg(sal) from emp group by deptno order by deptno desc;

 

\* 说明:

> \- 出现在SELECT列表中的字段,如果不是包含在组函数中,那么该字段必须同时在GROUP BY 子句中出现
>
> \- 包含在 GROUP BY子句中的字段则不必须出现在 SELECT列表中
>
> \- 可使用 where子句限定查询条件
>
> \- 可使用 order by子句指定排序方式



\* 注意:

\- 执行顺序: where -> group by -> select ... from ... -> order by..

 

 

\##########[ 基于多字段分组 ]##########

 

\- select deptno, job, avg(sal) from emp group by deptno, job;

 

 

\##########[ 组函数的错误用法 ]##########

 

\* 如果没有 GROUP BY子句, SELECT列表中不允许出现字段(单行函数)与分组函数混用的情况

\- select empno, sal from emp; -> (Y)

\- select avg(sal) from emp; -> (Y)

\- select empno, initcap(ename), avg(sal) from emp; -> (N)

 

\* 不允许在 WHERE子句中使用分组函数

\- select deptno, avg(sal)

\- from emp

\- where avg(sal) > 2000; -> (N)

\- group by deptno;

\- 注:这跟子句运行顺序有关,

\-   where 最先执行,

\-   在执行 where子句时,

\-   还没有执行 group by子句,

\-   还不知道什么分组,

\-   也没计算过 avg(sal)组内的平均工资

 

 

## **HAVING \**子句\****

 

\* HAVING 子句用于过滤分组

 

\* 语法格式

\- select column, group_function(column)

\- from table

\- [where condition]

\- [group by group_by_expression]

\- [order by column];

 

\* 例:

\- select deptno, job, avg(sal)

\- from emp

\- where hiredate >= to_date('1981-05-01', 'yyyy-mm-dd')

\- group by deptno, job

\- having avg(sal) > 1200

\- order by deptno, job;

 

 

\##########[ 分组函数嵌套 ]##########

 

\* 分组函数最多可嵌套两层

\- select max(avg(sal))

\- from emp

\- group by deptno;

 

 

# Oracle 表连接

 

\* SQL/Oracle 使用表连接从多个表中查询数据

 

\* 语法格式:

\- select 字段列表

\- from table1, table2

\- where table1.column1 = table2.column2

 

\* 说明:

\- 在 where子句中指定连接条件

\- 当被连接的多个表中存在同名字段时,必须在该字段前加上"表名."作为前缀

 

\* 例:

\- select empno, ename, job, emp.deptno, dname

\- from emp, dept

\- where emp.deptno = dept.deptno;

 

\* 提示:加上前缀可以提高效率

 

 

\##########[ 连接的类型 ]##########

 

\* Oracle8i之前的表连接

\- 等值连接(Equijoin)

\- 非等值连接(Non-Equijoin)

\- 外连接(Outer join)

\- 左外连接

\- 右外连接

\- 自连接(Selfjoin)

 

\* Oracle9i新引入的连接形式(支持SQL99规范):

\- 交叉连接(Cross join)

\- 自然连接(Natural join)

\- 使用 Using子句建立连接

\- 使用 On子句建立连接

\- 外连接(Outer join)

\- 左外连接

\- 右外连接

\- 全外连接

 

 

\##########[ 多表连接 ]##########

 

\* 多表连接中:

\- 可使用 AND操作符增加查询条件

\- 使用表别名可以简化查询

\- 使用表名(表别名)前缀可提高查询效率

\- 为了连接 n个表,至少需要 n-1个连接条件

 

 

\##########[ 等值连接(Equijion) ]##########

 

\* 什么是等值连接

\- select empno, ename, sal, emp.deptno, dname

\- from emp, dept

\- where emp.deptno = dept.deptno;

 

 

\##########[ 非等值连接(Not-Equijion) ]##########

 

\* 问题:如何查得每个员工的工资等级

 

\* 方法1:

\- select empno, ename, sal, grade, losal, hisal

\- from emp, salgrade

\- where sal >= losal and sal <= hisal;

 

\* 方法2:

\- select empno, ename, sal, grade, losal, hisal

\- from emp, salgrade

\- where sal between losal and hisal;

 

 

\##########[ 外连接(Outer jion) ]##########

 

\* 使用外连接可以看到参与连接的某一方不满足连接条件的记录

 

\* 外连接运算符为(+)

 

\* 传统的外连接分为左外连接和右外边接两种

 

\* 语法格式:

 

\- select 字段列表

\- from table1, table2

\- where table1.column1(+)=table2.column2;

 

\- select 字段列表

\- from table1, table2

\- where table1.column1=table2.column2(+);

 

\* 例:

 

\* 左外连接'(+)'放在右边,将左表中不符合条件的也显示出来

\- select EMPLOYEE_ID, FIRST_NAME, SALARY, e.DEPARTMENT_ID, DEPARTMENT_NAME

\- from employees e, departments d

\- where e.DEPARTMENT_ID = d.DEPARTMENT_ID(+)

\- order by EMPLOYEE_ID;

 

\* 右外连接'(+)'放在左边,将右表中不符合条件的也显示出来

\- select EMPLOYEE_ID, FIRST_NAME, SALARY, e.DEPARTMENT_ID, DEPARTMENT_NAME

\- from employees e, departments d

\- where e.DEPARTMENT_ID(+) = d.DEPARTMENT_ID

\- order by EMPLOYEE_ID;

 

 

\##########[ 自连接(Self jion) ]##########

 

\* 问题:如何查得每个员工及其上司的工号和姓名

\- select a.empno, a.ename, a.mgr, b.ename

\- from emp a, emp b

\- where a.mgr = b.empno

\- order by a.empno;

 

 

\##########[ SQL99 连接语法 ]##########

 

\* SQL1999 规范中规定的连接查询语法

\- select 字段列表

\- from table1

\- [cross join table2] |

\- [natural join table2] |

\- [join table2 using(字段名)] |

\- [join table2 on(table.column_name = table2.column_name)] |

\- [(left | right | full outer) join table2

\- on(table1.column_name = table2.column_name)];

 

 

\##########[ 交叉连接(Cross join) ]##########

##  交叉连接(Cross join)

\* Cross join产生了一个笛卡尔集,其效果等同于在两个表进行连接时未使用WHERE 子句阴定连接条件

 

\* 举例:

\- select empno, ename, sal, emp.deptno, dname

\- from emp cross join dept;

 

 

\##########[ 自然连接(Natural join) ]##########

##  Natural join自然连接

\* `Natural join` 基于两个表中的全部同名列建立连接

\- 从两个表中选出同名列的值均对应相等的所有行

\- 如果两个表中同名列的数据类型不同,则出错

\- 不允许在参照列上使用表名或者别名作为前缀

 

\* 举例:

\- select empno, ename, sal, deptno, dname

\- from emp natural join dept;

 

\- 上面SQL语句等同于:

 

\- select empno, ename, sal, emp.deptno, dname

\- from emp, dept

\- where emp.deptno = dept.deptno;

 

\* 注意:第一种方法的deptno不能加上表名前缀,第二种方法必须加上表名前缀

 

 

## **Using \**子句\****

 

\* 如果不希望参照被连接表的所有同名列进行等值连接,自然连接将无法满足

\* 要求,可以在连接时使用Using子句来设置用于等值连接的列(参照列)名.

 

\* 举例:

\- select empno, ename, sal, deptno, dname

\- from emp join dept

\- using(deptno);

 

\* 不允许在参照列上使用表名或者别名作为前缀

 

## **On \**子句\****

 

\* 如果要参照非同名的列进行等值连接,或想设置任意的连接条件,可以使用ON 子句

 

\* 举例:

\- select empno, ename, sal, emp.deptno, dname

\- from emp join dept

\- on(emp.deptno = dept.deptno);

 

\* 必须加上表名前缀(emp.deptno)

 

\- 上面SQL语句等同于:

 

\- select empno, ename, sal, emp.deptno, dname

\- from emp, dept

\- where emp.deptno = dept.deptno;

 

\--------------------------------------------------

 

\- select empno, ename, sal, emp.deptno, dname

\- from emp join dept

\- on(emp.deptno = dept.deptno and sal > 2500);

 

\- 上面SQL语句等同于:

 

\- select empno, ename, sal, emp.deptno, dname

\- from emp, dept

\- where emp.deptno = dept.deptno and sal > 2500;

 

 

**多表连接**

 

\* 使用SQL99连接语法,两个以上的表进行连接时应依次/分别指定相临的两个表之间的连接条件

 

\* 语法格式:

\- select 字段列表

\- from table1

\- [cross join table2] |

\- [natural join table2] |

\- [join table2 using(字段名)] |

\- [join table2 on(table1.column_name=table2.column_name)] |

\- [(left | right | full outer) join table2

\- on(table1.column_name=table2.column_name)]

\- [cross join table3] |

\- [`natural join` table3] |

\- [join table3 using(字段名)] |

\- [join table3 on(table2.colimn_name=table3.column_name)] |

\- [(left | right | full outer) join table3

\- on(table2.column_name=table3.column_name)];

 

\* 举例:

 

\- SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID, CITY

\- FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) NATURAL JOIN LOCATIONS;

 

\- 上面SQL语句等同于:

 

\- SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID, CITY

\- FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) JOIN LOCATIONS USING(LOCATION_ID);

 

\- 等同于:

 

\- SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, emp.DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID, CITY

\- FROM EMPLOYEES emp JOIN DEPARTMENTS dep ON(emp.DEPARTMENT_ID = dep.DEPARTMENT_ID)

\- JOIN LOCATIONS loc USING(LOCATION_ID);

 

\- 等同于:

 

\- SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, emp.DEPARTMENT_ID, DEPARTMENT_NAME, dep.LOCATION_ID, CITY

\- FROM EMPLOYEES emp JOIN DEPARTMENTS dep ON(emp.DEPARTMENT_ID = dep.DEPARTMENT_ID)

\- JOIN LOCATIONS loc ON(dep.LOCATION_ID = loc.LOCATION_ID);

 

 

## **内连接和外连接**

 

\* 内连接(Inner Join)

\- 在 SQL99规范中,内连接只返回满足连接条件的数据

 

\* 外连接(Outer Join)

 

\- 左外联接(Left Outer Join)

\- 两个表在连接过程中除返回满足连接条件的行以外,还返回左表中不满足条件的行,这种连接称为左外联接

 

\- 右外联接(Right Outer Join)

\- 两个表在连接过程中除返回满足连接条件的行以外,还返回右表中不满足条件的行,这种连接称为右外联接

 

\- 满外联接(Full Outer Join)

\- Oracle9i 开始新增功能,两个表在连接过程中除返回满足连接条件的行以外,还返回两个表中不满足条件的所有行,这种连接称为满外联接

 

\* 举例:

 

\* 不满足条件的不返回(内连接(Inner Join))

\- SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME

\- FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID);

 

\* 左表中不满足条件也返回(左外联接(Left Outer Join))

\- SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME

\- FROM EMPLOYEES LEFT JOIN DEPARTMENTS USING(DEPARTMENT_ID);

 

\* 右表中不满足条件也返回(右外联接(Right Outer Join))

\- SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME

\- FROM EMPLOYEES RIGHT JOIN DEPARTMENTS USING(DEPARTMENT_ID);

 

\* 将满足条件的和左表中不满足条件的还有右表中不满足条件的,都返回(满外联接(Full Outer Join))

\- SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME

\- FROM EMPLOYEES FULL OUTER JOIN DEPARTMENTS USING(DEPARTMENT_ID);

 

 

## **子查询\**(Sub Query)\****

 

\* 问题引入

\- 如何查得所有比'张三'工资高的员工的信息

 

\* 子查询

\- 子查询在主查询前执行一次

\- 主查询使用子查询的结果

\- 语法格式:

\- select 字段列表

\- from table

\- where 表达式 operator(select字段列表 from table);

 

\* 举例:

\- select * from emp where sal > (select sal from emp where empno = 7654);

 

\##########[ 使用子查询注意事项 ]##########

 

\* 在查询是基于未知值时应考虑使用子查询

 

\* 子查询必须包含在括号内

 

\* 建议将子查询放在比较运算符的右侧,以增强可读性

 

\* 除非进行 Top-N分析,否则不要在子查询中使用ORDER BY 子句

 

\* 对单行子查询使用单行运算符

 

\* 对多行子查询使用多行运算符

 

 

\##########[ 单行子查询 ]##########

 

\* 单行子查询只返回一行记录

 

\* 对单行子查询可使用单行记录比较运算符

\- 运算符  含义

\- =  等于

\- >  大于

\- >=  大于等于

\- <  小于

\- <=  小于等于

\- <>  不等于

 

\* 举例:

\- select * from emp

\- where sal > (select sal from emp where empno = 7566);

 

 

\##########[ 子查询空值/多值问题]##########

 

\* 如果子查询未返回任何行,则主查询也不会返回任何结果

\- select * from emp

\- where sal > (select sal from emp where empno = 8888);

 

\* 如果子查询返回单行结果,则为单行子查询,可以在主查询中对其使用相应的单行记录比较运算符

\- select * from emp

\- where sal > (select sal from emp where empno = 7566);

 

\* 如果子查询返回多行结果,则为多行子查询,此时不允许对其使用单行记录比较运算符

\- select * from emp

\- where sal > (select avg(sal) from emp group by deptno); -> (N)

 

\- SELECT EMPLOYEE_ID, LAST_NAME, SALARY FROM EMPLOYEES

\- WHERE JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE LAST_NAME = 'Grant'); -> (Y)

 

 

\##########[ 多行子查询 ]##########

 

\* 多行子查询返回多行记录

 

\* 对多行子查询只能使用多行记录比较运算符

 

\* 运算符  含义

\- IN  等于列表中的任何一个

\- ANY  和子查询返回的任意一个值比较

\- ALL  和子查询返回的所有值比较

 

\* 举例:

\- select * from emp where sal > any(select avg(sal) from emp group by deptno);

\- select * from emp where sal > all(select avg(sal) from emp group by deptno);

\- select * from emp where job in(select job from emp where ename = 'MARTIN' or ename = 'SMITH');

\##########[ TopN查询 ]##########

 

\* 在 ORACLE中通常用子查询的方式来实现 TOP N查询

 

\* 语法格式:

\- select 字段列表

\- from (select 字段列表 from table order by排序字段)

\- where rownum <= n;

 

\* 例:

\- select * from (select * from emp order by sal desc) where rownum <= 5;

 

 

\- select * from (select rownum myno, a.* from (select * from emp order by sal desc) a)

\- where myno >= 5 and myno <= 10;

##  注意：子查询配合表连接使用，子查询不能和left连接使用

# Oracle三范式

```
第一范式：（1NF）无重复的列
第二范式：（2NF）属性完全依赖于主键
第三范式：（3NF）属性不依赖于其它非主属性
```

# Oracle项目不推荐使用

> distinct ：推荐使用group by   
>
> 子查询：使用多表查询
>
> （+） ：使用left/right

# Oracle DML（增删改）

## 1.添加

> 从一个表中某行数据添加到另一个表中

```
insert into departments0713(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
select DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID from departments where DEPARTMENT_ID in (20,30)
```

# Oracle事务

> 在Commit或者Rollback前后数据的状态:
> 1、在数据已经被更改，但没有Commit前，被更改记录处于被锁定状态，其他用户无法进行更改;
> 2、在数据已经被更改，但没有Commit前，只有当前Session的用户可以看到这种变更，其他Session的用户看不到数据的变化。
> 3、在数据已经被更改，并且被Commit后，被更改记录自动解锁，其他用户可以进行更改;|
> 4、在数据已经被更改，并且被Commit后，其他Session的用户再次访问这些数据时，看到的是变化后的数据。

当有用户修改数据时，Oracle先把那部分原始数据备份到回滚段，在Commit之前，其他Session用户读到的这部分数据是回滚段上的;在提交之后，回滚段被释放。

**查询某个表是否有锁**

```
select a.*, C.type, C.LMODE
 from v$locked_object a, all_objects b, v$lock c
where a.OBJECT_ID = b.OBJECT_ID
 and a.SESSION_ID = c.SID
 and b.OBJECT_NAME = 'TESTTAB3'
```

查询某个表是否整在被锁

```
 select * from testtab3 for update nowait;
```

# 三.Oracle对象-表

## 1.对表的操作

> 表的命名要求和表中列的命名要求： 
>
> 1、必须以字母开头
>
>  2、长度不能超过30个字符 
>
> 3、只能包含 A–Z, a–z, 0–9, _, $, and # 
>
> 4、不能与数据库中的已有对象重名 
>
> 5、不能使用Oracle 数据库的保留字

### 建表语句：

```
CREATE TABLE [schema.]table
 (column datatype [DEFAULT expr][, ...]);
```

常用的字段数据类型：

![image-20210714094522941](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210714094522941.png)

### 复制表：

```
复制表和数据
CREATE TABLEA table as select * from tableb
复制表结构
CREATE TABLEA table as select * from tableb where 1=2
```

### 删除表

注意：表被删 除后，任何依赖于这张表的视图、Package等数据库对象都自动变为无效：

```
DROP TABLE tableName;  --删除表与数据
TRUNCATE TABLE tableName; ——清空表数据 但保留表结构：
delete from tableName;    ——清空表数据
```

> 注意TRUNCATE 与DELETE FROM table 的区别： 1）没有Rollback机会 2）HWM标记复位
>
> 补充：HWM标记复位是什么？
>
> > 所有的oracle段都有一个在段内容纳数据的上限，我们把这个上限称为"high water mark"或HWM。这个HWM是一个标记，用来说明已经有多少没有使用的数据块分配给这个segment。HWM通常增长的幅度为一次5个数据块，原则上HWM只会增大，不会缩小，即使将表中的数据全部删除，HWM还是为原值，由于这个特点，使HWM很象一个水库的历史最高水位，这也就是HWM的原始含义，当然不能说一个水库没水了，就说该水库的历史最高水位为0。`但是如果我们在表上使用了truncate命令，则该表的HWM会被重新置为0。`

### 更改表名

```
RENAME oldtablename to newtableName;
```

## 2.对列的操作：

```
添加列：
ALTER TABLE table
ADD (column datatype [DEFAULT expr]
 [, column datatype]...);
更改列：
ALTER TABLE table
MODIFY (column datatype [DEFAULT expr]
 [, column datatype]...);
删除列：
ALTER TABLE table
DROP (column)
```

## 3.约束

> ```
> 常用的约束有如下几种：
> NOT NULL （非空约束）
> UNIQUE （唯一性约束）
> PRIMARY KEY （主键约束）  :尽量别用
> FOREIGN KEY （外键约束）
> CHECK （自定义约束）：
> 	check的使用：salary必须大于0
>     .., salary NUMBER(2)
>     CONSTRAINT emp_salary_min 
>     CHECK (salary > 0),.
> 
> ```

### 3.1.添加约束

建表的时候添加约束：

```
CREATE TABLE employees(
 employee_id NUMBER(6),
 first_name VARCHAR2(20),
 ...
 job_id VARCHAR2(10) NOT NULL,
 CONSTRAINT emp_emp_id_pk
 PRIMARY KEY (EMPLOYEE_ID));

```

单独创建约束语法：

```
ALTER TABLE CUX_LES_JE_LINES ADD CONSTRAINT CUX_LES_JE_LINES_PK 
 PRIMARY KEY(JE_LINE_ID);
```

### 3.2.删除约束

```
ALTER TABLE departments
DROP PRIMARY KEY CASCADE;
```

### 3.3.约束失效

```
ALTER TABLE employees
ENABLE CONSTRAINTemp_emp_id_pk;
```

### 3.4.查看某个表有哪些约束

```
SELECT constraint_name, constraint_type,
search_condition
FROM user_constraints
WHERE table_name = 'EMPLOYEES'
```

## 4.试图

### 4.1.创建视图

```
CREATE VIEW empvu80
AS SELECT employee_id, last_name, salary
 FROM employees
 WHERE department_id = 80;
```

### 4.2.删除试图

```
DROP VIEW empvu80
```

### 4.3.TOP-N 查询：查询某个表前N行数据，并显示行号

```
SELECT [column_list], ROWNUM 
FROM (SELECT [column_list] 
 FROM table
 ORDER BY Top-N_column)
WHERE ROWNUM <= N;
```

### 4.4.视图可以修改吗？

> update的情况，必须是一下情况
>
> \1. view的字段只涉及一个表。
> \2. 如果涉及多个表的话，被(涉及到的)view列所映射table列(或列的组合)必须是有主健约束的\3. 强制执行，方法是加上hint /*+ BYPASS_UJVC */

## 5.序列（类似mysql中的自增主键）

注意：是不存在与某一个表，保存在内存中，通过sequence.NEXTVAL获取下一个，sequence.CURRVAL 获取上一个

> 有的时候我们定义某一张表中某一列为主键，当我们往表中插入数据的时候，`对于主键字段的赋值要求唯一性`， 我们希望能有个自增长类型的数据库对象，我们每获取一次，它自动增长，保证下次获取时肯定是不一样的值， 这样我们就方便了，Oracle 数据库提供“序列”这种对象来满足我们的要求。

### 5.1.创建序列

```
CREATE SEQUENCE sequence
 [INCREMENT BY n]  //自增阶梯  默认1
 [START WITH n]   //从多少开始
 [{MAXVALUE n | NOMAXVALUE}] //最大值
 [{MINVALUE n | NOMINVALUE}] //最小值
 [{CYCLE | NOCYCLE}]
 [{CACHE n | NOCACHE}];
```

> 1) INCREMENT BY用于定义序列的步长，如果省略，则默认为1，如果出现负值，则代表Oracle序列的值是按照此步长递减的。
>
> 2) START WITH 定义序列的初始值(即产生的第一个值)，默认为1。
>
> 3) MAXVALUE 定义序列生成器能产生的最大值。选项NOMAXVALUE是默认选项，代表没有最大值定义，这时对于递增Oracle序列，系统能够产生的最大值是10的27次方;对于递减序列，最大值是-1。
>
> 4) MINVALUE定义序列生成器能产生的最小值。选项NOMAXVALUE是默认选项，代表没有最小值定义，这时对于递减序列，系统能够产生的最小值是?10的26次方;对于递增序列，最小值是1。
>
> 5) CYCLE和NOCYCLE 表示当序列生成器的值达到限制值后是否循环。CYCLE代表循环，NOCYCLE代表不循环。如果循环，则当递增序列达到最大值时，循环到最小值;对于递减序列达到最小值时，循环到最大值。如果不循环，达到限制值后，继续产生新值就会发生错误。
>
> 6) CACHE(缓冲)定义存放序列的内存块的大小，默认为20。NOCACHE表示不对序列进行内存缓冲。对序列进行内存缓冲，可以改善序列的性能。
>
> 大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。Oracle序列允许将序列提前生成 cache x个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数也不能设置太大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入cache x个。这种情况也能会在数据库关闭时也会导致序号不连续。
>
> 7) NEXTVAL 返回序列中下一个有效的值，任何用户都可以引用。
>
> 8) CURRVAL 中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。

### 5.2.使用序列

```
INSERT INTO departments(department_id, 
 department_name, location_id)
VALUES (dept_deptid_seq.NEXTVAL, 
 'Support', 2500);
SELECT dept_deptid_seq.CURRVAL
FROM dual;
```

### 5.3.更改序列

```
ALTER SEQUENCE dept_deptid_seq
 INCREMENT BY 20
 MAXVALUE 999999
 NOCACHE NOCYCLE;
```

### 5.4.删除序列

```
DROP SEQUENCE dept_deptid_seq
```

## 6.索引

### 6.1.oracle中索引的区别：

```
逻辑上：
Single column 单行索引
Concatenated 多行索引
Unique 唯一索引
NonUnique 非唯一索引
Function-based函数索引
Domain 域索引
 
物理上：
Partitioned 分区索引
NonPartitioned 非分区索引
B-tree：
Normal 正常型B树
Rever Key 反转型B树 
Bitmap 位图索引
 
索引结构：
B-tree：
适合与大量的增、删、改（OLTP）；
不能用包含OR操作符的查询；
适合高基数的列（唯一值多）
典型的树状结构；
每个结点都是数据块；
大多都是物理上一层、两层或三层不定，逻辑上三层；
叶子块数据是排序的，从左向右递增；
在分支块和根块中放的是索引的范围；
Bitmap:
适合与决策支持系统；
做UPDATE代价非常高；
非常适合OR操作符的查询； 
基数比较少的时候才能建位图索引；
 
树型结构：
索引头 
开始ROWID，结束ROWID（先列出索引的最大范围）
BITMAP
每一个BIT对应着一个ROWID，它的值是1还是0，如果是1，表示着BIT对应的ROWID有值
```



```
1. b-tree索引
Oracle数据库中最常见的索引类型是b-tree索引，也就是B-树索引，以其同名的计算科学结构命名。CREATE 
INDEX语句时，默认就是在创建b-tree索引。没有特别规定可用于任何情况。
2. 位图索引(bitmap index)
位图索引特定于该列只有几个枚举值的情况，比如性别字段，标示字段比如只有0和1的情况。
3. 基于函数的索引
比如经常对某个字段做查询的时候是带函数操作的，那么此时建一个函数索引就有价值了。
4. 分区索引和全局索引
这2个是用于分区表的时候。前者是分区内索引，后者是全表索引
5. 反向索引（REVERSE）
这个索引不常见，但是特定情况特别有效，比如一个varchar(5)位字段(员工编号)含值
（10001,10002,10033,10005,10016..）
这种情况默认索引分布过于密集，不能利用好服务器的并行
但是反向之后10001,20001,33001,50001,61001就有了一个很好的分布，能高效的利用好并行运算。
6.HASH索引
HASH索引可能是访问数据库中数据的最快方法，但它也有自身的缺点。集群键上不同值的数目必须在创建HASH集群之前就要知道。需要在创建HASH集群的时候指定这个值。使用HASH索引必须要使用HASH集群。
```

### 6.2.创建索引

```
--普通索引Normal
CREATE INDEX emp_last_name_idx
ON employees(last_name);
--唯一索引Unique
CREATE INDEX emp_last_name_idx
ON employees(last_name);
```

### 6.3.什么时候适合索引

在什么样的情况下创建索引对加快查询有利呢：

> 查询条件中使用到这个列（或者这个列于其他列的组合），且这个列（或者与其他列的组合）上的数字 范围跨度很大，而大多数情况下我们要获取的数据的量占整个表的数据总量 小于4%； 

在什么样的情况下不适合创建索引呢：

>  被查询的表本身就很小，即是是全表扫描也非常快； 或者基于这张表的查询，大多数情况下需要获取 的数据量都超过了总量的4%；或者这张表需要频繁的被更新，建立索引的话会引起索引的频繁更新，从而反而 降低数据库的整体效率。

### 6.4.索引函数

当查询语句的Where条件中，对于某些列使用了函数表达式时，普通索引对查询没有帮助，如果想利用索引，则 必须创建函数索引，比如在下面的例子中，

```
SELECT *
FROM departments
WHERE UPPER(department_name) = 'SALES'
```

对于上述查询语句，如果建立普通索引，比如Create index dp_idx2 on departments(department_name) 那么上述SQL执行的时候，Oracle是不会走索引的，需要建立函数索引： 

```
CREATE INDEX upper_dept_name_idx ON departments(UPPER(department_name))
```

## 7.同义词

### 7.1.DB-LINK（不同数据库）

> Database Link , 如果你需要在当前数据库中访问另一个数据库中表，最简单的方法是在当前数据库中创建一个 数据库连接指向另一个数据库，然后通过@数据库连接的后缀就可以访问另一个数据库中的表了。

创建 DB-LINK，通过DB-LINK 访问另一数据库中的

```
CREATE PUBLIC DATABASE LINK hq.acme.com 

USING 'sales';

SELECT * FROM emp@HQ.ACME.COM;
```

### 7.2.同义词

当同一个数据库的A用户要访问B用户的表，需要加上前端B.table

当我们要通过DB-LINK访问另一个数据库中的某张表的时候我们需要加@后缀 @db-link-name

> 为了在程序中能够简化写法，Oracle 提供同义词，也就是可以在A用户下建立一个同义词指向B用户下的 Table1, 以后访问的时候可以直接访问这个同义词，而不用加前缀了。

### 7.2.创建同义词

```
CREATE SYNONYM Table1 for B.Table1
```

A用户就可以通过同义词访问B的表：

```
select * from Table1
```

## 8.控制权限

每个人登录Oracle数据库都是以某个特定的数据库用户登录的，用户能否创建表？ 该用户能否访问其他用户 下面的表。。等等这些事情都是可以利用Oracle的权限控制机制进行控制的。

### 8.1.给某个用户赋予权限

```
GRANT create session //会员权限
 , create table//表权限
 , create procedure //存储过程权限
 , create sequence//序列
 , create trigger
 , create view
 , create synonym 
 , alter session
TO HPOS;
```

### 8.2.添加角色

```
CREATE ROLE manager ;  --创建manager角色
GRANT create table, create view to manager; --manager赋予创建表、视图权限
GRANT manager to DEHAAN, KOCHHAR; --DEHAAN, KOCHHAR拥有manager的权限
```

### 8.3.给用户赋予修改某个表某个字段权限

```
GRANT update (department_name, location_id)
ON departments
TO scott, manager;
```

### 8.4.权限传递

```
如果你想让其他用户也有权 把你赋给他的权限进一步赋予给别人，那么需要带 WITH GRANT OPTION;
GRANT select, insert
ON departments
TO scott
WITH GRANT OPTION;
```

### 8.5.所有人都有某权限

```
GRANT select
ON alice.departments
TO PUBLIC;
```

### 8.6.权限数据字典

![image-20210714150513801](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210714150513801.png)

### 8.7.收回权限

```
REVOKE {privilege [, privilege...]|ALL}
ON object
FROM {user[, user...]|role|PUBLIC}
```

## 9.Oracle集合

### 9.1.并集

```
UNION 去重
UNION ALL  不去重
```

### 9.2.交集

```
INTERSECT
```

### 9.3.差集

```
MINUS
```

## 10.Group by子句增强

### 10.1.ROLLUP关键字

Rollup 后面跟了n个字段，就将进行n+1次分组，从右到左每次减少一个字段进行分组；然后进行 union

```
SELECT department_id, job_id, SUM(salary)
FROM employees 
WHERE department_id < 60
GROUP BY ROLLUP(department_id, job_id);
```

查询出来的结果：从group by右边每次减少一个，所以对department_id再进行一次分组

![image-20210715101315667](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210715101315667.png)

### 10.2.Cube

Cube 后面跟了n个字段，就将进行2的N次方的分组运算，然后进行；

```
SELECT department_id, job_id ,SUM(salary)
FROM employees 
WHERE department_id < 60
GROUP BY cube(department_id, job_id);  --对两个字段都额外分组
```

![image-20210715101926612](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210715101926612.png)

### 10.3.grouping关键字

由于ROLLUP、CUBE对字段进行额外的分组，可以使用grouping函数，没有被分组的列返回1，否则返回0

![image-20210715102229290](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210715102229290.png)

### 10.4.grouping set关键字

分别对（department_id,job_id）、（job_id,manager_id）进行分组

```
--GROUPING SETS
SELECT department_id, job_id, grouping(department_id),grouping(job_id),grouping(manager_id)
 manager_id,avg(salary)
FROM employees_copy
GROUP BY GROUPING SETS 
((department_id,job_id), (job_id,manager_id));
```

![image-20210715102835413](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210715102835413.png)

## 11.子查询进阶

### 11.1.把查询结果当做一个表

```
--把查询结果当做一个表
--查询员工大于自己部门的平均工资
SELECT a.last_name, a.salary, a.department_id, b.salavg
  FROM employees_copy a,
       (SELECT department_id, AVG(salary) salavg
          FROM employees_copy
         GROUP BY department_id) b
 WHERE a.department_id = b.department_id
   AND a.salary > b.salavg;
```

### 11.2.当做某个判断条件

```
--查询工资大于平均工资的员工信息
SELECT last_name, salary, department_id
  FROM employees
 outer WHERE salary > (SELECT AVG(salary)
                         FROM employees
                        WHERE department_id = outer.department_id);
```

### 11.3.exists关键字

> EXISTS(包括 NOT EXISTS )子句的返回值是一个BOOL值。 EXISTS内部有一个子查询语句(SELECT ... FROM...)， 我将其称为EXIST的内查询语句。其内查询语句返回一个结果集。 EXISTS子句根据其内查询语句的结果集空或者非空，返回一个布尔值。
>
> 一种通俗的可以理解为：将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则EXISTS子句返回TRUE，这一行行可作为外查询的结果行，否则不能作为结果。

```
SELECT employee_id, last_name, job_id, department_id
  FROM employees
 outer WHERE EXISTS
 --满足一条就执行
 (SELECT 'X' FROM employees WHERE manager_id = outer.employee_id);

SELECT employee_id, last_name, job_id, department_id
  FROM employees
 WHERE employee_id IN
       (SELECT manager_id FROM employees WHERE manager_id IS NOT NULL);
```

**IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。**

### 11.4.Not Exists

```
SELECT department_id, department_name
  FROM departments d
 WHERE NOT EXISTS
 (SELECT 'X' FROM employees WHERE department_id = d.department_id);
 
SELECT department_id, department_name
  FROM departments
 WHERE department_id NOT IN (SELECT department_id FROM employees);
```

> 注意：Not In 里面只要有一个NULL ，就不成立了，这是很容易出错的地方； 正确的方法请在后 面的子查询中加上where department_id is not null

### 11.5某个表的字段更新为另一个表的字段（慎用）

员工表的department_name去查询部门表获取，通过department_id关联

```
UPDATE employees e
SET department_name = 
 (SELECT department_name
 FROM departments d
 WHERE e.department_id = d.department_id);
```

### 11.6.子查询delete（不用）

删除工作年限五年，并且开始时间与员工入职时间相同的

```
DELETE FROM job_history JH
 WHERE employee_id =
 (SELECT employee_id
 FROM employees E
 WHERE JH.employee_id = E.employee_id
 AND start_date =
 (SELECT MIN(start_date) 
 FROM job_history JH
 WHERE JH.employee_id = E.employee_id)
 AND 5 > (SELECT COUNT(*) 
 FROM job_history JH
 WHERE JH.employee_id = E.employee_id
 GROUP BY employee_id
HAVING COUNT(*) >= 4));
```

### 11.7.With关键字

类似于取别名

```
 --with关键字
WITH dept_costs AS
 (SELECT d.department_name, SUM(e.salary) AS dept_total
    FROM employees e, departments d
   WHERE e.department_id = d.department_id
   GROUP BY d.department_name),
avg_cost AS
 (SELECT SUM(dept_total) / COUNT(*) AS dept_avg FROM dept_costs)

--使用别名
SELECT *
  FROM dept_costs
 WHERE dept_total > (SELECT dept_avg FROM avg_cost)
 ORDER BY department_name;
```

使用WITH好处：

> 1） 如果在后面多次使用则可以简化SQL ; 
>
> 2) 适当提高性能

## 12.递归查询

递归语句：

```
SELECT [LEVEL], column, expr...
FROM table
[WHERE condition(s)]
[START WITH condition(s)]
[CONNECT BY PRIOR condition(s)] ;


manager_id===员工上级ID  ,employee_id ===员工ID
--查找employee_id=100的下级员工
SELECT last_name || ' reports to ' || PRIOR last_name as "列名",
       PRIOR job_id as "parent_jobid",
       job_id
  FROM employees
 START WITH employee_id=100
CONNECT BY PRIOR employee_id = manager_id;

--查找employee_id=100的上级员工
SELECT last_name || ' reports to ' || PRIOR last_name as "列名",
       PRIOR job_id as "parent_jobid",
       job_id
  FROM employees
 START WITH employee_id=100
CONNECT BY PRIOR manager_id = employee_id;
```

`LEVEL`关键字和 `LPAD`函数 ，在OUTPUT中显示树形层次。

```
--递归查找employee_id=100的下级  根据树形级别在左边填充*
SELECT LPAD(last_name, LENGTH(last_name) + (LEVEL * 2) - 2, '*') AS org_chart,LEVEL
  FROM employees
 START WITH employee_id = 100
CONNECT BY PRIOR employee_id = manager_id
```

![image-20210715145217398](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210715145217398.png)

## 13.insert增强（插入几个表）

### 13.1.一个来源插入多个目标表（无条件）。

```
--根据查询的结果分别插入到sal_history、mgr_history表
INSERT ALL 
INTO sal_history VALUES(EMPID, HIREDATE, SAL) 
INTO mgr_history VALUES(EMPID, MGR, SAL)
  SELECT employee_id EMPID, hire_date HIREDATE, salary SAL, manager_id MGR
    FROM employees
   WHERE employee_id > 200;
```

### 13.2.一个来源插入多个目标表（有条件，首次匹配即跳到下一条）

```
--依次匹配，插入到一个表中即可
INSERT FIRST
 WHEN SAL > 25000 THEN INTO special_sal VALUES(DEPTID, SAL)
 WHEN HIREDATE like ('%00%') THEN INTO hiredate_history_00 VALUES(DEPTID,HIREDATE)
 WHEN HIREDATE like ('%99%') THEN INTO hiredate_history_99 VALUES(DEPTID, HIREDATE)
 ELSE INTO hiredate_history VALUES(DEPTID, HIREDATE)
   SELECT department_id DEPTID, SUM(salary) SAL,
   MAX(hire_date) HIREDATE
   FROM employees
   GROUP BY department_id;
```

## 14.sql进阶

### 14.1.查询部门的平均工资、最高工资和最低工资，并且把员工都查询出来

```
--查询根据部门名的平均工资、最高工资和最低工资（每个员工都要被查出来）
SELECT e.last_name,
       e.salary,
       d.department_name,
       AVG(e.salary) over(PARTITION BY d.department_name) department_avg_salary,
       MAX(e.salary) over(PARTITION BY d.department_name) department_max_salary,
       MIN(e.salary) over(PARTITION BY d.department_name) department_min_salary
  FROM employees e, departments d
 WHERE 1 = 1
   AND e.department_id = d.department_id;
```

使用子查询+表连接配合也可以实现：

```
select e1.last_name,e1.salary,e1.department_id,e2.avgFiled,e2.maxFiled,e2.minFiled 
from employees e1,
(select department_id, AVG(salary) as avgFiled,MAX(salary) as maxFiled,MIN(salary) as minFiled from employees group by department_id) e2,
departments d 
where e1.department_id = e2.department_id
and e1.department_id = d.department_id;
```

![image-20210715152020179](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210715152020179.png)

### 14.2.将一个部门内的员工的工资从高到低进行排序，注意三种排序结果是不一样的。

![image-20210715152230038](https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/image-20210715152230038.png)

### 14.3.Oracle的闪回机制

> Oracle数据库中提供一种机制可以用来查询之前一段时间内修改行原先的值，比如我们错误的提 交了修改结果，现在又想查看修改行原来的值，这时候就可以使用闪回。

```
--通过AS OF TIMESTAMP SYSDATE-5/(24*60)  回退到五分钟前
SELECT * FROM departments AS OF TIMESTAMP SYSDATE-5/(24*60) 
WHERE department_name = 'Sales';
```

查询被删除的department_name = 'Sales'并还原数据

```sql
--开始有数据
select * from departments WHERE department_name = 'Sales';

--删除
DELETE FROM departments WHERE department_name = 'Sales';
COMMMIT;

--查询数据已经被删除
select * from departments WHERE department_name = 'Sales';

--闪回到5分钟之前，再执行下查询试试有没有结果。
SELECT * FROM departments AS OF TIMESTAMP SYSDATE-5/(24*60) 
WHERE department_name = 'Sales';

--还原数据
insert into departments 
SELECT * FROM departments AS OF TIMESTAMP SYSDATE-5/(24*60) 
WHERE department_name = 'Sales';
```



