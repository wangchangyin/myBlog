---
title: Oracle基础知识
date: 2021-07-12 11:26:10
permalink: /pages/f1ccdf/
categories:
  - 后端
  - 数据库
  - Oracle
tags:
  - 
---
# Oracle函数

 

\* Oracle 函数分为单行函数和多行函数两大类

 

\* 单行函数

\- 操作数据项

\- 接受参数并返回处理结果

\- 对每一返回行起作用

\- 可修改数据类型

\- 可嵌套使用

 

\* 单行函数分类

\- 字符函数

\- 数值函数

\- 日期函数

\- 转换函数

\- 通用函数

 

 

## **字符函数**

 

\* 字符大小写转换函数

\* 函数  功能  用法   返回结果

\- lower()  转换为小写 lower('John Smith') john smith

\- upper()  转换为大写 upper('John Smith') JOHN SMITH

\- initcap() 单词首字母大写 initcap('JOHN smith') John Smith

 

\* 例:

\- select lower('John Smith') from dual;->(john smith)

\- select upper('John Smith') from dual;->(JOHN SMITH)

\- select initcap('JOHN smith') from dual;->(John Smith)

 

*字符处理函数

\* 函数  功能  用法   返回结果

\- concat() 字符串连接 concat('Hello', 'World') Hello World

\- substr() 截取子串 substr('HelloWorld', 4, 3) loW

\- length() 返回字符串长度 length('Hello World')  11

\- instr()  定位子串 instr('Hello World', 'or') 8

\- lpad()  左侧填充 lpad('Smith', 10, '*')  *****Smith

\- rpad()  右侧填充 rpad('Smith', 10, '*')  Smith*****

\- trim()  过滤首尾空格 trim(' Mr Smith ')  Mr Smith

\- replace() 替换  replace('ABA', 'A', 'C') CBC

 

\* 注意:函数可嵌套使用

\* 例:

\- select concat('Hello', 'World')   from dual;->(HelloWorld)

\- select concat(concat(ename, ' is a '), job) info from emp where empno=7369;->(SMITH is a CLERK)

\- select substr('HelloWorld', 4, 3)   from dual;->(loW)

\- select substr(substr('HelloWorld', 3, 6), 3, 3) from dual->(oWo)

\- select length('Hello World')   from dual;->(11)

\- select instr('Hello World', 'or')   from dual;->(8)

\- select lpad('Smith', 10, '*')   from dual;->(*****Smith)

\- select rpad('Smith', 10, '*')   from dual;->(Smith*****)

\- select trim(' Mr Smith ')   from dual;->(Mr Smith)

\- select replace('ABA', 'A', 'C')   from dual;->(CBC)

 

 

## **数值函数**

 

\* 函数  功能  用法   返回结果

\- abs()  取绝对值 abs(-3.14)  3.14

\- round()  四舍五入 round(3.1415)  3

   round(3.1415, 3) 3.142

   round(314.1592, -2) 300

\- trunc()  截断  trunc(3.1415, 3) 3.141

\- ceil()  向上取整 ceil(3.14)  4

\- floor()  向下取整 floor(3.14)  3

\- sign()  判断数值正负 sign(-3.14)  -1

\- sin()..  三角函数.. sin(3.14)  .001592653

\- power()  幂运算  power(4.5, 2)  20.25

\- sqrt()  开平方根 sqrt(9)   3

\- mod()  取模  mod(10, 3)  1

\- exp()  基数为e的幂运算exp(1)   2.71828183

\- log()  对数运算 log(4, 16.0)  2

\- ln()  自然对数运算 ln(7)   1.94591015

 

\* 例:

\- select abs(-3.14)  from dual;->(3.14)

\- select round(3.1415)  from dual;->(3)

\- select round(3.1415, 3) from dual;->(3.142)

\- select round(314.1592, -2) from dual;->(300)

\- select trunc(3.1415, 3) from dual;->(3.141)

\- select trunc(3.1415, -3) from dual;->(0)

\- select trunc(3.1415, 7) from dual;->(3.1415)

\- select ceil(3.14)  from dual;->(4)

\- select floor(3.14)  from dual;->(3)

\- select sign(-3.14)  from dual;->(-1)

\- select sin(3.14)  from dual;->(.001592653)

\- select power(4.5, 2)  from dual;->(20.25)

\- select sqrt(9)  from dual;->(3)

\- select mod(10, 3)  from dual;->(1)

\- select exp(1)   from dual;->(2.71828183)

\- select log(4, 16.0)  from dual;->(2)

\- select ln(7)   from dual;->(1.94591015)

 

 

## **日期类型**

 

\* 关于日期类型

\- Oracle内部以数字格式存储日期和时间信息:世纪,年,月,日,小时,分钟,秒

\- 缺省的日期格式是DD-MON-YY

\- 可使用sysdate函数获取当前系统日期和时间

 

\* 日期型数据的算术运算

\- 日期型数据可以直接加或减一个数值,结果仍为日期

\- 两个日期型数据可以相减,结果为二者相差多少天

 

\* 查询200-12-25减1991-12-25一共有多少天

\- select to_date('25-12月 -09') - to_date('25-12月-1991') from dual;

 

 

## **日期函数**

\* 函数   功能    用法   返回结果

\- add_months(x, y) 计算在日期x基础上增加y个月后的日期add_months(sysdate, 2)

\- last_day(x)  返回日期x当月最后一天的日期  last_day(sysdate)

\- months_between(x, y) 返回日期x和y之间相差的月数  months_between(sysdate, hiredate)

\- round(x, y)  将日期x四舍五入到y所指定的  round(sysdate, 'month')

   日期单位(月或年)的第一天  round(sysdate, 'year')

\- trunc(x, y)  将日期x截断到y所指定的   trunc(sysdate, 'month')

   日期单位(月或年)的第一天  trunc(sysdate, 'year')

\- next_day  计算指定日期x后的第一个星期几  next_day(sysdate, '星期二')

   (由参数y指定)对应的日期

 

\* 例:

\- select add_months(sysdate, 2)    from dual;->(05-10月-09)

\- select last_day(sysdate)    from dual;->(31-8月-09)

\- select hiredate, months_between(sysdate, hiredate)  from emp;

\- select months_between(sysdate, '17-12月-80')   from dual;->(343.63907)

\- select round(sysdate, 'month')   from dual;->(01-8月-09)

\- select round(to_date('16-8月 -09'), 'month')   from dual;->(01-9月-09)

\- select round(sysdate, 'year')    from dual;->(01-1月-10)

\- select round(to_date('1-7月 -09'), 'year')   from dual;->(01-1月-10)

\- select round(to_date('25-6月 -09'), 'year')   from dual;->(01-9月-09)

\- select trunc(sysdate, 'month')   from dual;->(01-8月-09)

\- select trunc(sysdate, 'year')    from dual;->(01-1月-09)

\- select next_day(sysdate, '星期二')    from dual;->(11-8月-09)

\- select next_day(next_day(sysdate, '星期二'), '星期二') from dual;->(18-8月-09)

 

 

## **转换函数**

 

\* 数据类型转换包括隐含转换和显式转换两方式,建议使用显式的数据类型转换,确保SQL语句的可靠性

 

\* 字符类型 ->数值类型 -> to_number()

\* 字符类型 ->日期类型 -> to_date()

\* 数值类型 ->字符类型 -> to_char()

\* 日期类型 ->字符类型 -> to_char()

 

 

## **日期 \**->\** \**字符串\****

 

\* to_char()函数可以将日期型数值转换为字符串形式

 

\* 格式:

\- to_char(date)   // 缺省转换为'dd-mm-yy'格式

\- to_char(date, 'format_model')  // 转换为模式串指定的格式

 

\* 例:

\- select empno, ename, sal, to_char(hiredate, 'yyyy-mm-dd') from emp;

\- select to_char(sysdate, 'yyyy-mm-dd hh:mi:ss') from dual;

\- select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') from dual;

 

 

## **常用日期格式符**

 

\* 格式符  说明   举列

\- yyyy  年份   2008

\- mm  用数字显示月份  02

\- dd  在当月中是第几天 28

\- day  星期几   星期五

\- am/pm  显示上午/下午  上午

\- hh/hh12/hh24 小时   2:30 14:30

\- mi  分钟   30

\- ss  秒钟   46

 

\* 说明:除上述格式符外,日期模式串中还可直接出现如下字符( - : ; / );

\* 如要显示其它文本字符串则需使用双引号括起来;也可在械串的开头使用"fm"标

\* 记以去掉数字前面的零

 

\* 例:

\- select to_char(sysdate, 'yyyy"年"mm"月"dd"日" day hh24:mi:ss') from dual;

\- select to_char(sysdate, 'fmyyyy"年"mm"月"dd"日" day hh24:mi:ss') from dual;

 

 

## **字符串 \**->\** \**日期\****

 

\* to_date()函数可以将字符串转换为日期型数值形式

 

\* 格式:

\- to_date(char)   // 按缺省格式'dd-mm-yy'进行解析

\- to_date(char, 'format_model')  // 按模式串指定的格式进行解析

 

\* 例:

\- insert into t5 values('BOBO', to_date('2008-02-28', 'yyyy-mm-dd'));

\- select to_date(to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') from dual;

\- select to_char(to_date(to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'), 'dd/mm/yyyy') from dual;

 

 

## **数字**

 

\* to_char()函数可以将数字值转换为字符串形式

 

\* 格式:

\- to_char(number)

\- to_char(number, 'format_model')

 

\* 例:

\- select to_char(12345.678901) from dual;

\- select to_char(12345.678901, '$99,999.0000') from dual;

 

\* 数字模式符:

\* 格式符 说 明

\- 9 代表一位数字

\- 0 代表一位数字,强制显示0

\- $ 放置一个美圆符$

\- L 放置一个本地货币符

\- . 小数点

\- , 千位指示符

 

\* 例:

\- select to_char(12345.6, 'L999,999.0000') from dual;

 

 

## **字符串 \**->\** \**数字\****

 

\* to_number()函数可以将字符串转换为数字值形式

 

\* 格式:

\- to_number(char)

\- to_number(char, 'format_model')

 

\* 例:

\- select to_number('12345.678901') from dual;

\- select to_number('$12,345.6789', '$99,999.0000') from dual;

 **2）如果数字在格式范围内的话，就是正确的，否则就是错误的；如：**

```
$12345.678小数点位数必须小于等于后面规定的格式
select to_number('$12345.678', '$999999.99') from dual;  X
select to_number('$12345.678', '$999999.999') from dual; √
select to_number('$12345.67', '$999999.999') from dual;  √
```

## **通用函数**

 

\* 通用函数适用于任何类型数据(包括空值):

\- nvl()

\- nvl2()

\- nullif()

\- coalesce()

\- case表达式

\- decode()

 

 

## **NVL()\**函数\****

 

\* NVL()函数用于将空值null替换为指定的缺省值,适用于字符,数字,日期等类型数据

 

\* 语法格式:

\- NVL(exp1, exp2)

 

\* 说明:

\- 如果表达式exp1的值为null,则返回exp2的值,否则返回exp1的值

 

\* 用法举例:

\- select empno, ename, sal, comm, sal+nvl(comm, 0) from emp;

\- select empno, ename, hiredate, nvl(hiredate, sysdate) from emp;

\- select empno, ename, job, nvl(job, 'NO job yet') from emp;

 

 

## **NVL2()\**函数\****

 

\* NVL2()函数用于实现条件表达式功能

 

\* 语法格式:

\- NVL2(exp1, exp2, exp3)

 

\* 说明:

\- 如果表达式exp1的值不为null,则返回exp2的值,否则返回exp3的值

 

\* 用法举例:

\- select empno, ename, sal, comm, nvl2(comm, sal+comm, sal) from emp;

 

 

## **NULLIF()\**函数\****

 

\* NULLIF()函数用于数据等价性比较并根据比较结果返回null或其中一个被比较的数值

 

\* 语法格式:

\- NULLIF(exp1, exp2)

 

\* 说明:

\- 如果表达式exp1与exp2的值相等返回null,否则返回exp1的值

 

\* 用法举例:

\- select name 原名, nullif(pen_name, name)化名 from author;

 

 

## **COALESCE()\**函数\****

 

\* COALESCE()函数用于实现数据"接合"功能

 

\* 语法格式:

\- COALESCE(exp1, exp2, ...)

 

\* 说明:

\- 依次考察各参数表达式,遇到非null值即停止并返回该值

 

\* 用法举例:

\- select empno, ename, sal, comm, coalesce(sal+comm, sal, 0) 总收入 from emp;

 

 

## **CASE()\**函数\****

 

\* CASE()表达式用于实现多路分支结构

 

\* 语法格式:

\- CASE exp1 when comparison_exp1 then return_exp1

\-      [when comparison_exp2 then return_exp2

\-      when comparison_expn then return_expn

\-      else esle_exp]

\- end [TempName]

 

\* 说明:

\- 如果 exp1是 comparison_exp1的时候,就返回return_exp1

\-       [ comparison_exp2 的时候,就返回return_exp2

\-        comparison_expn 的时候,就返回return_expn

\-        else 就返回 esle_exp ]

\- end [别名]

 

\* 用法举例:

```
- select empno, ename, sal,

\-     case deptno when 10 then '财务部'

\-           when 20 then '研发部'

\-           when 30 then '销售部'

\-           else '未知部门'

\-     end 部门

\- from emp;
```

**通配符：**

```
select 
JOB_ID,
  case  when JOB_ID like '%AD%' then 'AD'
    when JOB_ID like 'IT_PROG' then 'IT'
    when JOB_ID like '%FI%' then 'FI' 
    else 'No'
  end 部门简称
from employees
```

###  case高阶用法：

```
--case语句的种类:
1.简单case语句
语法:
   case exp when comexp then returnvalue
            ...
            when comexp then returnvalue
            else returnvalue
    end
      
  case到end之间相当于一个具体的值，可以做运算，取别名，嵌套case 等等。
  只要把case到end当作一个运算结果的表达式就可以了。

举例:
   select cust_last_name,
          case credit_limit when 100 then 'low'
                            when 5000 then 'high'
                            else 'medium'
          end
     from customers;
     
2.搜索case语句
语法:
    case when boolean then return value
         ...
         when boolean then return value
         else retur nvalue
     end
     
举例:
select case when id between 1 and 10 then 'low'
            when id between 20 and 30 then 'mid'
            when id between 40 and 50 then 'high'
            else 'unknow'
       end
from product;

--简单case和搜索case之间的区别：
1. 简单case只能是when后面的表达式完全匹配case后的表达式，相当于 =，所以也不能匹配null。
2. searched case可以作为比较条件，那么可以使用like、!=、between ..and、<、=、is null、is not null等，比简单case的使用更加广泛，完全可以替代简单case。

--注意事项:
1.case 表达式返回的是一个确定的value，若前面的都不匹配，则返回else中的项.
2.简单case 中的表达式，when 后面的表达式类型应该全部保持一致.
3.所有的then 后面的return_value类型要保持一致.
4.对于简单case 表达式，也就是case 表达式 when…那么when null 总是取不到。也就是case 后面的表达式如果值为null，不会与when null 匹配，只会与else匹配.
5.对于searched case来说，有自动类型转换，只要条件成立就可以。
如:select case when 1='1' then 1 end from dual; 其中1='1'条件成立

值得一提的是: sql中的case语句与pl/sql中的case语句的不同之处:
前者的else不是必须的，如果没有匹配就返回null;后者的else不写，则报case_not_found异常.

--case中嵌套子查询
Case语句中可以使用子查询，但是必须返回一行，不可以是多行.
如：
select case (select count(*) as s1 from t1 where a = 1)
           when (select count(*) as s2 from t1, t2 where t1.a = t2.a and t2.a = 1) then '相等'
           else '不相等'
       end
  from dual;
```



## **DECODE()\**函数\****

 

\* 和CASE()表达式类似,DECODE()函数也用于实现多路分支结构

 

\* 语法格式:

\- decode(col|expression, search1, result1

\-           [, search2, result2, ...,]

\-           [, default])

 

\* 说明:

\- 如果 col|expression是 search1的时候,就返回result1

\-            [ search2 的时候,就返回result2, ...]

\-            [, default])

\- [别名]

 

\* 用法举例:

\- select empno, ename, sal,

\-     decode(deptno, 10, '财务部',

\-            20, '研发部',

\-            30, '销售部',

\-           '未知部门')

\-     部门

\- from emp;

 

 

## **函数嵌套**

 

\* 单行孙数可以嵌套使用,嵌套层次无限制

 

\* 嵌套函数的执行顺序是由内到外

\- select empno, lpad(initcap(trim(ename)), 10, '*') name, job, sal from emp;

 

 

\##########[ 单行函数小结 ]##########

 

\* 使用系统提供的单行函数可实现如下功能:

\- 对数据进行计算

\- 控制数据的输出格式

\- 设置/改变日期的显示格式

\- 进行数据类型转换

\- 使用NVL函数处理空值

\- 实现IF-THEN-ELSE多路分支逻辑

 

 

# **分组函数**

 

\* 分组函数对一组数据进行运算,针对一组数据(多行记录)只返回一个结果,也称多行函数

 

\* 常用分组函数

\- 函数  功能说明   适用类型

\- avg()  计算平均值   数值型

\- count()  返回查询所行到的记录行数 任何类型数据

\- max()  计算最大值   任何类型数据

\- min()  计算最小值   任何类型数据

\- sun()  求和   数值型

> 1.上述函数除了count(*)会处理null，其他都会忽略null，可用nvl函数处理
>
> 2.备注:MIN,MAX可用于任何数据类型，便AVG， SUM，STDDEV,VARIANCE仅适用于数值型字段。

 

\* 举例:

\- select avg(sal), max(sal), min(sal), sum(sal) from emp;

\- select max(hiredate), min(hiredate) from emp;

 

 

 

## **COUNT()\**函数\****

 

\* count(*) 返回组中总记录数目**包括空行**

 

\* count(exp) 返回表达式exp值**非空**的记录数目

 

\* count(distinct(exp)) 返回表达式exp值不重复的,**非空**的记录数目

 

\* 举例:

\- select count(*) from emp;   ====      select count(*1) from emp; 

\- select count(comm) from emp;

\- select count(distinct(deptno)) from emp;

```
 select count(distinct(deptno)) from emp;
 不用distinct，使用group by改为：
 select count(deptno) from (select deptno from emp group by deptno)
```

 

## **分组函数与空值**

 

\* 分组函数省略列中的空值

\- select avg(comm) from emp;

\- select sum(comm) from emp;

 

\* **可使用NVL()函数强制分组函数处理空值**

\- select avg(nvl(comm, 0)) from emp;

 

 

## **GROUP BY\**子句\****

 

\* GROUP BY 子句将表中数据分成若干小组

 

\* 语法格式

\- select column, group_function(column)

\- from table

\- [where condition]

\- [group by group_by_expression]

\- [order by column]

 

\* 例:

\- select deptno, avg(sal) from emp group by deptno;

\- select deptno, avg(sal) from emp where deptno > 10 group by deptno;

\- select deptno, avg(sal) from emp group by deptno order by deptno desc;

 

\* 说明:

> \- 出现在SELECT列表中的字段,如果不是包含在组函数中,那么该字段必须同时在GROUP BY 子句中出现
>
> \- 包含在 GROUP BY子句中的字段则不必须出现在 SELECT列表中
>
> \- 可使用 where子句限定查询条件
>
> \- 可使用 order by子句指定排序方式



\* 注意:

\- 执行顺序: where -> group by -> select ... from ... -> order by..

 

 

\##########[ 基于多字段分组 ]##########

 

\- select deptno, job, avg(sal) from emp group by deptno, job;

 

 

\##########[ 组函数的错误用法 ]##########

 

\* 如果没有 GROUP BY子句, SELECT列表中不允许出现字段(单行函数)与分组函数混用的情况

\- select empno, sal from emp; -> (Y)

\- select avg(sal) from emp; -> (Y)

\- select empno, initcap(ename), avg(sal) from emp; -> (N)

 

\* 不允许在 WHERE子句中使用分组函数

\- select deptno, avg(sal)

\- from emp

\- where avg(sal) > 2000; -> (N)

\- group by deptno;

\- 注:这跟子句运行顺序有关,

\-   where 最先执行,

\-   在执行 where子句时,

\-   还没有执行 group by子句,

\-   还不知道什么分组,

\-   也没计算过 avg(sal)组内的平均工资

 

 

## **HAVING \**子句\****

 

\* HAVING 子句用于过滤分组

 

\* 语法格式

\- select column, group_function(column)

\- from table

\- [where condition]

\- [group by group_by_expression]

\- [order by column];

 

\* 例:

\- select deptno, job, avg(sal)

\- from emp

\- where hiredate >= to_date('1981-05-01', 'yyyy-mm-dd')

\- group by deptno, job

\- having avg(sal) > 1200

\- order by deptno, job;

 

 

\##########[ 分组函数嵌套 ]##########

 

\* 分组函数最多可嵌套两层

\- select max(avg(sal))

\- from emp

\- group by deptno;

 

 

# Oracle 表连接

 

\* SQL/Oracle 使用表连接从多个表中查询数据

 

\* 语法格式:

\- select 字段列表

\- from table1, table2

\- where table1.column1 = table2.column2

 

\* 说明:

\- 在 where子句中指定连接条件

\- 当被连接的多个表中存在同名字段时,必须在该字段前加上"表名."作为前缀

 

\* 例:

\- select empno, ename, job, emp.deptno, dname

\- from emp, dept

\- where emp.deptno = dept.deptno;

 

\* 提示:加上前缀可以提高效率

 

 

\##########[ 连接的类型 ]##########

 

\* Oracle8i之前的表连接

\- 等值连接(Equijoin)

\- 非等值连接(Non-Equijoin)

\- 外连接(Outer join)

\- 左外连接

\- 右外连接

\- 自连接(Selfjoin)

 

\* Oracle9i新引入的连接形式(支持SQL99规范):

\- 交叉连接(Cross join)

\- 自然连接(Natural join)

\- 使用 Using子句建立连接

\- 使用 On子句建立连接

\- 外连接(Outer join)

\- 左外连接

\- 右外连接

\- 全外连接

 

 

\##########[ 多表连接 ]##########

 

\* 多表连接中:

\- 可使用 AND操作符增加查询条件

\- 使用表别名可以简化查询

\- 使用表名(表别名)前缀可提高查询效率

\- 为了连接 n个表,至少需要 n-1个连接条件

 

 

\##########[ 等值连接(Equijion) ]##########

 

\* 什么是等值连接

\- select empno, ename, sal, emp.deptno, dname

\- from emp, dept

\- where emp.deptno = dept.deptno;

 

 

\##########[ 非等值连接(Not-Equijion) ]##########

 

\* 问题:如何查得每个员工的工资等级

 

\* 方法1:

\- select empno, ename, sal, grade, losal, hisal

\- from emp, salgrade

\- where sal >= losal and sal <= hisal;

 

\* 方法2:

\- select empno, ename, sal, grade, losal, hisal

\- from emp, salgrade

\- where sal between losal and hisal;

 

 

\##########[ 外连接(Outer jion) ]##########

 

\* 使用外连接可以看到参与连接的某一方不满足连接条件的记录

 

\* 外连接运算符为(+)

 

\* 传统的外连接分为左外连接和右外边接两种

 

\* 语法格式:

 

\- select 字段列表

\- from table1, table2

\- where table1.column1(+)=table2.column2;

 

\- select 字段列表

\- from table1, table2

\- where table1.column1=table2.column2(+);

 

\* 例:

 

\* 左外连接'(+)'放在右边,将左表中不符合条件的也显示出来

\- select EMPLOYEE_ID, FIRST_NAME, SALARY, e.DEPARTMENT_ID, DEPARTMENT_NAME

\- from employees e, departments d

\- where e.DEPARTMENT_ID = d.DEPARTMENT_ID(+)

\- order by EMPLOYEE_ID;

 

\* 右外连接'(+)'放在左边,将右表中不符合条件的也显示出来

\- select EMPLOYEE_ID, FIRST_NAME, SALARY, e.DEPARTMENT_ID, DEPARTMENT_NAME

\- from employees e, departments d

\- where e.DEPARTMENT_ID(+) = d.DEPARTMENT_ID

\- order by EMPLOYEE_ID;

 

 

\##########[ 自连接(Self jion) ]##########

 

\* 问题:如何查得每个员工及其上司的工号和姓名

\- select a.empno, a.ename, a.mgr, b.ename

\- from emp a, emp b

\- where a.mgr = b.empno

\- order by a.empno;

 

 

\##########[ SQL99 连接语法 ]##########

 

\* SQL1999 规范中规定的连接查询语法

\- select 字段列表

\- from table1

\- [cross join table2] |

\- [natural join table2] |

\- [join table2 using(字段名)] |

\- [join table2 on(table.column_name = table2.column_name)] |

\- [(left | right | full outer) join table2

\- on(table1.column_name = table2.column_name)];

 

 

\##########[ 交叉连接(Cross join) ]##########

##  交叉连接(Cross join)

\* Cross join产生了一个笛卡尔集,其效果等同于在两个表进行连接时未使用WHERE 子句阴定连接条件

 

\* 举例:

\- select empno, ename, sal, emp.deptno, dname

\- from emp cross join dept;

 

 

\##########[ 自然连接(Natural join) ]##########

##  Natural join自然连接

\* `Natural join` 基于两个表中的全部同名列建立连接

\- 从两个表中选出同名列的值均对应相等的所有行

\- 如果两个表中同名列的数据类型不同,则出错

\- 不允许在参照列上使用表名或者别名作为前缀

 

\* 举例:

\- select empno, ename, sal, deptno, dname

\- from emp natural join dept;

 

\- 上面SQL语句等同于:

 

\- select empno, ename, sal, emp.deptno, dname

\- from emp, dept

\- where emp.deptno = dept.deptno;

 

\* 注意:第一种方法的deptno不能加上表名前缀,第二种方法必须加上表名前缀

 

 

## **Using \**子句\****

 

\* 如果不希望参照被连接表的所有同名列进行等值连接,自然连接将无法满足

\* 要求,可以在连接时使用Using子句来设置用于等值连接的列(参照列)名.

 

\* 举例:

\- select empno, ename, sal, deptno, dname

\- from emp join dept

\- using(deptno);

 

\* 不允许在参照列上使用表名或者别名作为前缀

 

## **On \**子句\****

 

\* 如果要参照非同名的列进行等值连接,或想设置任意的连接条件,可以使用ON 子句

 

\* 举例:

\- select empno, ename, sal, emp.deptno, dname

\- from emp join dept

\- on(emp.deptno = dept.deptno);

 

\* 必须加上表名前缀(emp.deptno)

 

\- 上面SQL语句等同于:

 

\- select empno, ename, sal, emp.deptno, dname

\- from emp, dept

\- where emp.deptno = dept.deptno;

 

\--------------------------------------------------

 

\- select empno, ename, sal, emp.deptno, dname

\- from emp join dept

\- on(emp.deptno = dept.deptno and sal > 2500);

 

\- 上面SQL语句等同于:

 

\- select empno, ename, sal, emp.deptno, dname

\- from emp, dept

\- where emp.deptno = dept.deptno and sal > 2500;

 

 

**多表连接**

 

\* 使用SQL99连接语法,两个以上的表进行连接时应依次/分别指定相临的两个表之间的连接条件

 

\* 语法格式:

\- select 字段列表

\- from table1

\- [cross join table2] |

\- [natural join table2] |

\- [join table2 using(字段名)] |

\- [join table2 on(table1.column_name=table2.column_name)] |

\- [(left | right | full outer) join table2

\- on(table1.column_name=table2.column_name)]

\- [cross join table3] |

\- [`natural join` table3] |

\- [join table3 using(字段名)] |

\- [join table3 on(table2.colimn_name=table3.column_name)] |

\- [(left | right | full outer) join table3

\- on(table2.column_name=table3.column_name)];

 

\* 举例:

 

\- SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID, CITY

\- FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) NATURAL JOIN LOCATIONS;

 

\- 上面SQL语句等同于:

 

\- SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID, CITY

\- FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) JOIN LOCATIONS USING(LOCATION_ID);

 

\- 等同于:

 

\- SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, emp.DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID, CITY

\- FROM EMPLOYEES emp JOIN DEPARTMENTS dep ON(emp.DEPARTMENT_ID = dep.DEPARTMENT_ID)

\- JOIN LOCATIONS loc USING(LOCATION_ID);

 

\- 等同于:

 

\- SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, emp.DEPARTMENT_ID, DEPARTMENT_NAME, dep.LOCATION_ID, CITY

\- FROM EMPLOYEES emp JOIN DEPARTMENTS dep ON(emp.DEPARTMENT_ID = dep.DEPARTMENT_ID)

\- JOIN LOCATIONS loc ON(dep.LOCATION_ID = loc.LOCATION_ID);

 

 

## **内连接和外连接**

 

\* 内连接(Inner Join)

\- 在 SQL99规范中,内连接只返回满足连接条件的数据

 

\* 外连接(Outer Join)

 

\- 左外联接(Left Outer Join)

\- 两个表在连接过程中除返回满足连接条件的行以外,还返回左表中不满足条件的行,这种连接称为左外联接

 

\- 右外联接(Right Outer Join)

\- 两个表在连接过程中除返回满足连接条件的行以外,还返回右表中不满足条件的行,这种连接称为右外联接

 

\- 满外联接(Full Outer Join)

\- Oracle9i 开始新增功能,两个表在连接过程中除返回满足连接条件的行以外,还返回两个表中不满足条件的所有行,这种连接称为满外联接

 

\* 举例:

 

\* 不满足条件的不返回(内连接(Inner Join))

\- SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME

\- FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID);

 

\* 左表中不满足条件也返回(左外联接(Left Outer Join))

\- SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME

\- FROM EMPLOYEES LEFT JOIN DEPARTMENTS USING(DEPARTMENT_ID);

 

\* 右表中不满足条件也返回(右外联接(Right Outer Join))

\- SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME

\- FROM EMPLOYEES RIGHT JOIN DEPARTMENTS USING(DEPARTMENT_ID);

 

\* 将满足条件的和左表中不满足条件的还有右表中不满足条件的,都返回(满外联接(Full Outer Join))

\- SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME

\- FROM EMPLOYEES FULL OUTER JOIN DEPARTMENTS USING(DEPARTMENT_ID);

 

 

## **子查询\**(Sub Query)\****

 

\* 问题引入

\- 如何查得所有比'张三'工资高的员工的信息

 

\* 子查询

\- 子查询在主查询前执行一次

\- 主查询使用子查询的结果

\- 语法格式:

\- select 字段列表

\- from table

\- where 表达式 operator(select字段列表 from table);

 

\* 举例:

\- select * from emp where sal > (select sal from emp where empno = 7654);

 

 

\##########[ 使用子查询注意事项 ]##########

 

\* 在查询是基于未知值时应考虑使用子查询

 

\* 子查询必须包含在括号内

 

\* 建议将子查询放在比较运算符的右侧,以增强可读性

 

\* 除非进行 Top-N分析,否则不要在子查询中使用ORDER BY 子句

 

\* 对单行子查询使用单行运算符

 

\* 对多行子查询使用多行运算符

 

 

\##########[ 单行子查询 ]##########

 

\* 单行子查询只返回一行记录

 

\* 对单行子查询可使用单行记录比较运算符

\- 运算符  含义

\- =  等于

\- >  大于

\- >=  大于等于

\- <  小于

\- <=  小于等于

\- <>  不等于

 

\* 举例:

\- select * from emp

\- where sal > (select sal from emp where empno = 7566);

 

 

\##########[ 子查询空值/多值问题]##########

 

\* 如果子查询未返回任何行,则主查询也不会返回任何结果

\- select * from emp

\- where sal > (select sal from emp where empno = 8888);

 

\* 如果子查询返回单行结果,则为单行子查询,可以在主查询中对其使用相应的单行记录比较运算符

\- select * from emp

\- where sal > (select sal from emp where empno = 7566);

 

\* 如果子查询返回多行结果,则为多行子查询,此时不允许对其使用单行记录比较运算符

\- select * from emp

\- where sal > (select avg(sal) from emp group by deptno); -> (N)

 

\- SELECT EMPLOYEE_ID, LAST_NAME, SALARY FROM EMPLOYEES

\- WHERE JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE LAST_NAME = 'Grant'); -> (Y)

 

 

\##########[ 多行子查询 ]##########

 

\* 多行子查询返回多行记录

 

\* 对多行子查询只能使用多行记录比较运算符

 

\* 运算符  含义

\- IN  等于列表中的任何一个

\- ANY  和子查询返回的任意一个值比较

\- ALL  和子查询返回的所有值比较

 

\* 举例:

\- select * from emp where sal > any(select avg(sal) from emp group by deptno);

\- select * from emp where sal > all(select avg(sal) from emp group by deptno);

\- select * from emp where job in(select job from emp where ename = 'MARTIN' or ename = 'SMITH');

\##########[ TopN查询 ]##########

 

\* 在 ORACLE中通常用子查询的方式来实现 TOP N查询

 

\* 语法格式:

\- select 字段列表

\- from (select 字段列表 from table order by排序字段)

\- where rownum <= n;

 

\* 例:

\- select * from (select * from emp order by sal desc) where rownum <= 5;

 

 

\- select * from (select rownum myno, a.* from (select * from emp order by sal desc) a)

\- where myno >= 5 and myno <= 10;

# Oracle三范式

```
第一范式：（1NF）无重复的列
第二范式：（2NF）属性完全依赖于主键
第三范式：（3NF）属性不依赖于其它非主属性
```

# Oracle项目不推荐使用

> distinct ：推荐使用group by   
>
> 子查询：使用多表查询
>
> （+） ：使用left/right

# Oracle DML（增删改）

## 1.添加

> 从一个表中某行数据添加到另一个表中

```
insert into departments0713(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
select DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID from departments where DEPARTMENT_ID in (20,30)
```

# Oracle事务

> 在Commit或者Rollback前后数据的状态:
> 1、在数据已经被更改，但没有Commit前，被更改记录处于被锁定状态，其他用户无法进行更改;
> 2、在数据已经被更改，但没有Commit前，只有当前Session的用户可以看到这种变更，其他Session的用户看不到数据的变化。
> 3、在数据已经被更改，并且被Commit后，被更改记录自动解锁，其他用户可以进行更改;|
> 4、在数据已经被更改，并且被Commit后，其他Session的用户再次访问这些数据时，看到的是变化后的数据。

当有用户修改数据时，Oracle先把那部分原始数据备份到回滚段，在Commit之前，其他Session用户读到的这部分数据是回滚段上的;在提交之后，回滚段被释放。

**查询某个表是否有锁**

```
select a.*, C.type, C.LMODE
 from v$locked_object a, all_objects b, v$lock c
where a.OBJECT_ID = b.OBJECT_ID
 and a.SESSION_ID = c.SID
 and b.OBJECT_NAME = 'TESTTAB3'
```

查询某个表是否整在被锁

```
 select * from testtab3 for update nowait;
```

