---
title: Kafka笔记
date: 2021-08-04 19:50:36
permalink: /pages/6c0a61/
categories:
  - 后端
  - 消息队列
tags:
  - 
---
# Kafka

## 一.消息队列的两种模式

### （1）点对点模式

（一对一，消费者主动拉取数据，消息收到后消息清除） 

> 消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。 消息被消费以后，queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。 Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。

### （2）发布/订阅模式

（一对多，消费者消费数据之后不会清除消息） 

> 消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消 息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。

发布订阅也有两种模式

- 传统的发布订阅模式是队列（topic）**推送给消费者**，但是这样的坏处是，消费者处理能力不足可能造成宕机；
- **Kafka就是通过消费者主动去队列中拉数据**：但是也有坏处，消费者就需要去轮训队列中是否有数据（浪费资源）
- **队列在内部维护队列，存放某主题订阅的消费者，通知消费者去拉取数据，**该方式也有坏处，需要队列再多维护一个队列，消费者如果宕机了，队列照样要去通知。

## 二.Kafka架构

![image-20210730161800166](https://gitee.com/wcy_dch/images/raw/master/img/image-20210730161800166.png)

1）Producer ：消息生产者，就是向 kafka broker 发消息的客户端；

 2）Consumer ：消息消费者，向 kafka broker 取消息的客户端；

 3）**Consumer Group** （CG）：消费者组，由多个 consumer 组成。消费者组内每个消费者负 责消费不同分区的数据，**一个分区只能由一个组内消费者消费**；消费者组之间互不影响。所 有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。 

4）Broker ：一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。 5）Topic ：可以理解为一个队列，生产者和消费者面向的都是一个 topic； 

6）**Partition**：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上， 一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；

 7）Replica：副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失， 尚硅谷官网 且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本， 一个 leader 和若干个 follower。 

8）leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对 象都是 leader。 

9）follower：每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据 的同步。leader 发生故障时，某个 follower 会成为新的 follower。

## 三Kafka的集群搭建

> 本机搭建（伪集群）
>
> 前提：zookeeper集群已经启动
>
> 端口分别为：localhost:2181,localhost:2182,localhost:2183
>
> 参考：本网站搭建的zookeeper集群
>
> kafka端口：localhost:9092、localhost:9093、localhost:9094

下载地址：http://kafka.apache.org/downloads

kafka版本：kafka_2.11-0.11.0.0.gz

### 1.解压kafka

```
tar -zxvf kafka_2.11-0.11.0.0.tgz -C /opt/module/kafka/kafka/server1/
```

### 2.改名

```
mv kafka_2.11-0.11.0.0/ kafka
```

### 3.创建数据文件

存放生产者生产的数据

```
mkdir /opt/module/kafka/kafka/server1/data
mkdir /opt/module/kafka/kafka/server2/data
mkdir /opt/module/kafka/kafka/server3/data
```

### 4.修改配置文件

```
cd config/
vi server.properties
```

1. broker.id=0   **依次改为0,1,2**

2. 开启delete.topic.enable=true

3. listeners=PLAINTEXT://localhost:9092        **依次改为9092,9093,9094**

   注意：

   - listeners：是kafka真正bind的地址
   - advertised.listeners：是暴露给外部的listeners，如果没有设置，会用listeners
   - **若要外部访问kafka，一定要把listeners配置为IP+端口，外部就能访问了，控制台消费者就需要通过IP+端口来访问了。**

4. log.dirs=/opt/module/kafka/kafka/server1/data

5. zookeeper.connect=localhost:2181,localhost:2182,localhost:2183

```
#broker 的全局唯一编号，不能重复
broker.id=0
#删除 topic 功能使能
delete.topic.enable=true
#配置端口号
listeners=PLAINTEXT://localhost:9092 
#处理网络请求的线程数量
num.network.threads=3
#用来处理磁盘 IO 的现成数量
num.io.threads=8
#发送套接字的缓冲区大小
socket.send.buffer.bytes=102400
#接收套接字的缓冲区大小
socket.receive.buffer.bytes=102400
#请求套接字的缓冲区大小
socket.request.max.bytes=104857600
#kafka 运行日志存放的路径
log.dirs=/opt/module/kafka/kafka/server1/data
#topic 在当前 broker 上的分区个数
num.partitions=1
#用来恢复和清理 data 下数据的线程数量
num.recovery.threads.per.data.dir=1
#segment 文件保留的最长时间，超时将被删除
log.retention.hours=168
#配置连接 Zookeeper 集群地址
zookeeper.connect=localhost:2181,localhost:2182,localhost:2183
```

### 5.复制到server2、server3

```
cp -r ./kafka /opt/module/kafka/kafka/server2/
cp -r ./kafka /opt/module/kafka/kafka/server3/
```

依次修改配置文件，参考上方修改

### 6.启动

#### 方式一：一次启动

1. -daemon：后台启动
2. config/server.properties：加载配置文件

```
bin/kafka-server-start.sh -daemon config/server.properties
```

#### 方式二：sh文件启动

1.脚本内容kkStart.sh

```
#!/bin/bash

if [ "$1" = "" ];
then
    echo -e "\033[0;31m 未输入操作名 \033[0m  \033[0;34m {start|stop} \033[0m"
    exit 1
fi

function start()
{
	server1/kafka/bin/kafka-server-start.sh -daemon start server1/kafka/config/server.properties
	server2/kafka/bin/kafka-server-start.sh -daemon start server2/kafka/config/server.properties
	server3/kafka/bin/kafka-server-start.sh -daemon start server3/kafka/config/server.properties
}

function stop()
{
	server1/kafka/bin/kafka-server-stop.sh stop
	server2/kafka/bin/kafka-server-stop.sh stop
	server3/kafka/bin/kafka-server-stop.sh stop
}



case $1 in
    start)
    start;;
    stop)
    stop;;
    *)

esac

```

2.放到server1同一目录

3.给权限

```
chmod +x kkStart.sh
```

4.转化文件，通过wind10编辑后放入到linux，会出现文件格式不对

```
sed -i "s/\r//" kkStart.sh
```

### 7.测试

```
jps
```

## 四.操作主题（topic）

先进入kafka目录

### 1.创建topic

```
bin/kafka-topics.sh --zookeeper localhost:2182 --create --partitions 3 --replication-factor 2 --topic first
```

- bin/kafka-topics.sh：执行主题相关操作
- --zookeeper localhost:2182：与某台zookeeper关联，由于kafka依赖于zookeeper
- --partitions 3：分区数，该数没有限制，比如创建first，则会创建first0、first1、first2
- --replication-factor 2：副本，每个kafka集群只保存两个分区的副本，**最多为集群数**
- --topic first：名字

![image-20210804094426074](https://gitee.com/wcy_dch/images/raw/master/img/image-20210804094426074.png)

### 2.查看topic（有多少个topic）

```
bin/kafka-topics.sh --zookeeper localhost:2182 --list
```

### 3.查看详情

```
bin/kafka-topics.sh --zookeeper localhost:2182 --describe --topic first
```

![image-20210804095815851](https://gitee.com/wcy_dch/images/raw/master/img/image-20210804095815851.png)

### 4.删除topic

```
bin/kafka-topics.sh --zookeeper localhost:2182 --delete --topic two
```

## 五.发送消息

```
bin/kafka-console-producer.sh --broker-list localhost:9092 --topic first
```

## 六.消费消息

kafka默认是消费者去拉数据，所以可以收到之前订阅主题的数据，但是控制台需要加上--from-beginning才行

### 1.过时命令

> 注意：下面方式已经过时，以前消息存在zookeeper中，现在存在kafka中

```
./bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic first
```

从头开始接受数据

```
bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic first --from-beginning
```

### 2.新命令

该方式则存在kafka配置的log里面

```
bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic first
```

## 七.kafka架构深入

![image-20210804111159413](https://gitee.com/wcy_dch/images/raw/master/img/image-20210804111159413.png)

> 生产者发送消息，根据生产者的策略，发送给分区1、分区2、分区3，分区内部也自己维护了一个偏移量（offset），分区内部能保证顺序性，分区则不能保证。

Kafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，都是面向 topic 的。 

topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文 件，该 log 文件中存储的就是 producer 生产的数据。Producer 生产的数据会被不断追加到该 log 文件末端，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自己 消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。

## 八.kafka文件存储

![image-20210804112547009](https://gitee.com/wcy_dch/images/raw/master/img/image-20210804112547009.png)

> 消息都存放在分区的data文件中，消息会不断的追加到log文件末尾，为防止 log 文件过大导致数据定位 效率低下，Kafka 采取了分片和索引机制，里面有一个index文件和log文件，log存放的是实际的数据，index则是保存的消息的索引。

![image-20210804112838888](https://gitee.com/wcy_dch/images/raw/master/img/image-20210804112838888.png)

生产者发送的消息的偏移量通过二分法找到对应的index文件，index文件每一行的数据大小是固定的，假如每一行大小为1024，如果要查找偏移量为3的，则直接3*1024就能找到存储数据的偏移量，根据这个偏移量（存储了偏移量和数据大小）去log文件中直接读取数据即可。

## 九.生产者

### 1.分区规则

1）分区的原因 

- 方便在集群中扩展，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic 又可以有多个 Partition 组成，因此整个集群就可以适应任意大小的数据了； 

- 可以提高并发，因为可以以 Partition 为单位读写了。

2）分区的原则

我们需要将 producer 发送的数据封装成一个 ProducerRecord 对象。

![image-20210804134159728](https://gitee.com/wcy_dch/images/raw/master/img/image-20210804134159728.png)

1. 指明 partition 的情况下，直接将指明的值直接作为 partiton 值；
2. 没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition  数进行取余得到 partition 值； 
3. 既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后 面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition  值，也就是常说的 round-robin 算法。

### 2.数据可靠性

为保证 producer 发送的数据，能可靠的发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack（acknowledgement 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。

#### 1）副本数据同步策略

| 方案                      | 优点                                                       | 缺点                                                |
| ------------------------- | ---------------------------------------------------------- | --------------------------------------------------- |
| 半数以上发送ACK则代表成功 | 延迟低                                                     | 选取新的leader时，容忍n台节点故障，则需要2n+1个副本 |
| 全部完成同步，才发送ACK   | 选举新的 leader 时，容忍 n 台 节点的故障，需要 n+1 个副 本 | 延迟高                                              |

Kafka 选择了第二种方案：

原因如下：

 1.同样为了容忍 n 台节点的故障，第一种方案需要 2n+1 个副本，而第二种方案只需要 n+1 个副本，而 Kafka 的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。

 2.虽然第二种方案的网络延迟会比较高，但网络延迟对 Kafka 的影响较小。

#### 2）ISR

采用第二种方案之后，设想以下情景：leader 收到数据，所有 follower 都开始同步数据， 但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去， 直到它完成同步，才能发送 ack。这个问题怎么解决呢？ 

Leader 维护了一个动态的 in-sync replica set (ISR)，意为和 leader 保持同步的 follower 集 合。当 ISR 中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower 长时间 未 向 leader 同 步 数 据 ， 则 该 follower 将 被 踢 出 ISR ， 该 时 间 阈 值  replica.lag.time.max.ms 参数设定。Leader 发生故障之后，就会从 ISR 中选举新的 leader。

> 注意：0.8版本是由时间和条数决定的，后面版本已经剔除条数了；
>
> 时间：follower 向leader发送ack的时间
>
> 条数：follower 同步leader数据的条数
>
> 剔除条数的原因：
>
> ​	假如条数低于10的剔除ISR，如果生产者不停的发送数据，那么条数一会大于10，一会小于10，那么就会不停的在操作ISR，并且ISR信息也会保存到ZK，那么同样也会操作ZK。

#### 3）ack 应答机制

对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失， 所以没必要等 ISR 中的 follower 全部接收成功。 所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡， 选择以下的配置。

acks 参数配置：

1. 0：producer **不等待 broker 的 ack**，这一操作提供了一个最低的延迟，broker 一接收到还 没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据；

2. 1：producer 等待 broker 的 ack，**partition 的 leader 落盘成功后返回 ack**，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据；

3. -1（all）：producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才 返回 ack。但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会 造成数据重复。

   > 重复：当leader和follower 都同步成功后，还未发送ack时，leader挂掉，重新选择新的leader，但是生产者未收到ack，则重新发送数据，那么数据就重复了。

   > -1也会造成数据丢失:：比如ISR中只有一个副本，那么该副本肯定是leader，一旦该副本挂掉数据就没了

#### 4）故障处理细节

LEO：每个副本的最后一个offset 

HW：所有副本中最小的LEO

![image-20210804143228798](https://gitee.com/wcy_dch/images/raw/master/img/image-20210804143228798.png)

LEO：指的是每个副本最大的 offset； 

HW：指的是**消费者能见到的最大的 offset，**ISR 队列中最小的 LEO。 

（1）**follower 故障** follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后，follower 会读取本地磁盘 记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。 等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重 新加入 ISR 了。 

（2）leader 故障 leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的 数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。 注意：这只能保证副本之间的数据一致性，**并不能保证数据不丢失或者不重复。**

### 3.Exactly Once 语义（精准一次）

将服务器的 ACK 级别设置为-1，可以保证 Producer 到 Server 之间不会丢失数据，即 `At Least Once` （最少一次）语义。相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 `At Most Once` （至多一次）语义。

 At Least Once 可以保证数据不丢失，但是不能保证数据不重复；相对的，At Least Once 可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说 交易数据，下游数据消费者要求数据既不重复也不丢失，即 Exactly Once 语义。**在 0.11 版 本以前的 Kafka，对此是无能为力的，**只能保证数据不丢失，再在下游消费者对数据做全局 去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。 

0.11 版本的 Kafka，引入了一项重大特性：幂等性。所谓的幂等性就是指 Producer 不论 向 Server 发送多少次重复数据，Server 端都只会持久化一条。幂等性结合 At Least Once 语 义，就构成了 Kafka 的 Exactly Once 语义。即： 

> At Least Once + 幂等性 = Exactly Once 

要启用幂等性，只需要将 Producer 的参数中 enable.idompotence 设置为 true 即可。Kafka 的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的 Producer 在 初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而 Broker 端会对《PID、Partition 、Sequence Number》做缓存，当具有相同主键的消息提交时，Broker 只 会持久化一条。 

但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨 分区跨会话的 Exactly Once。

## 十.消费者

### 1.消费方式

consumer 采用 pull（拉）模式从 broker 中读取数据。 

push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。 它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息， 典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适 当的速率消费消息。

 pull 模式不足之处是，如果 kafka 没有数据，消费者可能会陷入循环中，一直返回空数 据。针对这一点，Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有 数据可供消费，consumer 会等待一段时间之后再返回，这段时长即为 timeout。

### 2.分区分配策略

> 消费者个数发生变化则触发：

一个 consumer group 中有多个 consumer，一个 topic 有多个 partition，所以必然会涉及 到 partition 的分配问题，即确定那个 partition 由哪个 consumer 来消费。

 Kafka 有两种分配策略，一是 RoundRobin，一是 Range。

> RoundRobin：轮训策略（适用于消费者组订阅的主题是一样的），是以消费者组为单位，把消费者所订阅的主题进行hash排序，挨个轮训发送给消费者；
>
> 问题：若消费者订阅的主题不相同，那么就会收到不是自己订阅的主题。
>
> **Range**：范围，是以**主题**为单位，在一个主题的分区中，通过分区数/消费者数目来分发给消费者

### 3.offset 的维护

由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故 障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢 复后继续消费。

![image-20210804163929513](https://gitee.com/wcy_dch/images/raw/master/img/image-20210804163929513.png)

```
存放在zookeeper中的/consumers/消费者/主题/分区：
```

![image-20210804163246499](https://gitee.com/wcy_dch/images/raw/master/img/image-20210804163246499.png)

Kafka 0.9 版本之前，consumer 默认将 offset 保存在 Zookeeper 中，从 0.9 版本开始， consumer 默认将 offset 保存在 Kafka 一个内置的 topic 中，该 topic 为**__consumer_offsets**。

### 4.消费者组案例

1.)需求：测试同一个消费者组中的消费者，同一时刻只能有一个消费者消费。

2)实操：

（1）在 server1、server2上修改/opt/module/kafka/config/consumer.properties 配置 文件中的 group.id 属性为任意组名。

```
$ vi consumer.properties
group.id=wcy
```

(2)在 server1、server2上分别启动消费者

```
server1上启动  加载刚才修改的配置文件
bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic bigdata --consumer.config config/consumer.properties
server2上启动   加载自己修改的配置文件
bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic bigdata --consumer.config config/consumer.properties
```

现在server1、server2是同一个消费者组的了。

（3）在 server3上启动消费者默认的配置文件

```
bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic bigdata
```

（4）随便启动一个生产者

```
bin/kafka-console-producer.sh --broker-list localhost:9092 --topic bigdata
```

> 最后可以看到：
>
> 生产者发送一条消息后，消费者server1和server2只可能同时接受到一条消息，不可能同意都接收到消息，而server3则一直收到消息，因为server1和server2是同一个消费者组。

## 十一.Kafka 高效读写数据

### 1）顺序写磁盘 

Kafka 的 producer 生产数据，要写入到 log 文件中，写的过程是一直追加到文件末端， 为顺序写。官网有数据表明，同样的磁盘，顺序写能到 600M/s，而随机写只有 100K/s。这 与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。

> 顺序写数据速度快

### 2）零复制技术

![image-20210804185801591](https://gitee.com/wcy_dch/images/raw/master/img/image-20210804185801591.png)

> 直接把文件的拷贝交给操作系统来完成

## 十二.Zookeeper 在 Kafka 中的作用

Kafka 集群中有一个 broker 会被选举为 Controller，负责管理集群 broker 的上下线，所 有 topic 的分区副本分配和 leader 选举等工作。

Controller 的管理工作都是依赖于 Zookeeper 的。

 以下为 partition 的 leader 选举过程：

![image-20210804185917244](https://gitee.com/wcy_dch/images/raw/master/img/image-20210804185917244.png)

## 十三. Kafka 事务

Kafka 从 0.11 版本开始引入了事务支持。事务可以保证 Kafka 在 Exactly Once 语义的基 础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败.

> 主要是为了保证跨分区精准消费，之前的幂等性不能保证分区精准消费

### Producer 事务

为了实现跨分区跨会话的事务，需要引入一个全局唯一的 Transaction ID，并将 Producer 获得的PID 和Transaction ID 绑定。这样当Producer 重启后就可以通过正在进行的 Transaction ID 获得原来的 PID。 

为了管理 Transaction，Kafka 引入了一个新的组件 Transaction Coordinator。Producer 就 是通过和 Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。Transaction Coordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于 事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。

### Consumer 事务

上述事务机制主要是从 Producer 方面考虑，对于 Consumer 而言，事务的保证就会相对 较弱，尤其时无法保证 Commit 的信息被精确消费。这是由于 Consumer 可以通过 offset 访 问任意信息，而且不同的 Segment File 生命周期不同，同一事务的消息可能会出现重启后被 删除的情况。

## 十四.API生产者流程

Kafka 的 Producer 发送消息采用的是`异步`发送的方式。在消息发送的过程中，涉及到了 两个线程——`main 线程和 Sender 线程`，以及一个线程共享变量——`RecordAccumulator`。 main 线程将消息发送给 RecordAccumulator，Sender 线程不断从 RecordAccumulator 中拉取 消息发送到 Kafka broker

![image-20210805092611016](https://gitee.com/wcy_dch/images/raw/master/img/image-20210805092611016.png)

相关参数：

batch.size：只有数据积累到 batch.size 之后，sender 才会发送数据。 

linger.ms：如果数据迟迟未达到 batch.size，sender 等待 linger.time 之后就会发送数据。

## 十五.java中引入生产者

### 1.生产者发送消息

#### 1.引入依赖

```
        <!--kafka客户端 根据本地的kafka版本-->
        <dependency>
            <groupId>org.apache.kafka</groupId>
            <artifactId>kafka-clients</artifactId>
            <version>0.11.0.0</version>
        </dependency>
```

#### 2.创建生产者

```
package com.wcy.produce;

import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.clients.producer.ProducerRecord;

import java.util.Properties;

public class MyProduce {
    public static void main(String[] args) throws InterruptedException {
        Properties properties=new Properties();
        //kafka集群地址
        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");
        //kafka ack应答策略   -1：ISR中全部发送才发送ACK   0：不管有没有回应   1：leader应答即可
        properties.put(ProducerConfig.ACKS_CONFIG,"all");
        //重试次数
        properties.put("retries", 1);
        //批次大小  当数据到达16K才发送消息
        properties.put("batch.size", 16384);
        //等待时间 毫秒  一毫秒后发送消息
        properties.put("linger.ms", 1);
        //RecordAccumulator 缓冲区大小
        properties.put("buffer.memory", 33554432);
        //序列化
        properties.put("key.serializer",
                "org.apache.kafka.common.serialization.StringSerializer");
        properties.put("value.serializer",
                "org.apache.kafka.common.serialization.StringSerializer");

        KafkaProducer<String, String> kafkaProducer = new KafkaProducer<>(properties);
        for (int i = 0; i < 10; i++) {
            kafkaProducer.send(new ProducerRecord<String,String>("bigdata","******"+i));
        }
        kafkaProducer.close();
    }
}
```

ProducerRecord()构造方法支持多种方式：

由于分区内部的数据是有序的，如果要保证顺序性消费，则放到一个分区中。

![image-20210805135203623](https://gitee.com/wcy_dch/images/raw/master/img/image-20210805135203623.png)

### 2.自定义分区

#### 1.自定义分区类实现Partitioner

```
package com.wcy.partition;

import org.apache.kafka.clients.producer.Partitioner;
import org.apache.kafka.common.Cluster;

import java.util.Map;

/**
 * 自定义分区
 */
public class MyPartition implements Partitioner {
    @Override
    public int partition(String s, Object o, byte[] bytes, Object o1, byte[] bytes1, Cluster cluster) {
        //可以参考默认的分区规则DefaultPartitioner
        return 1;
    }

    @Override
    public void close() {

    }

    @Override
    public void configure(Map<String, ?> map) {

    }
}

```

#### 4.生产者配置自定义分区器

```
properties.put(ProducerConfig.PARTITIONER_CLASS_CONFIG,"com.wcy.partition.MyPartition");
```

## 十六.引入消费者

### 1.消费者实现

> 注意一定要开启自动提交，防止消费者重复消费
>
> **若关闭自动提交，那么消费者消费数据以后，再宕机之后，上线后又会重复消费数据**

```
package com.wcy.consumer;

import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;

import java.util.Arrays;
import java.util.Properties;

/**
 * 消费者
 */
public class MyConsumer {
    public static void main(String[] args) {
        Properties properties=new Properties();
        //kafka集群信息
        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");
        //提交offset时间 单位：毫秒
        properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000");
        //自动提交
        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"true");
        //反序列化
        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");
        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");

        /**
         * 设置消费者从头消费
         * 生效条件：
         *  1.消费者组第一次消费
         *  2.消费者组之前保存的offset失效（即七天后）
         *
         *  earliest：从头消费
         *  latest：接受开启消费后的数据
         */
        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,"earliest");

        //设置消费者组
        properties.put(ConsumerConfig.GROUP_ID_CONFIG,"wcy1");

        KafkaConsumer<String,String> kafkaConsumer = new KafkaConsumer<String,String>(properties);
        kafkaConsumer.subscribe(Arrays.asList("first","bigdata"));//订阅主题

        while (true){//不停的获取数据
            ConsumerRecords<String, String> poll = kafkaConsumer.poll(1000);//获取到空数据阻塞一秒
            for(ConsumerRecord<String,String> consumerRecord:poll){
                System.out.println(consumerRecord.key()+":"+consumerRecord.value());
            }
        }
    }
}

```

### 2.消费者从头消费

消费者限制条件：

1. 消费者组第一次消费才能生效
2. 消费者之前保存的offet失效就会重新读取

```
        /**
         * 设置消费者从头消费
         * 生效条件：
         *  1.消费者组第一次消费
         *  2.消费者组之前保存的offset失效（即七天后）
         *
         *  earliest：从头消费
         *  latest：接受开启消费后的数据
         */
        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,"earliest");
```

**记得要重新设置新的消费者组**

### 3.消费者手动提交offset

若把 ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG设置为false，则不会自动提交offset，那么消费者宕机后下次来还是会消费之前的数据。

虽然自动提交 offset 十分简介便利，但由于其是基于时间提交的，开发人员难以把握 offset 提交的时机。因此 Kafka 还提供了手动提交 offset 的 API。 

手动提交 offset 的方法有两种：分别是 commitSync（同步提交）和 commitAsync（异步 提交）。两者的相同点是，都会将本次 poll 的一批数据最高的偏移量提交；不同点是， commitSync 阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致， 也会出现提交失败）；而 commitAsync 则没有失败重试机制，故有可能提交失败。

> 自动提交的补充：
>
> 1.若ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG设置为1秒钟提交offset，会造成数据丢失，假如消费者正在处理该数据，但是未处理完，已经提交到offset中，但是消费者挂掉了，那么该数据库就丢失了；
>
> 2.若ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG设置为10秒钟提交offset，会造成数据重复，假如消费者处理已经把消息处理完了，但是在6秒的时候宕机，还未写入到offset，就会造成数据重复

#### 3.1.同步提交offset

问题：若数据处理完，在手动同步提交offset时宕机，那么消费者重启后会重复消费

步骤：

1. 关闭自动提交
2. 调用kafkaConsumer.commitSync();//同步提交数据

```
package com.wcy.consumer;

import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;

import java.util.Arrays;
import java.util.Properties;

/**
 * 消费者
 */
public class MyConsumer {
    public static void main(String[] args) {
        Properties properties=new Properties();
        //kafka集群信息
        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");
        //提交offset时间 单位：毫秒
        properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000");
        //自动提交
//        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"true");
        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"false");
        //反序列化
        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");
        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");

        /**
         * 设置消费者从头消费
         * 生效条件：
         *  1.消费者组第一次消费
         *  2.消费者组之前保存的offset失效（即七天后）
         *
         *  earliest：从头消费
         *  latest：接受开启消费后的数据
         */
        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,"earliest");

        //设置消费者组
        properties.put(ConsumerConfig.GROUP_ID_CONFIG,"wcy1");

        KafkaConsumer<String,String> kafkaConsumer = new KafkaConsumer<String,String>(properties);
        kafkaConsumer.subscribe(Arrays.asList("first","bigdata"));//订阅主题

        while (true){//不停的获取数据
            ConsumerRecords<String, String> poll = kafkaConsumer.poll(1000);//获取到空数据阻塞一秒
            for(ConsumerRecord<String,String> consumerRecord:poll){
                System.out.println(consumerRecord.key()+":"+consumerRecord.value());
            }
            kafkaConsumer.commitSync();//同步提交数据
        }
    }
}
```

#### 3.2.异步提交offset

问题：若数据处理完，在手动异步提交宕机也会出现重复消费。

步骤：

1. 关闭自动提交

2. 调用

   ```
   kafkaConsumer.commitAsync(new OffsetCommitCallback() {
                   @Override
                   public void onComplete(Map<TopicPartition, OffsetAndMetadata> offsets, Exception exception) {
                       if(exception!=null){
                           System.out.println("手动提交失败");
                       }
                   }
               });
   ```

```
package com.wcy.consumer;

import org.apache.kafka.clients.consumer.*;
import org.apache.kafka.common.TopicPartition;

import java.util.Arrays;
import java.util.Map;
import java.util.Properties;

/**
 * 消费者
 */
public class MyConsumer {
    public static void main(String[] args) {
        Properties properties=new Properties();
        //kafka集群信息
        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");
        //提交offset时间 单位：毫秒
        properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000");
        //自动提交
//        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"true");
        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"false");
        //反序列化
        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");
        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");

        /**
         * 设置消费者从头消费
         * 生效条件：
         *  1.消费者组第一次消费
         *  2.消费者组之前保存的offset失效（即七天后）
         *
         *  earliest：从头消费
         *  latest：接受开启消费后的数据
         */
        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,"earliest");

        //设置消费者组
        properties.put(ConsumerConfig.GROUP_ID_CONFIG,"wcy1");

        KafkaConsumer<String,String> kafkaConsumer = new KafkaConsumer<String,String>(properties);
        kafkaConsumer.subscribe(Arrays.asList("first","bigdata"));//订阅主题

        while (true){//不停的获取数据
            ConsumerRecords<String, String> poll = kafkaConsumer.poll(1000);//获取到空数据阻塞一秒
            for(ConsumerRecord<String,String> consumerRecord:poll){
                System.out.println(consumerRecord.key()+":"+consumerRecord.value());
            }
            kafkaConsumer.commitAsync(new OffsetCommitCallback() {
                @Override
                public void onComplete(Map<TopicPartition, OffsetAndMetadata> offsets, Exception exception) {
                    if(exception!=null){
                        System.out.println("手动提交失败");
                    }
                }
            });
        }
    }
}

```

### 4 .自定义存储 offset

> 无论是同步提交还是异步提交 offset，都有可能会造成数据的漏消费或者重复消费。先 提交 offset 后消费，有可能造成数据的漏消费；而先消费后提交 offset，有可能会造成数据 的重复消费。

Kafka 0.9 版本之前，offset 存储在 zookeeper，0.9 版本及之后，默认将 offset 存储在 Kafka 的一个内置的 topic 中。除此之外，Kafka 还可以选择自定义存储 offset。 

offset 的维护是相当繁琐的，因为需要考虑到消费者的 Rebalace。

 当有新的消费者加入消费者组、已有的消费者推出消费者组或者所订阅的主题的分区发 生变化，就会触发到分区的重新分配，重新分配的过程叫做 Rebalance。 

消费者发生 Rebalance 之后，每个消费者消费的分区就会发生变化。因此消费者要首先获取到自己被重新分配到的分区，并且定位到每个分区最近提交的 offset 位置继续消费。 

要实现自定义存储 offset，需要借助 ConsumerRebalanceListener，以下为示例代码，其 中提交和获取 offset 的方法，需要根据所选的 offset 存储系统自行实现。

步骤：

1. 自定义Map存储offset信息
2. 关闭自动提交
3. 在订阅的时候绑定重新分配的监听，在重新分配之前，提交offset到mysql，在重新分配之后，读取mysql数据，让消费者从该offset消费
4. 处理完消息后，记得手动提交数据，就算出现异常也会**回滚数据（处理消息的逻辑放到一个mysql数据中）**

```
package com.wcy.consumer.offset;

import org.apache.kafka.clients.consumer.*;
import org.apache.kafka.common.TopicPartition;

import java.util.*;

/**
 * 自定义存储offset
 */
public class MyOffsetCusumer {
    //维护offset
    private static Map<TopicPartition, Long> currentOffset = new
            HashMap<>();

    public static void main(String[] args) {
        Properties properties=new Properties();
        //kafka集群信息
        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");
        //提交offset时间 单位：毫秒
        properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000");
        //自动提交
//        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"true");
        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"false");
        //反序列化
        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");
        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");

        /**
         * 设置消费者从头消费
         * 生效条件：
         *  1.消费者组第一次消费
         *  2.消费者组之前保存的offset失效（即七天后）
         *
         *  earliest：从头消费
         *  latest：接受开启消费后的数据
         */
        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,"earliest");

        //设置消费者组
        properties.put(ConsumerConfig.GROUP_ID_CONFIG,"wcy1");

        KafkaConsumer<String,String> kafkaConsumer = new KafkaConsumer<String,String>(properties);
        kafkaConsumer.subscribe(Arrays.asList("first", "bigdata"), new ConsumerRebalanceListener() {
            //该方法会在 Rebalance（重新分配） 之前调用
            @Override
            public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
                commitOffset(currentOffset);
            }

            //该方法会在 Rebalance（重新分配） 之后调用
            @Override
            public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
                currentOffset.clear();//清空offset
                //重新计算消费
                for (TopicPartition partition : partitions) {
                    //定位到最近提交的 offset 位置继续消费
                    kafkaConsumer.seek(partition, getOffset(partition));
                }
            }

        });//订阅主题

        while (true){//不停的获取数据
            ConsumerRecords<String, String> poll = kafkaConsumer.poll(1000);//获取到空数据阻塞一秒
            for(ConsumerRecord<String,String> consumerRecord:poll){
                System.out.println(consumerRecord.key()+":"+consumerRecord.value());
                currentOffset.put(new TopicPartition(consumerRecord.topic(),
                        consumerRecord.partition()), consumerRecord.offset());
            }
            commitOffset(currentOffset);//手动提交
        }
    }

    /**
     * 自定义提交到mysql  通过事务实现
     * 列：消费者组、主题、分区、offset
     * @param currentOffset
     */
    private static void commitOffset(Map<TopicPartition, Long> currentOffset) {
    }

    /**
     * 自定义读取offset
     * @param partition
     * @return
     */
    private static long getOffset(TopicPartition partition) {
        return 0;
    }
}

```

## 十七.自定义拦截器

Producer 拦截器(interceptor)是在 Kafka 0.10 版本被引入的，主要用于实现 clients 端的定 制化控制逻辑。 

对于 `producer` 而言，interceptor 使得用户在消息发送前以及 producer 回调逻辑前有机会 对消息做一些定制化需求，比如修改消息等。同时，producer 允许用户指定多个 interceptor 按序作用于同一条消息从而形成一个拦截链(interceptor chain)。Intercetpor 的实现接口是 org.apache.kafka.clients.producer.ProducerInterceptor，其定义的方法包括： 

（1）configure(configs) ：获取配置信息和初始化数据时调用。 

（2）onSend(ProducerRecord)： **消息发送前执行**，该方法封装进 KafkaProducer.send 方法中，即它运行在用户主线程中。Producer 确保在消息被序列化以及计算分区前调用该方法。用户可以在该方法中对消息做任何操作，但最好 保证不要修改消息所属的 topic 和分区，否则会影响目标分区的计算。 

（3）onAcknowledgement(RecordMetadata, Exception)：**消息发送后执行**， 该方法会在消息从 RecordAccumulator 成功发送到 Kafka Broker 之后，或者在发送过程 中失败时调用。并且通常都是在 producer 回调逻辑触发之前。onAcknowledgement 运行在 producer 的 IO 线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢 producer 的消息 发送效率。 

（4）close： **关闭 interceptor**，主要用于执行一些资源清理工作 如前所述，interceptor 可能被运行在多个线程中，因此在具体实现时用户需要自行确保 线程安全。另外倘若指定了多个 interceptor，则 producer 将按照指定顺序调用它们，并仅仅 是捕获每个 interceptor 可能抛出的异常记录到错误日志中而非在向上传递。这在使用过程中 要特别留意。 4.3.2 拦截器案

### 拦截器按钮

实现一个简单的双 interceptor 组成的拦截链。第一个 interceptor 会在消息发送前将时间 戳信息加到消息 value 的最前部；第二个 interceptor 会在消息发送后更新成功发送消息数或 失败发送消息数。

#### 1.自定义拦截器

```
package com.wcy.produce.interceptor;

import org.apache.kafka.clients.producer.ProducerInterceptor;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;

import java.util.Map;

public class TimeInterceptor implements ProducerInterceptor {
    int success;
    int error;
    @Override
    public void configure(Map<String, ?> configs) {
        System.out.println("配置信息：");
        System.out.println(configs);
    }
    @Override
    public ProducerRecord onSend(ProducerRecord record) {
        String value= (String) record.value();
        return new ProducerRecord(record.topic(),record.partition(),
                record.timestamp(),record.key(),System.currentTimeMillis()+value,record.headers());
    }

    @Override
    public void onAcknowledgement(RecordMetadata metadata, Exception exception) {
        if(exception!=null){
            success++;
        }else{
            error++;
        }
    }

    @Override
    public void close() {
        System.out.println("成功条数："+success);
        System.out.println("失败条数："+error);
    }

}
```

#### 2.生产者中引入

注意：存放的是集合

```
        properties.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, Arrays.asList("com.wcy.produce.interceptor.TimeInterceptor"));

```

## 十八.安装kafka-eagle监视

[下载地址](http://www.kafka-eagle.org/articles/docs/changelog/changelog.html)

### 1.解压

```
tar -zxvf kafka-eagle-bin-1.3.7.tar.gz
```

### 2.解压后还有个压缩文件，cd再解压

```
cd kafka-eagle-bin-1.3.7
tar -zxvf kafka-eagle-web-1.3.7-bin.tar.gz -C /opt/module/
```

### 3.改名

```
mv kafka-eagle-web-1.3.7/ eagle
```

### 4.给文件权限

```
cd /eagle/bin
chmod 777 ke.sh
```

### 5.修改配置文件

```
cd /conf
vi system-config.properties
```

修改：

eagle默认可以监控多个kafka环境

1. kafka.eagle.zk.cluster.alias=cluster1,cluster2:监控多个kafka环境
2. cluster1.zk.list：配置集群
3. cluster1.kafka.eagle.offset.storage:kafka的消息保存到kafka
4. kafka.eagle.metrics.charts：true界面有图表
5. 配置数据库

```
######################################
# multi zookeeper&kafka cluster list
######################################
#可以配置监控多个kafka
#kafka.eagle.zk.cluster.alias=cluster1,cluster2
kafka.eagle.zk.cluster.alias=cluster1
#配置集群
cluster1.zk.list=192.168.188.128:2181,192.168.188.128:2182,192.168.188.128:2183
#cluster2.zk.list=xdn10:2181,xdn11:2181,xdn12:2181

######################################
# zk client thread limit
######################################
kafka.zk.limit.size=25

######################################
# kafka eagle webui port
######################################
kafka.eagle.webui.port=8048

######################################
# kafka offset storage
######################################
#kafka0.10版本默认存放到kafka
cluster1.kafka.eagle.offset.storage=kafka
#cluster2.kafka.eagle.offset.storage=zookeeper

######################################
# enable kafka metrics
######################################
#web界面显示图表
kafka.eagle.metrics.charts=true
kafka.eagle.sql.fix.error=false

######################################
# kafka sql topic records max
######################################
kafka.eagle.sql.topic.records.max=5000

######################################
# alarm email configure
######################################
#kafka异常发送邮件
kafka.eagle.mail.enable=false
kafka.eagle.mail.sa=alert_sa@163.com
kafka.eagle.mail.username=alert_sa@163.com
kafka.eagle.mail.password=mqslimczkdqabbbh
kafka.eagle.mail.server.host=smtp.163.com
kafka.eagle.mail.server.port=25

######################################
# alarm im configure
######################################
#kafka.eagle.im.dingding.enable=true
#kafka.eagle.im.dingding.url=https://oapi.dingtalk.com/robot/send?access_token=

#kafka.eagle.im.wechat.enable=true
#kafka.eagle.im.wechat.token=https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=xxx&corpsecret=xxx
#kafka.eagle.im.wechat.url=https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=
#kafka.eagle.im.wechat.touser=
#kafka.eagle.im.wechat.toparty=
#kafka.eagle.im.wechat.totag=
#kafka.eagle.im.wechat.agentid=

######################################
# delete kafka topic token
######################################
kafka.eagle.topic.token=keadmin

######################################
# kafka sasl authenticate
######################################
cluster1.kafka.eagle.sasl.enable=false
cluster1.kafka.eagle.sasl.protocol=SASL_PLAINTEXT
cluster1.kafka.eagle.sasl.mechanism=PLAIN
cluster1.kafka.eagle.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="admin" password="kafka-eagle";

cluster2.kafka.eagle.sasl.enable=false
cluster2.kafka.eagle.sasl.protocol=SASL_PLAINTEXT
cluster2.kafka.eagle.sasl.mechanism=PLAIN
cluster2.kafka.eagle.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="admin" password="kafka-eagle";

######################################
# kafka jdbc driver address
######################################
#保存的数据库
#kafka.eagle.driver=org.sqlite.JDBC
#kafka.eagle.url=jdbc:sqlite:/hadoop/kafka-eagle/db/ke.db
#kafka.eagle.username=root
#kafka.eagle.password=www.kafka-eagle.org
#配置mysql
kafka.eagle.driver=com.mysql.jdbc.Driver
kafka.eagle.url=jdbc:mysql://localhost:3306/ke?useUnicode=true&ch
aracterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull
kafka.eagle.username=root
kafka.eagle.password=2452952178

```

6.添加环境变量（必须）

```
sudo vi /etc/profile
--添加内容
export KE_HOME=/opt/module/eagle
export PATH=$PATH:$KE_HOME/bin
重启
source /etc/profile
```

7.启动

```
ke.sh start
```

### 监控信息：

![image-20210805200512255](https://gitee.com/wcy_dch/images/raw/master/img/image-20210805200512255.png)

## 十九.面试题

[kafka](https://mp.weixin.qq.com/s/bCVtrHHpC_fpXY8Jgv6IfA)

## 二十.SSM引入Kafka

### 1.引入依赖

```
    <!--kafka-->
    <dependency>
      <groupId>org.springframework.kafka</groupId>
      <artifactId>spring-kafka</artifactId>
      <version>1.3.11.RELEASE</version>
    </dependency>
    <!--kafka客户端 根据本地的kafka版本-->
    <dependency>
      <groupId>org.apache.kafka</groupId>
      <artifactId>kafka-clients</artifactId>
      <version>0.11.0.0</version>
    </dependency>
```

### 2.kafka配置信息

```
#bootstrap.servers=10.1.10.80\:9092
#bootstrap.servers=10.1.10.77\:9092
bootstrap.servers=192.168.188.128\:9092,192.168.188.128\:9093,192.168.188.128\:9094
```

### 3.生产者配置

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/context
         http://www.springframework.org/schema/context/spring-context.xsd">

    <context:property-placeholder location="classpath:kafkaConfig.properties" ignore-unresolvable="true"/>

    <!-- 定义producer的参数 -->
    <bean id="producerProperties" class="java.util.HashMap">
        <constructor-arg>
            <map>
                <entry key="bootstrap.servers" value="${bootstrap.servers}"/>
                <!-- 组id标志 -->
                <entry key="group.id" value="test_group"/>
                <!--重试次数-->
                <entry key="retries" value="1"/>
                <!-- ack -1：ISR中全部发送才发送ACK   0：不管有没有回应   1：leader应答即可-->
                <entry key="acks" value="-1"/>
                <!-- 每次批量发送消息的数量 -->
                <entry key="batch.size" value="16384"/>
                <!-- 默认0ms，在异步IO线程被触发后（任何一个topic，partition满都可以触发） -->
                <entry key="linger.ms" value="1"/>
                <!--producer可以用来缓存数据的内存大小。如果数据产生速度大于向broker发送的速度，producer会阻塞或者抛出异常 -->
                <entry key="buffer.memory" value="33554432"/>
                <!--序列化-->
                <entry key="key.serializer" value="org.apache.kafka.common.serialization.StringSerializer"/>
                <entry key="value.serializer" value="org.apache.kafka.common.serialization.StringSerializer"/>
            </map>
        </constructor-arg>
    </bean>

    <!-- 创建kafkatemplate需要使用的producerfactory bean -->
    <bean id="producerFactory" class="org.springframework.kafka.core.DefaultKafkaProducerFactory">
        <constructor-arg>
            <ref bean="producerProperties"/>
        </constructor-arg>
    </bean>

    <!-- 创建kafkatemplate bean，使用的时候，只需要注入这个bean，即可使用template的send消息方法 -->
    <bean id="KafkaTemplate" class="org.springframework.kafka.core.KafkaTemplate">
        <constructor-arg ref="producerFactory"/>
        <constructor-arg name="autoFlush" value="true"/>
        <property name="defaultTopic" value="myTopic"/>
    </bean>
</beans>
```

### 4.消费者配置

containerProperties：可以监听多个topic主题

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/context
         http://www.springframework.org/schema/context/spring-context.xsd">

    <context:property-placeholder location="classpath:kafkaConfig.properties" ignore-unresolvable="true"/>

    <!-- 定义producer的参数 -->
    <bean id="consumerProperties" class="java.util.HashMap">
        <constructor-arg>
            <map>
                <!--Kafka服务地址 -->
                <entry key="bootstrap.servers" value="${bootstrap.servers}" />
                <!--Consumer的组ID，相同group.id的consumer属于同一个组。 -->
                <entry key="group.id" value="test_group" />
                <!--如果此值设置为true，consumer会周期性的把当前消费的offset值保存到zookeeper。当consumer失败重启之后将会使用此值作为新开始消费的值。 -->
                <entry key="enable.auto.commit" value="true" />
<!--                提交offset时间 单位：毫秒-->
                <entry key="auto.commit.interval.ms" value="1000" />
                <!--网络请求的socket超时时间。实际超时时间由max.fetch.wait + socket.timeout.ms 确定 -->
                <entry key="session.timeout.ms" value="15000" />
                <!--设置从头消费    earliest   latest-->
                <entry key="auto.offset.reset" value="earliest" />

                <entry key="key.deserializer"
                       value="org.apache.kafka.common.serialization.StringDeserializer" />

                <entry key="value.deserializer"
                       value="org.apache.kafka.common.serialization.StringDeserializer" />
            </map>
        </constructor-arg>
    </bean>

    <!-- 创建consumerFactory bean -->
    <bean id="consumerFactory" class="org.springframework.kafka.core.DefaultKafkaConsumerFactory">
        <constructor-arg>
            <ref bean="consumerProperties"/>
        </constructor-arg>
    </bean>

    <!-- 实际执行消息消费的类  自己定义的类 -->
    <bean id="messageListernerConsumerService" class="com.wcy.kafka.spring.KafkaConsumer"/>

    <!-- 消费者容器配置信息 -->
    <bean id="containerProperties" class="org.springframework.kafka.listener.config.ContainerProperties">
        <!-- 配置消费的主题 -->
<!--        <constructor-arg value="myTopic"/>-->
        <!-- 订阅多个主题 -->
        <constructor-arg>
            <list>
                <value>myTopic</value>
                <value>newTopic</value>
            </list>
        </constructor-arg>
        <property name="messageListener" ref="messageListernerConsumerService"/>
    </bean>

    <!-- 创建kafkatemplate bean，使用的时候，只需要注入这个bean，即可使用template的send消息方法 -->
    <bean id="messageListenerContainer" class="org.springframework.kafka.listener.KafkaMessageListenerContainer" init-method="doStart">
        <constructor-arg ref="consumerFactory"/>
        <constructor-arg ref="containerProperties"/>
    </bean>
    <!--ConcurrentMessageListenerContainer 这个是并发消费  concurrency这个属性就是并发消费者的数量-->
    <!--<bean id="messageListenerContainer"
        class="org.springframework.kafka.listener.ConcurrentMessageListenerContainer"
        init-method="doStart">
        <constructor-arg ref="consumerFactory" />
        <constructor-arg ref="containerProperties" />
        <property name="concurrency" value="3" />
    </bean> -->

</beans>
```

### 5.生产者发送消息

```
    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;

    public void testTemplateSend(String msg){
        kafkaTemplate.send("newTopic",msg); //指定主题
        kafkaTemplate.sendDefault("生产者默认主题");
//        for(int i=0;i<10000;i++){
//            kafkaTemplate.sendDefault("kafka发送消息****"+i);
//            if (i % 1000 == 0) {
//                System.out.println(i+"***kafka发送消息***"+i);
//            }
//        }
    }
```

6.消费者接受消息

```
package com.wcy.kafka.spring;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.listener.MessageListener;

public class KafkaConsumer implements MessageListener<Integer, String> {
    private int i;
    private int count;

    @Override
    public void onMessage(ConsumerRecord<Integer, String> record) {
	/*	 System.out.println("*****接受到消息开始***********");
		 System.out.println("整个对象:"+record);
//		 System.out.println("key:"+record.key());
//		 System.out.println("value:"+record.value());
		 System.out.println("partition:"+record.partition());*/
        try {
            System.out.println("key:"+record.key()+"value:"+record.value());
        }catch (Exception e) {
            e.printStackTrace();
        }
//        i++;
//        if (i % 1000 == 0) {
//            count++;
//            System.out.println(i+"***接受到消息结束***"+count+"---"+record);
//            i = 0;
//        }

    }


}
```



