# JUC（尚硅谷阳哥）笔记

2020权威_juc 与 jvm _并发编程_ Java 必学_阳哥- 尚硅谷视频地址：

https://www.bilibili.com/video/BV1vE411D7KE?p=38

> 多线程编程企业级套路+模板
>  * 高内聚低耦合
>  * 口诀： 线程    操作     资源类

## 一.并发题（售票员卖票）

### 1.1.旧版写法synchronized：

```
package com.wcy.juc;

/**
 * 三个售票员 卖20张票
 *
 * 多线程编程企业级套路+模板
 * 高内聚低耦合
 * 口诀： 线程    操作     资源类
 */
public class SaleTicket {
    public static void main(String[] args) {
        Ticket ticket=new Ticket();
        for (int i = 0; i < 3; i++) {
            new Thread(new Runnable() {//匿名内部类的写法
                @Override
                public void run() {
                    for (int j = 0; j < 40; j++) {
                        ticket.saleTicket();
                    }
                }
            },i+"售票员").start();
        }
    }
}
class Ticket{
    private int ticketNum=30;//票数

    public synchronized void saleTicket(){
        if(this.ticketNum > 0){
            System.out.println(Thread.currentThread().getName()+"卖出第"+ticketNum--+"票，还剩下"+ticketNum+"票");
        }
    }
}

```

### 1.2.新版写法Lock：

```
package com.wcy.juc;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 三个售票员 卖20张票
 *
 * 多线程编程企业级套路+模板
 * 高内聚低耦合
 * 口诀： 线程    操作     资源类
 */
public class SaleTicket {
    public static void main(String[] args) {
        Ticket ticket=new Ticket();
        for (int i = 0; i < 3; i++) {
//            new Thread(new Runnable() {//匿名内部类的写法
//                @Override
//                public void run() {
//                    for (int j = 0; j < 40; j++) {
//                        ticket.saleTicket();
//                    }
//                }
//            },i+"售票员").start();

            //lamda表达式
            new Thread(()->{
                for (int j = 0; j < 40; j++) {
                        ticket.saleTicket();
                }
            },i+"售票员").start();
        }
    }
}
class Ticket{
    private int ticketNum=30;//票数
    private Lock lock=new ReentrantLock();

    public synchronized void saleTicket(){
        lock.lock();
        try {
            if(this.ticketNum > 0){
                System.out.println(Thread.currentThread().getName()+"卖出第"+ticketNum--+"票，还剩下"+ticketNum+"票");
            }
        } finally {
            lock.unlock();
        }
    }
}

```

## 二.复习lambda表达式

> 条件：接口必须只有一个方法
>
> 2.1.口诀：拷贝小括号，写死右箭头，落地大括号
>
> 2.2 @FunctionalInterface 表示是函数式接口，只允许一个方法的定义
>
> 2.3 default  可以使接口有实现方法
> 2.4 静态方法实现  

```
package com.wcy.juc;

/**
 * lambda表达式练习
 */
public class LambdaTest {
    public static void main(String[] args) {
//        Foo foo=new Foo() {
//            @Override
//            public void div() {
//                System.out.println("匿名内部类写法");
//            }
//        };
//        foo.div();

        Foo foo=()->{
            System.out.println("lambda表达式写法");
        };
        foo.div();
        foo.mv();
        foo.mv1();
        Foo.staticTest();
        Foo.staticTest1();
    }
}
//表示该接口是函数式接口
@FunctionalInterface
interface Foo{
    public void div();
    default void mv(){
        System.out.println("我是默认的方法");
    }
    default void mv1(){
        System.out.println("我也是默认的方法");
    }
    public static void staticTest(){
        System.out.println("我是静态的方法");
    }
    public static void staticTest1(){
        System.out.println("我也是静态的方法");
    }
}
```

**强调**：java的接口可以有实现方法吗？

```
jdk1.8之前不可以，jdk1.8以后支持，通过default关键字实现
```



















