(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],l=e[1],c=e[2],d=0,u=[];d<s.length;d++)i=s[d],Object.prototype.hasOwnProperty.call(a,i)&&a[i]&&u.push(a[i][0]),a[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(p&&p(e);u.length;)u.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(r=!1)}r&&(o.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},a={1:0},o=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"ecdec458",3:"3c4324a9",4:"b0209c65",5:"27284ffb",6:"57ebcb36",7:"8ff1cc95",8:"63f9549b",9:"566067df",10:"7b0bdbd0",11:"5afa7e04",12:"208e8480",13:"091a9ce4",14:"7151b9d7",15:"bb6acdb2",16:"6067bc94",17:"2ee3b538",18:"3f280d96",19:"0c0231bb",20:"03b49756",21:"a144ec70",22:"be5e0407",23:"4198eb77",24:"5e54e47d",25:"0c7199fe",26:"7a5291cd",27:"b83b7f1a",28:"5477d887",29:"6ec32ac6",30:"a9eb9b15",31:"a6496a14",32:"b5379dbf",33:"78a535a0",34:"e6d4ad66",35:"ff8631ac",36:"db442c21",37:"c1ba9523",38:"6768b09a",39:"c9f1fd72",40:"35777943",41:"43e2f1d1",42:"9597c193",43:"ef6af607",44:"db0b54b7",45:"12cb4bef",46:"893e1c56",47:"52493713",48:"158af2b8",49:"0075d84b",50:"8c3be9f5",51:"2cee7923",52:"49f65b56",53:"64bfd10a",54:"d29bf96b",55:"185dab47",56:"c9fd3894",57:"c0a0dfed",58:"ad8ca2f6",59:"efeae7ff",60:"1c31cf41",61:"da830dc9",62:"68ba7528",63:"7ca1f04a",64:"43e071a5",65:"55233d69",66:"d1b2c741",67:"f594913f",68:"02f2b732",69:"467048f6",70:"b1045043",71:"42286b79",72:"46581568",73:"74e29ee5",74:"a797456b",75:"38d01bd0",76:"ad6eefc3",77:"663c63dd",78:"5f1858b7",79:"327b53e7",80:"60deb9cb",81:"e6af767f",82:"37c4c554",83:"32b7b26f",84:"5fb5e87e",85:"25a29421",86:"b00447c9",87:"6b326a02",88:"adced1fc",89:"a59352d1",90:"105072b7",91:"c1fd6382",92:"294df929",93:"85c3ce26",94:"9ef2cb4c",95:"521183de",96:"ba7fcc56",97:"1db11d02",98:"75156849",99:"ce5f296b",100:"5416bab4",101:"322c2725",102:"6b37be73",103:"6a821d54",104:"553a15b2",105:"f50b9a58",106:"439dbb4c",107:"550a13d3",108:"4fc6267e",109:"b0edf676",110:"e3256446",111:"f44da157",112:"cf2b7ccf",113:"ce23b62b",114:"a4efd687",115:"f37c3244",116:"a466bcbc",117:"f3ed6df6",118:"4019db0d",119:"2050eed3",120:"ce1004d6",121:"056aa58e",122:"ef174806",123:"af09e00a",124:"ff9f9b8b",125:"e426eee1",126:"0f67baf6",127:"d67b38ff",128:"44180ed5",129:"04983d17",130:"7521f0a4",131:"a1a68795",132:"07b70dd7",133:"cb6080fb",134:"d06e708e",135:"601c5b41",136:"4fb4f7cb",137:"5dfd3b84",138:"5fa36b65",139:"7d480183",140:"7404d5f7",141:"d6640d22"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",l.name="ChunkLoadError",l.type=r,l.request=o,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/myBlog",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var p=l;o.push([212,0]),t()}([function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({});function a(n){return null==n}function o(n){return null!=n}function i(n){return!0===n}function s(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function l(n){return null!==n&&"object"==typeof n}var c=Object.prototype.toString;function p(n){return"[object Object]"===c.call(n)}function d(n){return"[object RegExp]"===c.call(n)}function u(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===c?JSON.stringify(n,null,2):String(n)}function f(n){var e=parseFloat(n);return isNaN(e)?n:e}function h(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}h("slot,component",!0);var b=h("key,ref,slot,slot-scope,is");function v(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var y=Object.prototype.hasOwnProperty;function k(n,e){return y.call(n,e)}function x(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var w=/-(\w)/g,S=x((function(n){return n.replace(w,(function(n,e){return e?e.toUpperCase():""}))})),E=x((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),I=/\B([A-Z])/g,_=x((function(n){return n.replace(I,"-$1").toLowerCase()}));var T=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function j(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function C(n,e){for(var t in e)n[t]=e[t];return n}function A(n){for(var e={},t=0;t<n.length;t++)n[t]&&C(e,n[t]);return e}function z(n,e,t){}var O=function(n,e,t){return!1},L=function(n){return n};function P(n,e){if(n===e)return!0;var t=l(n),r=l(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),o=Array.isArray(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return P(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||o)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return P(n[t],e[t])}))}catch(n){return!1}}function R(n,e){for(var t=0;t<n.length;t++)if(P(n[t],e))return t;return-1}function M(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var B=["component","directive","filter"],D=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:O,isReservedAttr:O,isUnknownElement:O,getTagNamespace:z,parsePlatformTagName:L,mustUseProp:O,async:!0,_lifecycleHooks:D},q=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function F(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var U=new RegExp("[^"+q.source+".$_\\d]");var H,$="__proto__"in{},V="undefined"!=typeof window,G="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,W=G&&WXEnvironment.platform.toLowerCase(),K=V&&window.navigator.userAgent.toLowerCase(),Q=K&&/msie|trident/.test(K),X=K&&K.indexOf("msie 9.0")>0,Y=K&&K.indexOf("edge/")>0,J=(K&&K.indexOf("android"),K&&/iphone|ipad|ipod|ios/.test(K)||"ios"===W),Z=(K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K),K&&K.match(/firefox\/(\d+)/)),nn={}.watch,en=!1;if(V)try{var tn={};Object.defineProperty(tn,"passive",{get:function(){en=!0}}),window.addEventListener("test-passive",null,tn)}catch(n){}var rn=function(){return void 0===H&&(H=!V&&!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),H},an=V&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function on(n){return"function"==typeof n&&/native code/.test(n.toString())}var sn,ln="undefined"!=typeof Symbol&&on(Symbol)&&"undefined"!=typeof Reflect&&on(Reflect.ownKeys);sn="undefined"!=typeof Set&&on(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var cn=z,pn=0,dn=function(){this.id=pn++,this.subs=[]};dn.prototype.addSub=function(n){this.subs.push(n)},dn.prototype.removeSub=function(n){v(this.subs,n)},dn.prototype.depend=function(){dn.target&&dn.target.addDep(this)},dn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},dn.target=null;var un=[];function mn(n){un.push(n),dn.target=n}function gn(){un.pop(),dn.target=un[un.length-1]}var fn=function(n,e,t,r,a,o,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},hn={child:{configurable:!0}};hn.child.get=function(){return this.componentInstance},Object.defineProperties(fn.prototype,hn);var bn=function(n){void 0===n&&(n="");var e=new fn;return e.text=n,e.isComment=!0,e};function vn(n){return new fn(void 0,void 0,void 0,String(n))}function yn(n){var e=new fn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var kn=Array.prototype,xn=Object.create(kn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=kn[n];F(xn,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var a,o=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&i.observeArray(a),i.dep.notify(),o}))}));var wn=Object.getOwnPropertyNames(xn),Sn=!0;function En(n){Sn=n}var In=function(n){this.value=n,this.dep=new dn,this.vmCount=0,F(n,"__ob__",this),Array.isArray(n)?($?function(n,e){n.__proto__=e}(n,xn):function(n,e,t){for(var r=0,a=t.length;r<a;r++){var o=t[r];F(n,o,e[o])}}(n,xn,wn),this.observeArray(n)):this.walk(n)};function _n(n,e){var t;if(l(n)&&!(n instanceof fn))return k(n,"__ob__")&&n.__ob__ instanceof In?t=n.__ob__:Sn&&!rn()&&(Array.isArray(n)||p(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new In(n)),e&&t&&t.vmCount++,t}function Tn(n,e,t,r,a){var o=new dn,i=Object.getOwnPropertyDescriptor(n,e);if(!i||!1!==i.configurable){var s=i&&i.get,l=i&&i.set;s&&!l||2!==arguments.length||(t=n[e]);var c=!a&&_n(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(n):t;return dn.target&&(o.depend(),c&&(c.dep.depend(),Array.isArray(e)&&An(e))),e},set:function(e){var r=s?s.call(n):t;e===r||e!=e&&r!=r||s&&!l||(l?l.call(n,e):t=e,c=!a&&_n(e),o.notify())}})}}function jn(n,e,t){if(Array.isArray(n)&&u(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(Tn(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function Cn(n,e){if(Array.isArray(n)&&u(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||k(n,e)&&(delete n[e],t&&t.dep.notify())}}function An(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&An(e)}In.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)Tn(n,e[t])},In.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)_n(n[e])};var zn=N.optionMergeStrategies;function On(n,e){if(!e)return n;for(var t,r,a,o=ln?Reflect.ownKeys(e):Object.keys(e),i=0;i<o.length;i++)"__ob__"!==(t=o[i])&&(r=n[t],a=e[t],k(n,t)?r!==a&&p(r)&&p(a)&&On(r,a):jn(n,t,a));return n}function Ln(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,a="function"==typeof n?n.call(t,t):n;return r?On(r,a):a}:e?n?function(){return On("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Pn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Rn(n,e,t,r){var a=Object.create(n||null);return e?C(a,e):a}zn.data=function(n,e,t){return t?Ln(n,e,t):e&&"function"!=typeof e?n:Ln(n,e)},D.forEach((function(n){zn[n]=Pn})),B.forEach((function(n){zn[n+"s"]=Rn})),zn.watch=function(n,e,t,r){if(n===nn&&(n=void 0),e===nn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var o in C(a,n),e){var i=a[o],s=e[o];i&&!Array.isArray(i)&&(i=[i]),a[o]=i?i.concat(s):Array.isArray(s)?s:[s]}return a},zn.props=zn.methods=zn.inject=zn.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return C(a,n),e&&C(a,e),a},zn.provide=Ln;var Mn=function(n,e){return void 0===e?n:e};function Bn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,o={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(o[S(a)]={type:null});else if(p(t))for(var i in t)a=t[i],o[S(i)]=p(a)?a:{type:a};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(p(t))for(var o in t){var i=t[o];r[o]=p(i)?C({from:o},i):{from:i}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Bn(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=Bn(n,e.mixins[r],t);var o,i={};for(o in n)s(o);for(o in e)k(n,o)||s(o);function s(r){var a=zn[r]||Mn;i[r]=a(n[r],e[r],t,r)}return i}function Dn(n,e,t,r){if("string"==typeof t){var a=n[e];if(k(a,t))return a[t];var o=S(t);if(k(a,o))return a[o];var i=E(o);return k(a,i)?a[i]:a[t]||a[o]||a[i]}}function Nn(n,e,t,r){var a=e[n],o=!k(t,n),i=t[n],s=Hn(Boolean,a.type);if(s>-1)if(o&&!k(a,"default"))i=!1;else if(""===i||i===_(n)){var l=Hn(String,a.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!k(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==Fn(e.type)?r.call(n):r}(r,a,n);var c=Sn;En(!0),_n(i),En(c)}return i}var qn=/^\s*function (\w+)/;function Fn(n){var e=n&&n.toString().match(qn);return e?e[1]:""}function Un(n,e){return Fn(n)===Fn(e)}function Hn(n,e){if(!Array.isArray(e))return Un(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Un(e[t],n))return t;return-1}function $n(n,e,t){mn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var o=0;o<a.length;o++)try{if(!1===a[o].call(r,n,e,t))return}catch(n){Gn(n,r,"errorCaptured hook")}}Gn(n,e,t)}finally{gn()}}function Vn(n,e,t,r,a){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&m(o)&&!o._handled&&(o.catch((function(n){return $n(n,r,a+" (Promise/async)")})),o._handled=!0)}catch(n){$n(n,r,a)}return o}function Gn(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Wn(e,null,"config.errorHandler")}Wn(n,e,t)}function Wn(n,e,t){if(!V&&!G||"undefined"==typeof console)throw n;console.error(n)}var Kn,Qn=!1,Xn=[],Yn=!1;function Jn(){Yn=!1;var n=Xn.slice(0);Xn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&on(Promise)){var Zn=Promise.resolve();Kn=function(){Zn.then(Jn),J&&setTimeout(z)},Qn=!0}else if(Q||"undefined"==typeof MutationObserver||!on(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Kn="undefined"!=typeof setImmediate&&on(setImmediate)?function(){setImmediate(Jn)}:function(){setTimeout(Jn,0)};else{var ne=1,ee=new MutationObserver(Jn),te=document.createTextNode(String(ne));ee.observe(te,{characterData:!0}),Kn=function(){ne=(ne+1)%2,te.data=String(ne)},Qn=!0}function re(n,e){var t;if(Xn.push((function(){if(n)try{n.call(e)}catch(n){$n(n,e,"nextTick")}else t&&t(e)})),Yn||(Yn=!0,Kn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ae=new sn;function oe(n){!function n(e,t){var r,a,o=Array.isArray(e);if(!o&&!l(e)||Object.isFrozen(e)||e instanceof fn)return;if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(o)for(r=e.length;r--;)n(e[r],t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,ae),ae.clear()}var ie=x((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function se(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return Vn(r,null,arguments,e,"v-on handler");for(var a=r.slice(),o=0;o<a.length;o++)Vn(a[o],null,n,e,"v-on handler")}return t.fns=n,t}function le(n,e,t,r,o,s){var l,c,p,d;for(l in n)c=n[l],p=e[l],d=ie(l),a(c)||(a(p)?(a(c.fns)&&(c=n[l]=se(c,s)),i(d.once)&&(c=n[l]=o(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)a(n[l])&&r((d=ie(l)).name,e[l],d.capture)}function ce(n,e,t){var r;n instanceof fn&&(n=n.data.hook||(n.data.hook={}));var s=n[e];function l(){t.apply(this,arguments),v(r.fns,l)}a(s)?r=se([l]):o(s.fns)&&i(s.merged)?(r=s).fns.push(l):r=se([s,l]),r.merged=!0,n[e]=r}function pe(n,e,t,r,a){if(o(e)){if(k(e,t))return n[t]=e[t],a||delete e[t],!0;if(k(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function de(n){return s(n)?[vn(n)]:Array.isArray(n)?function n(e,t){var r,l,c,p,d=[];for(r=0;r<e.length;r++)a(l=e[r])||"boolean"==typeof l||(c=d.length-1,p=d[c],Array.isArray(l)?l.length>0&&(ue((l=n(l,(t||"")+"_"+r))[0])&&ue(p)&&(d[c]=vn(p.text+l[0].text),l.shift()),d.push.apply(d,l)):s(l)?ue(p)?d[c]=vn(p.text+l):""!==l&&d.push(vn(l)):ue(l)&&ue(p)?d[c]=vn(p.text+l.text):(i(e._isVList)&&o(l.tag)&&a(l.key)&&o(t)&&(l.key="__vlist"+t+"_"+r+"__"),d.push(l)));return d}(n):void 0}function ue(n){return o(n)&&o(n.text)&&!1===n.isComment}function me(n,e){if(n){for(var t=Object.create(null),r=ln?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var o=r[a];if("__ob__"!==o){for(var i=n[o].from,s=e;s;){if(s._provided&&k(s._provided,i)){t[o]=s._provided[i];break}s=s.$parent}if(!s)if("default"in n[o]){var l=n[o].default;t[o]="function"==typeof l?l.call(e):l}else 0}}return t}}function ge(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var o=n[r],i=o.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,o.context!==e&&o.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(o);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(fe)&&delete t[c];return t}function fe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function be(n,e,t){var a,o=Object.keys(e).length>0,i=n?!!n.$stable:!o,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(i&&t&&t!==r&&s===t.$key&&!o&&!t.$hasNormal)return t;for(var l in a={},n)n[l]&&"$"!==l[0]&&(a[l]=ve(e,l,n[l]))}else a={};for(var c in e)c in a||(a[c]=ye(e,c));return n&&Object.isExtensible(n)&&(n._normalized=a),F(a,"$stable",i),F(a,"$key",s),F(a,"$hasNormal",o),a}function ve(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:de(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!he(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function ye(n,e){return function(){return n[e]}}function ke(n,e){var t,r,a,i,s;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,a=n.length;r<a;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(l(n))if(ln&&n[Symbol.iterator]){t=[];for(var c=n[Symbol.iterator](),p=c.next();!p.done;)t.push(e(p.value,t.length)),p=c.next()}else for(i=Object.keys(n),t=new Array(i.length),r=0,a=i.length;r<a;r++)s=i[r],t[r]=e(n[s],s,r);return o(t)||(t=[]),t._isVList=!0,t}function xe(n,e,t,r){var a,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=C(C({},r),t)),a=o(t)||("function"==typeof e?e():e)):a=this.$slots[n]||("function"==typeof e?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},a):a}function we(n){return Dn(this.$options,"filters",n)||L}function Se(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Ee(n,e,t,r,a){var o=N.keyCodes[e]||t;return a&&r&&!N.keyCodes[e]?Se(a,r):o?Se(o,n):r?_(r)!==e:void 0===n}function Ie(n,e,t,r,a){if(t)if(l(t)){var o;Array.isArray(t)&&(t=A(t));var i=function(i){if("class"===i||"style"===i||b(i))o=n;else{var s=n.attrs&&n.attrs.type;o=r||N.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=S(i),c=_(i);l in o||c in o||(o[i]=t[i],a&&((n.on||(n.on={}))["update:"+i]=function(n){t[i]=n}))};for(var s in t)i(s)}else;return n}function _e(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||je(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Te(n,e,t){return je(n,"__once__"+e+(t?"_"+t:""),!0),n}function je(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Ce(n[r],e+"_"+r,t);else Ce(n,e,t)}function Ce(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ae(n,e){if(e)if(p(e)){var t=n.on=n.on?C({},n.on):{};for(var r in e){var a=t[r],o=e[r];t[r]=a?[].concat(a,o):o}}else;return n}function ze(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var o=n[a];Array.isArray(o)?ze(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function Oe(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Le(n,e){return"string"==typeof n?e+n:n}function Pe(n){n._o=Te,n._n=f,n._s=g,n._l=ke,n._t=xe,n._q=P,n._i=R,n._m=_e,n._f=we,n._k=Ee,n._b=Ie,n._v=vn,n._e=bn,n._u=ze,n._g=Ae,n._d=Oe,n._p=Le}function Re(n,e,t,a,o){var s,l=this,c=o.options;k(a,"_uid")?(s=Object.create(a))._original=a:(s=a,a=a._original);var p=i(c._compiled),d=!p;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=me(c.inject,a),this.slots=function(){return l.$slots||be(n.scopedSlots,l.$slots=ge(t,a)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(n.scopedSlots,this.slots())}}),p&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=be(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,r){var o=Ue(s,n,e,t,r,d);return o&&!Array.isArray(o)&&(o.fnScopeId=c._scopeId,o.fnContext=a),o}:this._c=function(n,e,t,r){return Ue(s,n,e,t,r,d)}}function Me(n,e,t,r,a){var o=yn(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function Be(n,e){for(var t in e)n[S(t)]=e[t]}Pe(Re.prototype);var De={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;De.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ye)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,o){0;var i=a.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==r&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l);n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a);if(n.$options._renderChildren=o,n.$attrs=a.data.attrs||r,n.$listeners=t||r,e&&n.$options.props){En(!1);for(var p=n._props,d=n.$options._propKeys||[],u=0;u<d.length;u++){var m=d[u],g=n.$options.props;p[m]=Nn(m,g,e,n)}En(!0),n.$options.propsData=e}t=t||r;var f=n.$options._parentListeners;n.$options._parentListeners=t,Xe(n,t,f),c&&(n.$slots=ge(o,a.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,et(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,rt.push(e)):nt(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,Ze(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);et(e,"deactivated")}}(e,!0):e.$destroy())}},Ne=Object.keys(De);function qe(n,e,t,s,c){if(!a(n)){var p=t.$options._base;if(l(n)&&(n=p.extend(n)),"function"==typeof n){var d;if(a(n.cid)&&void 0===(n=function(n,e){if(i(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=$e;t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(i(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],s=!0,c=null,p=null;t.$on("hook:destroyed",(function(){return v(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==c&&(clearTimeout(c),c=null),null!==p&&(clearTimeout(p),p=null))},u=M((function(t){n.resolved=Ve(t,e),s?r.length=0:d(!0)})),g=M((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),f=n(u,g);return l(f)&&(m(f)?a(n.resolved)&&f.then(u,g):m(f.component)&&(f.component.then(u,g),o(f.error)&&(n.errorComp=Ve(f.error,e)),o(f.loading)&&(n.loadingComp=Ve(f.loading,e),0===f.delay?n.loading=!0:c=setTimeout((function(){c=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,d(!1))}),f.delay||200)),o(f.timeout)&&(p=setTimeout((function(){p=null,a(n.resolved)&&g(null)}),f.timeout)))),s=!1,n.loading?n.loadingComp:n.resolved}}(d=n,p)))return function(n,e,t,r,a){var o=bn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:a},o}(d,e,t,s,c);e=e||{},St(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),i=a[r],s=e.model.callback;o(i)?(Array.isArray(i)?-1===i.indexOf(s):i!==s)&&(a[r]=[s].concat(i)):a[r]=s}(n.options,e);var u=function(n,e,t){var r=e.options.props;if(!a(r)){var i={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in r){var p=_(c);pe(i,l,c,p,!0)||pe(i,s,c,p,!1)}return i}}(e,n);if(i(n.options.functional))return function(n,e,t,a,i){var s=n.options,l={},c=s.props;if(o(c))for(var p in c)l[p]=Nn(p,c,e||r);else o(t.attrs)&&Be(l,t.attrs),o(t.props)&&Be(l,t.props);var d=new Re(t,l,i,a,n),u=s.render.call(null,d._c,d);if(u instanceof fn)return Me(u,t,d.parent,s,d);if(Array.isArray(u)){for(var m=de(u)||[],g=new Array(m.length),f=0;f<m.length;f++)g[f]=Me(m[f],t,d.parent,s,d);return g}}(n,u,e,t,s);var g=e.on;if(e.on=e.nativeOn,i(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Ne.length;t++){var r=Ne[t],a=e[r],o=De[r];a===o||a&&a._merged||(e[r]=a?Fe(o,a):o)}}(e);var h=n.options.name||c;return new fn("vue-component-"+n.cid+(h?"-"+h:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:u,listeners:g,tag:c,children:s},d)}}}function Fe(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function Ue(n,e,t,r,c,p){return(Array.isArray(t)||s(t))&&(c=r,r=t,t=void 0),i(p)&&(c=2),function(n,e,t,r,s){if(o(t)&&o(t.__ob__))return bn();o(t)&&o(t.is)&&(e=t.is);if(!e)return bn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===s?r=de(r):1===s&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var c,p;if("string"==typeof e){var d;p=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),c=N.isReservedTag(e)?new fn(N.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(d=Dn(n.$options,"components",e))?new fn(e,t,r,void 0,void 0,n):qe(d,t,n,r,e)}else c=qe(e,t,n,r);return Array.isArray(c)?c:o(c)?(o(p)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var s=0,l=e.children.length;s<l;s++){var c=e.children[s];o(c.tag)&&(a(c.ns)||i(r)&&"svg"!==c.tag)&&n(c,t,r)}}(c,p),o(t)&&function(n){l(n.style)&&oe(n.style);l(n.class)&&oe(n.class)}(t),c):bn()}(n,e,t,r,c)}var He,$e=null;function Ve(n,e){return(n.__esModule||ln&&"Module"===n[Symbol.toStringTag])&&(n=n.default),l(n)?e.extend(n):n}function Ge(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||he(t)))return t}}function We(n,e){He.$on(n,e)}function Ke(n,e){He.$off(n,e)}function Qe(n,e){var t=He;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Xe(n,e,t){He=n,le(e,t||{},We,Ke,Qe,n),He=void 0}var Ye=null;function Je(n){var e=Ye;return Ye=n,function(){Ye=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e){mn();var t=n.$options[e],r=e+" hook";if(t)for(var a=0,o=t.length;a<o;a++)Vn(t[a],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),gn()}var tt=[],rt=[],at={},ot=!1,it=!1,st=0;var lt=0,ct=Date.now;if(V&&!Q){var pt=window.performance;pt&&"function"==typeof pt.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return pt.now()})}function dt(){var n,e;for(lt=ct(),it=!0,tt.sort((function(n,e){return n.id-e.id})),st=0;st<tt.length;st++)(n=tt[st]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=rt.slice(),r=tt.slice();st=tt.length=rt.length=0,at={},ot=it=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&et(r,"updated")}}(r),an&&N.devtools&&an.emit("flush")}var ut=0,mt=function(n,e,t,r,a){this.vm=n,a&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++ut,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new sn,this.newDepIds=new sn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!U.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()};mt.prototype.get=function(){var n;mn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;$n(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&oe(n),gn(),this.cleanupDeps()}return n},mt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},mt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},mt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==at[e]){if(at[e]=!0,it){for(var t=tt.length-1;t>st&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);ot||(ot=!0,re(dt))}}(this)},mt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||l(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Vn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},mt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},mt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},mt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||v(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var gt={enumerable:!0,configurable:!0,get:z,set:z};function ft(n,e,t){gt.get=function(){return this[e][t]},gt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,gt)}function ht(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},a=n.$options._propKeys=[];n.$parent&&En(!1);var o=function(o){a.push(o);var i=Nn(o,e,t,n);Tn(r,o,i),o in n||ft(n,"_props",o)};for(var i in e)o(i);En(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?z:T(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;p(e=n._data="function"==typeof e?function(n,e){mn();try{return n.call(e,e)}catch(n){return $n(n,e,"data()"),{}}finally{gn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var o=t[a];0,r&&k(r,o)||(i=void 0,36!==(i=(o+"").charCodeAt(0))&&95!==i&&ft(n,"_data",o))}var i;_n(e,!0)}(n):_n(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=rn();for(var a in e){var o=e[a],i="function"==typeof o?o:o.get;0,r||(t[a]=new mt(n,i||z,z,bt)),a in n||vt(n,a,o)}}(n,e.computed),e.watch&&e.watch!==nn&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var a=0;a<r.length;a++)xt(n,t,r[a]);else xt(n,t,r)}}(n,e.watch)}var bt={lazy:!0};function vt(n,e,t){var r=!rn();"function"==typeof t?(gt.get=r?yt(e):kt(t),gt.set=z):(gt.get=t.get?r&&!1!==t.cache?yt(e):kt(t.get):z,gt.set=t.set||z),Object.defineProperty(n,e,gt)}function yt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),dn.target&&e.depend(),e.value}}function kt(n){return function(){return n.call(this,this)}}function xt(n,e,t,r){return p(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var wt=0;function St(n){var e=n.options;if(n.super){var t=St(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&C(n.extendOptions,r),(e=n.options=Bn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Et(n){this._init(n)}function It(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var o=n.name||t.options.name;var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=Bn(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)ft(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)vt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,B.forEach((function(n){i[n]=t[n]})),o&&(i.options.components[o]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=C({},i.options),a[r]=i,i}}function _t(n){return n&&(n.Ctor.options.name||n.tag)}function Tt(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!d(n)&&n.test(e)}function jt(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var o in t){var i=t[o];if(i){var s=i.name;s&&!e(s)&&Ct(t,o,r,a)}}}function Ct(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,v(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=wt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Bn(St(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Xe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=ge(e._renderChildren,a),n.$scopedSlots=r,n._c=function(e,t,r,a){return Ue(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return Ue(n,e,t,r,a,!0)};var o=t&&t.data;Tn(n,"$attrs",o&&o.attrs||r,null,!0),Tn(n,"$listeners",e._parentListeners||r,null,!0)}(e),et(e,"beforeCreate"),function(n){var e=me(n.$options.inject,n);e&&(En(!1),Object.keys(e).forEach((function(t){Tn(n,t,e[t])})),En(!0))}(e),ht(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Et),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=jn,n.prototype.$delete=Cn,n.prototype.$watch=function(n,e,t){if(p(e))return xt(this,n,e,t);(t=t||{}).user=!0;var r=new mt(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'+r.expression+'"';mn(),Vn(e,this,[r.value],this,a),gn()}return function(){r.teardown()}}}(Et),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var a=0,o=n.length;a<o;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var o,i=t._events[n];if(!i)return t;if(!e)return t._events[n]=null,t;for(var s=i.length;s--;)if((o=i[s])===e||o.fn===e){i.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?j(t):t;for(var r=j(arguments,1),a='event handler for "'+n+'"',o=0,i=t.length;o<i;o++)Vn(t[o],e,r,e,a)}return e}}(Et),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,o=Je(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||v(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Et),function(n){Pe(n.prototype),n.prototype.$nextTick=function(n){return re(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&(e.$scopedSlots=be(a.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=a;try{$e=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){$n(t,e,"render"),n=e._vnode}finally{$e=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof fn||(n=bn()),n.parent=a,n}}(Et);var At=[String,RegExp,Array],zt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:At,exclude:At,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,o=t.componentInstance,i=t.componentOptions;n[r]={name:_t(i),tag:a,componentInstance:o},e.push(r),this.max&&e.length>parseInt(this.max)&&Ct(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Ct(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){jt(n,(function(n){return Tt(e,n)}))})),this.$watch("exclude",(function(e){jt(n,(function(n){return!Tt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ge(n),t=e&&e.componentOptions;if(t){var r=_t(t),a=this.include,o=this.exclude;if(a&&(!r||!Tt(a,r))||o&&r&&Tt(o,r))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,v(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:cn,extend:C,mergeOptions:Bn,defineReactive:Tn},n.set=jn,n.delete=Cn,n.nextTick=re,n.observable=function(n){return _n(n),n},n.options=Object.create(null),B.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,C(n.options.components,zt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=j(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Bn(this.options,n),this}}(n),It(n),function(n){B.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Et),Object.defineProperty(Et.prototype,"$isServer",{get:rn}),Object.defineProperty(Et.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Et,"FunctionalRenderContext",{value:Re}),Et.version="2.6.14";var Ot=h("style,class"),Lt=h("input,textarea,option,select,progress"),Pt=h("contenteditable,draggable,spellcheck"),Rt=h("events,caret,typing,plaintext-only"),Mt=h("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Bt="http://www.w3.org/1999/xlink",Dt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Nt=function(n){return Dt(n)?n.slice(6,n.length):""},qt=function(n){return null==n||!1===n};function Ft(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=Ut(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=Ut(e,t.data));return function(n,e){if(o(n)||o(e))return Ht(n,$t(e));return""}(e.staticClass,e.class)}function Ut(n,e){return{staticClass:Ht(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function Ht(n,e){return n?e?n+" "+e:n:e||""}function $t(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)o(e=$t(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):l(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Vt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Gt=h("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Wt=h("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Kt=function(n){return Gt(n)||Wt(n)};var Qt=Object.create(null);var Xt=h("text,number,password,search,email,tel,url");var Yt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Vt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Jt={create:function(n,e){Zt(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Zt(n,!0),Zt(e))},destroy:function(n){Zt(n,!0)}};function Zt(n,e){var t=n.data.ref;if(o(t)){var r=n.context,a=n.componentInstance||n.elm,i=r.$refs;e?Array.isArray(i[t])?v(i[t],a):i[t]===a&&(i[t]=void 0):n.data.refInFor?Array.isArray(i[t])?i[t].indexOf(a)<0&&i[t].push(a):i[t]=[a]:i[t]=a}}var nr=new fn("",{},[]),er=["create","activate","update","remove","destroy"];function tr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,a=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===a||Xt(r)&&Xt(a)}(n,e)||i(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function rr(n,e,t){var r,a,i={};for(r=e;r<=t;++r)o(a=n[r].key)&&(i[a]=r);return i}var ar={create:or,update:or,destroy:function(n){or(n,nr)}};function or(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,o=n===nr,i=e===nr,s=sr(n.data.directives,n.context),l=sr(e.data.directives,e.context),c=[],p=[];for(t in l)r=s[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,cr(a,"update",e,n),a.def&&a.def.componentUpdated&&p.push(a)):(cr(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var d=function(){for(var t=0;t<c.length;t++)cr(c[t],"inserted",e,n)};o?ce(e,"insert",d):d()}p.length&&ce(e,"postpatch",(function(){for(var t=0;t<p.length;t++)cr(p[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||cr(s[t],"unbind",n,n,i)}(n,e)}var ir=Object.create(null);function sr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=ir),a[lr(r)]=r,r.def=Dn(e.$options,"directives",r.name);return a}function lr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function cr(n,e,t,r,a){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,a)}catch(r){$n(r,t.context,"directive "+n.name+" "+e+" hook")}}var pr=[Jt,ar];function dr(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,i,s=e.elm,l=n.data.attrs||{},c=e.data.attrs||{};for(r in o(c.__ob__)&&(c=e.data.attrs=C({},c)),c)i=c[r],l[r]!==i&&ur(s,r,i,e.data.pre);for(r in(Q||Y)&&c.value!==l.value&&ur(s,"value",c.value),l)a(c[r])&&(Dt(r)?s.removeAttributeNS(Bt,Nt(r)):Pt(r)||s.removeAttribute(r))}}function ur(n,e,t,r){r||n.tagName.indexOf("-")>-1?mr(n,e,t):Mt(e)?qt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Pt(e)?n.setAttribute(e,function(n,e){return qt(e)||"false"===e?"false":"contenteditable"===n&&Rt(e)?e:"true"}(e,t)):Dt(e)?qt(t)?n.removeAttributeNS(Bt,Nt(e)):n.setAttributeNS(Bt,e,t):mr(n,e,t)}function mr(n,e,t){if(qt(t))n.removeAttribute(e);else{if(Q&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var gr={create:dr,update:dr};function fr(n,e){var t=e.elm,r=e.data,i=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(i)||a(i.staticClass)&&a(i.class)))){var s=Ft(e),l=t._transitionClasses;o(l)&&(s=Ht(s,$t(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var hr,br={create:fr,update:fr};function vr(n,e,t){var r=hr;return function a(){var o=e.apply(null,arguments);null!==o&&xr(n,a,t,r)}}var yr=Qn&&!(Z&&Number(Z[1])<=53);function kr(n,e,t,r){if(yr){var a=lt,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}hr.addEventListener(n,e,en?{capture:t,passive:r}:t)}function xr(n,e,t,r){(r||hr).removeEventListener(n,e._wrapper||e,t)}function wr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};hr=e.elm,function(n){if(o(n.__r)){var e=Q?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),le(t,r,kr,xr,vr,e.context),hr=void 0}}var Sr,Er={create:wr,update:wr};function Ir(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,i=e.elm,s=n.data.domProps||{},l=e.data.domProps||{};for(t in o(l.__ob__)&&(l=e.data.domProps=C({},l)),s)t in l||(i[t]="");for(t in l){if(r=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===s[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var c=a(r)?"":String(r);_r(i,c)&&(i.value=c)}else if("innerHTML"===t&&Wt(i.tagName)&&a(i.innerHTML)){(Sr=Sr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var p=Sr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;p.firstChild;)i.appendChild(p.firstChild)}else if(r!==s[t])try{i[t]=r}catch(n){}}}}function _r(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return f(t)!==f(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Tr={create:Ir,update:Ir},jr=x((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Cr(n){var e=Ar(n.style);return n.staticStyle?C(n.staticStyle,e):e}function Ar(n){return Array.isArray(n)?A(n):"string"==typeof n?jr(n):n}var zr,Or=/^--/,Lr=/\s*!important$/,Pr=function(n,e,t){if(Or.test(e))n.style.setProperty(e,t);else if(Lr.test(t))n.style.setProperty(_(e),t.replace(Lr,""),"important");else{var r=Mr(e);if(Array.isArray(t))for(var a=0,o=t.length;a<o;a++)n.style[r]=t[a];else n.style[r]=t}},Rr=["Webkit","Moz","ms"],Mr=x((function(n){if(zr=zr||document.createElement("div").style,"filter"!==(n=S(n))&&n in zr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Rr.length;t++){var r=Rr[t]+e;if(r in zr)return r}}));function Br(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var i,s,l=e.elm,c=r.staticStyle,p=r.normalizedStyle||r.style||{},d=c||p,u=Ar(e.data.style)||{};e.data.normalizedStyle=o(u.__ob__)?C({},u):u;var m=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Cr(a.data))&&C(r,t);(t=Cr(n.data))&&C(r,t);for(var o=n;o=o.parent;)o.data&&(t=Cr(o.data))&&C(r,t);return r}(e,!0);for(s in d)a(m[s])&&Pr(l,s,"");for(s in m)(i=m[s])!==d[s]&&Pr(l,s,null==i?"":i)}}var Dr={create:Br,update:Br},Nr=/\s+/;function qr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Nr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Fr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Nr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Ur(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&C(e,Hr(n.name||"v")),C(e,n),e}return"string"==typeof n?Hr(n):void 0}}var Hr=x((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),$r=V&&!X,Vr="transition",Gr="transitionend",Wr="animation",Kr="animationend";$r&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Vr="WebkitTransition",Gr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Wr="WebkitAnimation",Kr="webkitAnimationEnd"));var Qr=V?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Xr(n){Qr((function(){Qr(n)}))}function Yr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),qr(n,e))}function Jr(n,e){n._transitionClasses&&v(n._transitionClasses,e),Fr(n,e)}function Zr(n,e,t){var r=ea(n,e),a=r.type,o=r.timeout,i=r.propCount;if(!a)return t();var s="transition"===a?Gr:Kr,l=0,c=function(){n.removeEventListener(s,p),t()},p=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),o+1),n.addEventListener(s,p)}var na=/\b(transform|all)(,|$)/;function ea(n,e){var t,r=window.getComputedStyle(n),a=(r[Vr+"Delay"]||"").split(", "),o=(r[Vr+"Duration"]||"").split(", "),i=ta(a,o),s=(r[Wr+"Delay"]||"").split(", "),l=(r[Wr+"Duration"]||"").split(", "),c=ta(s,l),p=0,d=0;return"transition"===e?i>0&&(t="transition",p=i,d=o.length):"animation"===e?c>0&&(t="animation",p=c,d=l.length):d=(t=(p=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:p,propCount:d,hasTransform:"transition"===t&&na.test(r[Vr+"Property"])}}function ta(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ra(e)+ra(n[t])})))}function ra(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function aa(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=Ur(n.data.transition);if(!a(r)&&!o(t._enterCb)&&1===t.nodeType){for(var i=r.css,s=r.type,c=r.enterClass,p=r.enterToClass,d=r.enterActiveClass,u=r.appearClass,m=r.appearToClass,g=r.appearActiveClass,h=r.beforeEnter,b=r.enter,v=r.afterEnter,y=r.enterCancelled,k=r.beforeAppear,x=r.appear,w=r.afterAppear,S=r.appearCancelled,E=r.duration,I=Ye,_=Ye.$vnode;_&&_.parent;)I=_.context,_=_.parent;var T=!I._isMounted||!n.isRootInsert;if(!T||x||""===x){var j=T&&u?u:c,C=T&&g?g:d,A=T&&m?m:p,z=T&&k||h,O=T&&"function"==typeof x?x:b,L=T&&w||v,P=T&&S||y,R=f(l(E)?E.enter:E);0;var B=!1!==i&&!X,D=sa(O),N=t._enterCb=M((function(){B&&(Jr(t,A),Jr(t,C)),N.cancelled?(B&&Jr(t,j),P&&P(t)):L&&L(t),t._enterCb=null}));n.data.show||ce(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),O&&O(t,N)})),z&&z(t),B&&(Yr(t,j),Yr(t,C),Xr((function(){Jr(t,j),N.cancelled||(Yr(t,A),D||(ia(R)?setTimeout(N,R):Zr(t,s,N)))}))),n.data.show&&(e&&e(),O&&O(t,N)),B||D||N()}}}function oa(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=Ur(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var i=r.css,s=r.type,c=r.leaveClass,p=r.leaveToClass,d=r.leaveActiveClass,u=r.beforeLeave,m=r.leave,g=r.afterLeave,h=r.leaveCancelled,b=r.delayLeave,v=r.duration,y=!1!==i&&!X,k=sa(m),x=f(l(v)?v.leave:v);0;var w=t._leaveCb=M((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Jr(t,p),Jr(t,d)),w.cancelled?(y&&Jr(t,c),h&&h(t)):(e(),g&&g(t)),t._leaveCb=null}));b?b(S):S()}function S(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),y&&(Yr(t,c),Yr(t,d),Xr((function(){Jr(t,c),w.cancelled||(Yr(t,p),k||(ia(x)?setTimeout(w,x):Zr(t,s,w)))}))),m&&m(t,w),y||k||w())}}function ia(n){return"number"==typeof n&&!isNaN(n)}function sa(n){if(a(n))return!1;var e=n.fns;return o(e)?sa(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function la(n,e){!0!==e.data.show&&aa(e)}var ca=function(n){var e,t,r={},l=n.modules,c=n.nodeOps;for(e=0;e<er.length;++e)for(r[er[e]]=[],t=0;t<l.length;++t)o(l[t][er[e]])&&r[er[e]].push(l[t][er[e]]);function p(n){var e=c.parentNode(n);o(e)&&c.removeChild(e,n)}function d(n,e,t,a,s,l,p){if(o(n.elm)&&o(l)&&(n=l[p]=yn(n)),n.isRootInsert=!s,!function(n,e,t,a){var s=n.data;if(o(s)){var l=o(n.componentInstance)&&s.keepAlive;if(o(s=s.hook)&&o(s=s.init)&&s(n,!1),o(n.componentInstance))return u(n,e),m(t,n.elm,a),i(l)&&function(n,e,t,a){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(i=s.data)&&o(i=i.transition)){for(i=0;i<r.activate.length;++i)r.activate[i](nr,s);e.push(s);break}m(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var d=n.data,f=n.children,h=n.tag;o(h)?(n.elm=n.ns?c.createElementNS(n.ns,h):c.createElement(h,n),v(n),g(n,f,e),o(d)&&b(n,e),m(t,n.elm,a)):i(n.isComment)?(n.elm=c.createComment(n.text),m(t,n.elm,a)):(n.elm=c.createTextNode(n.text),m(t,n.elm,a))}}function u(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(b(n,e),v(n)):(Zt(n),e.push(n))}function m(n,e,t){o(n)&&(o(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function g(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else s(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function b(n,t){for(var a=0;a<r.create.length;++a)r.create[a](nr,n);o(e=n.data.hook)&&(o(e.create)&&e.create(nr,n),o(e.insert)&&t.push(n))}function v(n){var e;if(o(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;o(e=Ye)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function y(n,e,t,r,a,o){for(;r<=a;++r)d(t[r],o,n,e,!1,t,r)}function k(n){var e,t,a=n.data;if(o(a))for(o(e=a.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)k(n.children[t])}function x(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(w(r),k(r)):p(r.elm))}}function w(n,e){if(o(e)||o(n.data)){var t,a=r.remove.length+1;for(o(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&p(n)}return t.listeners=e,t}(n.elm,a),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&w(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else p(n.elm)}function S(n,e,t,r){for(var a=t;a<r;a++){var i=e[a];if(o(i)&&tr(n,i))return a}}function E(n,e,t,s,l,p){if(n!==e){o(e.elm)&&o(s)&&(e=s[l]=yn(e));var u=e.elm=n.elm;if(i(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?T(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(i(e.isStatic)&&i(n.isStatic)&&e.key===n.key&&(i(e.isCloned)||i(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,g=e.data;o(g)&&o(m=g.hook)&&o(m=m.prepatch)&&m(n,e);var h=n.children,b=e.children;if(o(g)&&f(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);o(m=g.hook)&&o(m=m.update)&&m(n,e)}a(e.text)?o(h)&&o(b)?h!==b&&function(n,e,t,r,i){var s,l,p,u=0,m=0,g=e.length-1,f=e[0],h=e[g],b=t.length-1,v=t[0],k=t[b],w=!i;for(0;u<=g&&m<=b;)a(f)?f=e[++u]:a(h)?h=e[--g]:tr(f,v)?(E(f,v,r,t,m),f=e[++u],v=t[++m]):tr(h,k)?(E(h,k,r,t,b),h=e[--g],k=t[--b]):tr(f,k)?(E(f,k,r,t,b),w&&c.insertBefore(n,f.elm,c.nextSibling(h.elm)),f=e[++u],k=t[--b]):tr(h,v)?(E(h,v,r,t,m),w&&c.insertBefore(n,h.elm,f.elm),h=e[--g],v=t[++m]):(a(s)&&(s=rr(e,u,g)),a(l=o(v.key)?s[v.key]:S(v,e,u,g))?d(v,r,n,f.elm,!1,t,m):tr(p=e[l],v)?(E(p,v,r,t,m),e[l]=void 0,w&&c.insertBefore(n,p.elm,f.elm)):d(v,r,n,f.elm,!1,t,m),v=t[++m]);u>g?y(n,a(t[b+1])?null:t[b+1].elm,t,m,b,r):m>b&&x(e,u,g)}(u,h,b,t,p):o(b)?(o(n.text)&&c.setTextContent(u,""),y(u,null,b,0,b.length-1,t)):o(h)?x(h,0,h.length-1):o(n.text)&&c.setTextContent(u,""):n.text!==e.text&&c.setTextContent(u,e.text),o(g)&&o(m=g.hook)&&o(m=m.postpatch)&&m(n,e)}}}function I(n,e,t){if(i(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var _=h("attrs,class,staticClass,staticStyle,key");function T(n,e,t,r){var a,s=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,i(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(a=l.hook)&&o(a=a.init)&&a(e,!0),o(a=e.componentInstance)))return u(e,t),!0;if(o(s)){if(o(c))if(n.hasChildNodes())if(o(a=l)&&o(a=a.domProps)&&o(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var p=!0,d=n.firstChild,m=0;m<c.length;m++){if(!d||!T(d,c[m],t,r)){p=!1;break}d=d.nextSibling}if(!p||d)return!1}else g(e,c,t);if(o(l)){var f=!1;for(var h in l)if(!_(h)){f=!0,b(e,t);break}!f&&l.class&&oe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,s){if(!a(e)){var l,p=!1,u=[];if(a(n))p=!0,d(e,u);else{var m=o(n.nodeType);if(!m&&tr(n,e))E(n,e,u,null,null,s);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),i(t)&&T(n,e,u))return I(e,u,!0),n;l=n,n=new fn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var g=n.elm,h=c.parentNode(g);if(d(e,u,g._leaveCb?null:h,c.nextSibling(g)),o(e.parent))for(var b=e.parent,v=f(e);b;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](b);if(b.elm=e.elm,v){for(var w=0;w<r.create.length;++w)r.create[w](nr,b);var S=b.data.hook.insert;if(S.merged)for(var _=1;_<S.fns.length;_++)S.fns[_]()}else Zt(b);b=b.parent}o(h)?x([n],0,0):o(n.tag)&&k(n)}}return I(e,u,p),e.elm}o(n)&&k(n)}}({nodeOps:Yt,modules:[gr,br,Er,Tr,Dr,V?{create:la,activate:la,remove:function(n,e){!0!==n.data.show?oa(n,e):e()}}:{}].concat(pr)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&ba(n,"input")}));var pa={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?ce(t,"postpatch",(function(){pa.componentUpdated(n,e,t)})):da(n,e,t.context),n._vOptions=[].map.call(n.options,ga)):("textarea"===t.tag||Xt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",fa),n.addEventListener("compositionend",ha),n.addEventListener("change",ha),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){da(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,ga);if(a.some((function(n,e){return!P(n,r[e])})))(n.multiple?e.value.some((function(n){return ma(n,a)})):e.value!==e.oldValue&&ma(e.value,a))&&ba(n,"change")}}};function da(n,e,t){ua(n,e,t),(Q||Y)&&setTimeout((function(){ua(n,e,t)}),0)}function ua(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var o,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],a)o=R(r,ga(i))>-1,i.selected!==o&&(i.selected=o);else if(P(ga(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function ma(n,e){return e.every((function(e){return!P(e,n)}))}function ga(n){return"_value"in n?n._value:n.value}function fa(n){n.target.composing=!0}function ha(n){n.target.composing&&(n.target.composing=!1,ba(n.target,"input"))}function ba(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function va(n){return!n.componentInstance||n.data&&n.data.transition?n:va(n.componentInstance._vnode)}var ya={model:pa,show:{bind:function(n,e,t){var r=e.value,a=(t=va(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,aa(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=va(t)).data&&t.data.transition?(t.data.show=!0,r?aa(t,(function(){n.style.display=n.__vOriginalDisplay})):oa(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},ka={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function xa(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?xa(Ge(e.children)):n}function wa(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var o in a)e[S(o)]=a[o];return e}function Sa(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Ea=function(n){return n.tag||he(n)},Ia=function(n){return"show"===n.name},_a={name:"transition",props:ka,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Ea)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var o=xa(a);if(!o)return a;if(this._leaving)return Sa(n,a);var i="__transition-"+this._uid+"-";o.key=null==o.key?o.isComment?i+"comment":i+o.tag:s(o.key)?0===String(o.key).indexOf(i)?o.key:i+o.key:o.key;var l=(o.data||(o.data={})).transition=wa(this),c=this._vnode,p=xa(c);if(o.data.directives&&o.data.directives.some(Ia)&&(o.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,p)&&!he(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var d=p.data.transition=C({},l);if("out-in"===r)return this._leaving=!0,ce(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Sa(n,a);if("in-out"===r){if(he(o))return c;var u,m=function(){u()};ce(l,"afterEnter",m),ce(l,"enterCancelled",m),ce(d,"delayLeave",(function(n){u=n}))}}return a}}},Ta=C({tag:String,moveClass:String},ka);function ja(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ca(n){n.data.newPos=n.elm.getBoundingClientRect()}function Aa(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+a+"px)",o.transitionDuration="0s"}}delete Ta.mode;var za={Transition:_a,TransitionGroup:{props:Ta,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Je(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],o=this.children=[],i=wa(this),s=0;s<a.length;s++){var l=a[s];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))o.push(l),t[l.key]=l,(l.data||(l.data={})).transition=i;else;}if(r){for(var c=[],p=[],d=0;d<r.length;d++){var u=r[d];u.data.transition=i,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?c.push(u):p.push(u)}this.kept=n(e,null,c),this.removed=p}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(ja),n.forEach(Ca),n.forEach(Aa),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Yr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Gr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Gr,n),t._moveCb=null,Jr(t,e))})}})))},methods:{hasMove:function(n,e){if(!$r)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Fr(t,n)})),qr(t,e),t.style.display="none",this.$el.appendChild(t);var r=ea(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};Et.config.mustUseProp=function(n,e,t){return"value"===t&&Lt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Et.config.isReservedTag=Kt,Et.config.isReservedAttr=Ot,Et.config.getTagNamespace=function(n){return Wt(n)?"svg":"math"===n?"math":void 0},Et.config.isUnknownElement=function(n){if(!V)return!0;if(Kt(n))return!1;if(n=n.toLowerCase(),null!=Qt[n])return Qt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Qt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Qt[n]=/HTMLUnknownElement/.test(e.toString())},C(Et.options.directives,ya),C(Et.options.components,za),Et.prototype.__patch__=V?ca:z,Et.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=bn),et(n,"beforeMount"),r=function(){n._update(n._render(),t)},new mt(n,r,z,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&V?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},V&&setTimeout((function(){N.devtools&&an&&an.emit("init",Et)}),0),e.default=Et},function(n,e,t){var r=t(4),a=t(29).f,o=t(17),i=t(13),s=t(92),l=t(141),c=t(70);n.exports=function(n,e){var t,p,d,u,m,g=n.target,f=n.global,h=n.stat;if(t=f?r:h?r[g]||s(g,{}):(r[g]||{}).prototype)for(p in e){if(u=e[p],d=n.noTargetGet?(m=a(t,p))&&m.value:t[p],!c(f?p:g+(h?".":"#")+p,n.forced)&&void 0!==d){if(typeof u==typeof d)continue;l(u,d)}(n.sham||d&&d.sham)&&o(u,"sham",!0),i(t,p,u,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(4),a=t(66),o=t(10),i=t(67),s=t(94),l=t(136),c=a("wks"),p=r.Symbol,d=l?p:p&&p.withoutSetter||i;n.exports=function(n){return o(c,n)&&(s||"string"==typeof c[n])||(s&&o(p,n)?c[n]=p[n]:c[n]=d("Symbol."+n)),c[n]}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},function(n,e,t){var r=t(5);n.exports=function(n){if(!r(n))throw TypeError(String(n)+" is not an object");return n}},function(n,e,t){var r=t(2);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){"use strict";function r(n,e,t,r,a,o,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):a&&(l=s?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(102),a=t(13),o=t(224);r||a(Object.prototype,"toString",o,{unsafe:!0})},function(n,e,t){var r=t(14),a={}.hasOwnProperty;n.exports=Object.hasOwn||function(n,e){return a.call(r(n),e)}},function(n,e,t){var r=t(7),a=t(134),o=t(6),i=t(53),s=Object.defineProperty;e.f=r?s:function(n,e,t){if(o(n),e=i(e,!0),o(t),a)try{return s(n,e,t)}catch(n){}if("get"in t||"set"in t)throw TypeError("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(46),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e,t){var r=t(4),a=t(17),o=t(10),i=t(92),s=t(97),l=t(32),c=l.get,p=l.enforce,d=String(String).split("String");(n.exports=function(n,e,t,s){var l,c=!!s&&!!s.unsafe,u=!!s&&!!s.enumerable,m=!!s&&!!s.noTargetGet;"function"==typeof t&&("string"!=typeof e||o(t,"name")||a(t,"name",e),(l=p(t)).source||(l.source=d.join("string"==typeof e?e:""))),n!==r?(c?!m&&n[e]&&(u=!0):delete n[e],u?n[e]=t:a(n,e,t)):u?n[e]=t:i(e,t)})(Function.prototype,"toString",(function(){return"function"==typeof this&&c(this).source||s(this)}))},function(n,e,t){var r=t(15);n.exports=function(n){return Object(r(n))}},function(n,e){n.exports=function(n){if(null==n)throw TypeError("Can't call method on "+n);return n}},function(n,e,t){"use strict";var r=t(127).charAt,a=t(32),o=t(140),i=a.set,s=a.getterFor("String Iterator");o(String,"String",(function(n){i(this,{type:"String Iterator",string:String(n),index:0})}),(function(){var n,e=s(this),t=e.string,a=e.index;return a>=t.length?{value:void 0,done:!0}:(n=r(t,a),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var r=t(7),a=t(11),o=t(49);n.exports=r?function(n,e,t){return a.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";var r=t(1),a=t(159);r({target:"Array",proto:!0,forced:[].forEach!=a},{forEach:a})},function(n,e,t){var r=t(4),a=t(153),o=t(159),i=t(17);for(var s in a){var l=r[s],c=l&&l.prototype;if(c&&c.forEach!==o)try{i(c,"forEach",o)}catch(n){c.forEach=o}}},function(n,e,t){"use strict";var r=t(1),a=t(47).filter;r({target:"Array",proto:!0,forced:!t(75)("filter")},{filter:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(4),a=t(153),o=t(123),i=t(17),s=t(3),l=s("iterator"),c=s("toStringTag"),p=o.values;for(var d in a){var u=r[d],m=u&&u.prototype;if(m){if(m[l]!==p)try{i(m,l,p)}catch(n){m[l]=p}if(m[c]||i(m,c,d),a[d])for(var g in o)if(m[g]!==o[g])try{i(m,g,o[g])}catch(n){m[g]=o[g]}}}},function(n,e,t){var r=t(52),a=t(15);n.exports=function(n){return r(a(n))}},function(n,e,t){"use strict";var r=t(1),a=t(77);r({target:"RegExp",proto:!0,forced:/./.exec!==a},{exec:a})},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(168),a="object"==typeof self&&self&&self.Object===Object&&self,o=r||a||Function("return this")();n.exports=o},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(48),t(45),t(20),t(342),t(18),t(19),t(154),t(343),t(117);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}},function(n,e,t){var r=t(135),a=t(4),o=function(n){return"function"==typeof n?n:void 0};n.exports=function(n,e){return arguments.length<2?o(r[n])||o(a[n]):r[n]&&r[n][e]||a[n]&&a[n][e]}},function(n,e,t){var r=t(27);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(7),a=t(98),o=t(49),i=t(22),s=t(53),l=t(10),c=t(134),p=Object.getOwnPropertyDescriptor;e.f=r?p:function(n,e){if(n=i(n),e=s(e,!0),c)try{return p(n,e)}catch(n){}if(l(n,e))return o(!a.f.call(n,e),n[e])}},function(n,e){n.exports=function(n){if("function"!=typeof n)throw TypeError(String(n)+" is not a function");return n}},function(n,e,t){"use strict";var r=t(1),a=t(47).map;r({target:"Array",proto:!0,forced:!t(75)("map")},{map:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r,a,o,i=t(213),s=t(4),l=t(5),c=t(17),p=t(10),d=t(91),u=t(69),m=t(54),g=s.WeakMap;if(i||d.state){var f=d.state||(d.state=new g),h=f.get,b=f.has,v=f.set;r=function(n,e){if(b.call(f,n))throw new TypeError("Object already initialized");return e.facade=n,v.call(f,n,e),e},a=function(n){return h.call(f,n)||{}},o=function(n){return b.call(f,n)}}else{var y=u("state");m[y]=!0,r=function(n,e){if(p(n,y))throw new TypeError("Object already initialized");return e.facade=n,c(n,y,e),e},a=function(n){return p(n,y)?n[y]:{}},o=function(n){return p(n,y)}}n.exports={set:r,get:a,has:o,enforce:function(n){return o(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=a(e)).type!==n)throw TypeError("Incompatible receiver, "+n+" required");return t}}}},function(n,e){n.exports=!1},function(n,e,t){var r,a=t(6),o=t(125),i=t(96),s=t(54),l=t(139),c=t(93),p=t(69),d=p("IE_PROTO"),u=function(){},m=function(n){return"<script>"+n+"<\/script>"},g=function(){try{r=document.domain&&new ActiveXObject("htmlfile")}catch(n){}var n,e;g=r?function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e}(r):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F);for(var t=i.length;t--;)delete g.prototype[i[t]];return g()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(u.prototype=a(n),t=new u,u.prototype=null,t[d]=n):t=g(),void 0===e?t:o(t,e)}},function(n,e){var t={}.toString;n.exports=function(n){return t.call(n).slice(8,-1)}},function(n,e,t){var r=t(250),a=t(253);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";var r=t(1),a=t(5),o=t(50),i=t(138),s=t(12),l=t(22),c=t(74),p=t(3),d=t(75)("slice"),u=p("species"),m=[].slice,g=Math.max;r({target:"Array",proto:!0,forced:!d},{slice:function(n,e){var t,r,p,d=l(this),f=s(d.length),h=i(n,f),b=i(void 0===e?f:e,f);if(o(d)&&("function"!=typeof(t=d.constructor)||t!==Array&&!o(t.prototype)?a(t)&&null===(t=t[u])&&(t=void 0):t=void 0,t===Array||void 0===t))return m.call(d,h,b);for(r=new(void 0===t?Array:t)(g(b-h,0)),p=0;h<b;h++,p++)h in d&&c(r,p,d[h]);return r.length=p,r}})},function(n,e,t){var r=t(1),a=t(4),o=t(28),i=[].slice,s=function(n){return function(e,t){var r=arguments.length>2,a=r?i.call(arguments,2):void 0;return n(r?function(){("function"==typeof e?e:Function(e)).apply(this,a)}:e,t)}};r({global:!0,bind:!0,forced:/MSIE .\./.test(o)},{setTimeout:s(a.setTimeout),setInterval:s(a.setInterval)})},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return o})),t.d(e,"j",(function(){return i})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return p})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return g})),t.d(e,"d",(function(){return h})),t.d(e,"k",(function(){return b})),t.d(e,"n",(function(){return v})),t.d(e,"a",(function(){return k}));t(23),t(41),t(120),t(86),t(65),t(31),t(18),t(19),t(20),t(63),t(87),t(9),t(133),t(40),t(189),t(88);var r=/#.*$/,a=/\.(md|html)$/,o=/\/$/,i=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(a,"")}function l(n){return i.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;var e=n.match(r),t=e?e[0]:"",a=s(n);return o.test(a)?n:a+".html"+t}function u(n,e){var t=n.hash,a=function(n){var e=n.match(r);if(e)return e[0]}(e);return(!a||t===a)&&s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?a.pop():"."!==s&&a.push(s)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));for(var r=s(e),a=0;a<n.length;a++)if(s(n[a].regularPath)===r)return Object.assign({},n[a],{type:"page",path:d(n[a].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function g(n,e,t,r){var a=t.pages,o=t.themeConfig,i=r&&o.locales&&o.locales[r]||o;if("auto"===(n.frontmatter.sidebar||i.sidebar||o.sidebar))return f(n);var s=i.sidebar||o.sidebar;if(s){var l=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(r=n,/(\.html|\/)$/.test(r)?r:r+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var r;return{}}(e,s),c=l.base,p=l.config;return"auto"===p?f(n):p?p.map((function(n){return function n(e,t,r){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var o=e.children||[];return 0===o.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:o.map((function(e){return n(e,t,r,a+1)})),collapsable:!1!==e.collapsable}}(n,a,c)})):[]}return[]}function f(n){var e=h(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}function h(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function b(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function v(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){var e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(null==e?void 0:e.replace(/-/g,"/"))),t.getTime()}function k(n,e){return y(e)-y(n)}},function(n,e,t){"use strict";var r=t(1),a=t(2),o=t(50),i=t(5),s=t(14),l=t(12),c=t(74),p=t(128),d=t(75),u=t(3),m=t(44),g=u("isConcatSpreadable"),f=m>=51||!a((function(){var n=[];return n[g]=!1,n.concat()[0]!==n})),h=d("concat"),b=function(n){if(!i(n))return!1;var e=n[g];return void 0!==e?!!e:o(n)};r({target:"Array",proto:!0,forced:!f||!h},{concat:function(n){var e,t,r,a,o,i=s(this),d=p(i,0),u=0;for(e=-1,r=arguments.length;e<r;e++)if(b(o=-1===e?i:arguments[e])){if(u+(a=l(o.length))>9007199254740991)throw TypeError("Maximum allowed index exceeded");for(t=0;t<a;t++,u++)t in o&&c(d,u,o[t])}else{if(u>=9007199254740991)throw TypeError("Maximum allowed index exceeded");c(d,u++,o)}return d.length=u,d}})},function(n,e,t){"use strict";var r=t(89),a=t(2),o=t(6),i=t(12),s=t(46),l=t(15),c=t(107),p=t(231),d=t(90),u=t(3)("replace"),m=Math.max,g=Math.min,f="$0"==="a".replace(/./,"$0"),h=!!/./[u]&&""===/./[u]("a","$0");r("replace",(function(n,e,t){var r=h?"$":"$0";return[function(n,t){var r=l(this),a=null==n?void 0:n[u];return void 0!==a?a.call(n,r,t):e.call(String(r),n,t)},function(n,a){if("string"==typeof a&&-1===a.indexOf(r)&&-1===a.indexOf("$<")){var l=t(e,this,n,a);if(l.done)return l.value}var u=o(this),f=String(n),h="function"==typeof a;h||(a=String(a));var b=u.global;if(b){var v=u.unicode;u.lastIndex=0}for(var y=[];;){var k=d(u,f);if(null===k)break;if(y.push(k),!b)break;""===String(k[0])&&(u.lastIndex=c(f,i(u.lastIndex),v))}for(var x,w="",S=0,E=0;E<y.length;E++){k=y[E];for(var I=String(k[0]),_=m(g(s(k.index),f.length),0),T=[],j=1;j<k.length;j++)T.push(void 0===(x=k[j])?x:String(x));var C=k.groups;if(h){var A=[I].concat(T,_,f);void 0!==C&&A.push(C);var z=String(a.apply(void 0,A))}else z=p(I,f,_,T,C,a);_>=S&&(w+=f.slice(S,_)+z,S=_+I.length)}return w+f.slice(S)}]}),!!a((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!f||h)},function(n,e,t){"use strict";var r=t(2);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){throw 1},1)}))}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r,a,o=t(4),i=t(28),s=o.process,l=s&&s.versions,c=l&&l.v8;c?a=(r=c.split("."))[0]<4?1:r[0]+r[1]:i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(a=r[1]),n.exports=a&&+a},function(n,e,t){"use strict";var r=t(1),a=t(4),o=t(27),i=t(33),s=t(7),l=t(94),c=t(136),p=t(2),d=t(10),u=t(50),m=t(5),g=t(6),f=t(14),h=t(22),b=t(53),v=t(49),y=t(34),k=t(68),x=t(56),w=t(229),S=t(100),E=t(29),I=t(11),_=t(98),T=t(17),j=t(13),C=t(66),A=t(69),z=t(54),O=t(67),L=t(3),P=t(161),R=t(162),M=t(61),B=t(32),D=t(47).forEach,N=A("hidden"),q=L("toPrimitive"),F=B.set,U=B.getterFor("Symbol"),H=Object.prototype,$=a.Symbol,V=o("JSON","stringify"),G=E.f,W=I.f,K=w.f,Q=_.f,X=C("symbols"),Y=C("op-symbols"),J=C("string-to-symbol-registry"),Z=C("symbol-to-string-registry"),nn=C("wks"),en=a.QObject,tn=!en||!en.prototype||!en.prototype.findChild,rn=s&&p((function(){return 7!=y(W({},"a",{get:function(){return W(this,"a",{value:7}).a}})).a}))?function(n,e,t){var r=G(H,e);r&&delete H[e],W(n,e,t),r&&n!==H&&W(H,e,r)}:W,an=function(n,e){var t=X[n]=y($.prototype);return F(t,{type:"Symbol",tag:n,description:e}),s||(t.description=e),t},on=c?function(n){return"symbol"==typeof n}:function(n){return Object(n)instanceof $},sn=function(n,e,t){n===H&&sn(Y,e,t),g(n);var r=b(e,!0);return g(t),d(X,r)?(t.enumerable?(d(n,N)&&n[N][r]&&(n[N][r]=!1),t=y(t,{enumerable:v(0,!1)})):(d(n,N)||W(n,N,v(1,{})),n[N][r]=!0),rn(n,r,t)):W(n,r,t)},ln=function(n,e){g(n);var t=h(e),r=k(t).concat(un(t));return D(r,(function(e){s&&!cn.call(t,e)||sn(n,e,t[e])})),n},cn=function(n){var e=b(n,!0),t=Q.call(this,e);return!(this===H&&d(X,e)&&!d(Y,e))&&(!(t||!d(this,e)||!d(X,e)||d(this,N)&&this[N][e])||t)},pn=function(n,e){var t=h(n),r=b(e,!0);if(t!==H||!d(X,r)||d(Y,r)){var a=G(t,r);return!a||!d(X,r)||d(t,N)&&t[N][r]||(a.enumerable=!0),a}},dn=function(n){var e=K(h(n)),t=[];return D(e,(function(n){d(X,n)||d(z,n)||t.push(n)})),t},un=function(n){var e=n===H,t=K(e?Y:h(n)),r=[];return D(t,(function(n){!d(X,n)||e&&!d(H,n)||r.push(X[n])})),r};(l||(j(($=function(){if(this instanceof $)throw TypeError("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,e=O(n),t=function(n){this===H&&t.call(Y,n),d(this,N)&&d(this[N],e)&&(this[N][e]=!1),rn(this,e,v(1,n))};return s&&tn&&rn(H,e,{configurable:!0,set:t}),an(e,n)}).prototype,"toString",(function(){return U(this).tag})),j($,"withoutSetter",(function(n){return an(O(n),n)})),_.f=cn,I.f=sn,E.f=pn,x.f=w.f=dn,S.f=un,P.f=function(n){return an(L(n),n)},s&&(W($.prototype,"description",{configurable:!0,get:function(){return U(this).description}}),i||j(H,"propertyIsEnumerable",cn,{unsafe:!0}))),r({global:!0,wrap:!0,forced:!l,sham:!l},{Symbol:$}),D(k(nn),(function(n){R(n)})),r({target:"Symbol",stat:!0,forced:!l},{for:function(n){var e=String(n);if(d(J,e))return J[e];var t=$(e);return J[e]=t,Z[t]=e,t},keyFor:function(n){if(!on(n))throw TypeError(n+" is not a symbol");if(d(Z,n))return Z[n]},useSetter:function(){tn=!0},useSimple:function(){tn=!1}}),r({target:"Object",stat:!0,forced:!l,sham:!s},{create:function(n,e){return void 0===e?y(n):ln(y(n),e)},defineProperty:sn,defineProperties:ln,getOwnPropertyDescriptor:pn}),r({target:"Object",stat:!0,forced:!l},{getOwnPropertyNames:dn,getOwnPropertySymbols:un}),r({target:"Object",stat:!0,forced:p((function(){S.f(1)}))},{getOwnPropertySymbols:function(n){return S.f(f(n))}}),V)&&r({target:"JSON",stat:!0,forced:!l||p((function(){var n=$();return"[null]"!=V([n])||"{}"!=V({a:n})||"{}"!=V(Object(n))}))},{stringify:function(n,e,t){for(var r,a=[n],o=1;arguments.length>o;)a.push(arguments[o++]);if(r=e,(m(e)||void 0!==n)&&!on(n))return u(e)||(e=function(n,e){if("function"==typeof r&&(e=r.call(this,n,e)),!on(e))return e}),a[1]=e,V.apply(null,a)}});$.prototype[q]||T($.prototype,q,$.prototype.valueOf),M($,"Symbol"),z[N]=!0},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){return isNaN(n=+n)?0:(n>0?r:t)(n)}},function(n,e,t){var r=t(62),a=t(52),o=t(14),i=t(12),s=t(128),l=[].push,c=function(n){var e=1==n,t=2==n,c=3==n,p=4==n,d=6==n,u=7==n,m=5==n||d;return function(g,f,h,b){for(var v,y,k=o(g),x=a(k),w=r(f,h,3),S=i(x.length),E=0,I=b||s,_=e?I(g,S):t||u?I(g,0):void 0;S>E;E++)if((m||E in x)&&(y=w(v=x[E],E,k),n))if(e)_[E]=y;else if(y)switch(n){case 3:return!0;case 5:return v;case 6:return E;case 2:l.call(_,v)}else switch(n){case 4:return!1;case 7:l.call(_,v)}return d?-1:c||p?p:_}};n.exports={forEach:c(0),map:c(1),filter:c(2),some:c(3),every:c(4),find:c(5),findIndex:c(6),filterOut:c(7)}},function(n,e,t){var r=t(1),a=t(14),o=t(68);r({target:"Object",stat:!0,forced:t(2)((function(){o(1)}))},{keys:function(n){return o(a(n))}})},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(35);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){var r=t(58),a=t(235),o=t(236),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?a(n):o(n)}},function(n,e,t){var r=t(2),a=t(35),o="".split;n.exports=r((function(){return!Object("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?o.call(n,""):Object(n)}:Object},function(n,e,t){var r=t(5);n.exports=function(n,e){if(!r(n))return n;var t,a;if(e&&"function"==typeof(t=n.toString)&&!r(a=t.call(n)))return a;if("function"==typeof(t=n.valueOf)&&!r(a=t.call(n)))return a;if(!e&&"function"==typeof(t=n.toString)&&!r(a=t.call(n)))return a;throw TypeError("Can't convert object to primitive value")}},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var r=t(137),a=t(96).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){"use strict";var r=t(1),a=t(7),o=t(4),i=t(10),s=t(5),l=t(11).f,c=t(141),p=o.Symbol;if(a&&"function"==typeof p&&(!("description"in p.prototype)||void 0!==p().description)){var d={},u=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),e=this instanceof u?new p(n):void 0===n?p():p(n);return""===n&&(d[e]=!0),e};c(u,p);var m=u.prototype=p.prototype;m.constructor=u;var g=m.toString,f="Symbol(test)"==String(p("test")),h=/^Symbol\((.*)\)[^)]+$/;l(m,"description",{configurable:!0,get:function(){var n=s(this)?this.valueOf():this,e=g.call(n);if(i(d,n))return"";var t=f?e.slice(7,-1):e.replace(h,"$1");return""===t?void 0:t}}),r({global:!0,forced:!0},{Symbol:u})}},function(n,e,t){var r=t(25).Symbol;n.exports=r},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(63);var r=t(60);t(45),t(57),t(9),t(76),t(16),t(21),t(163);var a=t(83);function o(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(a.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(11).f,a=t(10),o=t(3)("toStringTag");n.exports=function(n,e,t){n&&!a(n=t?n:n.prototype,o)&&r(n,o,{configurable:!0,value:e})}},function(n,e,t){var r=t(30);n.exports=function(n,e,t){if(r(n),void 0===e)return n;switch(t){case 0:return function(){return n.call(e)};case 1:return function(t){return n.call(e,t)};case 2:return function(t,r){return n.call(e,t,r)};case 3:return function(t,r,a){return n.call(e,t,r,a)}}return function(){return n.apply(e,arguments)}}},function(n,e,t){t(1)({target:"Array",stat:!0},{isArray:t(50)})},function(n,e,t){var r=t(7),a=t(11).f,o=Function.prototype,i=o.toString,s=/^\s*function ([^ (]*)/;r&&!("name"in o)&&a(o,"name",{configurable:!0,get:function(){try{return i.call(this).match(s)[1]}catch(n){return""}}})},function(n,e,t){"use strict";var r=t(1),a=t(52),o=t(22),i=t(42),s=[].join,l=a!=Object,c=i("join",",");r({target:"Array",proto:!0,forced:l||!c},{join:function(n){return s.call(o(this),void 0===n?",":n)}})},function(n,e,t){var r=t(33),a=t(91);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.15.2",mode:r?"pure":"global",copyright:"© 2021 Denis Pushkarev (zloirock.ru)"})},function(n,e){var t=0,r=Math.random();n.exports=function(n){return"Symbol("+String(void 0===n?"":n)+")_"+(++t+r).toString(36)}},function(n,e,t){var r=t(137),a=t(96);n.exports=Object.keys||function(n){return r(n,a)}},function(n,e,t){var r=t(66),a=t(67),o=r("keys");n.exports=function(n){return o[n]||(o[n]=a(n))}},function(n,e,t){var r=t(2),a=/#|\.prototype\./,o=function(n,e){var t=s[i(n)];return t==c||t!=l&&("function"==typeof e?r(e):!!e)},i=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},s=o.data={},l=o.NATIVE="N",c=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(6),a=t(214);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(t,[]),e=t instanceof Array}catch(n){}return function(t,o){return r(t),a(o),e?n.call(t,o):t.__proto__=o,t}}():void 0)},function(n,e,t){var r=t(35),a=t(4);n.exports="process"==r(a.process)},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(9);function r(n,e,t,r,a,o,i){try{var s=n[o](i),l=s.value}catch(n){return void t(n)}s.done?e(l):Promise.resolve(l).then(r,a)}function a(n){return function(){var e=this,t=arguments;return new Promise((function(a,o){var i=n.apply(e,t);function s(n){r(i,a,o,s,l,"next",n)}function l(n){r(i,a,o,s,l,"throw",n)}s(void 0)}))}}},function(n,e,t){"use strict";var r=t(53),a=t(11),o=t(49);n.exports=function(n,e,t){var i=r(e);i in n?a.f(n,i,o(0,t)):n[i]=t}},function(n,e,t){var r=t(2),a=t(3),o=t(44),i=a("species");n.exports=function(n){return o>=51||!r((function(){var e=[];return(e.constructor={})[i]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){t(162)("iterator")},function(n,e,t){"use strict";var r,a,o=t(105),i=t(106),s=t(66),l=t(34),c=t(32).get,p=t(165),d=t(166),u=RegExp.prototype.exec,m=s("native-string-replace",String.prototype.replace),g=u,f=(r=/a/,a=/b*/g,u.call(r,"a"),u.call(a,"a"),0!==r.lastIndex||0!==a.lastIndex),h=i.UNSUPPORTED_Y||i.BROKEN_CARET,b=void 0!==/()??/.exec("")[1];(f||b||h||p||d)&&(g=function(n){var e,t,r,a,i,s,p,d=this,v=c(d),y=v.raw;if(y)return y.lastIndex=d.lastIndex,e=g.call(y,n),d.lastIndex=y.lastIndex,e;var k=v.groups,x=h&&d.sticky,w=o.call(d),S=d.source,E=0,I=n;if(x&&(-1===(w=w.replace("y","")).indexOf("g")&&(w+="g"),I=String(n).slice(d.lastIndex),d.lastIndex>0&&(!d.multiline||d.multiline&&"\n"!==n[d.lastIndex-1])&&(S="(?: "+S+")",I=" "+I,E++),t=new RegExp("^(?:"+S+")",w)),b&&(t=new RegExp("^"+S+"$(?!\\s)",w)),f&&(r=d.lastIndex),a=u.call(x?t:d,I),x?a?(a.input=a.input.slice(E),a[0]=a[0].slice(E),a.index=d.lastIndex,d.lastIndex+=a[0].length):d.lastIndex=0:f&&a&&(d.lastIndex=d.global?a.index+a[0].length:r),b&&a&&a.length>1&&m.call(a[0],t,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(a[i]=void 0)})),a&&k)for(a.groups=s=l(null),i=0;i<k.length;i++)s[(p=k[i])[0]]=a[p[1]];return a}),n.exports=g},function(n,e,t){var r=t(240),a=t(241),o=t(242),i=t(243),s=t(244);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(170);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(36)(Object,"create");n.exports=r},function(n,e,t){var r=t(262);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(115);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(37),t(9),t(64),t(163),t(16);var r=t(60);function a(n,e){if(n){if("string"==typeof n)return Object(r.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(r.a)(n,e):void 0}}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),p=r.speed,d=r.easing;return l.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,a}(n,p,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,i=e.querySelector(r.barSelector),l=n?"-100":o(t.status||0),p=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&u(a),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,o=arguments;if(2==o.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function p(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n){n.exports=JSON.parse('{"_from":"vuepress-plugin-comment@^0.7.3","_id":"vuepress-plugin-comment@0.7.3","_inBundle":false,"_integrity":"sha512-CvuBST37snmQGzGD5lMxyw0u2eXWKVPjegfuwlI2+CTs2qWarKX16dVHHLR8DVa/yL5UGT3VuoNETH/zEexl8A==","_location":"/vuepress-plugin-comment","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"vuepress-plugin-comment@^0.7.3","name":"vuepress-plugin-comment","escapedName":"vuepress-plugin-comment","rawSpec":"^0.7.3","saveSpec":null,"fetchSpec":"^0.7.3"},"_requiredBy":["/"],"_resolved":"https://registry.npmjs.org/vuepress-plugin-comment/-/vuepress-plugin-comment-0.7.3.tgz","_shasum":"2cff36b8f90896a7f88d494d78458398b1510249","_spec":"vuepress-plugin-comment@^0.7.3","_where":"D:\\\\个人笔记\\\\博客搭建\\\\我的笔记\\\\vuepress-theme-vdoing","author":{"name":"dongyuanxin"},"bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"bundleDependencies":false,"dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"},"deprecated":false,"description":"Comment plugin in vuepress, such as Gitalk, Valine...","homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"license":"MIT","main":"index.js","name":"vuepress-plugin-comment","repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"version":"0.7.3"}')},function(n,e,t){"use strict";var r=t(89),a=t(104),o=t(6),i=t(15),s=t(103),l=t(107),c=t(12),p=t(90),d=t(77),u=t(106),m=t(2),g=u.UNSUPPORTED_Y,f=[].push,h=Math.min;r("split",(function(n,e,t){var r;return r="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var r=String(i(this)),o=void 0===t?4294967295:t>>>0;if(0===o)return[];if(void 0===n)return[r];if(!a(n))return e.call(r,n,o);for(var s,l,c,p=[],u=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),m=0,g=new RegExp(n.source,u+"g");(s=d.call(g,r))&&!((l=g.lastIndex)>m&&(p.push(r.slice(m,s.index)),s.length>1&&s.index<r.length&&f.apply(p,s.slice(1)),c=s[0].length,m=l,p.length>=o));)g.lastIndex===s.index&&g.lastIndex++;return m===r.length?!c&&g.test("")||p.push(""):p.push(r.slice(m)),p.length>o?p.slice(0,o):p}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:e.call(this,n,t)}:e,[function(e,t){var a=i(this),o=null==e?void 0:e[n];return void 0!==o?o.call(e,a,t):r.call(String(a),e,t)},function(n,a){var i=t(r,this,n,a,r!==e);if(i.done)return i.value;var d=o(this),u=String(n),m=s(d,RegExp),f=d.unicode,b=(d.ignoreCase?"i":"")+(d.multiline?"m":"")+(d.unicode?"u":"")+(g?"g":"y"),v=new m(g?"^(?:"+d.source+")":d,b),y=void 0===a?4294967295:a>>>0;if(0===y)return[];if(0===u.length)return null===p(v,u)?[u]:[];for(var k=0,x=0,w=[];x<u.length;){v.lastIndex=g?0:x;var S,E=p(v,g?u.slice(x):u);if(null===E||(S=h(c(v.lastIndex+(g?x:0)),u.length))===k)x=l(u,x,f);else{if(w.push(u.slice(k,x)),w.length===y)return w;for(var I=1;I<=E.length-1;I++)if(w.push(E[I]),w.length===y)return w;x=k=S}}return w.push(u.slice(k)),w}]}),!!m((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),g)},function(n,e,t){"use strict";var r=t(1),a=t(95).indexOf,o=t(42),i=[].indexOf,s=!!i&&1/[1].indexOf(1,-0)<0,l=o("indexOf");r({target:"Array",proto:!0,forced:s||!l},{indexOf:function(n){return s?i.apply(this,arguments)||0:a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(13),a=t(6),o=t(2),i=t(105),s=RegExp.prototype,l=s.toString,c=o((function(){return"/a/b"!=l.call({source:"a",flags:"b"})})),p="toString"!=l.name;(c||p)&&r(RegExp.prototype,"toString",(function(){var n=a(this),e=String(n.source),t=n.flags;return"/"+e+"/"+String(void 0===t&&n instanceof RegExp&&!("flags"in s)?i.call(n):t)}),{unsafe:!0})},function(n,e,t){"use strict";t(23);var r=t(13),a=t(77),o=t(2),i=t(3),s=t(17),l=i("species"),c=RegExp.prototype;n.exports=function(n,e,t,p){var d=i(n),u=!o((function(){var e={};return e[d]=function(){return 7},7!=""[n](e)})),m=u&&!o((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[l]=function(){return t},t.flags="",t[d]=/./[d]),t.exec=function(){return e=!0,null},t[d](""),!e}));if(!u||!m||t){var g=/./[d],f=e(d,""[n],(function(n,e,t,r,o){var i=e.exec;return i===a||i===c.exec?u&&!o?{done:!0,value:g.call(e,t,r)}:{done:!0,value:n.call(t,e,r)}:{done:!1}}));r(String.prototype,n,f[0]),r(c,d,f[1])}p&&s(c[d],"sham",!0)}},function(n,e,t){var r=t(35),a=t(77);n.exports=function(n,e){var t=n.exec;if("function"==typeof t){var o=t.call(n,e);if("object"!=typeof o)throw TypeError("RegExp exec method returned something other than an Object or null");return o}if("RegExp"!==r(n))throw TypeError("RegExp#exec called on incompatible receiver");return a.call(n,e)}},function(n,e,t){var r=t(4),a=t(92),o=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=o},function(n,e,t){var r=t(4),a=t(17);n.exports=function(n,e){try{a(r,n,e)}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(4),a=t(5),o=r.document,i=a(o)&&a(o.createElement);n.exports=function(n){return i?o.createElement(n):{}}},function(n,e,t){var r=t(44),a=t(2);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r=t(22),a=t(12),o=t(138),i=function(n){return function(e,t,i){var s,l=r(e),c=a(l.length),p=o(i,c);if(n&&t!=t){for(;c>p;)if((s=l[p++])!=s)return!0}else for(;c>p;p++)if((n||p in l)&&l[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(91),a=Function.toString;"function"!=typeof r.inspectSource&&(r.inspectSource=function(n){return a.call(n)}),n.exports=r.inspectSource},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,o=a&&!r.call({1:2},1);e.f=o?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(27),a=t(56),o=t(100),i=t(6);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(i(n)),t=o.f;return t?e.concat(t(n)):e}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(10),a=t(14),o=t(69),i=t(143),s=o("IE_PROTO"),l=Object.prototype;n.exports=i?Object.getPrototypeOf:function(n){return n=a(n),r(n,s)?n[s]:"function"==typeof n.constructor&&n instanceof n.constructor?n.constructor.prototype:n instanceof Object?l:null}},function(n,e,t){var r={};r[t(3)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(6),a=t(30),o=t(3)("species");n.exports=function(n,e){var t,i=r(n).constructor;return void 0===i||null==(t=r(i)[o])?e:a(t)}},function(n,e,t){var r=t(5),a=t(35),o=t(3)("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[o])?!!e:"RegExp"==a(n))}},function(n,e,t){"use strict";var r=t(6);n.exports=function(){var n=r(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var r=t(2),a=function(n,e){return RegExp(n,e)};e.UNSUPPORTED_Y=r((function(){var n=a("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),e.BROKEN_CARET=r((function(){var n=a("^r","gy");return n.lastIndex=2,null!=n.exec("str")}))},function(n,e,t){"use strict";var r=t(127).charAt;n.exports=function(n,e,t){return e+(t?r(n,e).length:1)}},function(n,e,t){var r=t(234),a=t(43),o=Object.prototype,i=o.hasOwnProperty,s=o.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(36)(t(25),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(254),a=t(261),o=t(263),i=t(264),s=t(265);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(24),a=t(115),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(i.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(51),a=t(43);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(1),a=t(7);r({target:"Object",stat:!0,forced:!a,sham:!a},{defineProperty:t(11).f})},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(63);t(45),t(57),t(9),t(76),t(16),t(21);var r=t(83);function a(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var r,a,o=[],i=!0,s=!1;try{for(t=t.call(n);!(i=(r=t.next()).done)&&(o.push(r.value),!e||o.length!==e);i=!0);}catch(n){s=!0,a=n}finally{try{i||null==t.return||t.return()}finally{if(s)throw a}}return o}}(n,e)||Object(r.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";var r=t(7),a=t(4),o=t(70),i=t(13),s=t(10),l=t(35),c=t(188),p=t(53),d=t(2),u=t(34),m=t(56).f,g=t(29).f,f=t(11).f,h=t(131).trim,b=a.Number,v=b.prototype,y="Number"==l(u(v)),k=function(n){var e,t,r,a,o,i,s,l,c=p(n,!1);if("string"==typeof c&&c.length>2)if(43===(e=(c=h(c)).charCodeAt(0))||45===e){if(88===(t=c.charCodeAt(2))||120===t)return NaN}else if(48===e){switch(c.charCodeAt(1)){case 66:case 98:r=2,a=49;break;case 79:case 111:r=8,a=55;break;default:return+c}for(i=(o=c.slice(2)).length,s=0;s<i;s++)if((l=o.charCodeAt(s))<48||l>a)return NaN;return parseInt(o,r)}return+c};if(o("Number",!b(" 0o1")||!b("0b1")||b("+0x1"))){for(var x,w=function(n){var e=arguments.length<1?0:n,t=this;return t instanceof w&&(y?d((function(){v.valueOf.call(t)})):"Number"!=l(t))?c(new b(k(e)),t,w):k(e)},S=r?m(b):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(","),E=0;S.length>E;E++)s(b,x=S[E])&&!s(w,x)&&f(w,x,g(b,x));w.prototype=v,v.constructor=w,i(a,"Number",w)}},function(n,e,t){"use strict";var r=t(89),a=t(6),o=t(12),i=t(15),s=t(107),l=t(90);r("match",(function(n,e,t){return[function(e){var t=i(this),r=null==e?void 0:e[n];return void 0!==r?r.call(e,t):new RegExp(e)[n](String(t))},function(n){var r=t(e,this,n);if(r.done)return r.value;var i=a(this),c=String(n);if(!i.global)return l(i,c);var p=i.unicode;i.lastIndex=0;for(var d,u=[],m=0;null!==(d=l(i,c));){var g=String(d[0]);u[m]=g,""===g&&(i.lastIndex=s(c,o(i.lastIndex),p)),m++}return 0===m?null:u}]}))},function(n,e,t){var r=t(126),a=t(55),o=t(3)("iterator");n.exports=function(n){if(null!=n)return n[o]||n["@@iterator"]||a[r(n)]}},function(n,e,t){var r=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},a=r.iterator||"@@iterator",o=r.asyncIterator||"@@asyncIterator",i=r.toStringTag||"@@toStringTag";function s(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{s({},"")}catch(n){s=function(n,e,t){return n[e]=t}}function l(n,e,t,r){var a=e&&e.prototype instanceof d?e:d,o=Object.create(a.prototype),i=new S(r||[]);return o._invoke=function(n,e,t){var r="suspendedStart";return function(a,o){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===a)throw o;return I()}for(t.method=a,t.arg=o;;){var i=t.delegate;if(i){var s=k(i,t);if(s){if(s===p)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var l=c(n,e,t);if("normal"===l.type){if(r=t.done?"completed":"suspendedYield",l.arg===p)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(r="completed",t.method="throw",t.arg=l.arg)}}}(n,t,i),o}function c(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=l;var p={};function d(){}function u(){}function m(){}var g={};g[a]=function(){return this};var f=Object.getPrototypeOf,h=f&&f(f(E([])));h&&h!==e&&t.call(h,a)&&(g=h);var b=m.prototype=d.prototype=Object.create(g);function v(n){["next","throw","return"].forEach((function(e){s(n,e,(function(n){return this._invoke(e,n)}))}))}function y(n,e){var r;this._invoke=function(a,o){function i(){return new e((function(r,i){!function r(a,o,i,s){var l=c(n[a],n,o);if("throw"!==l.type){var p=l.arg,d=p.value;return d&&"object"==typeof d&&t.call(d,"__await")?e.resolve(d.__await).then((function(n){r("next",n,i,s)}),(function(n){r("throw",n,i,s)})):e.resolve(d).then((function(n){p.value=n,i(p)}),(function(n){return r("throw",n,i,s)}))}s(l.arg)}(a,o,r,i)}))}return r=r?r.then(i,i):i()}}function k(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,k(n,e),"throw"===e.method))return p;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return p}var r=c(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,p;var a=r.arg;return a?a.done?(e[n.resultName]=a.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,p):a:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,p)}function x(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function w(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function S(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(x,this),this.reset(!0)}function E(n){if(n){var e=n[a];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,o=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return o.next=o}}return{next:I}}function I(){return{value:void 0,done:!0}}return u.prototype=b.constructor=m,m.constructor=u,u.displayName=s(m,i,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===u||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,s(n,i,"GeneratorFunction")),n.prototype=Object.create(b),n},n.awrap=function(n){return{__await:n}},v(y.prototype),y.prototype[o]=function(){return this},n.AsyncIterator=y,n.async=function(e,t,r,a,o){void 0===o&&(o=Promise);var i=new y(l(e,t,r,a),o);return n.isGeneratorFunction(t)?i:i.next().then((function(n){return n.done?n.value:i.next()}))},v(b),s(b,i,"Generator"),b[a]=function(){return this},b.toString=function(){return"[object Generator]"},n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=E,S.prototype={constructor:S,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(w),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return i.type="throw",i.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var a=this.tryEntries.length-1;a>=0;--a){var o=this.tryEntries[a],i=o.completion;if("root"===o.tryLoc)return r("end");if(o.tryLoc<=this.prev){var s=t.call(o,"catchLoc"),l=t.call(o,"finallyLoc");if(s&&l){if(this.prev<o.catchLoc)return r(o.catchLoc,!0);if(this.prev<o.finallyLoc)return r(o.finallyLoc)}else if(s){if(this.prev<o.catchLoc)return r(o.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return r(o.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var a=this.tryEntries[r];if(a.tryLoc<=this.prev&&t.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var o=a;break}}o&&("break"===n||"continue"===n)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var i=o?o.completion:{};return i.type=n,i.arg=e,o?(this.method="next",this.next=o.finallyLoc,p):this.complete(i)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),p},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),w(t),p}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var a=r.arg;w(t)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:E(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),p}},n}(n.exports);try{regeneratorRuntime=r}catch(n){Function("r","regeneratorRuntime = r")(r)}},function(n,e,t){"use strict";var r=t(22),a=t(124),o=t(55),i=t(32),s=t(140),l=i.set,c=i.getterFor("Array Iterator");n.exports=s(Array,"Array",(function(n,e){l(this,{type:"Array Iterator",target:r(n),index:0,kind:e})}),(function(){var n=c(this),e=n.target,t=n.kind,r=n.index++;return!e||r>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:r,done:!1}:"values"==t?{value:e[r],done:!1}:{value:[r,e[r]],done:!1}}),"values"),o.Arguments=o.Array,a("keys"),a("values"),a("entries")},function(n,e,t){var r=t(3),a=t(34),o=t(11),i=r("unscopables"),s=Array.prototype;null==s[i]&&o.f(s,i,{configurable:!0,value:a(null)}),n.exports=function(n){s[i][n]=!0}},function(n,e,t){var r=t(7),a=t(11),o=t(6),i=t(68);n.exports=r?Object.defineProperties:function(n,e){o(n);for(var t,r=i(e),s=r.length,l=0;s>l;)a.f(n,t=r[l++],e[t]);return n}},function(n,e,t){var r=t(102),a=t(35),o=t(3)("toStringTag"),i="Arguments"==a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=Object(n),o))?t:i?a(e):"Object"==(r=a(e))&&"function"==typeof e.callee?"Arguments":r}},function(n,e,t){var r=t(46),a=t(15),o=function(n){return function(e,t){var o,i,s=String(a(e)),l=r(t),c=s.length;return l<0||l>=c?n?"":void 0:(o=s.charCodeAt(l))<55296||o>56319||l+1===c||(i=s.charCodeAt(l+1))<56320||i>57343?n?s.charAt(l):o:n?s.slice(l,l+2):i-56320+(o-55296<<10)+65536}};n.exports={codeAt:o(!1),charAt:o(!0)}},function(n,e,t){var r=t(5),a=t(50),o=t(3)("species");n.exports=function(n,e){var t;return a(n)&&("function"!=typeof(t=n.constructor)||t!==Array&&!a(t.prototype)?r(t)&&null===(t=t[o])&&(t=void 0):t=void 0),new(void 0===t?Array:t)(0===e?0:e)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,o=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),p=Object.prototype.toString,d=Math.max,u=Math.min,m=function(){return c.Date.now()};function g(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(g(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=g(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||o.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,o,i,s,l,c=0,p=!1,h=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=r,o=a;return r=a=void 0,c=e,i=n.apply(o,t)}function y(n){return c=n,s=setTimeout(x,e),p?v(n):i}function k(n){var t=n-l;return void 0===l||t>=e||t<0||h&&n-c>=o}function x(){var n=m();if(k(n))return w(n);s=setTimeout(x,function(n){var t=e-(n-l);return h?u(t,o-(n-c)):t}(n))}function w(n){return s=void 0,b&&r?v(n):(r=a=void 0,i)}function S(){var n=m(),t=k(n);if(r=arguments,a=this,l=n,t){if(void 0===s)return y(l);if(h)return s=setTimeout(x,e),v(l)}return void 0===s&&(s=setTimeout(x,e)),i}return e=f(e)||0,g(t)&&(p=!!t.leading,o=(h="maxWait"in t)?d(f(t.maxWait)||0,e):o,b="trailing"in t?!!t.trailing:b),S.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=a=s=void 0},S.flush=function(){return void 0===s?i:w(m())},S}},function(n,e,t){var r=t(15),a="["+t(132)+"]",o=RegExp("^"+a+a+"*"),i=RegExp(a+a+"*$"),s=function(n){return function(e){var t=String(r(e));return 1&n&&(t=t.replace(o,"")),2&n&&(t=t.replace(i,"")),t}};n.exports={start:s(1),end:s(2),trim:s(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){var r=t(13),a=Date.prototype,o=a.toString,i=a.getTime;new Date(NaN)+""!="Invalid Date"&&r(a,"toString",(function(){var n=i.call(this);return n==n?o.call(this):"Invalid Date"}))},function(n,e,t){var r=t(7),a=t(2),o=t(93);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(4);n.exports=r},function(n,e,t){var r=t(94);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(10),a=t(22),o=t(95).indexOf,i=t(54);n.exports=function(n,e){var t,s=a(n),l=0,c=[];for(t in s)!r(i,t)&&r(s,t)&&c.push(t);for(;e.length>l;)r(s,t=e[l++])&&(~o(c,t)||c.push(t));return c}},function(n,e,t){var r=t(46),a=Math.max,o=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):o(t,e)}},function(n,e,t){var r=t(27);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(1),a=t(203),o=t(101),i=t(71),s=t(61),l=t(17),c=t(13),p=t(3),d=t(33),u=t(55),m=t(142),g=m.IteratorPrototype,f=m.BUGGY_SAFARI_ITERATORS,h=p("iterator"),b=function(){return this};n.exports=function(n,e,t,p,m,v,y){a(t,e,p);var k,x,w,S=function(n){if(n===m&&j)return j;if(!f&&n in _)return _[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},E=e+" Iterator",I=!1,_=n.prototype,T=_[h]||_["@@iterator"]||m&&_[m],j=!f&&T||S(m),C="Array"==e&&_.entries||T;if(C&&(k=o(C.call(new n)),g!==Object.prototype&&k.next&&(d||o(k)===g||(i?i(k,g):"function"!=typeof k[h]&&l(k,h,b)),s(k,E,!0,!0),d&&(u[E]=b))),"values"==m&&T&&"values"!==T.name&&(I=!0,j=function(){return T.call(this)}),d&&!y||_[h]===j||l(_,h,j),u[e]=j,m)if(x={values:S("values"),keys:v?j:S("keys"),entries:S("entries")},y)for(w in x)(f||I||!(w in _))&&c(_,w,x[w]);else r({target:e,proto:!0,forced:f||I},x);return x}},function(n,e,t){var r=t(10),a=t(99),o=t(29),i=t(11);n.exports=function(n,e){for(var t=a(e),s=i.f,l=o.f,c=0;c<t.length;c++){var p=t[c];r(n,p)||s(n,p,l(e,p))}}},function(n,e,t){"use strict";var r,a,o,i=t(2),s=t(101),l=t(17),c=t(10),p=t(3),d=t(33),u=p("iterator"),m=!1;[].keys&&("next"in(o=[].keys())?(a=s(s(o)))!==Object.prototype&&(r=a):m=!0);var g=null==r||i((function(){var n={};return r[u].call(n)!==n}));g&&(r={}),d&&!g||c(r,u)||l(r,u,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:m}},function(n,e,t){var r=t(2);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var r=t(4);n.exports=r.Promise},function(n,e,t){"use strict";var r=t(27),a=t(11),o=t(3),i=t(7),s=o("species");n.exports=function(n){var e=r(n),t=a.f;i&&e&&!e[s]&&t(e,s,{configurable:!0,get:function(){return this}})}},function(n,e,t){var r=t(3),a=t(55),o=r("iterator"),i=Array.prototype;n.exports=function(n){return void 0!==n&&(a.Array===n||i[o]===n)}},function(n,e,t){var r=t(6);n.exports=function(n){var e=n.return;if(void 0!==e)return r(e.call(n)).value}},function(n,e,t){var r=t(3)("iterator"),a=!1;try{var o=0,i={next:function(){return{done:!!o++}},return:function(){a=!0}};i[r]=function(){return this},Array.from(i,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!a)return!1;var t=!1;try{var o={};o[r]=function(){return{next:function(){return{done:t=!0}}}},n(o)}catch(n){}return t}},function(n,e,t){var r,a,o,i=t(4),s=t(2),l=t(62),c=t(139),p=t(93),d=t(150),u=t(72),m=i.location,g=i.setImmediate,f=i.clearImmediate,h=i.process,b=i.MessageChannel,v=i.Dispatch,y=0,k={},x=function(n){if(k.hasOwnProperty(n)){var e=k[n];delete k[n],e()}},w=function(n){return function(){x(n)}},S=function(n){x(n.data)},E=function(n){i.postMessage(n+"",m.protocol+"//"+m.host)};g&&f||(g=function(n){for(var e=[],t=1;arguments.length>t;)e.push(arguments[t++]);return k[++y]=function(){("function"==typeof n?n:Function(n)).apply(void 0,e)},r(y),y},f=function(n){delete k[n]},u?r=function(n){h.nextTick(w(n))}:v&&v.now?r=function(n){v.now(w(n))}:b&&!d?(o=(a=new b).port2,a.port1.onmessage=S,r=l(o.postMessage,o,1)):i.addEventListener&&"function"==typeof postMessage&&!i.importScripts&&m&&"file:"!==m.protocol&&!s(E)?(r=E,i.addEventListener("message",S,!1)):r="onreadystatechange"in p("script")?function(n){c.appendChild(p("script")).onreadystatechange=function(){c.removeChild(this),x(n)}}:function(n){setTimeout(w(n),0)}),n.exports={set:g,clear:f}},function(n,e,t){var r=t(28);n.exports=/(?:iphone|ipod|ipad).*applewebkit/i.test(r)},function(n,e,t){var r=t(6),a=t(5),o=t(152);n.exports=function(n,e){if(r(n),a(e)&&e.constructor===n)return e;var t=o.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){"use strict";var r=t(30),a=function(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)};n.exports.f=function(n){return new a(n)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var r=t(1),a=t(7),o=t(99),i=t(22),s=t(29),l=t(74);r({target:"Object",stat:!0,sham:!a},{getOwnPropertyDescriptors:function(n){for(var e,t,r=i(n),a=s.f,c=o(r),p={},d=0;c.length>d;)void 0!==(t=a(r,e=c[d++]))&&l(p,e,t);return p}})},function(n,e,t){var r=t(1),a=t(2),o=t(14),i=t(101),s=t(143);r({target:"Object",stat:!0,forced:a((function(){i(1)})),sham:!s},{getPrototypeOf:function(n){return i(o(n))}})},function(n,e,t){"use strict";var r,a=t(1),o=t(29).f,i=t(12),s=t(157),l=t(15),c=t(158),p=t(33),d="".startsWith,u=Math.min,m=c("startsWith");a({target:"String",proto:!0,forced:!!(p||m||(r=o(String.prototype,"startsWith"),!r||r.writable))&&!m},{startsWith:function(n){var e=String(l(this));s(n);var t=i(u(arguments.length>1?arguments[1]:void 0,e.length)),r=String(n);return d?d.call(e,r,t):e.slice(t,t+r.length)===r}})},function(n,e,t){var r=t(104);n.exports=function(n){if(r(n))throw TypeError("The method doesn't accept regular expressions");return n}},function(n,e,t){var r=t(3)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var r=t(47).forEach,a=t(42)("forEach");n.exports=a?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var r=t(2);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var r=t(3);e.f=r},function(n,e,t){var r=t(135),a=t(10),o=t(161),i=t(11).f;n.exports=function(n){var e=r.Symbol||(r.Symbol={});a(e,n)||i(e,n,{value:o.f(n)})}},function(n,e,t){var r=t(1),a=t(206);r({target:"Array",stat:!0,forced:!t(148)((function(n){Array.from(n)}))},{from:a})},function(n,e,t){t(1)({target:"Object",stat:!0,sham:!t(7)},{create:t(34)})},function(n,e,t){var r=t(2);n.exports=r((function(){var n=RegExp(".","string".charAt(0));return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){var r=t(2);n.exports=r((function(){var n=RegExp("(?<a>b)","string".charAt(5));return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(78),a=t(245),o=t(246),i=t(247),s=t(248),l=t(249);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=o,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(51),a=t(110);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(266),a=t(43);n.exports=function n(e,t,o,i,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,o,i,n,s))}},function(n,e,t){var r=t(175),a=t(269),o=t(176);n.exports=function(n,e,t,i,s,l){var c=1&t,p=n.length,d=e.length;if(p!=d&&!(c&&d>p))return!1;var u=l.get(n),m=l.get(e);if(u&&m)return u==e&&m==n;var g=-1,f=!0,h=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++g<p;){var b=n[g],v=e[g];if(i)var y=c?i(v,b,g,e,n,l):i(b,v,g,n,e,l);if(void 0!==y){if(y)continue;f=!1;break}if(h){if(!a(e,(function(n,e){if(!o(h,e)&&(b===n||s(b,n,t,i,l)))return h.push(e)}))){f=!1;break}}else if(b!==v&&!s(b,v,t,i,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var r=t(111),a=t(267),o=t(268);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=a,i.prototype.has=o,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(279),a=t(285),o=t(181);n.exports=function(n){return o(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(25),a=t(281),o=e&&!e.nodeType&&e,i=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===o?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||a;n.exports=l}).call(this,t(129)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(282),a=t(283),o=t(284),i=o&&o.isTypedArray,s=i?a(i):r;n.exports=s},function(n,e,t){var r=t(171),a=t(113);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(36)(t(25),"Set");n.exports=r},function(n,e,t){var r=t(110);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(186),a=t(82);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[a(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(24),a=t(114),o=t(296),i=t(299);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:o(i(n))}},function(n,e,t){"use strict";var r=t(30),a=t(5),o=[].slice,i={},s=function(n,e,t){if(!(e in i)){for(var r=[],a=0;a<e;a++)r[a]="a["+a+"]";i[e]=Function("C,a","return new C("+r.join(",")+")")}return i[e](n,t)};n.exports=Function.bind||function(n){var e=r(this),t=o.call(arguments,1),i=function(){var r=t.concat(o.call(arguments));return this instanceof i?s(e,r.length,r):e.apply(n,r)};return a(e.prototype)&&(i.prototype=e.prototype),i}},function(n,e,t){var r=t(5),a=t(71);n.exports=function(n,e,t){var o,i;return a&&"function"==typeof(o=e.constructor)&&o!==t&&r(i=o.prototype)&&i!==t.prototype&&a(n,i),n}},function(n,e,t){"use strict";var r=t(1),a=t(330).start;r({target:"String",proto:!0,forced:t(332)},{padStart:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){},function(n,e,t){},function(n,e,t){t(1)({target:"Object",stat:!0},{setPrototypeOf:t(71)})},function(n,e,t){var r=t(1),a=t(27),o=t(30),i=t(6),s=t(5),l=t(34),c=t(187),p=t(2),d=a("Reflect","construct"),u=p((function(){function n(){}return!(d((function(){}),[],n)instanceof n)})),m=!p((function(){d((function(){}))})),g=u||m;r({target:"Reflect",stat:!0,forced:g,sham:g},{construct:function(n,e){o(n),i(e);var t=arguments.length<3?n:o(arguments[2]);if(m&&!u)return d(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var r=[null];return r.push.apply(r,e),new(c.apply(n,r))}var a=t.prototype,p=l(s(a)?a:Object.prototype),g=Function.apply.call(n,p,e);return s(g)?g:p}})},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(232),a=t(237),o=t(308),i=t(316),s=t(325),l=t(209),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(346),a=t(347),o=t(348),i=!1,s=t(349).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),p=/^\uFEFF/;function d(n,t){var a,o,i=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)a=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(o=e.resolveInclude(n,t.filename),r.existsSync(o)&&(a=o)),a||Array.isArray(i)&&i.some((function(t){return o=e.resolveInclude(n,t,!0),r.existsSync(o)}))&&(a=o),!a)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return a}function u(n,t){var r,a=n.filename,o=arguments.length>1;if(n.cache){if(!a)throw new Error("cache option requires a filename");if(r=e.cache.get(a))return r;o||(t=g(a).toString().replace(p,""))}else if(!o){if(!a)throw new Error("Internal EJS error: no file name or template provided");t=g(a).toString().replace(p,"")}return r=e.compile(t,n),n.cache&&e.cache.set(a,r),r}function m(n,t,r){var a;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(a=u(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{a=u(n)(t)}catch(n){return r(n)}r(null,a)}function g(n){return e.fileLoader(n)}function f(n,e,t,r,a){var o=e.split("\n"),i=Math.max(r-3,0),s=Math.min(o.length,r+3),l=a(t),c=o.slice(i,s).map((function(n,e){var t=e+i+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+r+"\n"+c+"\n\n"+n.message,n}function h(n){return n.replace(/;(\s*$)/,"$1")}function b(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||o.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=o.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=a.dirname,o=a.extname,i=(0,a.resolve)(t?e:r(e),n);return o(n)||(i+=".ejs"),i},e.compile=function(n,e){return e&&e.scope&&(i||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),i=!0),e.context||(e.context=e.scope),delete e.scope),new b(n,e).compile()},e.render=function(n,e,t){var r=e||{},a=t||{};return 2==arguments.length&&o.shallowCopyFromList(a,r,l),u(a,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),a=r.shift(),i={filename:a};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?o.shallowCopy(i,r.pop()):(e.settings&&(e.settings.views&&(i.views=e.settings.views),e.settings["view cache"]&&(i.cache=!0),(t=e.settings["view options"])&&o.shallowCopy(i,t)),o.shallowCopyFromList(i,e,c)),i.filename=a):e={},m(i,e,n)},e.Template=b,e.clearCache=function(){e.cache.reset()},b.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},b.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=o.escapeRegExpChars(this.opts.delimiter),t=o.escapeRegExpChars(this.opts.openDelimiter),r=o.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,i="",s="",l=r.escapeFunction;if(!this.source){if(this.generateSource(),i+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(i+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var c="  var __locals = ("+r.localsName+" || {}),\n",p=0;p<r.destructuredLocals.length;p++){var m=r.destructuredLocals[p];p>0&&(c+=",\n  "),c+=m+" = __locals."+m}i+=c+";\n"}!1!==r._with&&(i+="  with ("+r.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=i+this.source+s}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+f.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var g=r.client?e:function(n){return e.apply(r.context,[n||{},l,function(e,t){var a=o.shallowCopy({},n);return t&&(a=o.shallowCopy(a,t)),function(n,e){var t=o.shallowCopy({},e);return t.filename=d(n,t),u(t)}(e,r)(a)},f])};if(g.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var h=r.filename,b=a.basename(h,a.extname(h));try{Object.defineProperty(g,"name",{value:b,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return g},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),a=this.opts.delimiter,i=this.opts.openDelimiter,s=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(l,c){var u,m,f,h,v,y;if(0===l.indexOf(i+a)&&0!==l.indexOf(i+a+a)&&(m=r[c+2])!=a+s&&m!="-"+a+s&&m!="_"+a+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(f=l.match(/^\s*include\s+(\S+)/))&&(u=r[c-1])&&(u==i+a||u==i+a+"-"||u==i+a+"_"))return h=o.shallowCopy({},t.opts),v=function(n,e){var t,r,a=o.shallowCopy({},e);r=g(t=d(n,a)).toString().replace(p,""),a.filename=t;var i=new b(r,a);return i.generateSource(),{source:i.source,filename:t,template:r}}(f[1],h),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(v.template)+"\n      , __filename = "+JSON.stringify(v.filename)+";\n      try {\n"+v.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+v.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(f[1],h.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),a=[];r;)0!==(n=r.index)&&(a.push(e.substring(0,n)),e=e.slice(n)),a.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&a.push(e),a},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,a=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=b.modes.EVAL;break;case r+t+"=":this.mode=b.modes.ESCAPED;break;case r+t+"-":this.mode=b.modes.RAW;break;case r+t+"#":this.mode=b.modes.COMMENT;break;case r+t+t:this.mode=b.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+a:this.mode=b.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+a,t+a)+'")\n';break;case t+a:case"-"+t+a:case"_"+t+a:this.mode==b.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case b.modes.EVAL:case b.modes.ESCAPED:case b.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case b.modes.EVAL:this.source+="    ; "+n+"\n";break;case b.modes.ESCAPED:this.source+="    ; __append(escapeFn("+h(n)+"))\n";break;case b.modes.RAW:this.source+="    ; __append("+h(n)+")\n";break;case b.modes.COMMENT:break;case b.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=o.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){function r(e){return"function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?(n.exports=r=function(n){return typeof n},n.exports.default=n.exports,n.exports.__esModule=!0):(n.exports=r=function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},n.exports.default=n.exports,n.exports.__esModule=!0),r(e)}t(45),t(57),t(9),t(76),t(16),t(21),n.exports=r,n.exports.default=n.exports,n.exports.__esModule=!0},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(333),t(8)),o=Object(a.a)(r,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=o.exports},function(n,e,t){"use strict";t.r(e);t(18),t(19),t(31),t(20);var r={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(e,t){return""===e.componentOptions.propsData.active&&(n.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},a=(t(334),t(8)),o=Object(a.a)(r,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,r){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=o.exports},function(n,e,t){"use strict";var r=t(1),a=t(47).some;r({target:"Array",proto:!0,forced:!t(42)("some")},{some:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n,e,t){if(!(n instanceof e))throw TypeError("Incorrect "+(t?t+" ":"")+"invocation");return n}},function(n,e,t){"use strict";var r=t(142).IteratorPrototype,a=t(34),o=t(49),i=t(61),s=t(55),l=function(){return this};n.exports=function(n,e,t){var c=e+" Iterator";return n.prototype=a(r,{next:o(1,t)}),i(n,c,!1,!0),s[c]=l,n}},function(n,e,t){var r=t(13);n.exports=function(n,e,t){for(var a in e)r(n,a,e[a],t);return n}},function(n,e,t){"use strict";var r=t(7),a=t(2),o=t(68),i=t(100),s=t(98),l=t(14),c=t(52),p=Object.assign,d=Object.defineProperty;n.exports=!p||a((function(){if(r&&1!==p({b:1},p(d({},"a",{enumerable:!0,get:function(){d(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=p({},n)[t]||"abcdefghijklmnopqrst"!=o(p({},e)).join("")}))?function(n,e){for(var t=l(n),a=arguments.length,p=1,d=i.f,u=s.f;a>p;)for(var m,g=c(arguments[p++]),f=d?o(g).concat(d(g)):o(g),h=f.length,b=0;h>b;)m=f[b++],r&&!u.call(g,m)||(t[m]=g[m]);return t}:p},function(n,e,t){"use strict";var r=t(62),a=t(14),o=t(230),i=t(146),s=t(12),l=t(74),c=t(121);n.exports=function(n){var e,t,p,d,u,m,g=a(n),f="function"==typeof this?this:Array,h=arguments.length,b=h>1?arguments[1]:void 0,v=void 0!==b,y=c(g),k=0;if(v&&(b=r(b,h>2?arguments[2]:void 0,2)),null==y||f==Array&&i(y))for(t=new f(e=s(g.length));e>k;k++)m=v?b(g[k],k):g[k],l(t,k,m);else for(u=(d=y.call(g)).next,t=new f;!(p=u.call(d)).done;k++)m=v?o(d,b,[p.value,k],!0):p.value,l(t,k,m);return t.length=k,t}},function(n,e,t){"use strict";var r=t(1),a=t(95).includes,o=t(124);r({target:"Array",proto:!0},{includes:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(n,e,t){"use strict";var r=t(1),a=t(157),o=t(15);r({target:"String",proto:!0,forced:!t(158)("includes")},{includes:function(n){return!!~String(o(this)).indexOf(a(n),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var r=t(1),a=t(131).trim;r({target:"String",proto:!0,forced:t(328)("trim")},{trim:function(){return a(this)}})},function(n,e,t){var r=t(7),a=t(4),o=t(70),i=t(188),s=t(17),l=t(11).f,c=t(56).f,p=t(104),d=t(105),u=t(106),m=t(13),g=t(2),f=t(10),h=t(32).enforce,b=t(145),v=t(3),y=t(165),k=t(166),x=v("match"),w=a.RegExp,S=w.prototype,E=/^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/,I=/a/g,_=/a/g,T=new w(I)!==I,j=u.UNSUPPORTED_Y,C=r&&(!T||j||y||k||g((function(){return _[x]=!1,w(I)!=I||w(_)==_||"/a/i"!=w(I,"i")})));if(o("RegExp",C)){for(var A=function(n,e){var t,r,a,o,l,c,u=this instanceof A,m=p(n),g=void 0===e,b=[],v=n;if(!u&&m&&g&&n.constructor===A)return n;if((m||n instanceof A)&&(n=n.source,g&&(e="flags"in v?v.flags:d.call(v))),n=void 0===n?"":String(n),e=void 0===e?"":String(e),v=n,y&&"dotAll"in I&&(r=!!e&&e.indexOf("s")>-1)&&(e=e.replace(/s/g,"")),t=e,j&&"sticky"in I&&(a=!!e&&e.indexOf("y")>-1)&&(e=e.replace(/y/g,"")),k&&(n=(o=function(n){for(var e,t=n.length,r=0,a="",o=[],i={},s=!1,l=!1,c=0,p="";r<=t;r++){if("\\"===(e=n.charAt(r)))e+=n.charAt(++r);else if("]"===e)s=!1;else if(!s)switch(!0){case"["===e:s=!0;break;case"("===e:E.test(n.slice(r+1))&&(r+=2,l=!0),a+=e,c++;continue;case">"===e&&l:if(""===p||f(i,p))throw new SyntaxError("Invalid capture group name");i[p]=!0,o.push([p,c]),l=!1,p="";continue}l?p+=e:a+=e}return[a,o]}(n))[0],b=o[1]),l=i(w(n,e),u?this:S,A),(r||a||b.length)&&(c=h(l),r&&(c.dotAll=!0,c.raw=A(function(n){for(var e,t=n.length,r=0,a="",o=!1;r<=t;r++)"\\"!==(e=n.charAt(r))?o||"."!==e?("["===e?o=!0:"]"===e&&(o=!1),a+=e):a+="[\\s\\S]":a+=e+n.charAt(++r);return a}(n),t)),a&&(c.sticky=!0),b.length&&(c.groups=b)),n!==v)try{s(l,"source",""===v?"(?:)":v)}catch(n){}return l},z=function(n){n in A||l(A,n,{configurable:!0,get:function(){return w[n]},set:function(e){w[n]=e}})},O=c(w),L=0;O.length>L;)z(O[L++]);S.constructor=A,A.prototype=S,m(a,"RegExp",A)}b("RegExp")},function(n,e,t){n.exports=t(352)},function(n,e,t){var r=t(4),a=t(97),o=r.WeakMap;n.exports="function"==typeof o&&/native code/.test(a(o))},function(n,e,t){var r=t(5);n.exports=function(n){if(!r(n)&&null!==n)throw TypeError("Can't set "+String(n)+" as a prototype");return n}},function(n,e,t){"use strict";var r,a,o,i,s=t(1),l=t(33),c=t(4),p=t(27),d=t(144),u=t(13),m=t(204),g=t(71),f=t(61),h=t(145),b=t(5),v=t(30),y=t(202),k=t(97),x=t(216),w=t(148),S=t(103),E=t(149).set,I=t(217),_=t(151),T=t(219),j=t(152),C=t(220),A=t(32),z=t(70),O=t(3),L=t(221),P=t(72),R=t(44),M=O("species"),B="Promise",D=A.get,N=A.set,q=A.getterFor(B),F=d&&d.prototype,U=d,H=F,$=c.TypeError,V=c.document,G=c.process,W=j.f,K=W,Q=!!(V&&V.createEvent&&c.dispatchEvent),X="function"==typeof PromiseRejectionEvent,Y=!1,J=z(B,(function(){var n=k(U),e=n!==String(U);if(!e&&66===R)return!0;if(l&&!H.finally)return!0;if(R>=51&&/native code/.test(n))return!1;var t=new U((function(n){n(1)})),r=function(n){n((function(){}),(function(){}))};return(t.constructor={})[M]=r,!(Y=t.then((function(){}))instanceof r)||!e&&L&&!X})),Z=J||!w((function(n){U.all(n).catch((function(){}))})),nn=function(n){var e;return!(!b(n)||"function"!=typeof(e=n.then))&&e},en=function(n,e){if(!n.notified){n.notified=!0;var t=n.reactions;I((function(){for(var r=n.value,a=1==n.state,o=0;t.length>o;){var i,s,l,c=t[o++],p=a?c.ok:c.fail,d=c.resolve,u=c.reject,m=c.domain;try{p?(a||(2===n.rejection&&on(n),n.rejection=1),!0===p?i=r:(m&&m.enter(),i=p(r),m&&(m.exit(),l=!0)),i===c.promise?u($("Promise-chain cycle")):(s=nn(i))?s.call(i,d,u):d(i)):u(r)}catch(n){m&&!l&&m.exit(),u(n)}}n.reactions=[],n.notified=!1,e&&!n.rejection&&rn(n)}))}},tn=function(n,e,t){var r,a;Q?((r=V.createEvent("Event")).promise=e,r.reason=t,r.initEvent(n,!1,!0),c.dispatchEvent(r)):r={promise:e,reason:t},!X&&(a=c["on"+n])?a(r):"unhandledrejection"===n&&T("Unhandled promise rejection",t)},rn=function(n){E.call(c,(function(){var e,t=n.facade,r=n.value;if(an(n)&&(e=C((function(){P?G.emit("unhandledRejection",r,t):tn("unhandledrejection",t,r)})),n.rejection=P||an(n)?2:1,e.error))throw e.value}))},an=function(n){return 1!==n.rejection&&!n.parent},on=function(n){E.call(c,(function(){var e=n.facade;P?G.emit("rejectionHandled",e):tn("rejectionhandled",e,n.value)}))},sn=function(n,e,t){return function(r){n(e,r,t)}},ln=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,en(n,!0))},cn=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw $("Promise can't be resolved itself");var r=nn(e);r?I((function(){var t={done:!1};try{r.call(e,sn(cn,t,n),sn(ln,t,n))}catch(e){ln(t,e,n)}})):(n.value=e,n.state=1,en(n,!1))}catch(e){ln({done:!1},e,n)}}};if(J&&(H=(U=function(n){y(this,U,B),v(n),r.call(this);var e=D(this);try{n(sn(cn,e),sn(ln,e))}catch(n){ln(e,n)}}).prototype,(r=function(n){N(this,{type:B,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:0,value:void 0})}).prototype=m(H,{then:function(n,e){var t=q(this),r=W(S(this,U));return r.ok="function"!=typeof n||n,r.fail="function"==typeof e&&e,r.domain=P?G.domain:void 0,t.parent=!0,t.reactions.push(r),0!=t.state&&en(t,!1),r.promise},catch:function(n){return this.then(void 0,n)}}),a=function(){var n=new r,e=D(n);this.promise=n,this.resolve=sn(cn,e),this.reject=sn(ln,e)},j.f=W=function(n){return n===U||n===o?new a(n):K(n)},!l&&"function"==typeof d&&F!==Object.prototype)){i=F.then,Y||(u(F,"then",(function(n,e){var t=this;return new U((function(n,e){i.call(t,n,e)})).then(n,e)}),{unsafe:!0}),u(F,"catch",H.catch,{unsafe:!0}));try{delete F.constructor}catch(n){}g&&g(F,H)}s({global:!0,wrap:!0,forced:J},{Promise:U}),f(U,B,!1,!0),h(B),o=p(B),s({target:B,stat:!0,forced:J},{reject:function(n){var e=W(this);return e.reject.call(void 0,n),e.promise}}),s({target:B,stat:!0,forced:l||J},{resolve:function(n){return _(l&&this===o?U:this,n)}}),s({target:B,stat:!0,forced:Z},{all:function(n){var e=this,t=W(e),r=t.resolve,a=t.reject,o=C((function(){var t=v(e.resolve),o=[],i=0,s=1;x(n,(function(n){var l=i++,c=!1;o.push(void 0),s++,t.call(e,n).then((function(n){c||(c=!0,o[l]=n,--s||r(o))}),a)})),--s||r(o)}));return o.error&&a(o.value),t.promise},race:function(n){var e=this,t=W(e),r=t.reject,a=C((function(){var a=v(e.resolve);x(n,(function(n){a.call(e,n).then(t.resolve,r)}))}));return a.error&&r(a.value),t.promise}})},function(n,e,t){var r=t(6),a=t(146),o=t(12),i=t(62),s=t(121),l=t(147),c=function(n,e){this.stopped=n,this.result=e};n.exports=function(n,e,t){var p,d,u,m,g,f,h,b=t&&t.that,v=!(!t||!t.AS_ENTRIES),y=!(!t||!t.IS_ITERATOR),k=!(!t||!t.INTERRUPTED),x=i(e,b,1+v+k),w=function(n){return p&&l(p),new c(!0,n)},S=function(n){return v?(r(n),k?x(n[0],n[1],w):x(n[0],n[1])):k?x(n,w):x(n)};if(y)p=n;else{if("function"!=typeof(d=s(n)))throw TypeError("Target is not iterable");if(a(d)){for(u=0,m=o(n.length);m>u;u++)if((g=S(n[u]))&&g instanceof c)return g;return new c(!1)}p=d.call(n)}for(f=p.next;!(h=f.call(p)).done;){try{g=S(h.value)}catch(n){throw l(p),n}if("object"==typeof g&&g&&g instanceof c)return g}return new c(!1)}},function(n,e,t){var r,a,o,i,s,l,c,p,d=t(4),u=t(29).f,m=t(149).set,g=t(150),f=t(218),h=t(72),b=d.MutationObserver||d.WebKitMutationObserver,v=d.document,y=d.process,k=d.Promise,x=u(d,"queueMicrotask"),w=x&&x.value;w||(r=function(){var n,e;for(h&&(n=y.domain)&&n.exit();a;){e=a.fn,a=a.next;try{e()}catch(n){throw a?i():o=void 0,n}}o=void 0,n&&n.enter()},g||h||f||!b||!v?k&&k.resolve?((c=k.resolve(void 0)).constructor=k,p=c.then,i=function(){p.call(c,r)}):i=h?function(){y.nextTick(r)}:function(){m.call(d,r)}:(s=!0,l=v.createTextNode(""),new b(r).observe(l,{characterData:!0}),i=function(){l.data=s=!s})),n.exports=w||function(n){var e={fn:n,next:void 0};o&&(o.next=e),a||(a=e,i()),o=e}},function(n,e,t){var r=t(28);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,e,t){var r=t(4);n.exports=function(n,e){var t=r.console;t&&t.error&&(1===arguments.length?t.error(n):t.error(n,e))}},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e){n.exports="object"==typeof window},function(n,e,t){var r=t(1),a=t(205);r({target:"Object",stat:!0,forced:Object.assign!==a},{assign:a})},function(n,e,t){"use strict";var r=t(1),a=t(33),o=t(144),i=t(2),s=t(27),l=t(103),c=t(151),p=t(13);if(r({target:"Promise",proto:!0,real:!0,forced:!!o&&i((function(){o.prototype.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=l(this,s("Promise")),t="function"==typeof n;return this.then(t?function(t){return c(e,n()).then((function(){return t}))}:n,t?function(t){return c(e,n()).then((function(){throw t}))}:n)}}),!a&&"function"==typeof o){var d=s("Promise").prototype.finally;o.prototype.finally!==d&&p(o.prototype,"finally",d,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(102),a=t(126);n.exports=r?{}.toString:function(){return"[object "+a(this)+"]"}},function(n,e,t){"use strict";var r=t(1),a=t(226).left,o=t(42),i=t(44),s=t(72);r({target:"Array",proto:!0,forced:!o("reduce")||!s&&i>79&&i<83},{reduce:function(n){return a(this,n,arguments.length,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(30),a=t(14),o=t(52),i=t(12),s=function(n){return function(e,t,s,l){r(t);var c=a(e),p=o(c),d=i(c.length),u=n?d-1:0,m=n?-1:1;if(s<2)for(;;){if(u in p){l=p[u],u+=m;break}if(u+=m,n?u<0:d<=u)throw TypeError("Reduce of empty array with no initial value")}for(;n?u>=0:d>u;u+=m)u in p&&(l=t(l,p[u],u,c));return l}};n.exports={left:s(!1),right:s(!0)}},function(n,e,t){var r=t(1),a=t(160),o=t(2),i=t(5),s=t(228).onFreeze,l=Object.freeze;r({target:"Object",stat:!0,forced:o((function(){l(1)})),sham:!a},{freeze:function(n){return l&&i(n)?l(s(n)):n}})},function(n,e,t){var r=t(54),a=t(5),o=t(10),i=t(11).f,s=t(67),l=t(160),c=s("meta"),p=0,d=Object.isExtensible||function(){return!0},u=function(n){i(n,c,{value:{objectID:"O"+p++,weakData:{}}})},m=n.exports={REQUIRED:!1,fastKey:function(n,e){if(!a(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!o(n,c)){if(!d(n))return"F";if(!e)return"E";u(n)}return n[c].objectID},getWeakData:function(n,e){if(!o(n,c)){if(!d(n))return!0;if(!e)return!1;u(n)}return n[c].weakData},onFreeze:function(n){return l&&m.REQUIRED&&d(n)&&!o(n,c)&&u(n),n}};r[c]=!0},function(n,e,t){var r=t(22),a=t(56).f,o={}.toString,i="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return i&&"[object Window]"==o.call(n)?function(n){try{return a(n)}catch(n){return i.slice()}}(n):a(r(n))}},function(n,e,t){var r=t(6),a=t(147);n.exports=function(n,e,t,o){try{return o?e(r(t)[0],t[1]):e(t)}catch(e){throw a(n),e}}},function(n,e,t){var r=t(14),a=Math.floor,o="".replace,i=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,s=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,l,c,p){var d=t+n.length,u=l.length,m=s;return void 0!==c&&(c=r(c),m=i),o.call(p,m,(function(r,o){var i;switch(o.charAt(0)){case"$":return"$";case"&":return n;case"`":return e.slice(0,t);case"'":return e.slice(d);case"<":i=c[o.slice(1,-1)];break;default:var s=+o;if(0===s)return r;if(s>u){var p=a(s/10);return 0===p?r:p<=u?void 0===l[p-1]?o.charAt(1):l[p-1]+o.charAt(1):r}i=l[s-1]}return void 0===i?"":i}))}},function(n,e,t){var r=t(167),a=t(233);n.exports=function n(e,t,o,i,s){var l=-1,c=e.length;for(o||(o=a),s||(s=[]);++l<c;){var p=e[l];t>0&&o(p)?t>1?n(p,t-1,o,i,s):r(s,p):i||(s[s.length]=p)}return s}},function(n,e,t){var r=t(58),a=t(108),o=t(24),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||a(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(51),a=t(43);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(58),a=Object.prototype,o=a.hasOwnProperty,i=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=i.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(238),a=t(294),o=t(116),i=t(24),s=t(305);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?i(n)?a(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(239),a=t(293),o=t(184);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(169),a=t(173);n.exports=function(n,e,t,o){var i=t.length,s=i,l=!o;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var p=(c=t[i])[0],d=n[p],u=c[1];if(l&&c[2]){if(void 0===d&&!(p in n))return!1}else{var m=new r;if(o)var g=o(d,u,p,n,e,m);if(!(void 0===g?a(u,d,3,o,m):g))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(79),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(79);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(79);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(79);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(78);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(78),a=t(109),o=t(111);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!a||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(171),a=t(251),o=t(110),i=t(172),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,d=c.hasOwnProperty,u=RegExp("^"+p.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||a(n))&&(r(n)?u:s).test(i(n))}},function(n,e,t){var r,a=t(252),o=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(25)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(255),a=t(78),o=t(109);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||a),string:new r}}},function(n,e,t){var r=t(256),a=t(257),o=t(258),i=t(259),s=t(260);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(80);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(80),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(80),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(80);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(81);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(81);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(81);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(81);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(169),a=t(174),o=t(270),i=t(273),s=t(289),l=t(24),c=t(178),p=t(180),d="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,g,f){var h=l(n),b=l(e),v=h?"[object Array]":s(n),y=b?"[object Array]":s(e),k=(v="[object Arguments]"==v?d:v)==d,x=(y="[object Arguments]"==y?d:y)==d,w=v==y;if(w&&c(n)){if(!c(e))return!1;h=!0,k=!1}if(w&&!k)return f||(f=new r),h||p(n)?a(n,e,t,m,g,f):o(n,e,v,t,m,g,f);if(!(1&t)){var S=k&&u.call(n,"__wrapped__"),E=x&&u.call(e,"__wrapped__");if(S||E){var I=S?n.value():n,_=E?e.value():e;return f||(f=new r),g(I,_,t,m,f)}}return!!w&&(f||(f=new r),i(n,e,t,m,g,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(58),a=t(271),o=t(170),i=t(174),s=t(272),l=t(112),c=r?r.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var g=1&r;if(m||(m=l),n.size!=e.size&&!g)return!1;var f=u.get(n);if(f)return f==e;r|=2,u.set(n,e);var h=i(m(n),m(e),r,c,d,u);return u.delete(n),h;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var r=t(25).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(274),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,i,s){var l=1&t,c=r(n),p=c.length;if(p!=r(e).length&&!l)return!1;for(var d=p;d--;){var u=c[d];if(!(l?u in e:a.call(e,u)))return!1}var m=s.get(n),g=s.get(e);if(m&&g)return m==e&&g==n;var f=!0;s.set(n,e),s.set(e,n);for(var h=l;++d<p;){var b=n[u=c[d]],v=e[u];if(o)var y=l?o(v,b,u,e,n,s):o(b,v,u,n,e,s);if(!(void 0===y?b===v||i(b,v,t,o,s):y)){f=!1;break}h||(h="constructor"==u)}if(f&&!h){var k=n.constructor,x=e.constructor;k==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof k&&k instanceof k&&"function"==typeof x&&x instanceof x||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var r=t(275),a=t(276),o=t(177);n.exports=function(n){return r(n,o,a)}},function(n,e,t){var r=t(167),a=t(24);n.exports=function(n,e,t){var o=e(n);return a(n)?o:r(o,t(n))}},function(n,e,t){var r=t(277),a=t(278),o=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return o.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,o=[];++t<r;){var i=n[t];e(i,t,n)&&(o[a++]=i)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(280),a=t(108),o=t(24),i=t(178),s=t(179),l=t(180),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),p=!t&&a(n),d=!t&&!p&&i(n),u=!t&&!p&&!d&&l(n),m=t||p||d||u,g=m?r(n.length,String):[],f=g.length;for(var h in n)!e&&!c.call(n,h)||m&&("length"==h||d&&("offset"==h||"parent"==h)||u&&("buffer"==h||"byteLength"==h||"byteOffset"==h)||s(h,f))||g.push(h);return g}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(51),a=t(113),o=t(43),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&a(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(168),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,i=o&&o.exports===a&&r.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(129)(n))},function(n,e,t){var r=t(286),a=t(287),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(288)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(290),a=t(109),o=t(291),i=t(182),s=t(292),l=t(51),c=t(172),p=c(r),d=c(a),u=c(o),m=c(i),g=c(s),f=l;(r&&"[object DataView]"!=f(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=f(new a)||o&&"[object Promise]"!=f(o.resolve())||i&&"[object Set]"!=f(new i)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case p:return"[object DataView]";case d:return"[object Map]";case u:return"[object Promise]";case m:return"[object Set]";case g:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var r=t(36)(t(25),"DataView");n.exports=r},function(n,e,t){var r=t(36)(t(25),"Promise");n.exports=r},function(n,e,t){var r=t(36)(t(25),"WeakMap");n.exports=r},function(n,e,t){var r=t(183),a=t(177);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var o=e[t],i=n[o];e[t]=[o,i,r(i)]}return e}},function(n,e,t){var r=t(173),a=t(295),o=t(302),i=t(114),s=t(183),l=t(184),c=t(82);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=a(t,n);return void 0===i&&i===e?o(t,n):r(e,i,3)}}},function(n,e,t){var r=t(185);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(297),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(o,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(298);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(111);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],o=t.cache;if(o.has(a))return o.get(a);var i=n.apply(this,r);return t.cache=o.set(a,i)||o,i};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(300);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(58),a=t(301),o=t(24),i=t(115),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return a(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(303),a=t(304);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(186),a=t(108),o=t(24),i=t(179),s=t(113),l=t(82);n.exports=function(n,e,t){for(var c=-1,p=(e=r(e,n)).length,d=!1;++c<p;){var u=l(e[c]);if(!(d=null!=n&&t(n,u)))break;n=n[u]}return d||++c!=p?d:!!(p=null==n?0:n.length)&&s(p)&&i(u,p)&&(o(n)||a(n))}},function(n,e,t){var r=t(306),a=t(307),o=t(114),i=t(82);n.exports=function(n){return o(n)?r(i(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(185);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(116),a=t(309),o=t(311);n.exports=function(n,e){return o(a(n,e,r),n+"")}},function(n,e,t){var r=t(310),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var o=arguments,i=-1,s=a(o.length-e,0),l=Array(s);++i<s;)l[i]=o[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=o[i];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(312),a=t(315)(r);n.exports=a},function(n,e,t){var r=t(313),a=t(314),o=t(116),i=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(36),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),o=16-(a-r);if(r=a,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(175),a=t(317),o=t(322),i=t(176),s=t(323),l=t(112);n.exports=function(n,e,t){var c=-1,p=a,d=n.length,u=!0,m=[],g=m;if(t)u=!1,p=o;else if(d>=200){var f=e?null:s(n);if(f)return l(f);u=!1,p=i,g=new r}else g=e?[]:m;n:for(;++c<d;){var h=n[c],b=e?e(h):h;if(h=t||0!==h?h:0,u&&b==b){for(var v=g.length;v--;)if(g[v]===b)continue n;e&&g.push(b),m.push(h)}else p(g,b,t)||(g!==m&&g.push(b),m.push(h))}return m}},function(n,e,t){var r=t(318);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(319),a=t(320),o=t(321);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,o=t+(r?1:-1);r?o--:++o<a;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(182),a=t(324),o=t(112),i=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(181),a=t(43);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(2),a=t(132);n.exports=function(n){return r((function(){return!!a[n]()||"​᠎"!="​᠎"[n]()||a[n].name!==n}))}},function(n,e,t){t(1)({target:"Function",proto:!0},{bind:t(187)})},function(n,e,t){var r=t(12),a=t(331),o=t(15),i=Math.ceil,s=function(n){return function(e,t,s){var l,c,p=String(o(e)),d=p.length,u=void 0===s?" ":String(s),m=r(t);return m<=d||""==u?p:(l=m-d,(c=a.call(u,i(l/u.length))).length>l&&(c=c.slice(0,l)),n?p+c:c+p)}};n.exports={start:s(!1),end:s(!0)}},function(n,e,t){"use strict";var r=t(46),a=t(15);n.exports=function(n){var e=String(a(this)),t="",o=r(n);if(o<0||o==1/0)throw RangeError("Wrong number of repetitions");for(;o>0;(o>>>=1)&&(e+=e))1&o&&(t+=e);return t}},function(n,e,t){var r=t(28);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(r)},function(n,e,t){"use strict";t(190)},function(n,e,t){"use strict";t(191)},function(n,e,t){"use strict";var r=t(1),a=t(30),o=t(14),i=t(12),s=t(2),l=t(336),c=t(42),p=t(337),d=t(338),u=t(44),m=t(339),g=[],f=g.sort,h=s((function(){g.sort(void 0)})),b=s((function(){g.sort(null)})),v=c("sort"),y=!s((function(){if(u)return u<70;if(!(p&&p>3)){if(d)return!0;if(m)return m<603;var n,e,t,r,a="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(r=0;r<47;r++)g.push({k:e+r,v:t})}for(g.sort((function(n,e){return e.v-n.v})),r=0;r<g.length;r++)e=g[r].k.charAt(0),a.charAt(a.length-1)!==e&&(a+=e);return"DGBEFHACIJK"!==a}}));r({target:"Array",proto:!0,forced:h||!b||!v||!y},{sort:function(n){void 0!==n&&a(n);var e=o(this);if(y)return void 0===n?f.call(e):f.call(e,n);var t,r,s=[],c=i(e.length);for(r=0;r<c;r++)r in e&&s.push(e[r]);for(t=(s=l(s,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:String(e)>String(t)?1:-1}}(n))).length,r=0;r<t;)e[r]=s[r++];for(;r<c;)delete e[r++];return e}})},function(n,e){var t=Math.floor,r=function(n,e){var i=n.length,s=t(i/2);return i<8?a(n,e):o(r(n.slice(0,s),e),r(n.slice(s),e),e)},a=function(n,e){for(var t,r,a=n.length,o=1;o<a;){for(r=o,t=n[o];r&&e(n[r-1],t)>0;)n[r]=n[--r];r!==o++&&(n[r]=t)}return n},o=function(n,e,t){for(var r=n.length,a=e.length,o=0,i=0,s=[];o<r||i<a;)o<r&&i<a?s.push(t(n[o],e[i])<=0?n[o++]:e[i++]):s.push(o<r?n[o++]:e[i++]);return s};n.exports=r},function(n,e,t){var r=t(28).match(/firefox\/(\d+)/i);n.exports=!!r&&+r[1]},function(n,e,t){var r=t(28);n.exports=/MSIE|Trident/.test(r)},function(n,e,t){var r=t(28).match(/AppleWebKit\/(\d+)\./);n.exports=!!r&&+r[1]},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(1),a=t(2),o=t(22),i=t(29).f,s=t(7),l=a((function(){i(1)}));r({target:"Object",stat:!0,forced:!s||l,sham:!s},{getOwnPropertyDescriptor:function(n,e){return i(o(n),e)}})},function(n,e,t){var r=t(1),a=t(7);r({target:"Object",stat:!0,forced:!a,sham:!a},{defineProperties:t(125)})},function(n,e,t){n.exports=function(n){var e={};function t(r){if(e[r])return e[r].exports;var a=e[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}return t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)t.d(r,a,function(e){return n[e]}.bind(null,a));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s="fb15")}({"01f9":function(n,e,t){"use strict";var r=t("2d00"),a=t("5ca1"),o=t("2aba"),i=t("32e9"),s=t("84f2"),l=t("41a0"),c=t("7f20"),p=t("38fd"),d=t("2b4c")("iterator"),u=!([].keys&&"next"in[].keys()),m=function(){return this};n.exports=function(n,e,t,g,f,h,b){l(t,e,g);var v,y,k,x=function(n){if(!u&&n in I)return I[n];switch(n){case"keys":case"values":return function(){return new t(this,n)}}return function(){return new t(this,n)}},w=e+" Iterator",S="values"==f,E=!1,I=n.prototype,_=I[d]||I["@@iterator"]||f&&I[f],T=_||x(f),j=f?S?x("entries"):T:void 0,C="Array"==e&&I.entries||_;if(C&&(k=p(C.call(new n)))!==Object.prototype&&k.next&&(c(k,w,!0),r||"function"==typeof k[d]||i(k,d,m)),S&&_&&"values"!==_.name&&(E=!0,T=function(){return _.call(this)}),r&&!b||!u&&!E&&I[d]||i(I,d,T),s[e]=T,s[w]=m,f)if(v={values:S?T:x("values"),keys:h?T:x("keys"),entries:j},b)for(y in v)y in I||o(I,y,v[y]);else a(a.P+a.F*(u||E),e,v);return v}},"0a49":function(n,e,t){var r=t("9b43"),a=t("626a"),o=t("4bf8"),i=t("9def"),s=t("cd1c");n.exports=function(n,e){var t=1==n,l=2==n,c=3==n,p=4==n,d=6==n,u=5==n||d,m=e||s;return function(e,s,g){for(var f,h,b=o(e),v=a(b),y=r(s,g,3),k=i(v.length),x=0,w=t?m(e,k):l?m(e,0):void 0;k>x;x++)if((u||x in v)&&(h=y(f=v[x],x,b),n))if(t)w[x]=h;else if(h)switch(n){case 3:return!0;case 5:return f;case 6:return x;case 2:w.push(f)}else if(p)return!1;return d?-1:c||p?p:w}}},"0bfb":function(n,e,t){"use strict";var r=t("cb7c");n.exports=function(){var n=r(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},"0d58":function(n,e,t){var r=t("ce10"),a=t("e11e");n.exports=Object.keys||function(n){return r(n,a)}},1169:function(n,e,t){var r=t("2d95");n.exports=Array.isArray||function(n){return"Array"==r(n)}},"11e9":function(n,e,t){var r=t("52a7"),a=t("4630"),o=t("6821"),i=t("6a99"),s=t("69a8"),l=t("c69a"),c=Object.getOwnPropertyDescriptor;e.f=t("9e1e")?c:function(n,e){if(n=o(n),e=i(e,!0),l)try{return c(n,e)}catch(n){}if(s(n,e))return a(!r.f.call(n,e),n[e])}},1495:function(n,e,t){var r=t("86cc"),a=t("cb7c"),o=t("0d58");n.exports=t("9e1e")?Object.defineProperties:function(n,e){a(n);for(var t,i=o(e),s=i.length,l=0;s>l;)r.f(n,t=i[l++],e[t]);return n}},1991:function(n,e,t){var r,a,o,i=t("9b43"),s=t("31f4"),l=t("fab2"),c=t("230e"),p=t("7726"),d=p.process,u=p.setImmediate,m=p.clearImmediate,g=p.MessageChannel,f=p.Dispatch,h=0,b={},v=function(){var n=+this;if(b.hasOwnProperty(n)){var e=b[n];delete b[n],e()}},y=function(n){v.call(n.data)};u&&m||(u=function(n){for(var e=[],t=1;arguments.length>t;)e.push(arguments[t++]);return b[++h]=function(){s("function"==typeof n?n:Function(n),e)},r(h),h},m=function(n){delete b[n]},"process"==t("2d95")(d)?r=function(n){d.nextTick(i(v,n,1))}:f&&f.now?r=function(n){f.now(i(v,n,1))}:g?(o=(a=new g).port2,a.port1.onmessage=y,r=i(o.postMessage,o,1)):p.addEventListener&&"function"==typeof postMessage&&!p.importScripts?(r=function(n){p.postMessage(n+"","*")},p.addEventListener("message",y,!1)):r="onreadystatechange"in c("script")?function(n){l.appendChild(c("script")).onreadystatechange=function(){l.removeChild(this),v.call(n)}}:function(n){setTimeout(i(v,n,1),0)}),n.exports={set:u,clear:m}},"1fa8":function(n,e,t){var r=t("cb7c");n.exports=function(n,e,t,a){try{return a?e(r(t)[0],t[1]):e(t)}catch(e){var o=n.return;throw void 0!==o&&r(o.call(n)),e}}},"20d6":function(n,e,t){"use strict";var r=t("5ca1"),a=t("0a49")(6),o="findIndex",i=!0;o in[]&&Array(1)[o]((function(){i=!1})),r(r.P+r.F*i,"Array",{findIndex:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),t("9c6c")(o)},"214f":function(n,e,t){"use strict";var r=t("32e9"),a=t("2aba"),o=t("79e5"),i=t("be13"),s=t("2b4c");n.exports=function(n,e,t){var l=s(n),c=t(i,l,""[n]),p=c[0],d=c[1];o((function(){var e={};return e[l]=function(){return 7},7!=""[n](e)}))&&(a(String.prototype,n,p),r(RegExp.prototype,l,2==e?function(n,e){return d.call(n,this,e)}:function(n){return d.call(n,this)}))}},"230e":function(n,e,t){var r=t("d3f4"),a=t("7726").document,o=r(a)&&r(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},2350:function(n,e){n.exports=function(n){var e=[];return e.toString=function(){return this.map((function(e){var t=function(n,e){var t=n[1]||"",r=n[3];if(!r)return t;if(e&&"function"==typeof btoa){var a=(i=r,"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),o=r.sources.map((function(n){return"/*# sourceURL="+r.sourceRoot+n+" */"}));return[t].concat(o).concat([a]).join("\n")}var i;return[t].join("\n")}(e,n);return e[2]?"@media "+e[2]+"{"+t+"}":t})).join("")},e.i=function(n,t){"string"==typeof n&&(n=[[null,n,""]]);for(var r={},a=0;a<this.length;a++){var o=this[a][0];"number"==typeof o&&(r[o]=!0)}for(a=0;a<n.length;a++){var i=n[a];"number"==typeof i[0]&&r[i[0]]||(t&&!i[2]?i[2]=t:t&&(i[2]="("+i[2]+") and ("+t+")"),e.push(i))}},e}},"23c6":function(n,e,t){var r=t("2d95"),a=t("2b4c")("toStringTag"),o="Arguments"==r(function(){return arguments}());n.exports=function(n){var e,t,i;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=Object(n),a))?t:o?r(e):"Object"==(i=r(e))&&"function"==typeof e.callee?"Arguments":i}},2621:function(n,e){e.f=Object.getOwnPropertySymbols},"27ee":function(n,e,t){var r=t("23c6"),a=t("2b4c")("iterator"),o=t("84f2");n.exports=t("8378").getIteratorMethod=function(n){if(null!=n)return n[a]||n["@@iterator"]||o[r(n)]}},"28a5":function(n,e,t){t("214f")("split",2,(function(n,e,r){"use strict";var a=t("aae3"),o=r,i=[].push,s="length";if("c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1)[s]||2!="ab".split(/(?:ab)*/)[s]||4!=".".split(/(.?)(.?)/)[s]||".".split(/()()/)[s]>1||"".split(/.?/)[s]){var l=void 0===/()??/.exec("")[1];r=function(n,e){var t=String(this);if(void 0===n&&0===e)return[];if(!a(n))return o.call(t,n,e);var r,c,p,d,u,m=[],g=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),f=0,h=void 0===e?4294967295:e>>>0,b=new RegExp(n.source,g+"g");for(l||(r=new RegExp("^"+b.source+"$(?!\\s)",g));(c=b.exec(t))&&!((p=c.index+c[0][s])>f&&(m.push(t.slice(f,c.index)),!l&&c[s]>1&&c[0].replace(r,(function(){for(u=1;u<arguments[s]-2;u++)void 0===arguments[u]&&(c[u]=void 0)})),c[s]>1&&c.index<t[s]&&i.apply(m,c.slice(1)),d=c[0][s],f=p,m[s]>=h));)b.lastIndex===c.index&&b.lastIndex++;return f===t[s]?!d&&b.test("")||m.push(""):m.push(t.slice(f)),m[s]>h?m.slice(0,h):m}}else"0".split(void 0,0)[s]&&(r=function(n,e){return void 0===n&&0===e?[]:o.call(this,n,e)});return[function(t,a){var o=n(this),i=null==t?void 0:t[e];return void 0!==i?i.call(t,o,a):r.call(String(o),t,a)},r]}))},"2aba":function(n,e,t){var r=t("7726"),a=t("32e9"),o=t("69a8"),i=t("ca5a")("src"),s=Function.toString,l=(""+s).split("toString");t("8378").inspectSource=function(n){return s.call(n)},(n.exports=function(n,e,t,s){var c="function"==typeof t;c&&(o(t,"name")||a(t,"name",e)),n[e]!==t&&(c&&(o(t,i)||a(t,i,n[e]?""+n[e]:l.join(String(e)))),n===r?n[e]=t:s?n[e]?n[e]=t:a(n,e,t):(delete n[e],a(n,e,t)))})(Function.prototype,"toString",(function(){return"function"==typeof this&&this[i]||s.call(this)}))},"2aeb":function(n,e,t){var r=t("cb7c"),a=t("1495"),o=t("e11e"),i=t("613b")("IE_PROTO"),s=function(){},l=function(){var n,e=t("230e")("iframe"),r=o.length;for(e.style.display="none",t("fab2").appendChild(e),e.src="javascript:",(n=e.contentWindow.document).open(),n.write("<script>document.F=Object<\/script>"),n.close(),l=n.F;r--;)delete l.prototype[o[r]];return l()};n.exports=Object.create||function(n,e){var t;return null!==n?(s.prototype=r(n),t=new s,s.prototype=null,t[i]=n):t=l(),void 0===e?t:a(t,e)}},"2b4c":function(n,e,t){var r=t("5537")("wks"),a=t("ca5a"),o=t("7726").Symbol,i="function"==typeof o;(n.exports=function(n){return r[n]||(r[n]=i&&o[n]||(i?o:a)("Symbol."+n))}).store=r},"2d00":function(n,e){n.exports=!1},"2d95":function(n,e){var t={}.toString;n.exports=function(n){return t.call(n).slice(8,-1)}},"2e08":function(n,e,t){var r=t("9def"),a=t("9744"),o=t("be13");n.exports=function(n,e,t,i){var s=String(o(n)),l=s.length,c=void 0===t?" ":String(t),p=r(e);if(p<=l||""==c)return s;var d=p-l,u=a.call(c,Math.ceil(d/c.length));return u.length>d&&(u=u.slice(0,d)),i?u+s:s+u}},"2f21":function(n,e,t){"use strict";var r=t("79e5");n.exports=function(n,e){return!!n&&r((function(){e?n.call(null,(function(){}),1):n.call(null)}))}},"2fdb":function(n,e,t){"use strict";var r=t("5ca1"),a=t("d2c8");r(r.P+r.F*t("5147")("includes"),"String",{includes:function(n){return!!~a(this,n,"includes").indexOf(n,arguments.length>1?arguments[1]:void 0)}})},"31f4":function(n,e){n.exports=function(n,e,t){var r=void 0===t;switch(e.length){case 0:return r?n():n.call(t);case 1:return r?n(e[0]):n.call(t,e[0]);case 2:return r?n(e[0],e[1]):n.call(t,e[0],e[1]);case 3:return r?n(e[0],e[1],e[2]):n.call(t,e[0],e[1],e[2]);case 4:return r?n(e[0],e[1],e[2],e[3]):n.call(t,e[0],e[1],e[2],e[3])}return n.apply(t,e)}},"32e9":function(n,e,t){var r=t("86cc"),a=t("4630");n.exports=t("9e1e")?function(n,e,t){return r.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},"33a4":function(n,e,t){var r=t("84f2"),a=t("2b4c")("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(r.Array===n||o[a]===n)}},"37e7":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32"}},[t("path",{attrs:{d:"M25.468 6.947a1.004 1.004 0 0 0-1.03.057L18 11.384V7.831a1.001 1.001 0 0 0-1.562-.827l-12 8.164a1 1 0 0 0 0 1.654l12 8.168A.999.999 0 0 0 18 24.164v-3.556l6.438 4.382A.999.999 0 0 0 26 24.164V7.831c0-.371-.205-.71-.532-.884z"}})])}}},3846:function(n,e,t){t("9e1e")&&"g"!=/./g.flags&&t("86cc").f(RegExp.prototype,"flags",{configurable:!0,get:t("0bfb")})},"386b":function(n,e,t){var r=t("5ca1"),a=t("79e5"),o=t("be13"),i=/"/g,s=function(n,e,t,r){var a=String(o(n)),s="<"+e;return""!==t&&(s+=" "+t+'="'+String(r).replace(i,"&quot;")+'"'),s+">"+a+"</"+e+">"};n.exports=function(n,e){var t={};t[n]=e(s),r(r.P+r.F*a((function(){var e=""[n]('"');return e!==e.toLowerCase()||e.split('"').length>3})),"String",t)}},"38fd":function(n,e,t){var r=t("69a8"),a=t("4bf8"),o=t("613b")("IE_PROTO"),i=Object.prototype;n.exports=Object.getPrototypeOf||function(n){return n=a(n),r(n,o)?n[o]:"function"==typeof n.constructor&&n instanceof n.constructor?n.constructor.prototype:n instanceof Object?i:null}},"41a0":function(n,e,t){"use strict";var r=t("2aeb"),a=t("4630"),o=t("7f20"),i={};t("32e9")(i,t("2b4c")("iterator"),(function(){return this})),n.exports=function(n,e,t){n.prototype=r(i,{next:a(1,t)}),o(n,e+" Iterator")}},"456d":function(n,e,t){var r=t("4bf8"),a=t("0d58");t("5eda")("keys",(function(){return function(n){return a(r(n))}}))},4588:function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){return isNaN(n=+n)?0:(n>0?r:t)(n)}},4630:function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},4713:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32"}},[t("path",{attrs:{d:"M26.667 5.333H5.334h-.001a2.667 2.667 0 0 0-2.666 2.666V24.001a2.667 2.667 0 0 0 2.666 2.666h21.335a2.667 2.667 0 0 0 2.666-2.666V8v-.001a2.667 2.667 0 0 0-2.666-2.666h-.001zM5.333 16h5.333v2.667H5.333V16zm13.334 8H5.334v-2.667h13.333V24zm8 0h-5.333v-2.667h5.333V24zm0-5.333H13.334V16h13.333v2.667z"}})])}}},"475a":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32"}},[t("path",{attrs:{d:"M.622 18.334h19.54v7.55l11.052-9.412-11.052-9.413v7.549H.622v3.725z"}})])}}},"48d3":function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),function(n){for(var t in n)e.hasOwnProperty(t)||(e[t]=n[t])}(t("b349"));var r=t("66a1");e.modifiers=r.modifiers},4917:function(n,e,t){t("214f")("match",1,(function(n,e,t){return[function(t){"use strict";var r=n(this),a=null==t?void 0:t[e];return void 0!==a?a.call(t,r):new RegExp(t)[e](String(r))},t]}))},"499e":function(n,e,t){"use strict";function r(n,e){for(var t=[],r={},a=0;a<e.length;a++){var o=e[a],i=o[0],s={id:n+":"+a,css:o[1],media:o[2],sourceMap:o[3]};r[i]?r[i].parts.push(s):t.push(r[i]={id:i,parts:[s]})}return t}t.r(e),t.d(e,"default",(function(){return m}));var a="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!a)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var o={},i=a&&(document.head||document.getElementsByTagName("head")[0]),s=null,l=0,c=!1,p=function(){},d=null,u="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function m(n,e,t,a){c=t,d=a||{};var i=r(n,e);return g(i),function(e){for(var t=[],a=0;a<i.length;a++){var s=i[a];(l=o[s.id]).refs--,t.push(l)}e?g(i=r(n,e)):i=[];for(a=0;a<t.length;a++){var l;if(0===(l=t[a]).refs){for(var c=0;c<l.parts.length;c++)l.parts[c]();delete o[l.id]}}}}function g(n){for(var e=0;e<n.length;e++){var t=n[e],r=o[t.id];if(r){r.refs++;for(var a=0;a<r.parts.length;a++)r.parts[a](t.parts[a]);for(;a<t.parts.length;a++)r.parts.push(h(t.parts[a]));r.parts.length>t.parts.length&&(r.parts.length=t.parts.length)}else{var i=[];for(a=0;a<t.parts.length;a++)i.push(h(t.parts[a]));o[t.id]={id:t.id,refs:1,parts:i}}}}function f(){var n=document.createElement("style");return n.type="text/css",i.appendChild(n),n}function h(n){var e,t,r=document.querySelector('style[data-vue-ssr-id~="'+n.id+'"]');if(r){if(c)return p;r.parentNode.removeChild(r)}if(u){var a=l++;r=s||(s=f()),e=y.bind(null,r,a,!1),t=y.bind(null,r,a,!0)}else r=f(),e=k.bind(null,r),t=function(){r.parentNode.removeChild(r)};return e(n),function(r){if(r){if(r.css===n.css&&r.media===n.media&&r.sourceMap===n.sourceMap)return;e(n=r)}else t()}}var b,v=(b=[],function(n,e){return b[n]=e,b.filter(Boolean).join("\n")});function y(n,e,t,r){var a=t?"":r.css;if(n.styleSheet)n.styleSheet.cssText=v(e,a);else{var o=document.createTextNode(a),i=n.childNodes;i[e]&&n.removeChild(i[e]),i.length?n.insertBefore(o,i[e]):n.appendChild(o)}}function k(n,e){var t=e.css,r=e.media,a=e.sourceMap;if(r&&n.setAttribute("media",r),d.ssrId&&n.setAttribute("data-vue-ssr-id",e.id),a&&(t+="\n/*# sourceURL="+a.sources[0]+" */",t+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(a))))+" */"),n.styleSheet)n.styleSheet.cssText=t;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(t))}}},"4a59":function(n,e,t){var r=t("9b43"),a=t("1fa8"),o=t("33a4"),i=t("cb7c"),s=t("9def"),l=t("27ee"),c={},p={};(e=n.exports=function(n,e,t,d,u){var m,g,f,h,b=u?function(){return n}:l(n),v=r(t,d,e?2:1),y=0;if("function"!=typeof b)throw TypeError(n+" is not iterable!");if(o(b)){for(m=s(n.length);m>y;y++)if((h=e?v(i(g=n[y])[0],g[1]):v(n[y]))===c||h===p)return h}else for(f=b.call(n);!(g=f.next()).done;)if((h=a(f,v,g.value,e))===c||h===p)return h}).BREAK=c,e.RETURN=p},"4b41":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 28 32"}},[t("path",{attrs:{d:"M13.728 6.272v19.456q0 .448-.352.8t-.8.32-.8-.32l-5.952-5.952H1.152q-.48 0-.8-.352t-.352-.8v-6.848q0-.48.352-.8t.8-.352h4.672l5.952-5.952q.32-.32.8-.32t.8.32.352.8zM20.576 16q0 1.344-.768 2.528t-2.016 1.664q-.16.096-.448.096-.448 0-.8-.32t-.32-.832q0-.384.192-.64t.544-.448.608-.384.512-.64.192-1.024-.192-1.024-.512-.64-.608-.384-.544-.448-.192-.64q0-.48.32-.832t.8-.32q.288 0 .448.096 1.248.48 2.016 1.664T20.576 16zm4.576 0q0 2.72-1.536 5.056t-4 3.36q-.256.096-.448.096-.48 0-.832-.352t-.32-.8q0-.704.672-1.056 1.024-.512 1.376-.8 1.312-.96 2.048-2.4T22.848 16t-.736-3.104-2.048-2.4q-.352-.288-1.376-.8-.672-.352-.672-1.056 0-.448.32-.8t.8-.352q.224 0 .48.096 2.496 1.056 4 3.36T25.152 16zm4.576 0q0 4.096-2.272 7.552t-6.048 5.056q-.224.096-.448.096-.48 0-.832-.352t-.32-.8q0-.64.704-1.056l.384-.192q.256-.128.416-.192.8-.448 1.44-.896 2.208-1.632 3.456-4.064T27.424 16t-1.216-5.152-3.456-4.064q-.64-.448-1.44-.896-.128-.096-.416-.192t-.384-.192q-.704-.416-.704-1.056 0-.448.32-.8t.832-.352q.224 0 .448.096 3.776 1.632 6.048 5.056T29.728 16z"}})])}}},"4bf8":function(n,e,t){var r=t("be13");n.exports=function(n){return Object(r(n))}},"4d26":function(n,e,t){var r;
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/!function(){"use strict";var t={}.hasOwnProperty;function a(){for(var n=[],e=0;e<arguments.length;e++){var r=arguments[e];if(r){var o=typeof r;if("string"===o||"number"===o)n.push(r);else if(Array.isArray(r)&&r.length){var i=a.apply(null,r);i&&n.push(i)}else if("object"===o)for(var s in r)t.call(r,s)&&r[s]&&n.push(s)}}return n.join(" ")}n.exports?(a.default=a,n.exports=a):void 0===(r=function(){return a}.apply(e,[]))||(n.exports=r)}()},5147:function(n,e,t){var r=t("2b4c")("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,!"/./"[n](e)}catch(n){}}return!0}},"52a7":function(n,e){e.f={}.propertyIsEnumerable},"52f0":function(n,e,t){var r={"./loading.svg":"885d","./loop-all.svg":"f866","./loop-none.svg":"c3ab","./loop-one.svg":"5527","./lrc.svg":"4713","./menu.svg":"906b","./order-list.svg":"475a","./order-random.svg":"7a1a","./pause.svg":"daf8","./play.svg":"84d8","./right.svg":"bf5c","./skip.svg":"37e7","./volume-down.svg":"bdba","./volume-off.svg":"adec","./volume-up.svg":"4b41"};function a(n){var e=o(n);return t(e)}function o(n){var e=r[n];if(!(e+1)){var t=new Error("Cannot find module '"+n+"'");throw t.code="MODULE_NOT_FOUND",t}return e}a.keys=function(){return Object.keys(r)},a.resolve=o,n.exports=a,a.id="52f0"},"551c":function(n,e,t){"use strict";var r,a,o,i,s=t("2d00"),l=t("7726"),c=t("9b43"),p=t("23c6"),d=t("5ca1"),u=t("d3f4"),m=t("d8e8"),g=t("f605"),f=t("4a59"),h=t("ebd6"),b=t("1991").set,v=t("8079")(),y=t("a5b8"),k=t("9c80"),x=t("a25f"),w=t("bcaa"),S=l.TypeError,E=l.process,I=E&&E.versions,_=I&&I.v8||"",T=l.Promise,j="process"==p(E),C=function(){},A=a=y.f,z=!!function(){try{var n=T.resolve(1),e=(n.constructor={})[t("2b4c")("species")]=function(n){n(C,C)};return(j||"function"==typeof PromiseRejectionEvent)&&n.then(C)instanceof e&&0!==_.indexOf("6.6")&&-1===x.indexOf("Chrome/66")}catch(n){}}(),O=function(n){var e;return!(!u(n)||"function"!=typeof(e=n.then))&&e},L=function(n,e){if(!n._n){n._n=!0;var t=n._c;v((function(){for(var r=n._v,a=1==n._s,o=0,i=function(e){var t,o,i,s=a?e.ok:e.fail,l=e.resolve,c=e.reject,p=e.domain;try{s?(a||(2==n._h&&M(n),n._h=1),!0===s?t=r:(p&&p.enter(),t=s(r),p&&(p.exit(),i=!0)),t===e.promise?c(S("Promise-chain cycle")):(o=O(t))?o.call(t,l,c):l(t)):c(r)}catch(n){p&&!i&&p.exit(),c(n)}};t.length>o;)i(t[o++]);n._c=[],n._n=!1,e&&!n._h&&P(n)}))}},P=function(n){b.call(l,(function(){var e,t,r,a=n._v,o=R(n);if(o&&(e=k((function(){j?E.emit("unhandledRejection",a,n):(t=l.onunhandledrejection)?t({promise:n,reason:a}):(r=l.console)&&r.error&&r.error("Unhandled promise rejection",a)})),n._h=j||R(n)?2:1),n._a=void 0,o&&e.e)throw e.v}))},R=function(n){return 1!==n._h&&0===(n._a||n._c).length},M=function(n){b.call(l,(function(){var e;j?E.emit("rejectionHandled",n):(e=l.onrejectionhandled)&&e({promise:n,reason:n._v})}))},B=function(n){var e=this;e._d||(e._d=!0,(e=e._w||e)._v=n,e._s=2,e._a||(e._a=e._c.slice()),L(e,!0))},D=function(n){var e,t=this;if(!t._d){t._d=!0,t=t._w||t;try{if(t===n)throw S("Promise can't be resolved itself");(e=O(n))?v((function(){var r={_w:t,_d:!1};try{e.call(n,c(D,r,1),c(B,r,1))}catch(n){B.call(r,n)}})):(t._v=n,t._s=1,L(t,!1))}catch(n){B.call({_w:t,_d:!1},n)}}};z||(T=function(n){g(this,T,"Promise","_h"),m(n),r.call(this);try{n(c(D,this,1),c(B,this,1))}catch(n){B.call(this,n)}},(r=function(n){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1}).prototype=t("dcbc")(T.prototype,{then:function(n,e){var t=A(h(this,T));return t.ok="function"!=typeof n||n,t.fail="function"==typeof e&&e,t.domain=j?E.domain:void 0,this._c.push(t),this._a&&this._a.push(t),this._s&&L(this,!1),t.promise},catch:function(n){return this.then(void 0,n)}}),o=function(){var n=new r;this.promise=n,this.resolve=c(D,n,1),this.reject=c(B,n,1)},y.f=A=function(n){return n===T||n===i?new o(n):a(n)}),d(d.G+d.W+d.F*!z,{Promise:T}),t("7f20")(T,"Promise"),t("7a56")("Promise"),i=t("8378").Promise,d(d.S+d.F*!z,"Promise",{reject:function(n){var e=A(this);return(0,e.reject)(n),e.promise}}),d(d.S+d.F*(s||!z),"Promise",{resolve:function(n){return w(s&&this===i?T:this,n)}}),d(d.S+d.F*!(z&&t("5cc5")((function(n){T.all(n).catch(C)}))),"Promise",{all:function(n){var e=this,t=A(e),r=t.resolve,a=t.reject,o=k((function(){var t=[],o=0,i=1;f(n,!1,(function(n){var s=o++,l=!1;t.push(void 0),i++,e.resolve(n).then((function(n){l||(l=!0,t[s]=n,--i||r(t))}),a)})),--i||r(t)}));return o.e&&a(o.v),t.promise},race:function(n){var e=this,t=A(e),r=t.reject,a=k((function(){f(n,!1,(function(n){e.resolve(n).then(t.resolve,r)}))}));return a.e&&r(a.v),t.promise}})},5527:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 33 32"}},[t("path",{attrs:{d:"M9.333 9.333h13.333v4L27.999 8l-5.333-5.333v4h-16v8h2.667V9.334zm13.334 13.334H9.334v-4L4.001 24l5.333 5.333v-4h16v-8h-2.667v5.333zM17.333 20v-8H16l-2.667 1.333v1.333h2v5.333h2z"}})])}}},5537:function(n,e,t){var r=t("8378"),a=t("7726"),o=a["__core-js_shared__"]||(a["__core-js_shared__"]={});(n.exports=function(n,e){return o[n]||(o[n]=void 0!==e?e:{})})("versions",[]).push({version:r.version,mode:t("2d00")?"pure":"global",copyright:"© 2018 Denis Pushkarev (zloirock.ru)"})},"55dd":function(n,e,t){"use strict";var r=t("5ca1"),a=t("d8e8"),o=t("4bf8"),i=t("79e5"),s=[].sort,l=[1,2,3];r(r.P+r.F*(i((function(){l.sort(void 0)}))||!i((function(){l.sort(null)}))||!t("2f21")(s)),"Array",{sort:function(n){return void 0===n?s.call(o(this)):s.call(o(this),a(n))}})},"5ca1":function(n,e,t){var r=t("7726"),a=t("8378"),o=t("32e9"),i=t("2aba"),s=t("9b43"),l=function(n,e,t){var c,p,d,u,m=n&l.F,g=n&l.G,f=n&l.S,h=n&l.P,b=n&l.B,v=g?r:f?r[e]||(r[e]={}):(r[e]||{}).prototype,y=g?a:a[e]||(a[e]={}),k=y.prototype||(y.prototype={});for(c in g&&(t=e),t)d=((p=!m&&v&&void 0!==v[c])?v:t)[c],u=b&&p?s(d,r):h&&"function"==typeof d?s(Function.call,d):d,v&&i(v,c,d,n&l.U),y[c]!=d&&o(y,c,u),h&&k[c]!=d&&(k[c]=d)};r.core=a,l.F=1,l.G=2,l.S=4,l.P=8,l.B=16,l.W=32,l.U=64,l.R=128,n.exports=l},"5cc5":function(n,e,t){var r=t("2b4c")("iterator"),a=!1;try{var o=[7][r]();o.return=function(){a=!0},Array.from(o,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!a)return!1;var t=!1;try{var o=[7],i=o[r]();i.next=function(){return{done:t=!0}},o[r]=function(){return i},n(o)}catch(n){}return t}},"5dbc":function(n,e,t){var r=t("d3f4"),a=t("8b97").set;n.exports=function(n,e,t){var o,i=e.constructor;return i!==t&&"function"==typeof i&&(o=i.prototype)!==t.prototype&&r(o)&&a&&a(n,o),n}},"5eda":function(n,e,t){var r=t("5ca1"),a=t("8378"),o=t("79e5");n.exports=function(n,e){var t=(a.Object||{})[n]||Object[n],i={};i[n]=e(t),r(r.S+r.F*o((function(){t(1)})),"Object",i)}},"610a":function(n,e,t){var r=t("ab57");"string"==typeof r&&(r=[[n.i,r,""]]),r.locals&&(n.exports=r.locals);(0,t("499e").default)("4573c8b0",r,!0,{sourceMap:!1,shadowMode:!1})},"613b":function(n,e,t){var r=t("5537")("keys"),a=t("ca5a");n.exports=function(n){return r[n]||(r[n]=a(n))}},"626a":function(n,e,t){var r=t("2d95");n.exports=Object("z").propertyIsEnumerable(0)?Object:function(n){return"String"==r(n)?n.split(""):Object(n)}},"65d9":function(n,e,t){"use strict";
/**
  * vue-class-component v6.3.2
  * (c) 2015-present Evan You
  * @license MIT
  */Object.defineProperty(e,"__esModule",{value:!0});var r,a=(r=t("8bbf"))&&"object"==typeof r&&"default"in r?r.default:r,o="undefined"!=typeof Reflect&&Reflect.defineMetadata;function i(n,e,t){(t?Reflect.getOwnMetadataKeys(e,t):Reflect.getOwnMetadataKeys(e)).forEach((function(r){var a=t?Reflect.getOwnMetadata(r,e,t):Reflect.getOwnMetadata(r,e);t?Reflect.defineMetadata(r,a,n,t):Reflect.defineMetadata(r,a,n)}))}var s={__proto__:[]}instanceof Array;var l=["data","beforeCreate","created","beforeMount","mounted","beforeDestroy","destroyed","beforeUpdate","updated","activated","deactivated","render","errorCaptured"];function c(n,e){void 0===e&&(e={}),e.name=e.name||n._componentTag||n.name;var t=n.prototype;Object.getOwnPropertyNames(t).forEach((function(n){if("constructor"!==n)if(l.indexOf(n)>-1)e[n]=t[n];else{var r=Object.getOwnPropertyDescriptor(t,n);void 0!==r.value?"function"==typeof r.value?(e.methods||(e.methods={}))[n]=r.value:(e.mixins||(e.mixins=[])).push({data:function(){var e;return(e={})[n]=r.value,e}}):(r.get||r.set)&&((e.computed||(e.computed={}))[n]={get:r.get,set:r.set})}})),(e.mixins||(e.mixins=[])).push({data:function(){return function(n,e){var t=e.prototype._init;e.prototype._init=function(){var e=this,t=Object.getOwnPropertyNames(n);if(n.$options.props)for(var r in n.$options.props)n.hasOwnProperty(r)||t.push(r);t.forEach((function(t){"_"!==t.charAt(0)&&Object.defineProperty(e,t,{get:function(){return n[t]},set:function(e){n[t]=e},configurable:!0})}))};var r=new e;e.prototype._init=t;var a={};return Object.keys(r).forEach((function(n){void 0!==r[n]&&(a[n]=r[n])})),a}(this,n)}});var r=n.__decorators__;r&&(r.forEach((function(n){return n(e)})),delete n.__decorators__);var c,p,d=Object.getPrototypeOf(n.prototype),u=d instanceof a?d.constructor:a,m=u.extend(e);return function(n,e,t){Object.getOwnPropertyNames(e).forEach((function(r){if("prototype"!==r){var a=Object.getOwnPropertyDescriptor(n,r);if(!a||a.configurable){var o,i,l=Object.getOwnPropertyDescriptor(e,r);if(!s){if("cid"===r)return;var c=Object.getOwnPropertyDescriptor(t,r);if(o=l.value,i=typeof o,null!=o&&("object"===i||"function"===i)&&c&&c.value===l.value)return}0,Object.defineProperty(n,r,l)}}}))}(m,n,u),o&&(i(c=m,p=n),Object.getOwnPropertyNames(p.prototype).forEach((function(n){i(c.prototype,p.prototype,n)})),Object.getOwnPropertyNames(p).forEach((function(n){i(c,p,n)}))),m}function p(n){return"function"==typeof n?c(n):function(e){return c(e,n)}}p.registerHooks=function(n){l.push.apply(l,n)},e.default=p,e.createDecorator=function(n){return function(e,t,r){var a="function"==typeof e?e:e.constructor;a.__decorators__||(a.__decorators__=[]),"number"!=typeof r&&(r=void 0),a.__decorators__.push((function(e){return n(e,t,r)}))}},e.mixins=function(){for(var n=[],e=0;e<arguments.length;e++)n[e]=arguments[e];return a.extend({mixins:n})}},"66a1":function(n,e,t){"use strict";var r=this&&this.__assign||Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var a in e=arguments[t])Object.prototype.hasOwnProperty.call(e,a)&&(n[a]=e[a]);return n};function a(n,e,t){for(var r=0,a=e;r<a.length;r++){if(!(0,a[r])(n))return}t&&t(n)}Object.defineProperty(e,"__esModule",{value:!0});var o={esc:27,tab:9,enter:13,space:32,up:38,down:40,del:[8,46],left:37,right:39};function i(n){for(var e=[],t=0,r=n;t<r.length;t++){var a=r[t];if("number"==typeof a)e.push(a);else{var i=o[a];"number"==typeof i?e.push(i):e.push.apply(e,i)}}switch(e.length){case 0:return function(n){return!1};case 1:var s=e[0];return function(n){return n.keyCode===s};default:return function(n){return e.indexOf(n.keyCode)>=0}}}function s(n,e,t,r,a){Object.defineProperty(n,t,{get:function(){var o=l(e.concat([r]),a);return Object.defineProperty(n,t,{value:o,enumerable:!0}),o},enumerable:!0,configurable:!0})}function l(n,e){function t(e){return e instanceof Function?function(t){return a(t,n,e)}:void a(e,n)}if(e.keyboard||e.mouse){var l=r({},e,{keyboard:!1,mouse:!1});e.keyboard&&(function(n,e,t){var r=function(r){var a=r;if("left"===a||"right"===a)return"continue";var i=o[a];if("number"==typeof i)s(n,e,a,(function(n){return n.keyCode===i}),t);else{var l=i[0],c=i[1];s(n,e,a,(function(n){return n.keyCode===l||n.keyCode===c}),t)}};for(var a in o)r(a)}(t,n,l),function(n,e,t){Object.defineProperty(n,"keys",{get:function(){var n=this,r=function(){for(var r=[],a=0;a<arguments.length;a++)r[a]=arguments[a];var o="keys:"+r.toString(),l=n[o];if(void 0!==l)return l;var c=i(r);return s(n,e,o,c,t),n[o]};return Object.defineProperty(this,"keys",{value:r,enumerable:!0}),r},enumerable:!0,configurable:!0})}(t,n,l)),e.mouse&&s(t,n,"middle",(function(n){return 1===n.button}),l),s(t,n,"left",(function(n){return 37===n.keyCode||0===n.button}),l),s(t,n,"right",(function(n){return 39===n.keyCode||2===n.button}),l)}if(e.exact){l=r({},e,{exact:!1,modkey:!1});!function(n,e,t){Object.defineProperty(n,"exact",{get:function(){var n=this,r=function(){for(var r=[],a=0;a<arguments.length;a++)r[a]=arguments[a];var o="exact:"+r.toString(),i=n[o];if(void 0!==i)return i;var l={ctrl:!1,shift:!1,alt:!1,meta:!1};r.forEach((function(n){return l[n]=!0}));var c=function(n){return!!n.ctrlKey===l.ctrl&&!!n.shiftKey===l.shift&&!!n.altKey===l.alt&&!!n.metaKey===l.meta};return s(n,e,o,c,t),n[o]};return Object.defineProperty(this,"exact",{value:r,enumerable:!0}),r},enumerable:!0,configurable:!0})}(t,n,l)}if(e.modkey){l=r({},e,{exact:!1});s(t,n,"ctrl",(function(n){return n.ctrlKey}),l),s(t,n,"shift",(function(n){return n.shiftKey}),l),s(t,n,"alt",(function(n){return n.altKey}),l),s(t,n,"meta",(function(n){return n.metaKey}),l),s(t,n,"noctrl",(function(n){return!n.ctrlKey}),l),s(t,n,"noshift",(function(n){return!n.shiftKey}),l),s(t,n,"noalt",(function(n){return!n.altKey}),l),s(t,n,"nometa",(function(n){return!n.metaKey}),l)}return s(t,n,"stop",(function(n){return n.stopPropagation()||!0}),e),s(t,n,"prevent",(function(n){return n.preventDefault()||!0}),e),s(t,n,"self",(function(n){return n.target===n.currentTarget}),e),t}e.modifiers=l([],{keyboard:!0,mouse:!0,modkey:!0,exact:!0})},6762:function(n,e,t){"use strict";var r=t("5ca1"),a=t("c366")(!0);r(r.P,"Array",{includes:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),t("9c6c")("includes")},6821:function(n,e,t){var r=t("626a"),a=t("be13");n.exports=function(n){return r(a(n))}},"69a8":function(n,e){var t={}.hasOwnProperty;n.exports=function(n,e){return t.call(n,e)}},"6a99":function(n,e,t){var r=t("d3f4");n.exports=function(n,e){if(!r(n))return n;var t,a;if(e&&"function"==typeof(t=n.toString)&&!r(a=t.call(n)))return a;if("function"==typeof(t=n.valueOf)&&!r(a=t.call(n)))return a;if(!e&&"function"==typeof(t=n.toString)&&!r(a=t.call(n)))return a;throw TypeError("Can't convert object to primitive value")}},"6b54":function(n,e,t){"use strict";t("3846");var r=t("cb7c"),a=t("0bfb"),o=t("9e1e"),i=/./.toString,s=function(n){t("2aba")(RegExp.prototype,"toString",n,!0)};t("79e5")((function(){return"/a/b"!=i.call({source:"a",flags:"b"})}))?s((function(){var n=r(this);return"/".concat(n.source,"/","flags"in n?n.flags:!o&&n instanceof RegExp?a.call(n):void 0)})):"toString"!=i.name&&s((function(){return i.call(this)}))},7333:function(n,e,t){"use strict";var r=t("0d58"),a=t("2621"),o=t("52a7"),i=t("4bf8"),s=t("626a"),l=Object.assign;n.exports=!l||t("79e5")((function(){var n={},e={},t=Symbol(),r="abcdefghijklmnopqrst";return n[t]=7,r.split("").forEach((function(n){e[n]=n})),7!=l({},n)[t]||Object.keys(l({},e)).join("")!=r}))?function(n,e){for(var t=i(n),l=arguments.length,c=1,p=a.f,d=o.f;l>c;)for(var u,m=s(arguments[c++]),g=p?r(m).concat(p(m)):r(m),f=g.length,h=0;f>h;)d.call(m,u=g[h++])&&(t[u]=m[u]);return t}:l},7514:function(n,e,t){"use strict";var r=t("5ca1"),a=t("0a49")(5),o=!0;"find"in[]&&Array(1).find((function(){o=!1})),r(r.P+r.F*o,"Array",{find:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),t("9c6c")("find")},7726:function(n,e){var t=n.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=t)},"77f1":function(n,e,t){var r=t("4588"),a=Math.max,o=Math.min;n.exports=function(n,e){return(n=r(n))<0?a(n+e,0):o(n,e)}},"79e5":function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},"7a1a":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32"}},[t("path",{attrs:{d:"M22.667 4l7 6-7 6 7 6-7 6v-4h-3.653l-3.76-3.76 2.827-2.827L20.668 20h2v-8h-2l-12 12h-6v-4h4.347l12-12h3.653V4zm-20 4h6l3.76 3.76L9.6 14.587 7.013 12H2.666V8z"}})])}}},"7a56":function(n,e,t){"use strict";var r=t("7726"),a=t("86cc"),o=t("9e1e"),i=t("2b4c")("species");n.exports=function(n){var e=r[n];o&&e&&!e[i]&&a.f(e,i,{configurable:!0,get:function(){return this}})}},"7f20":function(n,e,t){var r=t("86cc").f,a=t("69a8"),o=t("2b4c")("toStringTag");n.exports=function(n,e,t){n&&!a(n=t?n:n.prototype,o)&&r(n,o,{configurable:!0,value:e})}},"7f7f":function(n,e,t){var r=t("86cc").f,a=Function.prototype,o=/^\s*function ([^ (]*)/;"name"in a||t("9e1e")&&r(a,"name",{configurable:!0,get:function(){try{return(""+this).match(o)[1]}catch(n){return""}}})},8079:function(n,e,t){var r=t("7726"),a=t("1991").set,o=r.MutationObserver||r.WebKitMutationObserver,i=r.process,s=r.Promise,l="process"==t("2d95")(i);n.exports=function(){var n,e,t,c=function(){var r,a;for(l&&(r=i.domain)&&r.exit();n;){a=n.fn,n=n.next;try{a()}catch(r){throw n?t():e=void 0,r}}e=void 0,r&&r.enter()};if(l)t=function(){i.nextTick(c)};else if(!o||r.navigator&&r.navigator.standalone)if(s&&s.resolve){var p=s.resolve(void 0);t=function(){p.then(c)}}else t=function(){a.call(r,c)};else{var d=!0,u=document.createTextNode("");new o(c).observe(u,{characterData:!0}),t=function(){u.data=d=!d}}return function(r){var a={fn:r,next:void 0};e&&(e.next=a),n||(n=a,t()),e=a}}},8378:function(n,e){var t=n.exports={version:"2.5.7"};"number"==typeof __e&&(__e=t)},"84d8":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 31"}},[t("path",{attrs:{d:"M15.552 15.168q.448.32.448.832 0 .448-.448.768L1.856 25.28q-.768.512-1.312.192T0 24.192V7.744q0-.96.544-1.28t1.312.192z"}})])}}},"84f2":function(n,e){n.exports={}},"86cc":function(n,e,t){var r=t("cb7c"),a=t("c69a"),o=t("6a99"),i=Object.defineProperty;e.f=t("9e1e")?Object.defineProperty:function(n,e,t){if(r(n),e=o(e,!0),r(t),a)try{return i(n,e,t)}catch(n){}if("get"in t||"set"in t)throw TypeError("Accessors not supported!");return"value"in t&&(n[e]=t.value),n}},"885d":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32"}},[t("path",{attrs:{d:"M4 16C4 9.4 9.4 4 16 4s12 5.4 12 12c0 1.2-.8 2-2 2s-2-.8-2-2c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8c1.2 0 2 .8 2 2s-.8 2-2 2C9.4 28 4 22.6 4 16z"}})])}}},"8b97":function(n,e,t){var r=t("d3f4"),a=t("cb7c"),o=function(n,e){if(a(n),!r(e)&&null!==e)throw TypeError(e+": can't set as prototype!")};n.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(n,e,r){try{(r=t("9b43")(Function.call,t("11e9").f(Object.prototype,"__proto__").set,2))(n,[]),e=!(n instanceof Array)}catch(n){e=!0}return function(n,t){return o(n,t),e?n.__proto__=t:r(n,t),n}}({},!1):void 0),check:o}},"8bbf":function(n,e){n.exports=t(0)},"906b":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 22 32"}},[t("path",{attrs:{d:"M20.8 14.4q.704 0 1.152.48T22.4 16t-.48 1.12-1.12.48H1.6q-.64 0-1.12-.48T0 16t.448-1.12T1.6 14.4h19.2zM1.6 11.2q-.64 0-1.12-.48T0 9.6t.448-1.12T1.6 8h19.2q.704 0 1.152.48T22.4 9.6t-.48 1.12-1.12.48H1.6zm19.2 9.6q.704 0 1.152.48t.448 1.12-.48 1.12-1.12.48H1.6q-.64 0-1.12-.48T0 22.4t.448-1.12T1.6 20.8h19.2z"}})])}}},9093:function(n,e,t){var r=t("ce10"),a=t("e11e").concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},"96cf":function(n,e){!function(e){"use strict";var t=Object.prototype,r=t.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},o=a.iterator||"@@iterator",i=a.asyncIterator||"@@asyncIterator",s=a.toStringTag||"@@toStringTag",l="object"==typeof n,c=e.regeneratorRuntime;if(c)l&&(n.exports=c);else{(c=e.regeneratorRuntime=l?n.exports:{}).wrap=f;var p={},d={};d[o]=function(){return this};var u=Object.getPrototypeOf,m=u&&u(u(_([])));m&&m!==t&&r.call(m,o)&&(d=m);var g=y.prototype=b.prototype=Object.create(d);v.prototype=g.constructor=y,y.constructor=v,y[s]=v.displayName="GeneratorFunction",c.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===v||"GeneratorFunction"===(e.displayName||e.name))},c.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,y):(n.__proto__=y,s in n||(n[s]="GeneratorFunction")),n.prototype=Object.create(g),n},c.awrap=function(n){return{__await:n}},k(x.prototype),x.prototype[i]=function(){return this},c.AsyncIterator=x,c.async=function(n,e,t,r){var a=new x(f(n,e,t,r));return c.isGeneratorFunction(e)?a:a.next().then((function(n){return n.done?n.value:a.next()}))},k(g),g[s]="Generator",g[o]=function(){return this},g.toString=function(){return"[object Generator]"},c.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},c.values=_,I.prototype={constructor:I,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(E),!n)for(var e in this)"t"===e.charAt(0)&&r.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function t(t,r){return i.type="throw",i.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var a=this.tryEntries.length-1;a>=0;--a){var o=this.tryEntries[a],i=o.completion;if("root"===o.tryLoc)return t("end");if(o.tryLoc<=this.prev){var s=r.call(o,"catchLoc"),l=r.call(o,"finallyLoc");if(s&&l){if(this.prev<o.catchLoc)return t(o.catchLoc,!0);if(this.prev<o.finallyLoc)return t(o.finallyLoc)}else if(s){if(this.prev<o.catchLoc)return t(o.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return t(o.finallyLoc)}}}},abrupt:function(n,e){for(var t=this.tryEntries.length-1;t>=0;--t){var a=this.tryEntries[t];if(a.tryLoc<=this.prev&&r.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var o=a;break}}o&&("break"===n||"continue"===n)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var i=o?o.completion:{};return i.type=n,i.arg=e,o?(this.method="next",this.next=o.finallyLoc,p):this.complete(i)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),p},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),E(t),p}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var a=r.arg;E(t)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:_(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),p}}}function f(n,e,t,r){var a=e&&e.prototype instanceof b?e:b,o=Object.create(a.prototype),i=new I(r||[]);return o._invoke=function(n,e,t){var r="suspendedStart";return function(a,o){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===a)throw o;return T()}for(t.method=a,t.arg=o;;){var i=t.delegate;if(i){var s=w(i,t);if(s){if(s===p)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var l=h(n,e,t);if("normal"===l.type){if(r=t.done?"completed":"suspendedYield",l.arg===p)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(r="completed",t.method="throw",t.arg=l.arg)}}}(n,t,i),o}function h(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}function b(){}function v(){}function y(){}function k(n){["next","throw","return"].forEach((function(e){n[e]=function(n){return this._invoke(e,n)}}))}function x(n){var e;this._invoke=function(t,a){function o(){return new Promise((function(e,o){!function e(t,a,o,i){var s=h(n[t],n,a);if("throw"!==s.type){var l=s.arg,c=l.value;return c&&"object"==typeof c&&r.call(c,"__await")?Promise.resolve(c.__await).then((function(n){e("next",n,o,i)}),(function(n){e("throw",n,o,i)})):Promise.resolve(c).then((function(n){l.value=n,o(l)}),i)}i(s.arg)}(t,a,e,o)}))}return e=e?e.then(o,o):o()}}function w(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,w(n,e),"throw"===e.method))return p;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return p}var r=h(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,p;var a=r.arg;return a?a.done?(e[n.resultName]=a.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,p):a:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,p)}function S(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function E(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function I(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(S,this),this.reset(!0)}function _(n){if(n){var e=n[o];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var t=-1,a=function e(){for(;++t<n.length;)if(r.call(n,t))return e.value=n[t],e.done=!1,e;return e.value=void 0,e.done=!0,e};return a.next=a}}return{next:T}}function T(){return{value:void 0,done:!0}}}(function(){return this}()||Function("return this")())},9744:function(n,e,t){"use strict";var r=t("4588"),a=t("be13");n.exports=function(n){var e=String(a(this)),t="",o=r(n);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(e+=e))1&o&&(t+=e);return t}},"9b43":function(n,e,t){var r=t("d8e8");n.exports=function(n,e,t){if(r(n),void 0===e)return n;switch(t){case 1:return function(t){return n.call(e,t)};case 2:return function(t,r){return n.call(e,t,r)};case 3:return function(t,r,a){return n.call(e,t,r,a)}}return function(){return n.apply(e,arguments)}}},"9c6c":function(n,e,t){var r=t("2b4c")("unscopables"),a=Array.prototype;null==a[r]&&t("32e9")(a,r,{}),n.exports=function(n){a[r][n]=!0}},"9c80":function(n,e){n.exports=function(n){try{return{e:!1,v:n()}}catch(n){return{e:!0,v:n}}}},"9def":function(n,e,t){var r=t("4588"),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},"9e1e":function(n,e,t){n.exports=!t("79e5")((function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a}))},a25f:function(n,e,t){var r=t("7726").navigator;n.exports=r&&r.userAgent||""},a481:function(n,e,t){t("214f")("replace",2,(function(n,e,t){return[function(r,a){"use strict";var o=n(this),i=null==r?void 0:r[e];return void 0!==i?i.call(r,o,a):t.call(String(o),r,a)},t]}))},a5b8:function(n,e,t){"use strict";var r=t("d8e8");function a(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)}n.exports.f=function(n){return new a(n)}},aa77:function(n,e,t){var r=t("5ca1"),a=t("be13"),o=t("79e5"),i=t("fdef"),s="["+i+"]",l=RegExp("^"+s+s+"*"),c=RegExp(s+s+"*$"),p=function(n,e,t){var a={},s=o((function(){return!!i[n]()||"​"!="​"[n]()})),l=a[n]=s?e(d):i[n];t&&(a[t]=l),r(r.P+r.F*s,"String",a)},d=p.trim=function(n,e){return n=String(a(n)),1&e&&(n=n.replace(l,"")),2&e&&(n=n.replace(c,"")),n};n.exports=p},aae3:function(n,e,t){var r=t("d3f4"),a=t("2d95"),o=t("2b4c")("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[o])?!!e:"RegExp"==a(n))}},ab57:function(n,e,t){(n.exports=t("2350")(!1)).push([n.i,'.aplayer{background:#fff;font-family:Arial,Helvetica,sans-serif;margin:5px;-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,.07),0 1px 5px 0 rgba(0,0,0,.1);box-shadow:0 2px 2px 0 rgba(0,0,0,.07),0 1px 5px 0 rgba(0,0,0,.1);border-radius:2px;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;line-height:normal;position:relative}.aplayer *{-webkit-box-sizing:content-box;box-sizing:content-box}.aplayer svg{width:100%;height:100%}.aplayer svg circle,.aplayer svg path{fill:#fff}.aplayer.aplayer-withlist .aplayer-info{border-bottom:1px solid #e9e9e9}.aplayer.aplayer-withlist .aplayer-list{display:block;width:100%}.aplayer.aplayer-withlist .aplayer-icon-order,.aplayer.aplayer-withlist .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu{display:inline}.aplayer.aplayer-withlrc .aplayer-pic{height:90px;width:90px}.aplayer.aplayer-withlrc .aplayer-info{margin-left:90px;height:90px;padding:10px 7px 0 7px}.aplayer.aplayer-withlrc .aplayer-lrc{display:block}.aplayer.aplayer-narrow{width:66px}.aplayer.aplayer-narrow .aplayer-info,.aplayer.aplayer-narrow .aplayer-list{display:none}.aplayer.aplayer-narrow .aplayer-body,.aplayer.aplayer-narrow .aplayer-pic{height:66px;width:66px}.aplayer.aplayer-fixed{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;overflow:visible;max-width:400px;-webkit-box-shadow:none;box-shadow:none}.aplayer.aplayer-fixed .aplayer-list{margin-bottom:65px;border:1px solid #eee;border-bottom:none;-webkit-box-sizing:border-box;box-sizing:border-box}.aplayer.aplayer-fixed .aplayer-body{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;background:#fff;padding-right:18px;-webkit-transition:width .3s ease;transition:width .3s ease;max-width:400px;width:calc(100% - 18px)}.aplayer.aplayer-fixed .aplayer-lrc{display:block;position:fixed;bottom:10px;left:0;right:0;margin:0;z-index:98;pointer-events:none;text-shadow:-1px -1px 0 #fff}.aplayer.aplayer-fixed .aplayer-lrc:after,.aplayer.aplayer-fixed .aplayer-lrc:before{display:none}.aplayer.aplayer-fixed .aplayer-info{-webkit-transform:scaleX(1);transform:scaleX(1);-webkit-transform-origin:0 0;transform-origin:0 0;-webkit-transition:all .3s ease;transition:all .3s ease;border-bottom:none;border-top:1px solid #e9e9e9}.aplayer.aplayer-fixed .aplayer-info .aplayer-music{width:calc(100% - 105px)}.aplayer.aplayer-fixed .aplayer-miniswitcher{display:block}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-info{display:block;-webkit-transform:scaleX(0);transform:scaleX(0)}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{width:66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-miniswitcher .aplayer-icon{-webkit-transform:rotateY(0);transform:rotateY(0)}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-lrc,.aplayer.aplayer-fixed .aplayer-icon-play{display:inline-block}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-menu,.aplayer.aplayer-fixed .aplayer-icon-play{position:absolute;bottom:27px;width:20px;height:20px}.aplayer.aplayer-fixed .aplayer-icon-back{right:75px}.aplayer.aplayer-fixed .aplayer-icon-play{right:50px}.aplayer.aplayer-fixed .aplayer-icon-forward{right:25px}.aplayer.aplayer-fixed .aplayer-icon-menu{right:0}.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order,.aplayer.aplayer-mobile .aplayer-icon-volume-down,.aplayer.aplayer-mobile .aplayer-icon-volume-up{display:none}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-loading-icon{display:block}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-body{position:relative}.aplayer .aplayer-icon{width:15px;height:15px;border:none;background-color:transparent;outline:none;cursor:pointer;opacity:.8;vertical-align:middle;padding:0;font-size:12px;margin:0;display:inline-block}.aplayer .aplayer-icon path{-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.aplayer .aplayer-icon-back,.aplayer .aplayer-icon-forward,.aplayer .aplayer-icon-lrc,.aplayer .aplayer-icon-order,.aplayer .aplayer-icon-play{display:none}.aplayer .aplayer-icon-lrc-inactivity svg{opacity:.4}.aplayer .aplayer-icon-forward{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.aplayer .aplayer-lrc-content{display:none}.aplayer .aplayer-pic{position:relative;float:left;height:66px;width:66px;background-size:cover;background-position:50%;-webkit-transition:all .3s ease;transition:all .3s ease;cursor:pointer}.aplayer .aplayer-pic:hover .aplayer-button{opacity:1}.aplayer .aplayer-pic .aplayer-button{position:absolute;border-radius:50%;opacity:.8;text-shadow:0 1px 1px rgba(0,0,0,.2);-webkit-box-shadow:0 1px 1px rgba(0,0,0,.2);box-shadow:0 1px 1px rgba(0,0,0,.2);background:rgba(0,0,0,.2);-webkit-transition:all .1s ease;transition:all .1s ease}.aplayer .aplayer-pic .aplayer-button path{fill:#fff}.aplayer .aplayer-pic .aplayer-hide{display:none}.aplayer .aplayer-pic .aplayer-play{width:26px;height:26px;border:2px solid #fff;bottom:50%;right:50%;margin:0 -15px -15px 0}.aplayer .aplayer-pic .aplayer-play svg{position:absolute;top:3px;left:4px;height:20px;width:20px}.aplayer .aplayer-pic .aplayer-pause{width:16px;height:16px;border:2px solid #fff;bottom:4px;right:4px}.aplayer .aplayer-pic .aplayer-pause svg{position:absolute;top:2px;left:2px;height:12px;width:12px}.aplayer .aplayer-info{margin-left:66px;padding:14px 7px 0 10px;height:66px;-webkit-box-sizing:border-box;box-sizing:border-box}.aplayer .aplayer-info .aplayer-music{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 0 13px 5px;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default;padding-bottom:2px;height:20px}.aplayer .aplayer-info .aplayer-music .aplayer-title{font-size:14px}.aplayer .aplayer-info .aplayer-music .aplayer-author{font-size:12px;color:#666}.aplayer .aplayer-info .aplayer-controller{position:relative;display:-webkit-box;display:-ms-flexbox;display:flex}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap{margin:0 0 0 5px;padding:4px 0;cursor:pointer!important;-webkit-box-flex:1;-ms-flex:1;flex:1}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap:hover .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar{position:relative;height:2px;width:100%;background:#cdcdcd}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-loaded{position:absolute;left:0;top:0;bottom:0;background:#aaa;height:2px;-webkit-transition:all .5s ease;transition:all .5s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played{position:absolute;left:0;top:0;bottom:0;height:2px;-webkit-transition:background-color .3s ease;transition:background-color .3s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{position:absolute;top:0;right:5px;margin-top:-4px;margin-right:-10px;height:10px;width:10px;border-radius:50%;cursor:pointer;-webkit-transition:all .3s ease-in-out;transition:all .3s ease-in-out;-webkit-transform:scale(0);transform:scale(0)}.aplayer .aplayer-info .aplayer-controller .aplayer-time{position:relative;right:0;bottom:4px;height:17px;color:#999;font-size:11px;padding-left:7px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-time-inner{vertical-align:middle}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon{cursor:pointer;-webkit-transition:all .2s ease;transition:all .2s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#666}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-loop{margin-right:2px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon:hover path{fill:#000}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-mode{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap{position:relative;display:inline-block;margin-left:3px;cursor:pointer!important}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap:hover .aplayer-volume-bar-wrap{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap{position:absolute;bottom:15px;right:-3px;width:25px;height:0;z-index:99;overflow:hidden;-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap.aplayer-volume-bar-wrap-active{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar{position:absolute;bottom:0;right:10px;width:5px;height:35px;background:#aaa;border-radius:2.5px;overflow:hidden}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar .aplayer-volume{position:absolute;bottom:0;right:0;width:5px;-webkit-transition:all .1s ease;transition:all .1s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon svg{position:absolute;-webkit-animation:rotate 1s linear infinite;animation:rotate 1s linear infinite}.aplayer .aplayer-lrc{display:none;position:relative;height:30px;text-align:center;overflow:hidden;margin:-10px 0 7px}.aplayer .aplayer-lrc:before{top:0;height:10%;background:-webkit-gradient(linear,left top,left bottom,from(#fff),to(hsla(0,0%,100%,0)));background:linear-gradient(180deg,#fff 0,hsla(0,0%,100%,0));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr="#ffffff",endColorstr="#00ffffff",GradientType=0)}.aplayer .aplayer-lrc:after,.aplayer .aplayer-lrc:before{position:absolute;z-index:1;display:block;overflow:hidden;width:100%;content:" "}.aplayer .aplayer-lrc:after{bottom:0;height:33%;background:-webkit-gradient(linear,left top,left bottom,from(hsla(0,0%,100%,0)),to(hsla(0,0%,100%,.8)));background:linear-gradient(180deg,hsla(0,0%,100%,0) 0,hsla(0,0%,100%,.8));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr="#00ffffff",endColorstr="#ccffffff",GradientType=0)}.aplayer .aplayer-lrc p{font-size:12px;color:#666;line-height:16px!important;height:16px!important;padding:0!important;margin:0!important;-webkit-transition-property:font-size,color,opacity;transition-property:font-size,color,opacity;-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out;-webkit-transition-duration:.5s;transition-duration:.5s;opacity:.4;overflow:hidden}.aplayer .aplayer-lrc p.aplayer-lrc-current{opacity:1;overflow:visible;height:auto!important;min-height:16px}.aplayer .aplayer-lrc.aplayer-lrc-hide{display:none}.aplayer .aplayer-lrc .aplayer-lrc-contents{width:100%;-webkit-transition:all .5s ease-out;transition:all .5s ease-out;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default}.aplayer .aplayer-list{overflow:auto;-webkit-transition:all .5s ease;transition:all .5s ease;will-change:height;display:none;overflow:hidden;list-style-type:none;margin:0;padding:0;overflow-y:auto}.aplayer .aplayer-list::-webkit-scrollbar{width:5px}.aplayer .aplayer-list::-webkit-scrollbar-thumb{border-radius:3px;background-color:#eee}.aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#ccc}.aplayer .aplayer-list li{position:relative;height:32px;line-height:32px;padding:0 15px;font-size:12px;border-top:1px solid #e9e9e9;cursor:pointer;-webkit-transition:all .2s ease;transition:all .2s ease;overflow:hidden;margin:0}.aplayer .aplayer-list li:first-child{border-top:none}.aplayer .aplayer-list li:hover{background:#efefef}.aplayer .aplayer-list li.aplayer-list-light{background:#e9e9e9}.aplayer .aplayer-list li.aplayer-list-light .aplayer-list-cur{display:inline-block}.aplayer .aplayer-list li .aplayer-list-cur{display:none;width:3px;height:22px;position:absolute;left:0;top:5px;-webkit-transition:background-color .3s ease;transition:background-color .3s ease;cursor:pointer}.aplayer .aplayer-list li .aplayer-list-index{color:#666;margin-right:12px;cursor:pointer}.aplayer .aplayer-list li .aplayer-list-author{color:#666;float:right;cursor:pointer}.aplayer .aplayer-notice{opacity:0;position:absolute;z-index:1;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);font-size:12px;border-radius:4px;padding:5px 10px;-webkit-transition:all .3s ease-in-out;transition:all .3s ease-in-out;overflow:hidden;color:#fff;pointer-events:none;background-color:#f4f4f5;color:#909399}.aplayer .aplayer-miniswitcher{display:none;position:absolute;top:0;right:0;bottom:0;height:100%;background:#e6e6e6;width:18px;border-radius:0 2px 2px 0}.aplayer .aplayer-miniswitcher .aplayer-icon{height:100%;width:100%;-webkit-transform:rotateY(180deg);transform:rotateY(180deg);-webkit-transition:all .3s ease;transition:all .3s ease}.aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#666}.aplayer .aplayer-miniswitcher .aplayer-icon:hover path{fill:#000}@-webkit-keyframes aplayer-roll{0%{left:0}to{left:-100%}}@keyframes aplayer-roll{0%{left:0}to{left:-100%}}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}',""])},ac6a:function(n,e,t){for(var r=t("cadf"),a=t("0d58"),o=t("2aba"),i=t("7726"),s=t("32e9"),l=t("84f2"),c=t("2b4c"),p=c("iterator"),d=c("toStringTag"),u=l.Array,m={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},g=a(m),f=0;f<g.length;f++){var h,b=g[f],v=m[b],y=i[b],k=y&&y.prototype;if(k&&(k[p]||s(k,p,u),k[d]||s(k,d,b),l[b]=u,v))for(h in r)k[h]||o(k,h,r[h],!0)}},adec:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 28 32"}},[t("path",{attrs:{d:"M13.728 6.272v19.456q0 .448-.352.8t-.8.32-.8-.32l-5.952-5.952H1.152q-.48 0-.8-.352t-.352-.8v-6.848q0-.48.352-.8t.8-.352h4.672l5.952-5.952q.32-.32.8-.32t.8.32.352.8z"}})])}}},b349:function(n,e,t){"use strict";var r,a=this&&this.__extends||(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)e.hasOwnProperty(t)&&(n[t]=e[t])},function(n,e){function t(){this.constructor=n}r(n,e),n.prototype=null===e?Object.create(e):(t.prototype=e.prototype,new t)}),o=this&&this.__assign||Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var a in e=arguments[t])Object.prototype.hasOwnProperty.call(e,a)&&(n[a]=e[a]);return n},i=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0});var s=i(t("8bbf")),l=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e._tsxattrs=void 0,e.$scopedSlots=void 0,e}return a(e,n),e}(s.default);e.Component=l,e.createComponent=function(n){return s.default.extend(n)};var c={convert:function(n){return n},extendFrom:function(n){return n}};function p(n,e){return{create:function(t){var r=t.mixins?t.mixins.concat(e):e;return n.extend(o({},t,{mixins:r}))},mixin:function(t){return p(n,e.concat([t]))}}}e.ofType=function(){return c},e.withNativeOn=function(n){return n},e.withHtmlAttrs=function(n){return n},e.withUnknownProps=function(n){return n},e.componentFactory={create:function(n){return s.default.extend(n)},extendFrom:function(n){return p(n,[])},mixin:function(n){return p(s.default,[n])}},e.componentFactoryOf=function(){return e.componentFactory},e.component=e.componentFactory.create,e.extendFrom=e.componentFactory.extendFrom},bcaa:function(n,e,t){var r=t("cb7c"),a=t("d3f4"),o=t("a5b8");n.exports=function(n,e){if(r(n),a(e)&&e.constructor===n)return e;var t=o.f(n);return(0,t.resolve)(e),t.promise}},bdba:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 28 32"}},[t("path",{attrs:{d:"M13.728 6.272v19.456q0 .448-.352.8t-.8.32-.8-.32l-5.952-5.952H1.152q-.48 0-.8-.352t-.352-.8v-6.848q0-.48.352-.8t.8-.352h4.672l5.952-5.952q.32-.32.8-.32t.8.32.352.8zM20.576 16q0 1.344-.768 2.528t-2.016 1.664q-.16.096-.448.096-.448 0-.8-.32t-.32-.832q0-.384.192-.64t.544-.448.608-.384.512-.64.192-1.024-.192-1.024-.512-.64-.608-.384-.544-.448-.192-.64q0-.48.32-.832t.8-.32q.288 0 .448.096 1.248.48 2.016 1.664T20.576 16z"}})])}}},be13:function(n,e){n.exports=function(n){if(null==n)throw TypeError("Can't call method on  "+n);return n}},bf5c:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32"}},[t("path",{attrs:{d:"M22 16L11.895 5.4 10 7.387 18.211 16 10 24.612l1.895 1.988 8.211-8.613z"}})])}}},c366:function(n,e,t){var r=t("6821"),a=t("9def"),o=t("77f1");n.exports=function(n){return function(e,t,i){var s,l=r(e),c=a(l.length),p=o(i,c);if(n&&t!=t){for(;c>p;)if((s=l[p++])!=s)return!0}else for(;c>p;p++)if((n||p in l)&&l[p]===t)return n||p||0;return!n&&-1}}},c3ab:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 29 32"}},[t("path",{attrs:{d:"M2.667 7.027l1.707-1.693 22.293 22.293-1.693 1.707-4-4H9.334v4l-5.333-5.333 5.333-5.333v4h8.973l-8.973-8.973v.973H6.667v-3.64l-4-4zm20 10.306h2.667v5.573l-2.667-2.667v-2.907zm0-10.666v-4L28 8l-5.333 5.333v-4H11.76L9.093 6.666h13.573z"}})])}}},c5f6:function(n,e,t){"use strict";var r=t("7726"),a=t("69a8"),o=t("2d95"),i=t("5dbc"),s=t("6a99"),l=t("79e5"),c=t("9093").f,p=t("11e9").f,d=t("86cc").f,u=t("aa77").trim,m=r.Number,g=m,f=m.prototype,h="Number"==o(t("2aeb")(f)),b="trim"in String.prototype,v=function(n){var e=s(n,!1);if("string"==typeof e&&e.length>2){var t,r,a,o=(e=b?e.trim():u(e,3)).charCodeAt(0);if(43===o||45===o){if(88===(t=e.charCodeAt(2))||120===t)return NaN}else if(48===o){switch(e.charCodeAt(1)){case 66:case 98:r=2,a=49;break;case 79:case 111:r=8,a=55;break;default:return+e}for(var i,l=e.slice(2),c=0,p=l.length;c<p;c++)if((i=l.charCodeAt(c))<48||i>a)return NaN;return parseInt(l,r)}}return+e};if(!m(" 0o1")||!m("0b1")||m("+0x1")){m=function(n){var e=arguments.length<1?0:n,t=this;return t instanceof m&&(h?l((function(){f.valueOf.call(t)})):"Number"!=o(t))?i(new g(v(e)),t,m):v(e)};for(var y,k=t("9e1e")?c(g):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),x=0;k.length>x;x++)a(g,y=k[x])&&!a(m,y)&&d(m,y,p(g,y));m.prototype=f,f.constructor=m,t("2aba")(r,"Number",m)}},c69a:function(n,e,t){n.exports=!t("9e1e")&&!t("79e5")((function(){return 7!=Object.defineProperty(t("230e")("div"),"a",{get:function(){return 7}}).a}))},ca5a:function(n,e){var t=0,r=Math.random();n.exports=function(n){return"Symbol(".concat(void 0===n?"":n,")_",(++t+r).toString(36))}},cadf:function(n,e,t){"use strict";var r=t("9c6c"),a=t("d53b"),o=t("84f2"),i=t("6821");n.exports=t("01f9")(Array,"Array",(function(n,e){this._t=i(n),this._i=0,this._k=e}),(function(){var n=this._t,e=this._k,t=this._i++;return!n||t>=n.length?(this._t=void 0,a(1)):a(0,"keys"==e?t:"values"==e?n[t]:[t,n[t]])}),"values"),o.Arguments=o.Array,r("keys"),r("values"),r("entries")},cb7c:function(n,e,t){var r=t("d3f4");n.exports=function(n){if(!r(n))throw TypeError(n+" is not an object!");return n}},cd1c:function(n,e,t){var r=t("e853");n.exports=function(n,e){return new(r(n))(e)}},ce10:function(n,e,t){var r=t("69a8"),a=t("6821"),o=t("c366")(!1),i=t("613b")("IE_PROTO");n.exports=function(n,e){var t,s=a(n),l=0,c=[];for(t in s)t!=i&&r(s,t)&&c.push(t);for(;e.length>l;)r(s,t=e[l++])&&(~o(c,t)||c.push(t));return c}},d263:function(n,e,t){"use strict";t("386b")("fixed",(function(n){return function(){return n(this,"tt","","")}}))},d2c8:function(n,e,t){var r=t("aae3"),a=t("be13");n.exports=function(n,e,t){if(r(e))throw TypeError("String#"+t+" doesn't accept regex!");return String(a(n))}},d3f4:function(n,e){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},d53b:function(n,e){n.exports=function(n,e){return{value:e,done:!!n}}},d8e8:function(n,e){n.exports=function(n){if("function"!=typeof n)throw TypeError(n+" is not a function!");return n}},daf8:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 17 32"}},[t("path",{attrs:{d:"M14.08 4.8q2.88 0 2.88 2.048v18.24q0 2.112-2.88 2.112t-2.88-2.112V6.848q0-2.048 2.88-2.048zm-11.2 0q2.88 0 2.88 2.048v18.24q0 2.112-2.88 2.112T0 25.088V6.848Q0 4.8 2.88 4.8z"}})])}}},dcbc:function(n,e,t){var r=t("2aba");n.exports=function(n,e,t){for(var a in e)r(n,a,e[a],t);return n}},e11e:function(n,e){n.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},e853:function(n,e,t){var r=t("d3f4"),a=t("1169"),o=t("2b4c")("species");n.exports=function(n){var e;return a(n)&&("function"!=typeof(e=n.constructor)||e!==Array&&!a(e.prototype)||(e=void 0),r(e)&&null===(e=e[o])&&(e=void 0)),void 0===e?Array:e}},ebd6:function(n,e,t){var r=t("cb7c"),a=t("d8e8"),o=t("2b4c")("species");n.exports=function(n,e){var t,i=r(n).constructor;return void 0===i||null==(t=r(i)[o])?e:a(t)}},f559:function(n,e,t){"use strict";var r=t("5ca1"),a=t("9def"),o=t("d2c8"),i="".startsWith;r(r.P+r.F*t("5147")("startsWith"),"String",{startsWith:function(n){var e=o(this,n,"startsWith"),t=a(Math.min(arguments.length>1?arguments[1]:void 0,e.length)),r=String(n);return i?i.call(e,r,t):e.slice(t,t+r.length)===r}})},f576:function(n,e,t){"use strict";var r=t("5ca1"),a=t("2e08"),o=t("a25f");r(r.P+r.F*/Version\/10\.\d+(\.\d+)? Safari\//.test(o),"String",{padStart:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0,!0)}})},f605:function(n,e){n.exports=function(n,e,t,r){if(!(n instanceof e)||void 0!==r&&r in n)throw TypeError(t+": incorrect invocation!");return n}},f751:function(n,e,t){var r=t("5ca1");r(r.S+r.F,"Object",{assign:t("7333")})},f866:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 29 32"}},[t("path",{attrs:{d:"M9.333 9.333h13.333v4L27.999 8l-5.333-5.333v4h-16v8h2.667V9.334zm13.334 13.334H9.334v-4L4.001 24l5.333 5.333v-4h16v-8h-2.667v5.333z"}})])}}},fab2:function(n,e,t){var r=t("7726").document;n.exports=r&&r.documentElement},fb15:function(n,e,t){"use strict";var r;(t.r(e),"undefined"!=typeof window)&&((r=window.document.currentScript)&&(r=r.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))&&(t.p=r[1]));t("f751");function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{},r=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(t).filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable})))),r.forEach((function(e){a(n,e,t[e])}))}return n}t("c5f6");function i(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},o=Object.keys(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}function s(n){return function(n){if(Array.isArray(n)){for(var e=0,t=new Array(n.length);e<n.length;e++)t[e]=n[e];return t}}(n)||function(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}t("ac6a"),t("551c"),t("6762"),t("2fdb"),t("7f7f"),t("7514"),t("6b54");function l(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=[],r=!0,a=!1,o=void 0;try{for(var i,s=n[Symbol.iterator]();!(r=(i=s.next()).done)&&(t.push(i.value),!e||t.length!==e);r=!0);}catch(n){a=!0,o=n}finally{try{r||null==s.return||s.return()}finally{if(a)throw o}}return t}(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}t("20d6"),t("96cf");function c(n,e,t,r,a,o,i){try{var s=n[o](i),l=s.value}catch(n){return void t(n)}s.done?e(l):Promise.resolve(l).then(r,a)}function p(n){return function(){var e=this,t=arguments;return new Promise((function(r,a){var o=n.apply(e,t);function i(n){c(o,r,a,i,s,"next",n)}function s(n){c(o,r,a,i,s,"throw",n)}i(void 0)}))}}t("d263");function d(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function u(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function m(n,e,t){return e&&u(n.prototype,e),t&&u(n,t),n}function g(n){return(g="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function f(n){return(f="function"==typeof Symbol&&"symbol"===g(Symbol.iterator)?function(n){return g(n)}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":g(n)})(n)}function h(n,e){return!e||"object"!==f(e)&&"function"!=typeof e?function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n):e}function b(n){return(b=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function v(n,e){return(v=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}function y(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&v(n,e)}var k=t("48d3"),x=t("65d9"),w=t.n(x),S=t("8bbf"),E=t.n(S);function I(n){return Object(x.createDecorator)((function(e,t){void 0===e.inject&&(e.inject={}),Array.isArray(e.inject)||(e.inject[t]=n||t)}))}function _(n){return Object(x.createDecorator)((function(e,t){var r=e.provide;if("function"!=typeof r||!r.managed){var a=e.provide;(r=e.provide=function(){var n=Object.create(("function"==typeof a?a.call(this):a)||null);for(var e in r.managed)n[r.managed[e]]=this[e];return n}).managed={}}r.managed[t]=n||t}))}function T(n){return void 0===n&&(n={}),Object(x.createDecorator)((function(e,t){(e.props||(e.props={}))[t]=n}))}function j(n,e){void 0===e&&(e={});var t=e.deep,r=void 0!==t&&t,a=e.immediate,o=void 0!==a&&a;return Object(x.createDecorator)((function(e,t){"object"!=typeof e.watch&&(e.watch=Object.create(null)),e.watch[n]={handler:t,deep:r,immediate:o}}))}var C=t("4d26"),A=t.n(C);t("cadf"),t("456d");function z(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3e3;return new Promise((function(t,r){var a=(new Date).getTime(),o=setInterval((function(){n()?(t(),clearInterval(o)):e>0&&(new Date).getTime()-a>e&&(r(),clearInterval(o))}),100)}))}var O,L=["abort","canplay","canplaythrough","durationchange","emptied","ended","error","loadeddata","loadedmetadata","loadstart","pause","play","playing","progress","ratechange","readystatechange","seeked","seeking","stalled","suspend","timeupdate","volumechange","waiting"],P=function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i},R=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)};!function(n){n[n.HAVE_NOTHING=0]="HAVE_NOTHING",n[n.HAVE_METADATA=1]="HAVE_METADATA",n[n.HAVE_CURRENT_DATA=2]="HAVE_CURRENT_DATA",n[n.HAVE_FUTURE_DATA=3]="HAVE_FUTURE_DATA",n[n.HAVE_ENOUGH_DATA=4]="HAVE_ENOUGH_DATA"}(O||(O={}));var M=function(n){function e(){var n;return d(this,e),(n=h(this,b(e).call(this))).audio=new Audio,n.audioTracks=n.audio.audioTracks,n.autoplay=n.audio.autoplay,n.buffered=n.audio.buffered,n.controls=n.audio.controls,n.crossOrigin=n.audio.crossOrigin,n.currentSrc=n.audio.currentSrc,n.currentTime=n.audio.currentTime,n.defaultMuted=n.audio.defaultMuted,n.defaultPlaybackRate=n.audio.defaultPlaybackRate,n.duration=n.audio.duration,n.ended=n.audio.ended,n.error=n.audio.error,n.loop=n.audio.loop,n.mediaKeys=n.audio.mediaKeys,n.muted=n.audio.muted,n.networkState=n.audio.networkState,n.paused=n.audio.paused,n.playbackRate=n.audio.playbackRate,n.played=n.audio.played,n.preload=n.audio.preload,n.readyState=n.audio.readyState,n.seekable=n.audio.seekable,n.seeking=n.audio.seeking,n.src=n.audio.src,n.textTracks=n.audio.textTracks,n.volume=n.audio.volume,L.forEach((function(e){n.audio.addEventListener(e,(function(e){n.sync()}))})),n}return y(e,n),m(e,[{key:"sync",value:function(){var n=this;Object.keys(this.$data).forEach((function(e){"audio"!==e&&(n[e]=n.audio[e])}))}},{key:"loaded",value:function(){var n=this;return z((function(){return n.readyState>=O.HAVE_FUTURE_DATA}),0)}},{key:"srcLoaded",value:function(){var n=this;return z((function(){return n.src}),0)}},{key:"render",value:function(){return null}}]),e}(E.a),B=M=P([w.a,R("design:paramtypes",[])],M),D=function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i},N=function(n){function e(){var n;return d(this,e),(n=h(this,b(e).apply(this,arguments))).key="aplayer-setting",n.store=n.get(n.key),n}return y(e,n),m(e,[{key:"get",value:function(n){return JSON.parse(localStorage.getItem(n)||"[]")}},{key:"set",value:function(n){this.store=n,localStorage.setItem(this.key,JSON.stringify(n))}},{key:"render",value:function(){return null}}]),e}(E.a),q=N=D([w.a],N),F=function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i},U=function(n){function e(){return d(this,e),h(this,b(e).apply(this,arguments))}return y(e,n),m(e,[{key:"isMobile",get:function(){var n=this.$ssrContext?this.$ssrContext.userAgent:window.navigator.userAgent;return/mobile/i.test(n)}}]),e}(E.a),H=U=F([w.a],U),$=function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i},V=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},G=function(n){function e(){return d(this,e),h(this,b(e).apply(this,arguments))}return y(e,n),m(e,[{key:"handleClick",value:function(n){this.$emit("click",n)}},{key:"render",value:function(){var n=arguments[0];return n("div",{class:"aplayer-pic",style:this.style,on:{click:this.handleClick}},[this.$slots.default])}},{key:"style",get:function(){var n=this.aplayer,e=n.options,t=n.currentTheme,r=n.currentMusic.cover||e.defaultCover;return{backgroundImage:r&&'url("'.concat(r,'")'),backgroundColor:t}}}]),e}(k.Component);$([I(),V("design:type",Object)],G.prototype,"aplayer",void 0);var W=G=$([w.a],G),K=function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i},Q=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},X=function(n){return t("52f0")("./".concat(n,".svg")).default},Y=function(n){function e(){return d(this,e),h(this,b(e).apply(this,arguments))}return y(e,n),m(e,[{key:"render",value:function(){var n=arguments[0],e=X(this.type);return n(e)}}]),e}(k.Component);K([T({type:String,required:!0}),Q("design:type",String)],Y.prototype,"type",void 0);var J=Y=K([w.a],Y);t("55dd"),t("28a5"),t("a481"),t("4917");var Z=function(){function n(){d(this,n),this.xhr=new XMLHttpRequest}return m(n,[{key:"download",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return new Promise((function(r,a){e.xhr.open("get",n),e.xhr.responseType=t,e.xhr.onload=function(){var n=e.xhr.status;(n>=200&&n<300||304===n)&&r(e.xhr.response)},e.xhr.onabort=a,e.xhr.onerror=a,e.xhr.ontimeout=a,e.xhr.send()}))}}]),n}(),nn=function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i},en=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},tn=function(n){function e(){var n;return d(this,e),(n=h(this,b(e).apply(this,arguments))).lrc="",n.xhr=new Z,n.isLoading=!1,n}var t;return y(e,n),m(e,[{key:"getLyricFromCurrentMusic",value:function(){var n=this;return new Promise((function(e,t){var r=n.aplayer,a=r.lrcType,o=r.currentMusic;switch(a){case 0:e("");break;case 1:e(o.lrc);break;case 3:e(o.lrc?n.xhr.download(o.lrc):"");break;default:t(new Error("Illegal lrcType: ".concat(a)))}}))}},{key:"parseLRC",value:function(n){var e=/\[(\d+):(\d+)[.|:](\d+)\](.+)/,t=/\[(\d+):(\d+)[.|:](\d+)\]/g,r=/\[(\d+):(\d+)]()(.+)/,a=/\[(\d+):(\d+)]/g,o=this.lrc.match(/\[offset:\s*(-?\d+)\]/),i=o?Number(o[1]):0,s=[];return n.replace(/\\n/g,"\n").split("\n").forEach((function(n){return function n(o){var l=o.match(e)||o.match(r);if(l&&5===l.length){var c=60*(Number(l[1])||0)*1e3+1e3*(Number(l[2])||0)+(Number(l[3])||0)+i,p=l[4].replace(t,"").replace(a,"");p&&(s.push({time:c,text:p}),n(l[4]))}}(n)})),s.length>0&&s.sort((function(n,e){return n.time-e.time})),s}},{key:"handleChange",value:(t=p(regeneratorRuntime.mark((function n(){return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.prev=0,this.isLoading=!0,this.lrc="",n.next=5,this.getLyricFromCurrentMusic();case 5:this.lrc=n.sent;case 6:return n.prev=6,this.isLoading=!1,n.finish(6);case 9:case"end":return n.stop()}}),n,this,[[0,,6,9]])}))),function(){return t.apply(this,arguments)})},{key:"render",value:function(){var n=arguments[0],e=this.visible,t=this.style,r=this.parsed,a=this.current,o=this.noLyric;return n("div",{class:A()({"aplayer-lrc":!0,"aplayer-lrc-hide":!e})},[n("div",{class:"aplayer-lrc-contents",style:t},[r.length>0?r.map((function(e,t){return n("p",{key:e.time,class:A()({"aplayer-lrc-current":a.time===e.time})},[e.text])})):n("p",{class:"aplayer-lrc-current"},[o])])])}},{key:"noLyric",get:function(){return this.aplayer.currentMusic.id?this.isLoading?"(*ゝω・) 少女祈祷中..":this.lrc?"(・∀・*) 抱歉，该歌词格式不支持":"(,,•́ . •̀,,) 抱歉，当前歌曲暂无歌词":"(ಗ ‸ ಗ ) 未加载音频"}},{key:"parsed",get:function(){return this.parseLRC(this.lrc)}},{key:"current",get:function(){var n=this.aplayer,e=n.media,t=n.currentPlayed,r=this.parsed.filter((function(n){return n.time<t*e.duration*1e3}));return r&&r.length>0?r[r.length-1]:this.parsed[0]}},{key:"transitionDuration",get:function(){return this.parsed.length>1?500:0}},{key:"translateY",get:function(){var n=this.current,e=this.parsed;if(e.length<=0)return 0;var t=e.indexOf(n);return-1*(t===e.length-1?16*(t-1):16*t)}},{key:"style",get:function(){return{transitionDuration:"".concat(this.transitionDuration,"ms"),transform:"translate3d(0, ".concat(this.translateY,"px, 0)")}}}]),e}(k.Component);nn([T({type:Boolean,required:!1,default:!0}),en("design:type",Boolean)],tn.prototype,"visible",void 0),nn([I(),en("design:type",Object)],tn.prototype,"aplayer",void 0),nn([j("aplayer.lrcType",{immediate:!0}),j("aplayer.currentMusic.lrc",{immediate:!0}),en("design:type",Function),en("design:paramtypes",[]),en("design:returntype",Promise)],tn.prototype,"handleChange",null);var rn=tn=nn([w.a],tn),an=function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i},on=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},sn=function(n){function e(){return d(this,e),h(this,b(e).apply(this,arguments))}return y(e,n),m(e,[{key:"render",value:function(){var n=arguments[0],e=this.music,t=this.aplayer.fixed;return n("div",{class:"aplayer-info"},[n("div",{class:"aplayer-music"},[n("span",{class:"aplayer-title"},[e.name]),n("span",{class:"aplayer-author"},[e.artist])]),t?null:n(rn),this.$slots.default])}},{key:"music",get:function(){var n=this.aplayer.currentMusic;return{name:n.name,artist:n.artist?" - ".concat(n.artist):""}}}]),e}(k.Component);an([I(),on("design:type",Object)],sn.prototype,"aplayer",void 0);var ln=sn=an([w.a],sn),cn=(t("f559"),t("f576"),function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i}),pn=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},dn=function(n){function e(){var n;return d(this,e),(n=h(this,b(e).apply(this,arguments))).isDragMove=!1,n}return y(e,n),m(e,[{key:"thumbMove",value:function(n){this.isDragMove=!0,this.$emit("panMove",n)}},{key:"thumbUp",value:function(n){document.removeEventListener(this.dragMove,this.thumbMove),document.removeEventListener(this.dragEnd,this.thumbUp),this.isDragMove=!1,this.$emit("panEnd",n)}},{key:"mounted",value:function(){var n=this;this.$el.addEventListener(this.dragStart,(function(e){n.$emit("panStart",e),document.addEventListener(n.dragMove,n.thumbMove),document.addEventListener(n.dragEnd,n.thumbUp)}))}},{key:"render",value:function(){var n=arguments[0];return n("div",{class:this.classNames,style:{touchAction:"none",userSelect:"none",webkitUserDrag:"none",webkitTapHighlightColor:"rgba(0, 0, 0, 0)"}},[this.$slots.default])}},{key:"classNames",get:function(){return a({},this.panMoveClass,this.isDragMove)}},{key:"dragStart",get:function(){return this.isMobile?"touchstart":"mousedown"}},{key:"dragMove",get:function(){return this.isMobile?"touchmove":"mousemove"}},{key:"dragEnd",get:function(){return this.isMobile?"touchend":"mouseup"}}]),e}(k.Component);cn([T({type:String,required:!1}),pn("design:type",String)],dn.prototype,"panMoveClass",void 0);var un=dn=cn([w()({mixins:[H]})],dn),mn=function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i},gn=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},fn=function(n){function e(){return d(this,e),h(this,b(e).apply(this,arguments))}return y(e,n),m(e,[{key:"handleClick",value:function(){this.$emit("click")}},{key:"render",value:function(){var n=arguments[0];return n("button",{attrs:{type:"button"},class:"aplayer-icon aplayer-icon-".concat(this.type),on:{click:this.handleClick}},[n(J,{attrs:{type:this.icon}})])}}]),e}(k.Component);mn([T({type:String,required:!0}),gn("design:type",String)],fn.prototype,"type",void 0),mn([T({type:String,required:!0}),gn("design:type",String)],fn.prototype,"icon",void 0);var hn=fn=mn([w.a],fn),bn=function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i},vn=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},yn=function(n){function e(){return d(this,e),h(this,b(e).apply(this,arguments))}return y(e,n),m(e,[{key:"handleChange",value:function(n){var e=this.$refs.progressBar,t=e.getBoundingClientRect().left,r=((n.type.startsWith("touch")?n.changedTouches[0].clientX:n.clientX)-t)/e.offsetWidth;r=Math.min(r,1),r=Math.max(r,0),this.handleChangeProgress(n,r)}},{key:"render",value:function(){var n=arguments[0],e=this.aplayer,t=e.currentTheme,r=e.currentLoaded,a=e.currentPlayed;return n(un,{class:"aplayer-bar-wrap",on:{panMove:this.handleChange,panEnd:this.handleChange}},[n("div",{ref:"progressBar",class:"aplayer-bar"},[n("div",{class:"aplayer-loaded",style:{width:"".concat(100*r,"%")}}),n("div",{class:"aplayer-played",style:{width:"".concat(100*a,"%"),backgroundColor:t}},[n("span",{class:"aplayer-thumb",style:{backgroundColor:t}},[n("span",{class:"aplayer-loading-icon"},[n(J,{attrs:{type:"loading"}})])])])])])}}]),e}(k.Component);bn([I(),vn("design:type",Object)],yn.prototype,"aplayer",void 0),bn([I(),vn("design:type",Function)],yn.prototype,"handleChangeProgress",void 0);var kn=yn=bn([w.a],yn),xn=function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i},wn=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},Sn=function(n){function e(){return d(this,e),h(this,b(e).apply(this,arguments))}return y(e,n),m(e,[{key:"timeSecondsFormat",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=Math.floor(n/60)||0,t=Math.floor(n%60)||0;return"".concat(e.toString().padStart(2,"0"),":").concat(t.toString().padStart(2,"0"))}},{key:"handleToggleVolume",value:function(){var n=this.aplayer,e=n.currentVolume,t=n.currentSettings;this.handleChangeVolume(e>0?0:t.volume)}},{key:"handleClickVolumeBar",value:function(n){this.handlePanMove(n)}},{key:"handlePanMove",value:function(n){var e=this.$refs.volumeBar,t=e.getBoundingClientRect().bottom;if(!(t<=0)){var r=n.type.startsWith("touch")?n.changedTouches[0].clientY:n.clientY,a=Math.round(t-r)/e.offsetHeight;a=Math.min(a,1),a=Math.max(a,0),this.handleChangeVolume(a)}}},{key:"render",value:function(){var n=arguments[0],e=this.ptime,t=this.dtime,r=this.volumeIcon,a=this.aplayer,o=a.lrcType,i=a.currentTheme,s=a.currentVolume,l=a.currentOrder,c=a.currentLoop;return n("div",{class:"aplayer-controller"},[n(kn),n("div",{class:"aplayer-time"},[n("span",{class:"aplayer-time-inner"},[n("span",{class:"aplayer-ptime"},[e])," /"," ",n("span",{class:"aplayer-dtime"},[t])," "]),n("span",{class:"aplayer-icon aplayer-icon-back",on:{click:this.handleSkipBack}},[n(J,{attrs:{type:"skip"}})]),n("span",{class:"aplayer-icon aplayer-icon-play",on:{click:this.handleTogglePlay}},[n(J,{attrs:{type:this.playIcon}})]),n("span",{class:"aplayer-icon aplayer-icon-forward",on:{click:this.handleSkipForward}},[n(J,{attrs:{type:"skip"}})]),n("div",{class:"aplayer-volume-wrap"},[n(hn,{attrs:{type:"volume-".concat(r),icon:"volume-".concat(r)},on:{click:this.handleToggleVolume}}),n(un,{class:"aplayer-volume-bar-wrap",attrs:{panMoveClass:"aplayer-volume-bar-wrap-active"},on:{panMove:this.handlePanMove}},[n("div",{ref:"volumeBar",class:"aplayer-volume-bar",on:{click:this.handleClickVolumeBar}},[n("div",{class:"aplayer-volume",style:{height:"".concat(100*s,"%"),backgroundColor:i}})])])])," ",n(hn,{attrs:{type:"order",icon:"order-".concat(l)},on:{click:this.handleToggleOrderMode}})," ",n(hn,{attrs:{type:"loop",icon:"loop-".concat(c)},on:{click:this.handleToggleLoopMode}})," ",n(hn,{attrs:{type:"menu",icon:"menu"},on:{click:this.handleTogglePlaylist}}),0!==o?n(hn,{attrs:{type:"lrc",icon:"lrc"},on:{click:this.handleToggleLyric}}):null])])}},{key:"playIcon",get:function(){return this.aplayer.media.paused?"play":"pause"}},{key:"volumeIcon",get:function(){var n=this.aplayer.currentVolume;return n<=0?"off":n>=.95?"up":"down"}},{key:"ptime",get:function(){var n=this.aplayer,e=n.media,t=n.currentPlayed;return this.timeSecondsFormat(t*e.duration)}},{key:"dtime",get:function(){return this.timeSecondsFormat(this.aplayer.media.duration)}}]),e}(k.Component);xn([I(),wn("design:type",Object)],Sn.prototype,"aplayer",void 0),xn([I(),wn("design:type",Function)],Sn.prototype,"handleSkipBack",void 0),xn([I(),wn("design:type",Function)],Sn.prototype,"handleSkipForward",void 0),xn([I(),wn("design:type",Function)],Sn.prototype,"handleTogglePlay",void 0),xn([I(),wn("design:type",Function)],Sn.prototype,"handleToggleOrderMode",void 0),xn([I(),wn("design:type",Function)],Sn.prototype,"handleToggleLoopMode",void 0),xn([I(),wn("design:type",Function)],Sn.prototype,"handleTogglePlaylist",void 0),xn([I(),wn("design:type",Function)],Sn.prototype,"handleToggleLyric",void 0),xn([I(),wn("design:type",Function)],Sn.prototype,"handleChangeVolume",void 0);var En=Sn=xn([w.a],Sn),In=function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i},_n=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},Tn=function(n){function e(){return d(this,e),h(this,b(e).apply(this,arguments))}return y(e,n),m(e,[{key:"handleTogglePlay",value:function(){this.$emit("togglePlay")}},{key:"handleSkipBack",value:function(){this.$emit("skipBack")}},{key:"handleSkipForward",value:function(){this.$emit("skipForward")}},{key:"handleToggleOrderMode",value:function(){this.$emit("toggleOrderMode")}},{key:"handleToggleLoopMode",value:function(){this.$emit("toggleLoopMode")}},{key:"handleTogglePlaylist",value:function(){this.$emit("togglePlaylist")}},{key:"handleToggleLyric",value:function(){this.$emit("toggleLyric")}},{key:"handleChangeVolume",value:function(n){this.$emit("changeVolume",n)}},{key:"handleChangeProgress",value:function(n,e){this.$emit("changeProgress",n,e)}},{key:"handleMiniSwitcher",value:function(){this.$emit("miniSwitcher")}},{key:"render",value:function(){var n=arguments[0],e=this.playIcon,t=this.notice;return n("div",{class:"aplayer-body"},[n(W,{on:{click:this.handleTogglePlay}},[n("div",{class:"aplayer-button aplayer-".concat(e)},[n(J,{attrs:{type:e}})])]),n(ln,[n(En,{on:{skipBack:this.handleSkipBack,skipForward:this.handleSkipForward,togglePlay:this.handleTogglePlay,toggleOrderMode:this.handleToggleOrderMode,toggleLoopMode:this.handleToggleLoopMode,togglePlaylist:this.handleTogglePlaylist,toggleLyric:this.handleToggleLyric,changeVolume:this.handleChangeVolume,changeProgress:this.handleChangeProgress}})]),n("div",{class:"aplayer-notice",style:{opacity:t.opacity}},[t.text]),n("div",{class:"aplayer-miniswitcher",on:{click:this.handleMiniSwitcher}},[n(hn,{attrs:{type:"miniswitcher",icon:"right"}})])])}},{key:"playIcon",get:function(){return this.aplayer.media.paused?"play":"pause"}}]),e}(k.Component);In([T({type:Object,required:!0}),_n("design:type",Object)],Tn.prototype,"notice",void 0),In([I(),_n("design:type",Object)],Tn.prototype,"aplayer",void 0),In([_(),_n("design:type",Function),_n("design:paramtypes",[]),_n("design:returntype",void 0)],Tn.prototype,"handleTogglePlay",null),In([_(),_n("design:type",Function),_n("design:paramtypes",[]),_n("design:returntype",void 0)],Tn.prototype,"handleSkipBack",null),In([_(),_n("design:type",Function),_n("design:paramtypes",[]),_n("design:returntype",void 0)],Tn.prototype,"handleSkipForward",null),In([_(),_n("design:type",Function),_n("design:paramtypes",[]),_n("design:returntype",void 0)],Tn.prototype,"handleToggleOrderMode",null),In([_(),_n("design:type",Function),_n("design:paramtypes",[]),_n("design:returntype",void 0)],Tn.prototype,"handleToggleLoopMode",null),In([_(),_n("design:type",Function),_n("design:paramtypes",[]),_n("design:returntype",void 0)],Tn.prototype,"handleTogglePlaylist",null),In([_(),_n("design:type",Function),_n("design:paramtypes",[]),_n("design:returntype",void 0)],Tn.prototype,"handleToggleLyric",null),In([_(),_n("design:type",Function),_n("design:paramtypes",[Number]),_n("design:returntype",void 0)],Tn.prototype,"handleChangeVolume",null),In([_(),_n("design:type",Function),_n("design:paramtypes",[Object,Number]),_n("design:returntype",void 0)],Tn.prototype,"handleChangeProgress",null);var jn,Cn,An=Tn=In([w.a],Tn),zn=function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i},On=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},Ln=function(n){function e(){return d(this,e),h(this,b(e).apply(this,arguments))}var t;return y(e,n),m(e,[{key:"handleChangeScrollTop",value:(t=p(regeneratorRuntime.mark((function n(){return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.$nextTick();case 2:this.visible&&(this.$refs.list.scrollTop=this.scrollTop);case 3:case"end":return n.stop()}}),n,this)}))),function(){return t.apply(this,arguments)})},{key:"render",value:function(){var n=this,e=arguments[0],t=this.listHeight,r=this.dataSource,a=this.currentMusic,o=this.aplayer.currentTheme;return e("ol",{ref:"list",class:"aplayer-list",style:{height:"".concat(t,"px")}},[r.map((function(t,r){return e("li",{key:t.id,class:A()({"aplayer-list-light":t.id===a.id}),on:{click:function(){return n.$emit("change",t,r)}}},[e("span",{class:"aplayer-list-cur",style:{backgroundColor:o}}),e("span",{class:"aplayer-list-index"},[r+1])," ",e("span",{class:"aplayer-list-title"},[t.name]),e("span",{class:"aplayer-list-author"},[t.artist])])}))])}},{key:"listHeight",get:function(){var n=this.visible,e=this.dataSource;return n?Math.min(33*e.length,Number(this.aplayer.listMaxHeight)):0}}]),e}(k.Component);zn([T({type:Boolean,required:!1,default:!0}),On("design:type",Boolean)],Ln.prototype,"visible",void 0),zn([T({type:Object,required:!0}),On("design:type","function"==typeof(jn="undefined"!=typeof APlayer&&APlayer.Audio)?jn:Object)],Ln.prototype,"currentMusic",void 0),zn([T({type:Array,required:!0}),On("design:type","function"==typeof(Cn="undefined"!=typeof Array&&Array)?Cn:Object)],Ln.prototype,"dataSource",void 0),zn([T({type:Number,required:!0}),On("design:type",Number)],Ln.prototype,"scrollTop",void 0),zn([I(),On("design:type",Object)],Ln.prototype,"aplayer",void 0),zn([j("scrollTop",{immediate:!0}),j("dataSource",{immediate:!0,deep:!0}),j("visible"),On("design:type",Function),On("design:paramtypes",[]),On("design:returntype",Promise)],Ln.prototype,"handleChangeScrollTop",null);var Pn,Rn,Mn,Bn,Dn,Nn,qn=Ln=zn([w.a],Ln),Fn=(t("610a"),function(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i}),Un=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":f(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},Hn=[],$n=new q,Vn=null;"undefined"!=typeof BroadcastChannel&&(Vn=new BroadcastChannel("aplayer"));var Gn=function(n){function e(){var n;return d(this,e),(n=h(this,b(e).apply(this,arguments))).isDraggingProgressBar=!1,n.isAwaitChangeProgressBar=!1,n.isMini=null!==n.mini?n.mini:n.fixed,n.isArrow=!1,n.canPlay=!n.isMobile&&n.autoplay,n.listVisible=!n.listFolded,n.lyricVisible=!0,n.img=new Image,n.xhr=new Z,n.media=new B,n.player=n.media.audio,n.store=$n,n.currentMusic={id:NaN,name:"未加载音频",artist:"(ಗ ‸ ಗ )",url:""},n.currentPlayed=0,n.currentVolume=n.volume,n.currentLoop=n.loop,n.currentOrder=n.order,n.currentTheme=n.currentMusic.theme||n.theme,n.notice={text:"",time:2e3,opacity:0},n}var t,r,a,c,u;return y(e,n),m(e,[{key:"handleChangePlayList",value:(u=p(regeneratorRuntime.mark((function n(e,t){var r,a,o,i,s,c,p,d;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(t&&(r=e.length,a=t.length,r!==a&&(r<=0?this.$emit("listClear"):r>a?this.$emit("listAdd"):(this.currentOrderIndex<0&&(o=this.currentMusic,i=o.id,s=o.url,c=t.findIndex((function(n){return n.id===i||n.url===s})),Object.assign(this.currentMusic,t[c-1])),this.canPlay=!this.player.paused,this.$emit("listRemove")))),!(this.orderList.length>0)){n.next=6;break}return this.currentMusic.id?(this.canPlay=!this.player.paused,d=this.orderList[this.currentOrderIndex]||this.orderList[0],Object.assign(this.currentMusic,d)):(p=l(this.currentList,1),this.currentMusic=p[0]),n.next=5,this.$nextTick();case 5:this.canPlay=!0;case 6:case"end":return n.stop()}}),n,this)}))),function(n,e){return u.apply(this,arguments)})},{key:"handleChangeCurrentMusic",value:(c=p(regeneratorRuntime.mark((function n(e,t){var r,a,o=this;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(e.theme?this.currentTheme=e.theme:(r=e.cover||this.options.defaultCover)&&setTimeout(p(regeneratorRuntime.mark((function n(){return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.prev=0,n.next=3,o.getThemeColorFromCover(r);case 3:o.currentTheme=n.sent,n.next=9;break;case 6:n.prev=6,n.t0=n.catch(0),o.currentTheme=e.theme||o.theme;case 9:case"end":return n.stop()}}),n,this,[[0,6]])})))),!e.url){n.next=15;break}if((void 0!==t&&t.url)===e.url&&this.player.src===e.url){n.next=14;break}return this.currentPlayed=0,t&&t.id&&(this.handleChangeSettings(),this.$emit("listSwitch",e)),n.next=7,this.getAudioUrl(e);case 7:(a=n.sent)&&(this.player.src=a),this.player.playbackRate=e.speed||1,this.player.preload=this.preload,this.player.volume=this.currentVolume,this.player.currentTime=0,this.player.onerror=function(n){o.showNotice(n.toString())};case 14:this.canPlay&&this.play();case 15:case"end":return n.stop()}}),n,this)}))),function(n,e){return c.apply(this,arguments)})},{key:"handleChangeVolume",value:function(n){this.currentVolume=n}},{key:"handleChangeCurrentVolume",value:function(){this.player.volume=this.currentVolume,this.$emit("update:volume",this.currentVolume)}},{key:"handleChangeCurrentTime",value:function(){this.isDraggingProgressBar||this.isAwaitChangeProgressBar||(this.currentPlayed=this.media.currentTime/this.media.duration||0)}},{key:"handleChangeSettings",value:function(){var n={currentTime:this.media.currentTime,duration:this.media.duration,paused:this.media.paused,mini:this.isMini,lrc:this.lyricVisible,list:this.listVisible,volume:this.currentVolume,loop:this.currentLoop,order:this.currentOrder,music:this.currentMusic};n.volume<=0&&(n.volume=this.currentSettings.volume),this.saveSettings(n)}},{key:"handleChangeEnded",value:function(){if(this.media.ended)switch(this.currentPlayed=0,this.currentLoop){default:case"all":this.handleSkipForward();break;case"one":this.play();break;case"none":if(this.currentIndex===this.currentList.length-1){var n=l(this.currentList,1);this.currentMusic=n[0],this.pause(),this.canPlay=!1}else this.handleSkipForward()}}},{key:"handleChangeMini",value:function(){this.isMini=this.mini}},{key:"handleChangeCurrentMini",value:(a=p(regeneratorRuntime.mark((function n(e,t){var r;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.$nextTick();case 2:r=this.$refs.container,this.isArrow=r&&r.offsetWidth<=300,void 0!==t&&(this.$emit("update:mini",this.isMini),this.handleChangeSettings());case 5:case"end":return n.stop()}}),n,this)}))),function(n,e){return a.apply(this,arguments)})},{key:"handleChangeLoop",value:function(){this.currentLoop=this.loop}},{key:"handleChangeCurrentLoop",value:function(){this.$emit("update:loop",this.currentLoop),this.handleChangeSettings()}},{key:"handleChangeOrder",value:function(){this.currentOrder=this.order}},{key:"handleChangeCurrentOrder",value:function(){this.$emit("update:order",this.currentOrder),this.handleChangeSettings()}},{key:"handleChangeListVisible",value:function(){this.$emit(this.listVisible?"listShow":"listHide"),this.$emit("update:listFolded",this.listVisible),this.handleChangeSettings()}},{key:"handleChangeLyricVisible",value:function(){this.$emit(this.lyricVisible?"lrcShow":"lrcHide"),this.handleChangeSettings()}},{key:"play",value:(r=p(regeneratorRuntime.mark((function n(){return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.prev=0,this.mutex&&this.pauseOtherInstances(),n.next=4,this.player.play();case 4:n.next=10;break;case 6:n.prev=6,n.t0=n.catch(0),this.showNotice(n.t0.message),this.player.pause();case 10:case"end":return n.stop()}}),n,this,[[0,6]])}))),function(){return r.apply(this,arguments)})},{key:"pause",value:function(){this.player.pause()}},{key:"toggle",value:function(){this.media.paused?this.play():this.pause()}},{key:"seeking",value:(t=p(regeneratorRuntime.mark((function n(e){var t,r,a=arguments;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(t=!(a.length>1&&void 0!==a[1])||a[1],n.prev=1,this.isAwaitChangeProgressBar=!0,"none"!==this.preload){n.next=11;break}if(this.player.src){n.next=7;break}return n.next=7,this.media.srcLoaded();case 7:return r=this.player.paused,n.next=10,this.play();case 10:t&&r&&this.pause();case 11:return t&&this.pause(),n.next=14,this.media.loaded();case 14:this.player.currentTime=e*this.media.duration,t||(this.play(),Vn&&this.mutex&&Vn.postMessage("mutex")),n.next=21;break;case 18:n.prev=18,n.t0=n.catch(1),this.showNotice(n.t0.message);case 21:return n.prev=21,this.isAwaitChangeProgressBar=!1,n.finish(21);case 24:case"end":return n.stop()}}),n,this,[[1,18,21,24]])}))),function(n){return t.apply(this,arguments)})},{key:"seek",value:function(n){this.seeking(n/this.media.duration,this.media.paused)}},{key:"switch",value:function(n){switch(f(n)){case"number":this.currentMusic=this.orderList[Math.min(Math.max(0,n),this.orderList.length-1)];break;default:var e=this.orderList.find((function(e){return"string"==typeof e.name&&e.name.includes(n)}));e&&(this.currentMusic=e)}}},{key:"skipBack",value:function(){var n=this.getPlayIndexByMode("skipBack");this.currentMusic=o({},this.currentList[n])}},{key:"skipForward",value:function(){var n=this.getPlayIndexByMode("skipForward");this.currentMusic=o({},this.currentList[n])}},{key:"showLrc",value:function(){this.lyricVisible=!0}},{key:"hideLrc",value:function(){this.lyricVisible=!1}},{key:"toggleLrc",value:function(){this.lyricVisible=!this.lyricVisible}},{key:"showList",value:function(){this.listVisible=!0}},{key:"hideList",value:function(){this.listVisible=!1}},{key:"toggleList",value:function(){this.listVisible=!this.listVisible}},{key:"showNotice",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2e3,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.8;return new Promise((function(a){e.isMini?(console.warn("aplayer notice:",n),a()):(e.notice={text:n,time:t,opacity:r},e.$emit("noticeShow"),t>0&&setTimeout((function(){e.notice.opacity=0,e.$emit("noticeHide"),a()}),t))}))}},{key:"getThemeColorFromCover",value:function(n){var e=this;return new Promise(function(){var t=p(regeneratorRuntime.mark((function t(r,a){var o,i;return regeneratorRuntime.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(t.prev=0,"undefined"==typeof ColorThief){t.next=12;break}return t.next=4,e.xhr.download(n,"blob");case 4:o=t.sent,(i=new FileReader).onload=function(){e.img.src=i.result,e.img.onload=function(){var n=l((new ColorThief).getColor(e.img),3),t=n[0],a=n[1],o=n[2],i="rgb(".concat(t,", ").concat(a,", ").concat(o,")");r(i||e.currentMusic.theme||e.theme)},e.img.onabort=a,e.img.onerror=a},i.onabort=a,i.onerror=a,i.readAsDataURL(o),t.next=13;break;case 12:r(e.currentMusic.theme||e.theme);case 13:t.next=18;break;case 15:t.prev=15,t.t0=t.catch(0),r(e.currentMusic.theme||e.theme);case 18:case"end":return t.stop()}}),t,this,[[0,15]])})));return function(n,e){return t.apply(this,arguments)}}())}},{key:"getAudioUrl",value:function(n){var e=this;return new Promise((function(t,r){var a=n.type;if(a&&e.customAudioType&&e.customAudioType[a])"function"==typeof e.customAudioType[a]?e.customAudioType[a](e.player,n,e):console.error("Illegal customType: ".concat(a)),t();else if(a&&"auto"!==a||(a=/m3u8(#|\?|$)/i.test(n.url)?"hls":"normal"),"hls"===a)try{if(Hls.isSupported()){var o=new Hls;o.loadSource(n.url),o.attachMedia(e.player),t()}else e.player.canPlayType("application/x-mpegURL")||e.player.canPlayType("application/vnd.apple.mpegURL")?t(n.url):r(new Error("HLS is not supported."))}catch(n){r(new Error("HLS is not supported."))}else t(n.url)}))}},{key:"getPlayIndexByMode",value:function(n){var e=this.currentList.length,t=this.currentIndex;return("skipBack"===n?e+(t-1):t+1)%e}},{key:"pauseOtherInstances",value:function(){var n=this;Hn.filter((function(e){return e!==n})).forEach((function(n){return n.pause()}))}},{key:"saveSettings",value:function(n){var e=Hn.indexOf(this);null===n&&delete Hn[e],this.store.set(void 0!==this.settings[e]?this.settings.map((function(t,r){return r===e?n:t})):s(this.settings).concat([n]))}},{key:"handleSkipBack",value:function(){this.skipBack()}},{key:"handleSkipForward",value:function(){this.skipForward()}},{key:"handleTogglePlay",value:function(){this.toggle()}},{key:"handleToggleOrderMode",value:function(){this.currentOrder="list"===this.currentOrder?"random":"list"}},{key:"handleToggleLoopMode",value:function(){this.currentLoop="all"===this.currentLoop?"one":"one"===this.currentLoop?"none":"all"}},{key:"handleTogglePlaylist",value:function(){this.toggleList()}},{key:"handleToggleLyric",value:function(){this.toggleLrc()}},{key:"handleChangeProgress",value:function(n,e){this.currentPlayed=e,this.isDraggingProgressBar=n.type.includes("move"),["touchend","mouseup"].includes(n.type)&&this.seeking(e,this.media.paused)}},{key:"handleMiniSwitcher",value:function(){this.isMini=!this.isMini}},{key:"handleChangePlaylist",value:function(n,e){n.id===this.currentMusic.id?this.handleTogglePlay():this.currentMusic=this.orderList[e]}},{key:"beforeMount",value:function(){var n=this;this.store.key=this.storageName;var e=Hn.findIndex((function(n){return!n}));if(e>-1?Hn[e]=this:Hn.push(this),this.currentSettings){var t=this.currentSettings,r=t.mini,a=t.lrc,o=t.list,i=t.volume,s=t.loop,l=t.order,c=t.music,p=t.currentTime,d=t.duration,u=t.paused;this.isMini=r,this.lyricVisible=a,this.listVisible=o,this.currentVolume=i,this.currentLoop=s,this.currentOrder=l,c&&(this.currentMusic=c,!this.isMobile&&d&&this.seeking(p/d,u))}Vn&&this.mutex&&Vn.addEventListener("message",(function(e){"mutex"===e.data&&n.pause()})),L.forEach((function(e){n.player.addEventListener(e,(function(t){return n.$emit(e,t)}))}))}},{key:"beforeDestroy",value:function(){this.pause(),this.saveSettings(null),this.$emit("destroy"),this.$el.remove()}},{key:"render",value:function(){var n=arguments[0],e=this.dataSource,t=this.fixed,r=this.lrcType,a=this.isMini,o=this.isMobile,i=this.isArrow,s=this.isLoading,l=this.notice,c=this.listVisible,p=this.listScrollTop,d=this.currentMusic,u=this.lyricVisible;return n("div",{ref:"container",class:A()({aplayer:!0,"aplayer-withlist":e.length>1,"aplayer-withlrc":!t&&0!==r&&u,"aplayer-narrow":a,"aplayer-fixed":t,"aplayer-mobile":o,"aplayer-arrow":i,"aplayer-loading":s})},[n(An,{attrs:{notice:l},on:{skipBack:this.handleSkipBack,skipForward:this.handleSkipForward,togglePlay:this.handleTogglePlay,toggleOrderMode:this.handleToggleOrderMode,toggleLoopMode:this.handleToggleLoopMode,togglePlaylist:this.handleTogglePlaylist,toggleLyric:this.handleToggleLyric,changeVolume:this.handleChangeVolume,changeProgress:this.handleChangeProgress,miniSwitcher:this.handleMiniSwitcher}}),n(qn,{attrs:{visible:c,scrollTop:p,currentMusic:d,dataSource:e},on:{change:this.handleChangePlaylist}}),t&&0!==r?n(rn,{attrs:{visible:u}}):null])}},{key:"aplayer",get:function(){return this}},{key:"settings",get:function(){return this.store.store}},{key:"currentSettings",get:function(){return this.settings[Hn.indexOf(this)]}},{key:"currentList",get:function(){return"list"===this.currentOrder?this.orderList:this.randomList}},{key:"dataSource",get:function(){return(Array.isArray(this.audio)?this.audio:[this.audio]).filter((function(n){return n})).map((function(n,e){return o({id:e+1},n)}))}},{key:"orderList",get:function(){var n=function(n,e){return"string"==typeof n?n:n.data&&n.data.attrs&&n.data.attrs["data-".concat(e)]};return this.dataSource.map((function(e){var t=e.name,r=e.artist;return o({},i(e,["name","artist"]),{name:n(t,"name"),artist:n(r,"artist")})}))}},{key:"randomList",get:function(){return function(n){for(var e=n.length-1;e>=0;e--){var t=Math.floor(Math.random()*(e+1)),r=n[t];n[t]=n[e],n[e]=r}return n}(s(this.orderList))}},{key:"isLoading",get:function(){var n=this.preload,e=this.currentPlayed,t=this.currentLoaded,r=this.media,a=r.src,o=r.paused,i=r.duration,s=!!a&&(e>t||!i);return"none"===n?!o&&s:s}},{key:"listScrollTop",get:function(){return 33*this.currentOrderIndex}},{key:"currentIndex",get:function(){return"list"===this.currentOrder?this.currentOrderIndex:this.currentRandomIndex}},{key:"currentOrderIndex",get:function(){var n=this.currentMusic,e=n.id,t=n.url;return this.orderList.findIndex((function(n){return n.id===e||n.url===t}))}},{key:"currentRandomIndex",get:function(){var n=this.currentMusic,e=n.id,t=n.url;return this.randomList.findIndex((function(n){return n.id===e||n.url===t}))}},{key:"currentLoaded",get:function(){if(this.media.readyState<O.HAVE_FUTURE_DATA)return 0;var n=this.media.buffered.length;return n>0?this.media.buffered.end(n-1)/this.media.duration:1}}]),e}(k.Component);Gn.version="2.0.0-beta.5",Fn([T({type:Boolean,required:!1,default:!1}),Un("design:type",Boolean)],Gn.prototype,"fixed",void 0),Fn([T({type:Boolean,required:!1,default:null}),Un("design:type",Boolean)],Gn.prototype,"mini",void 0),Fn([T({type:Boolean,required:!1,default:!1}),Un("design:type",Boolean)],Gn.prototype,"autoplay",void 0),Fn([T({type:String,required:!1,default:"#b7daff"}),Un("design:type",String)],Gn.prototype,"theme",void 0),Fn([T({type:String,required:!1,default:"all"}),Un("design:type","function"==typeof(Pn=void 0!==Gn&&Gn.LoopMode)?Pn:Object)],Gn.prototype,"loop",void 0),Fn([T({type:String,required:!1,default:"list"}),Un("design:type","function"==typeof(Rn=void 0!==Gn&&Gn.OrderMode)?Rn:Object)],Gn.prototype,"order",void 0),Fn([T({type:String,required:!1,default:"auto"}),Un("design:type","function"==typeof(Mn=void 0!==Gn&&Gn.Preload)?Mn:Object)],Gn.prototype,"preload",void 0),Fn([T({type:Number,required:!1,default:.7}),Un("design:type",Number)],Gn.prototype,"volume",void 0),Fn([T({type:[Object,Array],required:!0}),Un("design:type",Object)],Gn.prototype,"audio",void 0),Fn([T({type:Object,required:!1}),Un("design:type",Object)],Gn.prototype,"customAudioType",void 0),Fn([T({type:Boolean,required:!1,default:!0}),Un("design:type",Boolean)],Gn.prototype,"mutex",void 0),Fn([T({type:Number,required:!1,default:0}),Un("design:type","function"==typeof(Bn=void 0!==Gn&&Gn.LrcType)?Bn:Object)],Gn.prototype,"lrcType",void 0),Fn([T({type:Boolean,required:!1,default:!1}),Un("design:type",Boolean)],Gn.prototype,"listFolded",void 0),Fn([T({type:Number,required:!1,default:250}),Un("design:type",Number)],Gn.prototype,"listMaxHeight",void 0),Fn([T({type:String,required:!1,default:"aplayer-setting"}),Un("design:type",String)],Gn.prototype,"storageName",void 0),Fn([_(),Un("design:type",Object),Un("design:paramtypes",[])],Gn.prototype,"aplayer",null),Fn([j("orderList",{immediate:!0,deep:!0}),Un("design:type",Function),Un("design:paramtypes",[Array,Array]),Un("design:returntype",Promise)],Gn.prototype,"handleChangePlayList",null),Fn([j("currentMusic",{immediate:!0,deep:!0}),Un("design:type",Function),Un("design:paramtypes",["function"==typeof(Dn=void 0!==Gn&&Gn.Audio)?Dn:Object,"function"==typeof(Nn=void 0!==Gn&&Gn.Audio)?Nn:Object]),Un("design:returntype",Promise)],Gn.prototype,"handleChangeCurrentMusic",null),Fn([j("volume"),Un("design:type",Function),Un("design:paramtypes",[Number]),Un("design:returntype",void 0)],Gn.prototype,"handleChangeVolume",null),Fn([j("currentVolume"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Gn.prototype,"handleChangeCurrentVolume",null),Fn([j("media.currentTime"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Gn.prototype,"handleChangeCurrentTime",null),Fn([j("media.$data",{deep:!0}),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Gn.prototype,"handleChangeSettings",null),Fn([j("media.ended"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Gn.prototype,"handleChangeEnded",null),Fn([j("mini"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Gn.prototype,"handleChangeMini",null),Fn([j("isMini",{immediate:!0}),Un("design:type",Function),Un("design:paramtypes",[Boolean,Boolean]),Un("design:returntype",Promise)],Gn.prototype,"handleChangeCurrentMini",null),Fn([j("loop"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Gn.prototype,"handleChangeLoop",null),Fn([j("currentLoop"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Gn.prototype,"handleChangeCurrentLoop",null),Fn([j("order"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Gn.prototype,"handleChangeOrder",null),Fn([j("currentOrder"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Gn.prototype,"handleChangeCurrentOrder",null),Fn([j("listVisible"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Gn.prototype,"handleChangeListVisible",null),Fn([j("lyricVisible"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Gn.prototype,"handleChangeLyricVisible",null);var Wn=Gn=Fn([w()({mixins:[H]})],Gn);t.d(e,"APlayer",(function(){return Wn}));e.default=function(n,e){var t=o({},{productionTip:!0,defaultCover:"https://avatars2.githubusercontent.com/u/20062482?s=270"},e);Object.assign(Wn.prototype,{options:t}),n.component("aplayer",Wn),n.component("APlayer",Wn),t.productionTip&&console.log("%c vue-aplayer %c v".concat("2.0.0-beta.5"," ").concat("dd10c50"," %c"),"background: #35495e; padding: 1px; border-radius: 3px 0 0 3px; color: #fff","background: #41b883; padding: 1px; border-radius: 0 3px 3px 0; color: #fff","background: transparent")}},fdef:function(n,e){n.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"}})},function(n,e,t){t(1)({target:"Reflect",stat:!0},{ownKeys:t(99)})},function(n,e){},function(n,e){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var a=n[r];"."===a?n.splice(r,1):".."===a?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var n="",e=!1,a=arguments.length-1;a>=-1&&!e;a--){var o=a>=0?arguments[a]:process.cwd();if("string"!=typeof o)throw new TypeError("Arguments to path.resolve must be strings");o&&(n=o+"/"+n,e="/"===o.charAt(0))}return(e?"/":"")+(n=t(r(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var o=e.isAbsolute(n),i="/"===a(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!o).join("/"))||o||(n="."),n&&i&&(n+="/"),(o?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var a=r(n.split("/")),o=r(t.split("/")),i=Math.min(a.length,o.length),s=i,l=0;l<i;l++)if(a[l]!==o[l]){s=l;break}var c=[];for(l=s;l<a.length;l++)c.push("..");return(c=c.concat(o.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,a=!0,o=n.length-1;o>=1;--o)if(47===(e=n.charCodeAt(o))){if(!a){r=o;break}}else a=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,a=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!a){t=e+1;break}}else-1===r&&(a=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,a=!0,o=0,i=n.length-1;i>=0;--i){var s=n.charCodeAt(i);if(47!==s)-1===r&&(a=!1,r=i+1),46===s?-1===e?e=i:1!==o&&(o=1):-1!==e&&(o=-1);else if(!a){t=i+1;break}}return-1===e||-1===r||0===o||1===o&&e===r-1&&e===t+1?"":n.slice(e,r)};var a="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var a={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},o=/[&<>'"]/g;function i(n){return a[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(o,i)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var a=t[r];void 0!==e[a]&&(n[a]=e[a])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"_from":"ejs@^2.6.1","_id":"ejs@2.7.4","_inBundle":false,"_integrity":"sha512-7vmuyh5+kuUyJKePhQfRQBhXV5Ce+RnaeeQArKu1EAMpL3WbgMt5WG6uQZpEVvYSSsxMXRKOewtDk9RaTKXRlA==","_location":"/ejs","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"ejs@^2.6.1","name":"ejs","escapedName":"ejs","rawSpec":"^2.6.1","saveSpec":null,"fetchSpec":"^2.6.1"},"_requiredBy":["/vuepress-plugin-comment"],"_resolved":"https://registry.npmjs.org/ejs/-/ejs-2.7.4.tgz","_shasum":"48661287573dcc53e366c7a1ae52c3a120eec9ba","_spec":"ejs@^2.6.1","_where":"D:\\\\个人笔记\\\\博客搭建\\\\我的笔记\\\\vuepress-theme-vdoing\\\\node_modules\\\\vuepress-plugin-comment","author":{"name":"Matthew Eernisse","email":"mde@fleegix.org","url":"http://fleegix.org"},"bugs":{"url":"https://github.com/mde/ejs/issues"},"bundleDependencies":false,"dependencies":{},"deprecated":false,"description":"Embedded JavaScript templates","devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/mde/ejs","keywords":["template","engine","ejs"],"license":"Apache-2.0","main":"./lib/ejs.js","name":"ejs","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"scripts":{"postinstall":"node ./postinstall.js","test":"mocha"},"version":"2.7.4"}')},function(n,e,t){"use strict";t(194)},function(n,e,t){"use strict";t(195)},function(n,e,t){"use strict";t.r(e);t(123),t(215),t(222),t(223);var r=t(73),a=(t(122),t(37),t(9),t(16),t(21),t(31),t(20),t(0));function o(n,e){for(var t in e)n[t]=e[t];return n}var i=/[!'()*]/g,s=function(n){return"%"+n.charCodeAt(0).toString(16)},l=/%2C/g,c=function(n){return encodeURIComponent(n).replace(i,s).replace(l,",")};function p(n){try{return decodeURIComponent(n)}catch(n){0}return n}var d=function(n){return null==n||"object"==typeof n?n:String(n)};function u(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=p(t.shift()),a=t.length>0?p(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function m(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return c(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(c(e)):r.push(c(e)+"="+c(n)))})),r.join("&")}return c(e)+"="+c(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var g=/\/?$/;function f(n,e,t,r){var a=r&&r.options.stringifyQuery,o=e.query||{};try{o=h(o)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:y(e,a),matched:n?v(n):[]};return t&&(i.redirectedFrom=y(t,a)),Object.freeze(i)}function h(n){if(Array.isArray(n))return n.map(h);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=h(n[t]);return e}return n}var b=f(null,{path:"/"});function v(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function y(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||m)(r)+a}function k(n,e,t){return e===b?n===e:!!e&&(n.path&&e.path?n.path.replace(g,"")===e.path.replace(g,"")&&(t||n.hash===e.hash&&x(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&x(n.query,e.query)&&x(n.params,e.params))))}function x(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var o=n[t];if(r[a]!==t)return!1;var i=e[t];return null==o||null==i?o===i:"object"==typeof o&&"object"==typeof i?x(o,i):String(o)===String(i)}))}function w(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],o=t.enteredCbs[r];if(a&&o){delete t.enteredCbs[r];for(var i=0;i<o.length;i++)a._isBeingDestroyed||o[i](a)}}}}var S={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,i=e.data;i.routerView=!0;for(var s=a.$createElement,l=t.name,c=a.$route,p=a._routerViewCache||(a._routerViewCache={}),d=0,u=!1;a&&a._routerRoot!==a;){var m=a.$vnode?a.$vnode.data:{};m.routerView&&d++,m.keepAlive&&a._directInactive&&a._inactive&&(u=!0),a=a.$parent}if(i.routerViewDepth=d,u){var g=p[l],f=g&&g.component;return f?(g.configProps&&E(f,i,g.route,g.configProps),s(f,i,r)):s()}var h=c.matched[d],b=h&&h.components[l];if(!h||!b)return p[l]=null,s();p[l]={component:b},i.registerRouteInstance=function(n,e){var t=h.instances[l];(e&&t!==n||!e&&t===n)&&(h.instances[l]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){h.instances[l]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[l]&&(h.instances[l]=n.componentInstance),w(c)};var v=h.props&&h.props[l];return v&&(o(p[l],{route:c,configProps:v}),E(b,i,c,v)),s(b,i,r)}};function E(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=o({},a);var i=e.attrs=e.attrs||{};for(var s in a)n.props&&s in n.props||(i[s]=a[s],delete a[s])}}function I(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function _(n){return n.replace(/\/\//g,"/")}var T=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},j=U,C=P,A=function(n,e){return M(P(n,e),e)},z=M,O=F,L=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function P(n,e){for(var t,r=[],a=0,o=0,i="",s=e&&e.delimiter||"/";null!=(t=L.exec(n));){var l=t[0],c=t[1],p=t.index;if(i+=n.slice(o,p),o=p+l.length,c)i+=c[1];else{var d=n[o],u=t[2],m=t[3],g=t[4],f=t[5],h=t[6],b=t[7];i&&(r.push(i),i="");var v=null!=u&&null!=d&&d!==u,y="+"===h||"*"===h,k="?"===h||"*"===h,x=t[2]||s,w=g||f;r.push({name:m||a++,prefix:u||"",delimiter:x,optional:k,repeat:y,partial:v,asterisk:!!b,pattern:w?D(w):b?".*":"[^"+B(x)+"]+?"})}}return o<n.length&&(i+=n.substr(o)),i&&r.push(i),r}function R(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function M(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",q(e)));return function(e,r){for(var a="",o=e||{},i=(r||{}).pretty?R:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,p=o[l.name];if(null==p){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(T(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<p.length;d++){if(c=i(p[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(p),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function B(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function D(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function N(n,e){return n.keys=e,n}function q(n){return n&&n.sensitive?"":"i"}function F(n,e,t){T(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,o="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)o+=B(s);else{var l=B(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=B(t.delimiter||"/"),d=o.slice(-p.length)===p;return r||(o=(d?o.slice(0,-p.length):o)+"(?:"+p+"(?=$))?"),o+=a?"$":r&&d?"":"(?="+p+"|$)",N(new RegExp("^"+o,q(t)),e)}function U(n,e,t){return T(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return N(n,e)}(n,e):T(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(U(n[a],e,t).source);return N(new RegExp("(?:"+r.join("|")+")",q(t)),e)}(n,e,t):function(n,e,t){return F(P(n,t),e,t)}(n,e,t)}j.parse=C,j.compile=A,j.tokensToFunction=z,j.tokensToRegExp=O;var H=Object.create(null);function $(n,e,t){e=e||{};try{var r=H[n]||(H[n]=j.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function V(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var i=(a=o({},n)).params;return i&&"object"==typeof i&&(a.params=o({},i)),a}if(!a.path&&a.params&&e){(a=o({},a))._normalized=!0;var s=o(o({},e.params),a.params);if(e.name)a.name=e.name,a.params=s;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;a.path=$(l,s,e.path)}else 0;return a}var c=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),p=e&&e.path||"/",m=c.path?I(c.path,p,t||a.append):p,g=function(n,e,t){void 0===e&&(e={});var r,a=t||u;try{r=a(n||"")}catch(n){r={}}for(var o in e){var i=e[o];r[o]=Array.isArray(i)?i.map(d):d(i)}return r}(c.query,a.query,r&&r.options.parseQuery),f=a.hash||c.hash;return f&&"#"!==f.charAt(0)&&(f="#"+f),{_normalized:!0,path:m,query:g,hash:f}}var G,W=function(){},K={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),i=a.location,s=a.route,l=a.href,c={},p=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==p?"router-link-active":p,m=null==d?"router-link-exact-active":d,h=null==this.activeClass?u:this.activeClass,b=null==this.exactActiveClass?m:this.exactActiveClass,v=s.redirectedFrom?f(null,V(s.redirectedFrom),null,t):s;c[b]=k(r,v,this.exactPath),c[h]=this.exact||this.exactPath?c[b]:function(n,e){return 0===n.path.replace(g,"/").indexOf(e.path.replace(g,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,v);var y=c[b]?this.ariaCurrentValue:null,x=function(n){Q(n)&&(e.replace?t.replace(i,W):t.push(i,W))},w={click:Q};Array.isArray(this.event)?this.event.forEach((function(n){w[n]=x})):w[this.event]=x;var S={class:c},E=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:s,navigate:x,isActive:c[h],isExactActive:c[b]});if(E){if(1===E.length)return E[0];if(E.length>1||!E.length)return 0===E.length?n():n("span",{},E)}if("a"===this.tag)S.on=w,S.attrs={href:l,"aria-current":y};else{var I=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(I){I.isStatic=!1;var _=I.data=o({},I.data);for(var T in _.on=_.on||{},_.on){var j=_.on[T];T in w&&(_.on[T]=Array.isArray(j)?j:[j])}for(var C in w)C in _.on?_.on[C].push(w[C]):_.on[C]=x;var A=I.data.attrs=o({},I.data.attrs);A.href=l,A["aria-current"]=y}else S.on=w}return n(this.tag,S,this.$slots.default)}};function Q(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var X="undefined"!=typeof window;function Y(n,e,t,r,a){var o=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,o,i){var s=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return _(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var d={path:p,regex:J(p,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:i,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var o=i?_(i+"/"+a.path):void 0;n(e,t,r,a,d,o)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==a.alias)for(var u=Array.isArray(a.alias)?a.alias:[a.alias],m=0;m<u.length;++m){0;var g={path:u[m],children:a.children};n(e,t,r,g,o,d.path||"/")}l&&(r[l]||(r[l]=d))}(o,i,s,n,a)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:i,nameMap:s}}function J(n,e){return j(n,[],e)}function Z(n,e){var t=Y(n),r=t.pathList,a=t.pathMap,o=t.nameMap;function i(n,t,i){var s=V(n,t,!1,e),c=s.name;if(c){var p=o[c];if(!p)return l(null,s);var d=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in s.params)&&d.indexOf(u)>-1&&(s.params[u]=t.params[u]);return s.path=$(p.path,s.params),l(p,s,i)}if(s.path){s.params={};for(var m=0;m<r.length;m++){var g=r[m],f=a[g];if(nn(f.regex,s.path,s.params))return l(f,s,i)}}return l(null,s)}function s(n,t){var r=n.redirect,a="function"==typeof r?r(f(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var s=a,c=s.name,p=s.path,d=t.query,u=t.hash,m=t.params;if(d=s.hasOwnProperty("query")?s.query:d,u=s.hasOwnProperty("hash")?s.hash:u,m=s.hasOwnProperty("params")?s.params:m,c){o[c];return i({_normalized:!0,name:c,query:d,hash:u,params:m},void 0,t)}if(p){var g=function(n,e){return I(n,e.parent?e.parent.path:"/",!0)}(p,n);return i({_normalized:!0,path:$(g,m),query:d,hash:u},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:$(t,e.params)});if(r){var a=r.matched,o=a[a.length-1];return e.params=r.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):f(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;Y([e||n],r,a,o,t),t&&t.alias.length&&Y(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,o,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){Y(n,r,a,o)}}}function nn(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,o=r.length;a<o;++a){var i=n.keys[a-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[a]?p(r[a]):r[a])}return!0}var en=X&&window.performance&&window.performance.now?window.performance:Date;function tn(){return en.now().toFixed(3)}var rn=tn();function an(){return rn}function on(n){return rn=n}var sn=Object.create(null);function ln(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=o({},window.history.state);return t.key=an(),window.history.replaceState(t,"",e),window.addEventListener("popstate",dn),function(){window.removeEventListener("popstate",dn)}}function cn(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var o=function(){var n=an();if(n)return sn[n]}(),i=a.call(n,e,t,r?o:null);i&&("function"==typeof i.then?i.then((function(n){hn(n,o)})).catch((function(n){0})):hn(i,o))}))}}function pn(){var n=an();n&&(sn[n]={x:window.pageXOffset,y:window.pageYOffset})}function dn(n){pn(),n.state&&n.state.key&&on(n.state.key)}function un(n){return gn(n.x)||gn(n.y)}function mn(n){return{x:gn(n.x)?n.x:window.pageXOffset,y:gn(n.y)?n.y:window.pageYOffset}}function gn(n){return"number"==typeof n}var fn=/^#\d/;function hn(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=fn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,o={x:gn((t=o).x)?t.x:0,y:gn(t.y)?t.y:0})}else un(n)&&(e=mn(n))}else r&&un(n)&&(e=mn(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var bn,vn=X&&((-1===(bn=window.navigator.userAgent).indexOf("Android 2.")&&-1===bn.indexOf("Android 4.0")||-1===bn.indexOf("Mobile Safari")||-1!==bn.indexOf("Chrome")||-1!==bn.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function yn(n,e){pn();var t=window.history;try{if(e){var r=o({},t.state);r.key=an(),t.replaceState(r,"",n)}else t.pushState({key:on(tn())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function kn(n){yn(n,!0)}function xn(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}var wn={redirected:2,aborted:4,cancelled:8,duplicated:16};function Sn(n,e){return In(n,e,wn.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return _n.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function En(n,e){return In(n,e,wn.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function In(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var _n=["params","query","hash"];function Tn(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function jn(n,e){return Tn(n)&&n._isRouter&&(null==e||n.type===e)}function Cn(n){return function(e,t,r){var a=!1,o=0,i=null;An(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,o++;var l,c=Ln((function(e){var a;((a=e).__esModule||On&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:G.extend(e),t.components[s]=e,--o<=0&&r()})),p=Ln((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=Tn(n)?n:new Error(e),r(i))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,p)}}})),a||r()}}function An(n,e){return zn(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function zn(n){return Array.prototype.concat.apply([],n)}var On="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ln(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Pn=function(n,e){this.router=n,this.base=function(n){if(!n)if(X){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=b,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Rn(n,e,t,r){var a=An(n,(function(n,r,a,o){var i=function(n,e){"function"!=typeof n&&(n=G.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,a,o)})):t(i,r,a,o)}));return zn(r?a.reverse():a)}function Mn(n,e){if(e)return function(){return n.apply(e,arguments)}}Pn.prototype.listen=function(n){this.cb=n},Pn.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Pn.prototype.onError=function(n){this.errorCbs.push(n)},Pn.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,o)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(jn(n,wn.redirected)&&o===b||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},Pn.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var o,i,s=function(n){!jn(n)&&Tn(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=a.matched.length-1;if(k(n,a)&&l===c&&n.matched[l]===a.matched[c])return this.ensureURL(),s(((i=In(o=a,n,wn.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",i));var p=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=p.updated,u=p.deactivated,m=p.activated,g=[].concat(function(n){return Rn(n,"beforeRouteLeave",Mn,!0)}(u),this.router.beforeHooks,function(n){return Rn(n,"beforeRouteUpdate",Mn)}(d),m.map((function(n){return n.beforeEnter})),Cn(m)),f=function(e,t){if(r.pending!==n)return s(En(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return In(n,e,wn.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):Tn(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(Sn(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};xn(g,f,(function(){xn(function(n){return Rn(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,o){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),f,(function(){if(r.pending!==n)return s(En(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){w(n)}))}))}))},Pn.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Pn.prototype.setupListeners=function(){},Pn.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=b,this.pending=null};var Bn=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Dn(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=vn&&t;r&&this.listeners.push(ln());var a=function(){var t=n.current,a=Dn(n.base);n.current===b&&a===n._startLocation||n.transitionTo(a,(function(n){r&&cn(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){yn(_(r.base+n.fullPath)),cn(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){kn(_(r.base+n.fullPath)),cn(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Dn(this.base)!==this.current.fullPath){var e=_(this.base+this.current.fullPath);n?yn(e):kn(e)}},e.prototype.getCurrentLocation=function(){return Dn(this.base)},e}(Pn);function Dn(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(_(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Nn=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Dn(n);if(!/^\/#/.test(e))return window.location.replace(_(n+"/#"+e)),!0}(this.base)||qn()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=vn&&e;t&&this.listeners.push(ln());var r=function(){var e=n.current;qn()&&n.transitionTo(Fn(),(function(r){t&&cn(n.router,r,e,!0),vn||$n(r.fullPath)}))},a=vn?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Hn(n.fullPath),cn(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){$n(n.fullPath),cn(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Fn()!==e&&(n?Hn(e):$n(e))},e.prototype.getCurrentLocation=function(){return Fn()},e}(Pn);function qn(){var n=Fn();return"/"===n.charAt(0)||($n("/"+n),!1)}function Fn(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Un(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Hn(n){vn?yn(Un(n)):window.location.hash=n}function $n(n){vn?kn(Un(n)):window.location.replace(Un(n))}var Vn=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){jn(n,wn.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Pn),Gn=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Z(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!vn&&!1!==n.fallback,this.fallback&&(e="hash"),X||(e="abstract"),this.mode=e,e){case"history":this.history=new Bn(this,n.base);break;case"hash":this.history=new Nn(this,n.base,this.fallback);break;case"abstract":this.history=new Vn(this,n.base);break;default:0}},Wn={currentRoute:{configurable:!0}};function Kn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Gn.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Wn.currentRoute.get=function(){return this.history&&this.history.current},Gn.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Bn||t instanceof Nn){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;vn&&a&&"fullPath"in n&&cn(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Gn.prototype.beforeEach=function(n){return Kn(this.beforeHooks,n)},Gn.prototype.beforeResolve=function(n){return Kn(this.resolveHooks,n)},Gn.prototype.afterEach=function(n){return Kn(this.afterHooks,n)},Gn.prototype.onReady=function(n,e){this.history.onReady(n,e)},Gn.prototype.onError=function(n){this.history.onError(n)},Gn.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Gn.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Gn.prototype.go=function(n){this.history.go(n)},Gn.prototype.back=function(){this.go(-1)},Gn.prototype.forward=function(){this.go(1)},Gn.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Gn.prototype.resolve=function(n,e,t){var r=V(n,e=e||this.history.current,t,this),a=this.match(r,e),o=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?_(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:a}},Gn.prototype.getRoutes=function(){return this.matcher.getRoutes()},Gn.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==b&&this.history.transitionTo(this.history.getCurrentLocation())},Gn.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==b&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Gn.prototype,Wn),Gn.install=function n(e){if(!n.installed||G!==e){n.installed=!0,G=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",S),e.component("RouterLink",K);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Gn.version="3.5.2",Gn.isNavigationFailure=jn,Gn.NavigationFailureType=wn,Gn.START_LOCATION=b,X&&window.Vue&&window.Vue.use(Gn);var Qn=Gn;t(154),t(155),t(225),t(48),t(156),t(18),t(19),t(227);function Xn(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(45),t(57),t(76);var Yn=t(59),Jn=(t(164),t(23),t(41),t(207),t(208),{NotFound:function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,445))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,444))}}),Zn={"v-43889aea":function(){return t.e(5).then(t.bind(null,447))},"v-1b5ef630":function(){return t.e(8).then(t.bind(null,448))},"v-af46de00":function(){return t.e(6).then(t.bind(null,449))},"v-3d5634c4":function(){return t.e(7).then(t.bind(null,450))},"v-35224e19":function(){return t.e(9).then(t.bind(null,451))},"v-1d4719ac":function(){return t.e(10).then(t.bind(null,452))},"v-39efffc4":function(){return t.e(15).then(t.bind(null,453))},"v-497c4d75":function(){return t.e(12).then(t.bind(null,454))},"v-3cf10cf0":function(){return t.e(11).then(t.bind(null,455))},"v-fcc0afa6":function(){return t.e(13).then(t.bind(null,456))},"v-65d0c5d8":function(){return t.e(14).then(t.bind(null,457))},"v-52b1827e":function(){return t.e(17).then(t.bind(null,458))},"v-ab811dba":function(){return t.e(16).then(t.bind(null,459))},"v-dd4ff4ac":function(){return t.e(18).then(t.bind(null,460))},"v-44acf49a":function(){return t.e(20).then(t.bind(null,461))},"v-67eee40d":function(){return t.e(19).then(t.bind(null,462))},"v-51f48c41":function(){return t.e(21).then(t.bind(null,463))},"v-95754022":function(){return t.e(22).then(t.bind(null,464))},"v-5bf22270":function(){return t.e(23).then(t.bind(null,465))},"v-172994e6":function(){return t.e(24).then(t.bind(null,466))},"v-44e904ad":function(){return t.e(25).then(t.bind(null,467))},"v-7ed2fa29":function(){return t.e(27).then(t.bind(null,468))},"v-a6e5a316":function(){return t.e(26).then(t.bind(null,469))},"v-44f3f994":function(){return t.e(29).then(t.bind(null,470))},"v-6ffc7c26":function(){return t.e(28).then(t.bind(null,471))},"v-5ace857b":function(){return t.e(30).then(t.bind(null,472))},"v-d5c1ca98":function(){return t.e(31).then(t.bind(null,473))},"v-c934e8f6":function(){return t.e(32).then(t.bind(null,474))},"v-2fd5fa4e":function(){return t.e(33).then(t.bind(null,475))},"v-8ee4cd26":function(){return t.e(34).then(t.bind(null,476))},"v-f43959ca":function(){return t.e(35).then(t.bind(null,477))},"v-470866cf":function(){return t.e(36).then(t.bind(null,478))},"v-159e4156":function(){return t.e(37).then(t.bind(null,479))},"v-46c1284f":function(){return t.e(38).then(t.bind(null,480))},"v-b641931a":function(){return t.e(39).then(t.bind(null,481))},"v-e39894f0":function(){return t.e(42).then(t.bind(null,482))},"v-23d7c457":function(){return t.e(41).then(t.bind(null,483))},"v-926d06f0":function(){return t.e(40).then(t.bind(null,484))},"v-01fcb9f0":function(){return t.e(43).then(t.bind(null,485))},"v-932e5b4a":function(){return t.e(45).then(t.bind(null,486))},"v-58fd5da2":function(){return t.e(48).then(t.bind(null,487))},"v-59998266":function(){return t.e(47).then(t.bind(null,488))},"v-bc34ada2":function(){return t.e(44).then(t.bind(null,489))},"v-32c6d179":function(){return t.e(49).then(t.bind(null,490))},"v-7a886be6":function(){return t.e(50).then(t.bind(null,491))},"v-42d8b944":function(){return t.e(46).then(t.bind(null,492))},"v-2191c822":function(){return t.e(51).then(t.bind(null,493))},"v-8ab2f9f8":function(){return t.e(52).then(t.bind(null,494))},"v-3fa66498":function(){return t.e(53).then(t.bind(null,495))},"v-dc38c17c":function(){return t.e(54).then(t.bind(null,496))},"v-1e2f1c3d":function(){return t.e(55).then(t.bind(null,497))},"v-030111c0":function(){return t.e(56).then(t.bind(null,498))},"v-4e759c6e":function(){return t.e(57).then(t.bind(null,499))},"v-2fed3cf2":function(){return t.e(59).then(t.bind(null,500))},"v-0d219152":function(){return t.e(58).then(t.bind(null,501))},"v-7b37fec3":function(){return t.e(60).then(t.bind(null,502))},"v-52f4fef2":function(){return t.e(61).then(t.bind(null,503))},"v-65c06378":function(){return t.e(62).then(t.bind(null,504))},"v-1e0c4778":function(){return t.e(63).then(t.bind(null,505))},"v-1e0d1a72":function(){return t.e(64).then(t.bind(null,506))},"v-ca1e139c":function(){return t.e(66).then(t.bind(null,507))},"v-1bf6726c":function(){return t.e(68).then(t.bind(null,508))},"v-fe3f074c":function(){return t.e(65).then(t.bind(null,509))},"v-6b16421e":function(){return t.e(67).then(t.bind(null,510))},"v-28ef8a63":function(){return t.e(69).then(t.bind(null,511))},"v-630cc93a":function(){return t.e(70).then(t.bind(null,512))},"v-1528edda":function(){return t.e(71).then(t.bind(null,513))},"v-25d3e376":function(){return t.e(73).then(t.bind(null,514))},"v-003925aa":function(){return t.e(75).then(t.bind(null,515))},"v-4174a582":function(){return t.e(72).then(t.bind(null,516))},"v-0473e648":function(){return t.e(74).then(t.bind(null,517))},"v-a6b40bf6":function(){return t.e(78).then(t.bind(null,518))},"v-687be266":function(){return t.e(79).then(t.bind(null,519))},"v-4edf1e42":function(){return t.e(76).then(t.bind(null,520))},"v-f1aa535c":function(){return t.e(77).then(t.bind(null,521))},"v-fc837a0e":function(){return t.e(81).then(t.bind(null,522))},"v-2e17fd90":function(){return t.e(80).then(t.bind(null,523))},"v-29898959":function(){return t.e(83).then(t.bind(null,524))},"v-1a7cf4bc":function(){return t.e(84).then(t.bind(null,525))},"v-4accbd96":function(){return t.e(85).then(t.bind(null,526))},"v-822e42c2":function(){return t.e(82).then(t.bind(null,527))},"v-9bccd544":function(){return t.e(86).then(t.bind(null,528))},"v-60ec441d":function(){return t.e(88).then(t.bind(null,529))},"v-35949522":function(){return t.e(87).then(t.bind(null,530))},"v-a72e87c4":function(){return t.e(89).then(t.bind(null,531))},"v-6dc6a488":function(){return t.e(90).then(t.bind(null,532))},"v-3e5a7f98":function(){return t.e(91).then(t.bind(null,533))},"v-1741bda2":function(){return t.e(93).then(t.bind(null,534))},"v-a1218f50":function(){return t.e(96).then(t.bind(null,535))},"v-551fc23c":function(){return t.e(92).then(t.bind(null,536))},"v-72bc6c96":function(){return t.e(94).then(t.bind(null,537))},"v-ba42e26c":function(){return t.e(95).then(t.bind(null,538))},"v-4b00cd86":function(){return t.e(98).then(t.bind(null,539))},"v-60f033c1":function(){return t.e(99).then(t.bind(null,540))},"v-6e5d990a":function(){return t.e(100).then(t.bind(null,541))},"v-6c0dd964":function(){return t.e(97).then(t.bind(null,542))},"v-dce71a6e":function(){return t.e(101).then(t.bind(null,543))},"v-82fe639c":function(){return t.e(102).then(t.bind(null,544))},"v-d5e0168a":function(){return t.e(105).then(t.bind(null,545))},"v-2f624b2e":function(){return t.e(103).then(t.bind(null,546))},"v-4880eaba":function(){return t.e(104).then(t.bind(null,547))},"v-31054822":function(){return t.e(106).then(t.bind(null,548))},"v-32b5c37d":function(){return t.e(107).then(t.bind(null,549))},"v-1f7e1d2a":function(){return t.e(109).then(t.bind(null,550))},"v-aac523bc":function(){return t.e(111).then(t.bind(null,551))},"v-37ac8ce7":function(){return t.e(112).then(t.bind(null,552))},"v-288e2030":function(){return t.e(108).then(t.bind(null,553))},"v-7a20c888":function(){return t.e(110).then(t.bind(null,554))},"v-46a61472":function(){return t.e(113).then(t.bind(null,555))},"v-7a7a5a41":function(){return t.e(114).then(t.bind(null,556))},"v-76fb83c4":function(){return t.e(116).then(t.bind(null,557))},"v-7e08e799":function(){return t.e(115).then(t.bind(null,558))},"v-fa94273a":function(){return t.e(117).then(t.bind(null,559))},"v-6e10f0cd":function(){return t.e(118).then(t.bind(null,560))},"v-1444ff88":function(){return t.e(119).then(t.bind(null,561))},"v-4e774dac":function(){return t.e(121).then(t.bind(null,562))},"v-6ed06e8c":function(){return t.e(120).then(t.bind(null,563))},"v-29d3ff9f":function(){return t.e(123).then(t.bind(null,564))},"v-15feff80":function(){return t.e(125).then(t.bind(null,565))},"v-45d858b5":function(){return t.e(122).then(t.bind(null,566))},"v-c69d916e":function(){return t.e(124).then(t.bind(null,567))},"v-98490bfe":function(){return t.e(127).then(t.bind(null,568))},"v-b70d62ba":function(){return t.e(128).then(t.bind(null,569))},"v-4a693b12":function(){return t.e(129).then(t.bind(null,570))},"v-7de57f53":function(){return t.e(126).then(t.bind(null,571))},"v-a0b08d08":function(){return t.e(130).then(t.bind(null,572))},"v-331c4066":function(){return t.e(131).then(t.bind(null,446))},"v-407767e1":function(){return t.e(136).then(t.bind(null,573))},"v-cd88a6aa":function(){return t.e(132).then(t.bind(null,574))},"v-68b82861":function(){return t.e(137).then(t.bind(null,575))},"v-e1e3bd88":function(){return t.e(134).then(t.bind(null,576))},"v-776b15dc":function(){return t.e(135).then(t.bind(null,577))},"v-671ae95c":function(){return t.e(133).then(t.bind(null,578))},"v-5bd48070":function(){return t.e(138).then(t.bind(null,579))}};function ne(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var ee=/-(\w)/g,te=ne((function(n){return n.replace(ee,(function(n,e){return e?e.toUpperCase():""}))})),re=/\B([A-Z])/g,ae=ne((function(n){return n.replace(re,"-$1").toLowerCase()})),oe=ne((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function ie(n,e){if(e)return n(e)?n(e):e.includes("-")?n(oe(te(e))):n(oe(e))||n(ae(e))}var se=Object.assign({},Jn,Zn),le=function(n){return se[n]},ce=function(n){return Zn[n]},pe=function(n){return Jn[n]},de=function(n){return a.default.component(n)};function ue(n){return ie(ce,n)}function me(n){return ie(pe,n)}function ge(n){return ie(le,n)}function fe(n){return ie(de,n)}function he(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(r.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(fe(e)||!ge(e)){n.next=5;break}return n.next=3,ge(e)();case 3:t=n.sent,a.default.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function be(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ve=t(118),ye=(t(65),t(40),t(196)),ke=t.n(ye),xe={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(ve.a)(n,1)[0]})).map((function(n){var e=Object(ve.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(n[t],'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=Se(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(Yn.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=Ee(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return ke()([{name:"description",content:this.$description}],n,this.siteMeta,Ie)},updateCanonicalLink:function(){we(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",Se(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){Ee(null,this.currentMetaTags),we()}};function we(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function Se(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function Ee(n,e){if(e&&Object(Yn.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function Ie(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var r=t[e];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}t(201);var _e=t(130),Te={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(_e)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+r,i=0;i<t.length;i++){var s=t[i],l=t[i+1],c=0===i&&0===r||r>=s.parentElement.offsetTop+10&&(!l||r<l.parentElement.offsetTop-10),p=decodeURIComponent(this.$route.hash);if(c&&p!==decodeURIComponent(s.hash)){var d=s;if(o===a)for(var u=i+1;u<t.length;u++)if(p===decodeURIComponent(t[u].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(d.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},je=(t(64),t(84)),Ce=t.n(je),Ae={mounted:function(){var n=this;Ce.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||a.default.component(n.name)||Ce.a.start(),t()})),this.$router.afterEach((function(){Ce.a.done(),n.isSidebarOpen=!1}))}};t(38),t(63),t(326);function ze(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(117);function Oe(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function Le(n,e,t){return e&&Oe(n.prototype,e),t&&Oe(n,t),n}t(327);var Pe=function(){function n(){ze(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return Le(n,[{key:"show",value:function(n){var e=this,t=n.text,r=void 0===t?"":t,a=n.duration,o=void 0===a?3e3:a,i=document.createElement("div");i.className="message move-in",i.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(r,"</div>\n    "),this.containerEl.appendChild(i),o>0&&setTimeout((function(){e.close(i)}),o)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),Re={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Click to Copy to Clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new Pe).show({text:"复制成功,请标注来源哦",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};t(210),t(87),t(86),t(120),t(329);!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Me={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Be={},De=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Ne=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Me[n]},qe=function n(e,t,r){var a=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))a[n]=t[n];else{var e=n.replace("data","");a.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,o=e.children;a.appendChild(n(t,r,o))})),a},Fe=function(n,e,t){var r,a=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==a.length||t?a:a[0]},Ue=function(n,e){var t,r,a=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<template>([\s\S]+)<\/template>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:a&&a[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=De(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),a=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,o=[eval][0](a);return o.template=e,o}(s.js,s.html);var l=Ne("vue");return s.jsLib.unshift(l),s},He=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<html>([\s\S]+)<\/html>/),o=n.match(/<script>([\s\S]+)<\/script>/),i={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return i.htmlTpl=i.html,i.jsTpl=i.js,i.script=(t=i.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),i},$e=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ve(){var n=Fe(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Fe(n,"vuepress-plugin-demo-block__code"),t=Fe(n,"vuepress-plugin-demo-block__display"),r=Fe(n,"vuepress-plugin-demo-block__footer"),a=Fe(t,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(n.dataset.code),i=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);i=i?JSON.parse(i):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),a=new Function("return ".concat(r))(),o={js:a,css:a.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:$e(n),htmlTpl:De("")},i=Ne("react"),s=Ne("reactDOM");return o.jsLib.unshift(i,s),o}(o,i):"vanilla"===s?He(o,i):Ue(o,i),p=qe("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(p),p.addEventListener("click",Ge.bind(null,p,l,e,r)),Ne("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,o=n.cssLib,i=a.concat(o).concat(Ne("cssLib")).concat(Ne("jsLib")).join(",");return qe("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:i}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Ne("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,o=n.cssLib,i=JSON.stringify({css:e,html:t,js:r,js_external:a.concat(Ne("jsLib")).join(";"),css_external:o.concat(Ne("cssLib")).join(";"),layout:Ne("codepenLayout"),js_pre_processor:Ne("codepenJsProcessor"),editors:Ne("codepenEditors")});return qe("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:i}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==i.horizontal?i.horizontal:Ne("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(c.css&&function(n){if(!Be[n]){var e=qe("style",{innerHTML:n});document.body.appendChild(e),Be[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),a);else if("vue"===s){var u=(new(Vue.extend(c.script))).$mount();a.appendChild(u.$el)}else"vanilla"===s&&(a.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Ve()}),300)}function Ge(n,e,t,r){var a="1"!==n.dataset.isExpand;t.style.height=a?"".concat(e,"px"):0,a?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=a?"1":"0"}var We={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ve()},updated:function(){Ve()}},Ke=(t(119),"auto"),Qe="zoom-in",Xe="zoom-out",Ye="grab",Je="move";function Ze(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};r?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function nt(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function et(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function tt(n,e,t){!function(n){var e=rt,t=at;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var r=n.style,a={};for(var o in e)t&&(a[o]=r[o]||""),r[o]=e[o];return a}var rt="transition",at="transform",ot="transform",it="transitionend";var st=function(){},lt={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:st,onClose:st,onGrab:st,onMove:st,onRelease:st,onBeforeOpen:st,onBeforeClose:st,onBeforeGrab:st,onBeforeRelease:st,onImageLoading:st,onImageLoaded:st},ct={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),dt(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(a)>=o||Math.abs(r)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(pt(n)&&!dt(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){pt(n)&&!dt(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function pt(n){return 0===n.button}function dt(n){return n.metaKey||n.ctrlKey}var ut={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,tt(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Ze(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){tt(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},mt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},gt=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),ft=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},ht={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=et(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ye:Xe,transition:ot+"\n        "+r+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=tt(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,tt(this.el,{transform:"none"})},grab:function(n,e,t){var r=bt(),a=r.x-n,o=r.y-e;tt(this.el,{cursor:Je,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=bt(),a=r.x-n,o=r.y-e;tt(this.el,{transition:ot,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){tt(this.el,this.styleClose)},restoreOpenStyle:function(){tt(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=bt(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,a=r.customSize,o=r.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":mt(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var i=this.rect.width/2,s=this.rect.height/2,l=bt(),c={x:l.x-i,y:l.y-s},p=c.x/i,d=c.y/s,u=o+Math.min(p,d);if(a&&"string"==typeof a){var m=t||this.el.naturalWidth,g=e||this.el.naturalHeight,f=parseFloat(a)*m/(100*this.rect.width),h=parseFloat(a)*g/(100*this.rect.height);if(u>f||u>h)return{x:f,y:h}}return{x:u,y:u}}};function bt(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function vt(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Ze(n,r,e[r],t)}))}var yt=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ht),this.overlay=Object.create(ut),this.handler=Object.create(ct),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=ft({},lt,e),this.overlay.init(this),this.handler.init(this)}return gt(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Qe,Ze(n,"click",this.handler.click),this.options.preloadImage&&nt(et(n)));return this}},{key:"config",value:function(n){return n?(ft(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(r),nt(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Ze(document,"scroll",this.handler.scroll),Ze(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Ze(window,"resize",this.handler.resizeWindow);var o=function n(){Ze(r,it,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&vt(document,e.handler,!0),t(r)};return Ze(r,it,o),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Ke,this.overlay.fadeOut(),this.target.zoomOut(),Ze(document,"scroll",this.handler.scroll,!1),Ze(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Ze(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Ze(t,it,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&vt(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Ze(t,it,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var o=function n(){Ze(a,it,n,!1),r(a)};return Ze(a,it,o),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Je,this.target.move(n,e,t);var a=this.target.el,o=function n(){Ze(a,it,n,!1),r(a)};return Ze(a,it,o),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Ke,this.target.restoreOpenStyle();var r=function r(){Ze(t,it,r,!1),n.lock=!1,n.released=!0,e(t)};return Ze(t,it,r),this}}}]),n}(),kt=".theme-vdoing-content img:not(.no-zoom)",xt=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),wt=Number("500"),St=function(){function n(){ze(this,n),this.instance=new yt(xt)}return Le(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:kt;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:kt,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:wt;setTimeout((function(){return n.update(e)}),t)}}]),n}(),Et=[xe,Te,Ae,Re,We,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new St,this.$vuepress.zooming.updateDelay()}}],It={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return be("layout",n),a.default.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},_t=t(8),Tt=Object(_t.a)(It,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var r;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(r=n[e]).push.apply(r,Object(Yn.a)(t));break;default:throw new Error("Unknown option name.")}}(Tt,"mixins",Et);var jt=[{name:"v-43889aea",path:"/back-end/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-43889aea").then(t)}},{path:"/back-end/index.html",redirect:"/back-end/"},{path:"/00.目录页/01.后端.html",redirect:"/back-end/"},{name:"v-1b5ef630",path:"/more/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-1b5ef630").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/00.目录页/04.更多.html",redirect:"/more/"},{name:"v-af46de00",path:"/web/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-af46de00").then(t)}},{path:"/web/index.html",redirect:"/web/"},{path:"/00.目录页/02.前端.html",redirect:"/web/"},{name:"v-3d5634c4",path:"/technology/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-3d5634c4").then(t)}},{path:"/technology/index.html",redirect:"/technology/"},{path:"/00.目录页/03.技术.html",redirect:"/technology/"},{name:"v-35224e19",path:"/tool/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-35224e19").then(t)}},{path:"/tool/index.html",redirect:"/tool/"},{path:"/00.目录页/12.工具的使用.html",redirect:"/tool/"},{name:"v-1d4719ac",path:"/interview/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-1d4719ac").then(t)}},{path:"/interview/index.html",redirect:"/interview/"},{path:"/00.目录页/13.面试笔记.html",redirect:"/interview/"},{name:"v-39efffc4",path:"/pages/c22e6b/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-39efffc4").then(t)}},{path:"/pages/c22e6b/index.html",redirect:"/pages/c22e6b/"},{path:"/01.后端/00.java/04.java线程.html",redirect:"/pages/c22e6b/"},{name:"v-497c4d75",path:"/pages/501d3a/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-497c4d75").then(t)}},{path:"/pages/501d3a/index.html",redirect:"/pages/501d3a/"},{path:"/01.后端/00.java/01.java流的操作.html",redirect:"/pages/501d3a/"},{name:"v-3cf10cf0",path:"/pages/122101/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-3cf10cf0").then(t)}},{path:"/pages/122101/index.html",redirect:"/pages/122101/"},{path:"/01.后端/00.java/00.java 基础学习.html",redirect:"/pages/122101/"},{name:"v-fcc0afa6",path:"/pages/2ec93c/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-fcc0afa6").then(t)}},{path:"/pages/2ec93c/index.html",redirect:"/pages/2ec93c/"},{path:"/01.后端/00.java/02.java反射.html",redirect:"/pages/2ec93c/"},{name:"v-65d0c5d8",path:"/pages/4400b9/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-65d0c5d8").then(t)}},{path:"/pages/4400b9/index.html",redirect:"/pages/4400b9/"},{path:"/01.后端/00.java/03.java集合.html",redirect:"/pages/4400b9/"},{name:"v-52b1827e",path:"/pages/38be09/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-52b1827e").then(t)}},{path:"/pages/38be09/index.html",redirect:"/pages/38be09/"},{path:"/01.后端/00.java/06.UUID唯一订单号.html",redirect:"/pages/38be09/"},{name:"v-ab811dba",path:"/pages/394e33/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-ab811dba").then(t)}},{path:"/pages/394e33/index.html",redirect:"/pages/394e33/"},{path:"/01.后端/00.java/05.java stream.html",redirect:"/pages/394e33/"},{name:"v-dd4ff4ac",path:"/pages/f99bc2/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-dd4ff4ac").then(t)}},{path:"/pages/f99bc2/index.html",redirect:"/pages/f99bc2/"},{path:"/01.后端/01.JUC/00.JUC笔记.html",redirect:"/pages/f99bc2/"},{name:"v-44acf49a",path:"/pages/c67291/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-44acf49a").then(t)}},{path:"/pages/c67291/index.html",redirect:"/pages/c67291/"},{path:"/01.后端/01.JUC/10.java主线程等待所有子线程执行完毕再执行.html",redirect:"/pages/c67291/"},{name:"v-67eee40d",path:"/pages/dea0da/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-67eee40d").then(t)}},{path:"/pages/dea0da/index.html",redirect:"/pages/dea0da/"},{path:"/01.后端/01.JUC/01.java并发编程之美（笔记）.html",redirect:"/pages/dea0da/"},{name:"v-51f48c41",path:"/pages/486416/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-51f48c41").then(t)}},{path:"/pages/486416/index.html",redirect:"/pages/486416/"},{path:"/01.后端/10.Spring全家桶/00.Spring/00.过滤器、拦截器、AOP切面.html",redirect:"/pages/486416/"},{name:"v-95754022",path:"/pages/9f1398/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-95754022").then(t)}},{path:"/pages/9f1398/index.html",redirect:"/pages/9f1398/"},{path:"/01.后端/10.Spring全家桶/00.Spring/10.Spring.html",redirect:"/pages/9f1398/"},{name:"v-5bf22270",path:"/pages/7f80ea/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-5bf22270").then(t)}},{path:"/pages/7f80ea/index.html",redirect:"/pages/7f80ea/"},{path:"/01.后端/10.Spring全家桶/00.Spring/11.SSM环境搭建.html",redirect:"/pages/7f80ea/"},{name:"v-172994e6",path:"/pages/1f16ed/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-172994e6").then(t)}},{path:"/pages/1f16ed/index.html",redirect:"/pages/1f16ed/"},{path:"/01.后端/10.Spring全家桶/00.Spring/12.SSM的问题.html",redirect:"/pages/1f16ed/"},{name:"v-44e904ad",path:"/pages/04d292/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-44e904ad").then(t)}},{path:"/pages/04d292/index.html",redirect:"/pages/04d292/"},{path:"/01.后端/10.Spring全家桶/00.Spring/20.SpringSecurity.html",redirect:"/pages/04d292/"},{name:"v-7ed2fa29",path:"/pages/e3c3e5/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-7ed2fa29").then(t)}},{path:"/pages/e3c3e5/index.html",redirect:"/pages/e3c3e5/"},{path:"/01.后端/10.Spring全家桶/02.Mybatis/01.mybatis.html",redirect:"/pages/e3c3e5/"},{name:"v-a6e5a316",path:"/pages/9af6ea/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-a6e5a316").then(t)}},{path:"/pages/9af6ea/index.html",redirect:"/pages/9af6ea/"},{path:"/01.后端/10.Spring全家桶/01.SpringBoot/00.SpringBoot开发问题.html",redirect:"/pages/9af6ea/"},{name:"v-44f3f994",path:"/pages/5ca4e4/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-44f3f994").then(t)}},{path:"/pages/5ca4e4/index.html",redirect:"/pages/5ca4e4/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/00.SpingCloud导航.html",redirect:"/pages/5ca4e4/"},{name:"v-6ffc7c26",path:"/pages/1923fe/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-6ffc7c26").then(t)}},{path:"/pages/1923fe/index.html",redirect:"/pages/1923fe/"},{path:"/01.后端/10.Spring全家桶/03.SpringMVC/00.SpringMVC.html",redirect:"/pages/1923fe/"},{name:"v-5ace857b",path:"/pages/b5f6d0/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-5ace857b").then(t)}},{path:"/pages/b5f6d0/index.html",redirect:"/pages/b5f6d0/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/01.什么是微服务.html",redirect:"/pages/b5f6d0/"},{name:"v-d5c1ca98",path:"/pages/f1a77d/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-d5c1ca98").then(t)}},{path:"/pages/f1a77d/index.html",redirect:"/pages/f1a77d/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/02.选择Boot和Cloud版本.html",redirect:"/pages/f1a77d/"},{name:"v-c934e8f6",path:"/pages/8e2398/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-c934e8f6").then(t)}},{path:"/pages/8e2398/index.html",redirect:"/pages/8e2398/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/03.关于Cloud组件停更升级.html",redirect:"/pages/8e2398/"},{name:"v-2fd5fa4e",path:"/pages/ad4ca5/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-2fd5fa4e").then(t)}},{path:"/pages/ad4ca5/index.html",redirect:"/pages/ad4ca5/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/04.环境搭建.html",redirect:"/pages/ad4ca5/"},{name:"v-8ee4cd26",path:"/pages/93e73f/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-8ee4cd26").then(t)}},{path:"/pages/93e73f/index.html",redirect:"/pages/93e73f/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/05.Eureka基础篇.html",redirect:"/pages/93e73f/"},{name:"v-f43959ca",path:"/pages/1b8908/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-f43959ca").then(t)}},{path:"/pages/1b8908/index.html",redirect:"/pages/1b8908/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/06.Zookeeper.html",redirect:"/pages/1b8908/"},{name:"v-470866cf",path:"/pages/046d09/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-470866cf").then(t)}},{path:"/pages/046d09/index.html",redirect:"/pages/046d09/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/07.consul.html",redirect:"/pages/046d09/"},{name:"v-159e4156",path:"/pages/7dbd36/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-159e4156").then(t)}},{path:"/pages/7dbd36/index.html",redirect:"/pages/7dbd36/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/08.三种服务注册的区别.html",redirect:"/pages/7dbd36/"},{name:"v-46c1284f",path:"/pages/a5d650/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-46c1284f").then(t)}},{path:"/pages/a5d650/index.html",redirect:"/pages/a5d650/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/09.Ribbon.html",redirect:"/pages/a5d650/"},{name:"v-b641931a",path:"/pages/7348c0/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-b641931a").then(t)}},{path:"/pages/7348c0/index.html",redirect:"/pages/7348c0/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/10.OpenFeign.html",redirect:"/pages/7348c0/"},{name:"v-e39894f0",path:"/pages/fa46ca/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-e39894f0").then(t)}},{path:"/pages/fa46ca/index.html",redirect:"/pages/fa46ca/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/13.config全局配置.html",redirect:"/pages/fa46ca/"},{name:"v-23d7c457",path:"/pages/1beabf/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-23d7c457").then(t)}},{path:"/pages/1beabf/index.html",redirect:"/pages/1beabf/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/12.Gateway网关.html",redirect:"/pages/1beabf/"},{name:"v-926d06f0",path:"/pages/e3e514/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-926d06f0").then(t)}},{path:"/pages/e3e514/index.html",redirect:"/pages/e3e514/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/11.Hystrix豪猪哥.html",redirect:"/pages/e3e514/"},{name:"v-01fcb9f0",path:"/pages/c29287/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-01fcb9f0").then(t)}},{path:"/pages/c29287/index.html",redirect:"/pages/c29287/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/14.Bus消息总线.html",redirect:"/pages/c29287/"},{name:"v-932e5b4a",path:"/pages/080e29/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-932e5b4a").then(t)}},{path:"/pages/080e29/index.html",redirect:"/pages/080e29/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/16.Sleuth链路追踪.html",redirect:"/pages/080e29/"},{name:"v-58fd5da2",path:"/pages/f97989/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-58fd5da2").then(t)}},{path:"/pages/f97989/index.html",redirect:"/pages/f97989/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/19.Sentinel.html",redirect:"/pages/f97989/"},{name:"v-59998266",path:"/pages/2eb82f/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-59998266").then(t)}},{path:"/pages/2eb82f/index.html",redirect:"/pages/2eb82f/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/18.SpringCloud alibaba Nacos服务注册和配置中心 - 副本.html",redirect:"/pages/2eb82f/"},{name:"v-bc34ada2",path:"/pages/79277f/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-bc34ada2").then(t)}},{path:"/pages/79277f/index.html",redirect:"/pages/79277f/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/15.Stream.html",redirect:"/pages/79277f/"},{name:"v-32c6d179",path:"/pages/31cb74/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-32c6d179").then(t)}},{path:"/pages/31cb74/index.html",redirect:"/pages/31cb74/"},{path:"/01.后端/20.数据库/00.Mysql/00.经典SQL语句.html",redirect:"/pages/31cb74/"},{name:"v-7a886be6",path:"/pages/ef2328/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-7a886be6").then(t)}},{path:"/pages/ef2328/index.html",redirect:"/pages/ef2328/"},{path:"/01.后端/20.数据库/00.Mysql/02.索引失效的十大杂症.html",redirect:"/pages/ef2328/"},{name:"v-42d8b944",path:"/pages/91c605/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-42d8b944").then(t)}},{path:"/pages/91c605/index.html",redirect:"/pages/91c605/"},{path:"/01.后端/10.Spring全家桶/04.SpringCloud/17.SpringCloud alibaba入门介绍.html",redirect:"/pages/91c605/"},{name:"v-2191c822",path:"/pages/e581ae/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-2191c822").then(t)}},{path:"/pages/e581ae/index.html",redirect:"/pages/e581ae/"},{path:"/01.后端/20.数据库/00.Mysql/03.100道经典MYSQL面试题.html",redirect:"/pages/e581ae/"},{name:"v-8ab2f9f8",path:"/pages/349793/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-8ab2f9f8").then(t)}},{path:"/pages/349793/index.html",redirect:"/pages/349793/"},{path:"/01.后端/20.数据库/01.Oracle/00.oracle.html",redirect:"/pages/349793/"},{name:"v-3fa66498",path:"/pages/f1ccdf/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-3fa66498").then(t)}},{path:"/pages/f1ccdf/index.html",redirect:"/pages/f1ccdf/"},{path:"/01.后端/20.数据库/01.Oracle/01.Oracle基础知识.html",redirect:"/pages/f1ccdf/"},{name:"v-dc38c17c",path:"/pages/f59efe/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-dc38c17c").then(t)}},{path:"/pages/f59efe/index.html",redirect:"/pages/f59efe/"},{path:"/01.后端/20.数据库/01.Oracle/03.SQL调优简介.html",redirect:"/pages/f59efe/"},{name:"v-1e2f1c3d",path:"/pages/78011c/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-1e2f1c3d").then(t)}},{path:"/pages/78011c/index.html",redirect:"/pages/78011c/"},{path:"/01.后端/20.数据库/01.Oracle/04.oracle锁表.html",redirect:"/pages/78011c/"},{name:"v-030111c0",path:"/pages/44c61f/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-030111c0").then(t)}},{path:"/pages/44c61f/index.html",redirect:"/pages/44c61f/"},{path:"/01.后端/30.linux/00.Linux.html",redirect:"/pages/44c61f/"},{name:"v-4e759c6e",path:"/pages/1aff84/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-4e759c6e").then(t)}},{path:"/pages/1aff84/index.html",redirect:"/pages/1aff84/"},{path:"/01.后端/30.linux/01.常用命令.html",redirect:"/pages/1aff84/"},{name:"v-2fed3cf2",path:"/pages/261ec0/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-2fed3cf2").then(t)}},{path:"/pages/261ec0/index.html",redirect:"/pages/261ec0/"},{path:"/01.后端/40.数据结构/00.链表.html",redirect:"/pages/261ec0/"},{name:"v-0d219152",path:"/pages/1adf94/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-0d219152").then(t)}},{path:"/pages/1adf94/index.html",redirect:"/pages/1adf94/"},{path:"/01.后端/30.linux/02.阿里云增加虚拟内存.html",redirect:"/pages/1adf94/"},{name:"v-7b37fec3",path:"/pages/7b4831/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-7b37fec3").then(t)}},{path:"/pages/7b4831/index.html",redirect:"/pages/7b4831/"},{path:"/01.后端/40.数据结构/10.常见的排序算法/00.常见排序算法知识体系详解.html",redirect:"/pages/7b4831/"},{name:"v-52f4fef2",path:"/pages/b5b5a5/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-52f4fef2").then(t)}},{path:"/pages/b5b5a5/index.html",redirect:"/pages/b5b5a5/"},{path:"/01.后端/40.数据结构/10.常见的排序算法/01.排序_冒泡排序(BubbleSort).html",redirect:"/pages/b5b5a5/"},{name:"v-65c06378",path:"/pages/27b7f8/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-65c06378").then(t)}},{path:"/pages/27b7f8/index.html",redirect:"/pages/27b7f8/"},{path:"/01.后端/40.数据结构/10.常见的排序算法/02.排序_快速排序(QuickSort).html",redirect:"/pages/27b7f8/"},{name:"v-1e0c4778",path:"/pages/4cf198/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-1e0c4778").then(t)}},{path:"/pages/4cf198/index.html",redirect:"/pages/4cf198/"},{path:"/01.后端/40.数据结构/10.常见的排序算法/03.排序_插入排序(InsertionSort).html",redirect:"/pages/4cf198/"},{name:"v-1e0d1a72",path:"/pages/c8e6c6/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-1e0d1a72").then(t)}},{path:"/pages/c8e6c6/index.html",redirect:"/pages/c8e6c6/"},{path:"/01.后端/40.数据结构/10.常见的排序算法/04.排序_Shell排序(ShellSort).html",redirect:"/pages/c8e6c6/"},{name:"v-ca1e139c",path:"/pages/decb9d/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-ca1e139c").then(t)}},{path:"/pages/decb9d/index.html",redirect:"/pages/decb9d/"},{path:"/01.后端/40.数据结构/10.常见的排序算法/06.排序_堆排序(HeapSort).html",redirect:"/pages/decb9d/"},{name:"v-1bf6726c",path:"/pages/d82d31/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-1bf6726c").then(t)}},{path:"/pages/d82d31/index.html",redirect:"/pages/d82d31/"},{path:"/01.后端/40.数据结构/10.常见的排序算法/08.排序_桶排序(BucketSort).html",redirect:"/pages/d82d31/"},{name:"v-fe3f074c",path:"/pages/3de055/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-fe3f074c").then(t)}},{path:"/pages/3de055/index.html",redirect:"/pages/3de055/"},{path:"/01.后端/40.数据结构/10.常见的排序算法/05.排序_选择排序(Selectionsort).html",redirect:"/pages/3de055/"},{name:"v-6b16421e",path:"/pages/b0b120/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-6b16421e").then(t)}},{path:"/pages/b0b120/index.html",redirect:"/pages/b0b120/"},{path:"/01.后端/40.数据结构/10.常见的排序算法/07.排序_归并排序(MergeSort).html",redirect:"/pages/b0b120/"},{name:"v-28ef8a63",path:"/pages/bddf9b/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-28ef8a63").then(t)}},{path:"/pages/bddf9b/index.html",redirect:"/pages/bddf9b/"},{path:"/01.后端/40.数据结构/10.常见的排序算法/09.排序_计数排序(RadixSort).html",redirect:"/pages/bddf9b/"},{name:"v-630cc93a",path:"/pages/6c0a61/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-630cc93a").then(t)}},{path:"/pages/6c0a61/index.html",redirect:"/pages/6c0a61/"},{path:"/01.后端/60.消息队列/01.Kafka笔记.html",redirect:"/pages/6c0a61/"},{name:"v-1528edda",path:"/pages/fd92ef/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-1528edda").then(t)}},{path:"/pages/fd92ef/index.html",redirect:"/pages/fd92ef/"},{path:"/01.后端/60.消息队列/02.SpringBoot整合kafka.html",redirect:"/pages/fd92ef/"},{name:"v-25d3e376",path:"/pages/bd0628/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-25d3e376").then(t)}},{path:"/pages/bd0628/index.html",redirect:"/pages/bd0628/"},{path:"/01.后端/61.Sa-Token/00.单点登录/01.模式一：同域同后端.html",redirect:"/pages/bd0628/"},{name:"v-003925aa",path:"/pages/1f749b/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-003925aa").then(t)}},{path:"/pages/1f749b/index.html",redirect:"/pages/1f749b/"},{path:"/02.前端/00.JS/00.JS通用方法.html",redirect:"/pages/1f749b/"},{name:"v-4174a582",path:"/pages/59cf58/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-4174a582").then(t)}},{path:"/pages/59cf58/index.html",redirect:"/pages/59cf58/"},{path:"/01.后端/61.Sa-Token/00.单点登录/00.初识单点登录.html",redirect:"/pages/59cf58/"},{name:"v-0473e648",path:"/pages/658e4c/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-0473e648").then(t)}},{path:"/pages/658e4c/index.html",redirect:"/pages/658e4c/"},{path:"/01.后端/61.Sa-Token/00.单点登录/02.模式二：URL重定向传播会话.html",redirect:"/pages/658e4c/"},{name:"v-a6b40bf6",path:"/pages/8632d0/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-a6b40bf6").then(t)}},{path:"/pages/8632d0/index.html",redirect:"/pages/8632d0/"},{path:"/03.技术/05.面试笔记/01.java.html",redirect:"/pages/8632d0/"},{name:"v-687be266",path:"/pages/1dde6d/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-687be266").then(t)}},{path:"/pages/1dde6d/index.html",redirect:"/pages/1dde6d/"},{path:"/03.技术/05.面试笔记/02.操作系统.html",redirect:"/pages/1dde6d/"},{name:"v-4edf1e42",path:"/pages/9ff38f/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-4edf1e42").then(t)}},{path:"/pages/9ff38f/index.html",redirect:"/pages/9ff38f/"},{path:"/02.前端/01.Layui/00.Layui使用.html",redirect:"/pages/9ff38f/"},{name:"v-f1aa535c",path:"/pages/1861bf/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-f1aa535c").then(t)}},{path:"/pages/1861bf/index.html",redirect:"/pages/1861bf/"},{path:"/03.技术/05.面试笔记/00.SpringBoot面试笔记.html",redirect:"/pages/1861bf/"},{name:"v-fc837a0e",path:"/pages/18b13f/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-fc837a0e").then(t)}},{path:"/pages/18b13f/index.html",redirect:"/pages/18b13f/"},{path:"/03.技术/05.面试笔记/04.数据结构.html",redirect:"/pages/18b13f/"},{name:"v-2e17fd90",path:"/pages/b28288/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-2e17fd90").then(t)}},{path:"/pages/b28288/index.html",redirect:"/pages/b28288/"},{path:"/03.技术/05.面试笔记/03.高频面试.html",redirect:"/pages/b28288/"},{name:"v-29898959",path:"/pages/23b3cf/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-29898959").then(t)}},{path:"/pages/23b3cf/index.html",redirect:"/pages/23b3cf/"},{path:"/03.技术/05.面试笔记/80.面试经历/00.记第一次腾讯面试（惨疼）.html",redirect:"/pages/23b3cf/"},{name:"v-1a7cf4bc",path:"/pages/d67e98/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-1a7cf4bc").then(t)}},{path:"/pages/d67e98/index.html",redirect:"/pages/d67e98/"},{path:"/03.技术/05.面试笔记/80.面试经历/01.记第二次腾讯面试.html",redirect:"/pages/d67e98/"},{name:"v-4accbd96",path:"/pages/0f6bf1/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-4accbd96").then(t)}},{path:"/pages/0f6bf1/index.html",redirect:"/pages/0f6bf1/"},{path:"/03.技术/05.面试笔记/80.面试经历/02.腾讯面试题目.html",redirect:"/pages/0f6bf1/"},{name:"v-822e42c2",path:"/pages/88b3b7/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-822e42c2").then(t)}},{path:"/pages/88b3b7/index.html",redirect:"/pages/88b3b7/"},{path:"/03.技术/05.面试笔记/20.面试的准备.html",redirect:"/pages/88b3b7/"},{name:"v-9bccd544",path:"/pages/8b2440/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-9bccd544").then(t)}},{path:"/pages/8b2440/index.html",redirect:"/pages/8b2440/"},{path:"/03.技术/05.面试笔记/80.面试经历/03.奇安信笔试.html",redirect:"/pages/8b2440/"},{name:"v-60ec441d",path:"/pages/6edb2d/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-60ec441d").then(t)}},{path:"/pages/6edb2d/index.html",redirect:"/pages/6edb2d/"},{path:"/03.技术/06.工具使用/01.Nginx.html",redirect:"/pages/6edb2d/"},{name:"v-35949522",path:"/pages/e931bb/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-35949522").then(t)}},{path:"/pages/e931bb/index.html",redirect:"/pages/e931bb/"},{path:"/03.技术/06.工具使用/00.Git.html",redirect:"/pages/e931bb/"},{name:"v-a72e87c4",path:"/pages/1f82c9/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-a72e87c4").then(t)}},{path:"/pages/1f82c9/index.html",redirect:"/pages/1f82c9/"},{path:"/03.技术/06.工具使用/01.前端/00.VScode的使用.html",redirect:"/pages/1f82c9/"},{name:"v-6dc6a488",path:"/pages/fa218a/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-6dc6a488").then(t)}},{path:"/pages/fa218a/index.html",redirect:"/pages/fa218a/"},{path:"/03.技术/06.工具使用/02.Idea的使用.html",redirect:"/pages/fa218a/"},{name:"v-3e5a7f98",path:"/pages/1632a8/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-3e5a7f98").then(t)}},{path:"/pages/1632a8/index.html",redirect:"/pages/1632a8/"},{path:"/03.技术/06.工具使用/03.ES的使用.html",redirect:"/pages/1632a8/"},{name:"v-1741bda2",path:"/pages/c7e33c/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-1741bda2").then(t)}},{path:"/pages/c7e33c/index.html",redirect:"/pages/c7e33c/"},{path:"/03.技术/06.工具使用/05.PLSQL的使用.html",redirect:"/pages/c7e33c/"},{name:"v-a1218f50",path:"/pages/910866/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-a1218f50").then(t)}},{path:"/pages/910866/index.html",redirect:"/pages/910866/"},{path:"/03.技术/06.工具使用/10.docker/02.Docker基础_入门基础和Helloworld.html",redirect:"/pages/910866/"},{name:"v-551fc23c",path:"/pages/e09ac3/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-551fc23c").then(t)}},{path:"/pages/e09ac3/index.html",redirect:"/pages/e09ac3/"},{path:"/03.技术/06.工具使用/04.Typora的使用.html",redirect:"/pages/e09ac3/"},{name:"v-72bc6c96",path:"/pages/96abfe/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-72bc6c96").then(t)}},{path:"/pages/96abfe/index.html",redirect:"/pages/96abfe/"},{path:"/03.技术/06.工具使用/10.docker/00.Docker_Overview.html",redirect:"/pages/96abfe/"},{name:"v-ba42e26c",path:"/pages/1163f9/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-ba42e26c").then(t)}},{path:"/pages/1163f9/index.html",redirect:"/pages/1163f9/"},{path:"/03.技术/06.工具使用/10.docker/01.虚拟化技术.html",redirect:"/pages/1163f9/"},{name:"v-4b00cd86",path:"/pages/fac510/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-4b00cd86").then(t)}},{path:"/pages/fac510/index.html",redirect:"/pages/fac510/"},{path:"/03.技术/06.工具使用/10.docker/04.Docker基础_一个web应用实例.html",redirect:"/pages/fac510/"},{name:"v-60f033c1",path:"/pages/4cbf7b/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-60f033c1").then(t)}},{path:"/pages/4cbf7b/index.html",redirect:"/pages/4cbf7b/"},{path:"/03.技术/06.工具使用/10.docker/98.Dockerfile指令详解.html",redirect:"/pages/4cbf7b/"},{name:"v-6e5d990a",path:"/pages/4cf767/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-6e5d990a").then(t)}},{path:"/pages/4cf767/index.html",redirect:"/pages/4cf767/"},{path:"/03.技术/06.工具使用/10.docker/99.构建镜像.html",redirect:"/pages/4cf767/"},{name:"v-6c0dd964",path:"/pages/3c17ac/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-6c0dd964").then(t)}},{path:"/pages/3c17ac/index.html",redirect:"/pages/3c17ac/"},{path:"/03.技术/06.工具使用/10.docker/03.Docker基础_仓库镜像容器详解.html",redirect:"/pages/3c17ac/"},{name:"v-dce71a6e",path:"/pages/9fef0c/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-dce71a6e").then(t)}},{path:"/pages/9fef0c/index.html",redirect:"/pages/9fef0c/"},{path:"/03.技术/07.环境搭建/00.docker搭建halo博客.html",redirect:"/pages/9fef0c/"},{name:"v-82fe639c",path:"/pages/5cc41b/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-82fe639c").then(t)}},{path:"/pages/5cc41b/index.html",redirect:"/pages/5cc41b/"},{path:"/03.技术/07.环境搭建/01.SpringBoot项目搭建成jar包.html",redirect:"/pages/5cc41b/"},{name:"v-d5e0168a",path:"/pages/2daf7d/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-d5e0168a").then(t)}},{path:"/pages/2daf7d/index.html",redirect:"/pages/2daf7d/"},{path:"/03.技术/07.环境搭建/05.PLSQL的安装.html",redirect:"/pages/2daf7d/"},{name:"v-2f624b2e",path:"/pages/0a56c4/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-2f624b2e").then(t)}},{path:"/pages/0a56c4/index.html",redirect:"/pages/0a56c4/"},{path:"/03.技术/07.环境搭建/03.windows安装jekyll步骤及问题.html",redirect:"/pages/0a56c4/"},{name:"v-4880eaba",path:"/pages/63547b/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-4880eaba").then(t)}},{path:"/pages/63547b/index.html",redirect:"/pages/63547b/"},{path:"/03.技术/07.环境搭建/04.教你如何使用github+jsDelivr搭建免费图床 - 副本.html",redirect:"/pages/63547b/"},{name:"v-31054822",path:"/pages/370eba/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-31054822").then(t)}},{path:"/pages/370eba/index.html",redirect:"/pages/370eba/"},{path:"/03.技术/07.环境搭建/06.docker安装rabbitmq.html",redirect:"/pages/370eba/"},{name:"v-32b5c37d",path:"/pages/f4bf6d/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-32b5c37d").then(t)}},{path:"/pages/f4bf6d/index.html",redirect:"/pages/f4bf6d/"},{path:"/03.技术/07.环境搭建/07.docker搭建minio云盘.html",redirect:"/pages/f4bf6d/"},{name:"v-1f7e1d2a",path:"/pages/9cfdf3/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-1f7e1d2a").then(t)}},{path:"/pages/9cfdf3/index.html",redirect:"/pages/9cfdf3/"},{path:"/03.技术/07.环境搭建/20.vuepress博客搭建/02.vdoing主题搭建.html",redirect:"/pages/9cfdf3/"},{name:"v-aac523bc",path:"/pages/7f54e3/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-aac523bc").then(t)}},{path:"/pages/7f54e3/index.html",redirect:"/pages/7f54e3/"},{path:"/03.技术/07.环境搭建/20.vuepress博客搭建/04.引入gitalk评论.html",redirect:"/pages/7f54e3/"},{name:"v-37ac8ce7",path:"/pages/0bea88/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-37ac8ce7").then(t)}},{path:"/pages/0bea88/index.html",redirect:"/pages/0bea88/"},{path:"/03.技术/07.环境搭建/20.vuepress博客搭建/05.引入meting音乐播放器.html",redirect:"/pages/0bea88/"},{name:"v-288e2030",path:"/pages/555c24/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-288e2030").then(t)}},{path:"/pages/555c24/index.html",redirect:"/pages/555c24/"},{path:"/03.技术/07.环境搭建/20.vuepress博客搭建/01.vuepress搭建个人博客.html",redirect:"/pages/555c24/"},{name:"v-7a20c888",path:"/pages/ae1444/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-7a20c888").then(t)}},{path:"/pages/ae1444/index.html",redirect:"/pages/ae1444/"},{path:"/03.技术/07.环境搭建/20.vuepress博客搭建/03.引入全文搜索插件fulltext-sarch.html",redirect:"/pages/ae1444/"},{name:"v-46a61472",path:"/pages/d3988d/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-46a61472").then(t)}},{path:"/pages/d3988d/index.html",redirect:"/pages/d3988d/"},{path:"/03.技术/07.环境搭建/20.vuepress博客搭建/06.引入dynamic-title离开标签显示文字.html",redirect:"/pages/d3988d/"},{name:"v-7a7a5a41",path:"/pages/599c9d/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-7a7a5a41").then(t)}},{path:"/pages/599c9d/index.html",redirect:"/pages/599c9d/"},{path:"/03.技术/07.环境搭建/20.vuepress博客搭建/20.Vdoing主题丰富自己的笔记.html",redirect:"/pages/599c9d/"},{name:"v-76fb83c4",path:"/pages/0d18d5/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-76fb83c4").then(t)}},{path:"/pages/0d18d5/index.html",redirect:"/pages/0d18d5/"},{path:"/03.技术/08.项目笔记/00.若依笔记/00.若依框架笔记.html",redirect:"/pages/0d18d5/"},{name:"v-7e08e799",path:"/pages/2c4811/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-7e08e799").then(t)}},{path:"/pages/2c4811/index.html",redirect:"/pages/2c4811/"},{path:"/03.技术/07.环境搭建/20.vuepress博客搭建/30.vuepress编译时报错TypeError _normalized undefined的解决.html",redirect:"/pages/2c4811/"},{name:"v-fa94273a",path:"/pages/2ca9b2/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-fa94273a").then(t)}},{path:"/pages/2ca9b2/index.html",redirect:"/pages/2ca9b2/"},{path:"/03.技术/08.项目笔记/01.绿色健康答疑系统.html",redirect:"/pages/2ca9b2/"},{name:"v-6e10f0cd",path:"/pages/8945e1/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-6e10f0cd").then(t)}},{path:"/pages/8945e1/index.html",redirect:"/pages/8945e1/"},{path:"/03.技术/09.谷歌插件/00.音量调解.html",redirect:"/pages/8945e1/"},{name:"v-1444ff88",path:"/pages/f2a556/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-1444ff88").then(t)}},{path:"/pages/f2a556/index.html",redirect:"/pages/f2a556/"},{path:"/04.更多/01.学习/00.费曼学习法.html",redirect:"/pages/f2a556/"},{name:"v-4e774dac",path:"/pages/a8692ab3bdcb4588/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-4e774dac").then(t)}},{path:"/pages/a8692ab3bdcb4588/index.html",redirect:"/pages/a8692ab3bdcb4588/"},{path:"/04.更多/01.学习/02.提高学习效率的策略.html",redirect:"/pages/a8692ab3bdcb4588/"},{name:"v-6ed06e8c",path:"/pages/e60c81/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-6ed06e8c").then(t)}},{path:"/pages/e60c81/index.html",redirect:"/pages/e60c81/"},{path:"/04.更多/01.学习/01.笔记方法.html",redirect:"/pages/e60c81/"},{name:"v-29d3ff9f",path:"/pages/c3f302a03c8daf79/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-29d3ff9f").then(t)}},{path:"/pages/c3f302a03c8daf79/index.html",redirect:"/pages/c3f302a03c8daf79/"},{path:"/04.更多/01.学习/04.自律小建议.html",redirect:"/pages/c3f302a03c8daf79/"},{name:"v-15feff80",path:"/pages/ce818a/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-15feff80").then(t)}},{path:"/pages/ce818a/index.html",redirect:"/pages/ce818a/"},{path:"/04.更多/01.学习/10.搜索引擎使用技巧.html",redirect:"/pages/ce818a/"},{name:"v-45d858b5",path:"/pages/996822b2a2ca6e3b/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-45d858b5").then(t)}},{path:"/pages/996822b2a2ca6e3b/index.html",redirect:"/pages/996822b2a2ca6e3b/"},{path:"/04.更多/01.学习/03.提高记忆的技巧.html",redirect:"/pages/996822b2a2ca6e3b/"},{name:"v-c69d916e",path:"/pages/9ba2b8fb13de1957/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-c69d916e").then(t)}},{path:"/pages/9ba2b8fb13de1957/index.html",redirect:"/pages/9ba2b8fb13de1957/"},{path:"/04.更多/01.学习/05.处理问题的思路.html",redirect:"/pages/9ba2b8fb13de1957/"},{name:"v-98490bfe",path:"/pages/2d615df9a36a98ed/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-98490bfe").then(t)}},{path:"/pages/2d615df9a36a98ed/index.html",redirect:"/pages/2d615df9a36a98ed/"},{path:"/04.更多/05.心情杂货/01.一个完美主义者的自我救赎.html",redirect:"/pages/2d615df9a36a98ed/"},{name:"v-b70d62ba",path:"/pages/d6d331/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-b70d62ba").then(t)}},{path:"/pages/d6d331/index.html",redirect:"/pages/d6d331/"},{path:"/04.更多/05.心情杂货/10.反向拆解让人上瘾的套路，找回自律.html",redirect:"/pages/d6d331/"},{name:"v-4a693b12",path:"/pages/baaa02/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-4a693b12").then(t)}},{path:"/pages/baaa02/index.html",redirect:"/pages/baaa02/"},{path:"/04.更多/10.实用技巧/01.2分钟规则.html",redirect:"/pages/baaa02/"},{name:"v-7de57f53",path:"/pages/aea6571b7a8bae86/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-7de57f53").then(t)}},{path:"/pages/aea6571b7a8bae86/index.html",redirect:"/pages/aea6571b7a8bae86/"},{path:"/04.更多/03.面试/01.面试问题集锦.html",redirect:"/pages/aea6571b7a8bae86/"},{name:"v-a0b08d08",path:"/friends/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-a0b08d08").then(t)}},{path:"/friends/index.html",redirect:"/friends/"},{path:"/04.更多/99.友情链接.html",redirect:"/friends/"},{name:"v-331c4066",path:"/about/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-331c4066").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/05.关于/01.关于.html",redirect:"/about/"},{name:"v-407767e1",path:"/pages/f2e63f/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-407767e1").then(t)}},{path:"/pages/f2e63f/index.html",redirect:"/pages/f2e63f/"},{path:"/_posts/随笔/你知道的越多，不知道的也就越多.html",redirect:"/pages/f2e63f/"},{name:"v-cd88a6aa",path:"/pages/beb6c0bd8a66cea6/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-cd88a6aa").then(t)}},{path:"/pages/beb6c0bd8a66cea6/index.html",redirect:"/pages/beb6c0bd8a66cea6/"},{path:"/06.收藏夹/01.网站.html",redirect:"/pages/beb6c0bd8a66cea6/"},{name:"v-68b82861",path:"/pages/cd8bde/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-68b82861").then(t)}},{path:"/pages/cd8bde/index.html",redirect:"/pages/cd8bde/"},{path:"/_posts/随笔/拥抱生活，拥抱快乐.html",redirect:"/pages/cd8bde/"},{name:"v-e1e3bd88",path:"/categories/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-e1e3bd88").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-776b15dc",path:"/tags/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-776b15dc").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-671ae95c",path:"/archives/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-671ae95c").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-5bd48070",path:"/",component:Tt,beforeEnter:function(n,e,t){he("Layout","v-5bd48070").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:Tt}],Ct={title:"CY blog",description:"CY,长印,技术博客,java,Spring,SpringBoot,SpringCloud,git,github等技术文章。",base:"/myBlog",headTags:[["link",{rel:"icon",href:"/myBlogimg/favicon.ico"}],["meta",{name:"keywords",content:"CY,长印,技术博客,java,Spring,SpringBoot,SpringCloud,git,github等技术文章。"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#11a8cd"}],["script",{"data-ad-client":"ca-pub-7828333725993554",async:"async",src:"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"}],[["script",{language:"javascript",type:"text/javascript",src:"/js/pgmanor-self.js"}]]],pages:[{title:"后端",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.后端",imgUrl:"/img/web.png",description:"java、数据库、linux、Spring框架等后端技术"}},title:"后端",date:"2020-03-11T21:50:53.000Z",permalink:"/back-end",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%90%8E%E7%AB%AF.html",relativePath:"00.目录页/01.后端.md",key:"v-43889aea",path:"/back-end/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/13, 12:33:23"},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"04.更多",imgUrl:"/img/more.png",description:"学习、面试、在线工具等更多文章和页面"}},title:"更多",date:"2020-03-11T21:50:56.000Z",permalink:"/more",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E6%9B%B4%E5%A4%9A.html",relativePath:"00.目录页/04.更多.md",key:"v-1b5ef630",path:"/more/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/13, 12:33:23"},{title:"项目笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.前端",imgUrl:"/img/ui.png",description:"前端、JS、layui、Html等"}},title:"项目笔记",date:"2020-03-11T21:50:54.000Z",permalink:"/web",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E5%89%8D%E7%AB%AF.html",relativePath:"00.目录页/02.前端.md",key:"v-af46de00",path:"/web/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/13, 18:28:04"},{title:"技术",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"03.技术",imgUrl:"/img/other.png",description:"技术文档、教程、技巧、总结等文章"}},title:"技术",date:"2020-03-11T21:50:55.000Z",permalink:"/technology",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%8A%80%E6%9C%AF.html",relativePath:"00.目录页/03.技术.md",key:"v-3d5634c4",path:"/technology/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/13, 12:33:23"},{title:"工具的使用",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"03.技术/06.工具使用",imgUrl:"/img/more.png",description:"各种工具的搭建、使用"}},title:"工具的使用",date:"2020-03-11T21:50:56.000Z",permalink:"/tool",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/12.%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"00.目录页/12.工具的使用.md",key:"v-35224e19",path:"/tool/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/13, 12:33:23"},{title:"面试笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"03.技术/13.面试笔记",imgUrl:"/img/more.png",description:"java、框架、面试、笔记、技术"}},title:"面试笔记",date:"2020-03-11T21:50:56.000Z",permalink:"/interview",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/13.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html",relativePath:"00.目录页/13.面试笔记.md",key:"v-1d4719ac",path:"/interview/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/13, 12:33:23"},{title:"java线程",frontmatter:{title:"java线程",date:"2021-07-11T20:30:16.000Z",permalink:"/pages/c22e6b/",categories:["后端","java"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/00.java/04.java%E7%BA%BF%E7%A8%8B.html",relativePath:"01.后端/00.java/04.java线程.md",key:"v-39efffc4",path:"/pages/c22e6b/",headersStr:null,content:'# java多线程\n\n练习一：试用多线程完成数字1-1000的打印，10个并发线程，每个线程打印的数字不能重复，多个线程打印的数字要求保证顺序。\n\n/**\n * 试用多线程完成数字1-1000的打印，10个并发线程，每个线程打印的数字不能重复，多个线程打印的数字要求保证顺序。\n */\npublic class Demo3 {\n    public static void main(String[] args) {\n        Object object=new Object();\n        for (int i = 0; i < 10; i++) {\n            new Thread(new MyThread(object)).start();\n        }\n    }\n}\nclass MyThread implements Runnable{\n    private Object object;//锁对象\n    private static int num=0;//打印数\n\n    public MyThread(Object object){\n        this.object=object;\n    }\n    @Override\n    public void run() {\n            while (num<1000){\n                synchronized (object) {\n                    object.notify();//唤醒其他线程\n                    if(num<1000){//双重判断 防止超过1000\n                        for (int i = 0; i < 10; i++) {//一个线程输出10\n                            System.out.println(Thread.currentThread().getName()  + " num:" + ++num);\n                        }\n//                        System.out.println(Thread.currentThread().getName()  + " num:" + ++num);\n                        try {\n                            object.wait();//释放CPU 让给其他线程打印\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n            }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n',normalizedContent:'# java多线程\n\n练习一：试用多线程完成数字1-1000的打印，10个并发线程，每个线程打印的数字不能重复，多个线程打印的数字要求保证顺序。\n\n/**\n * 试用多线程完成数字1-1000的打印，10个并发线程，每个线程打印的数字不能重复，多个线程打印的数字要求保证顺序。\n */\npublic class demo3 {\n    public static void main(string[] args) {\n        object object=new object();\n        for (int i = 0; i < 10; i++) {\n            new thread(new mythread(object)).start();\n        }\n    }\n}\nclass mythread implements runnable{\n    private object object;//锁对象\n    private static int num=0;//打印数\n\n    public mythread(object object){\n        this.object=object;\n    }\n    @override\n    public void run() {\n            while (num<1000){\n                synchronized (object) {\n                    object.notify();//唤醒其他线程\n                    if(num<1000){//双重判断 防止超过1000\n                        for (int i = 0; i < 10; i++) {//一个线程输出10\n                            system.out.println(thread.currentthread().getname()  + " num:" + ++num);\n                        }\n//                        system.out.println(thread.currentthread().getname()  + " num:" + ++num);\n                        try {\n                            object.wait();//释放cpu 让给其他线程打印\n                        } catch (interruptedexception e) {\n                            e.printstacktrace();\n                        }\n                    }\n                }\n            }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n',charsets:{cjk:!0},lastUpdated:"2021/07/13, 18:28:04"},{title:"java流的操作",frontmatter:{title:"java流的操作",date:"2021-07-09T14:32:09.000Z",permalink:"/pages/501d3a/",categories:["后端","java"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/00.java/01.java%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C.html",relativePath:"01.后端/00.java/01.java流的操作.md",key:"v-497c4d75",path:"/pages/501d3a/",headers:[{level:2,title:"一.File类（主要是与文件路径进行绑定）",slug:"一-file类-主要是与文件路径进行绑定",normalizedTitle:"一.file类（主要是与文件路径进行绑定）",charIndex:2},{level:2,title:"二.字节流和字符流",slug:"二-字节流和字符流",normalizedTitle:"二.字节流和字符流",charIndex:3746},{level:2,title:"三.流的高级处理",slug:"三-流的高级处理",normalizedTitle:"三.流的高级处理",charIndex:5356}],headersStr:"一.File类（主要是与文件路径进行绑定） 二.字节流和字符流 三.流的高级处理",content:'# 一.File类（主要是与文件路径进行绑定）\n\n参考：点击 1、File 类的基本介绍\n\nFile 类是文件和目录路径名的抽象表示，一个 File 对象的建立不等于创建了一个文件或者目录，而是指与文件或者目录建立了联系，通过 File 类的对象可以访问文件的属性、创建空文件和目录、以及删除文件和目录等操作。 2.File类的两个常量\n\n 1. File.pathSeparator 表示系统默认路径分隔符，Windows 中使用“;”表示，Linux中使用“:”表示；\n 2. File.separator 表示系统默认名称分隔符，Windows 中使用“\\”表示，Linux中使用“/”表示。\n\n在开发中推荐大家使用“”/”来做目录名称的分隔符，不管是什么系统都可以使用比如：“D:/Download/image/tomcat.png”。\n\n@Test\n  public void test2()\n    // 路径分隔符 windows(;) linux(:)\n    System.out.println(File.pathSeparator); \n    // 名称分隔符 windows(\\) linux(/)\n    System.out.println(File.separator); \n    // 路径的几种表示形式\n    // windows 的方式\n    String path = "D:\\\\Download\\\\image\\\\tomcat.png"; \n    // 动态生成推荐使用这种方式\n    path = "D:" + File.separator + "Download" + File.separator + "image" + File.separator + "tomcat.png"; \n    // 推荐使用的方式，什么平台都能用\n    path = "D:/Download/image/tomcat.png"; \n    System.out.println(path);\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n3.使用 File 类进行文件的判断操作\n\n@Test\n  public void test3() {\n    String path = "D:/Download/image/tomcat.png";\n    File file = new File(path);  // 建立与文件的联系\n    System.out.println("文件是否存在：" + file.exists());\n    System.out.println("文件是否是文件：" + file.isFile());\n    System.out.println("文件是否是文件夹：" + file.isDirectory());\n    // 返回字节数，如果是文件夹则读不出来长度\n    System.out.println("文件的长度是：" + file.length());\n    System.out.println("文件是否可写：" + file.canWrite());\n    System.out.println("文件是否可读：" + file.canRead());\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n4.使用 File 类进行文件的创建与删除\n\n@Test\n  public void test4() throws IOException, InterruptedException {\n    String path = "D:/Download/image/tomcat.jpg";\n    File file = new File(path); // 建立文件的联系\n    if (!file.exists()) {\n      boolean flag = file.createNewFile(); // 文件不存在则创建新文件，存在则返回false\n      System.out.println(flag ? "文件创建成功" : "文件创建失败");\n    }\n    if (file.exists()) {\n      boolean flag = file.delete(); // 文件不存在返回false\n      System.out.println(flag ? "文件删除成功" : "文件删除失败");\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n5.使用 File 类进行目录的操作 file.mkdir()创建文件\nfile.mkdirs()递归创建文件\n\n\n@Test\n  public void test5() throws IOException, InterruptedException {\n    // 本地存在pic目录，但是没有photo和2020目录\n    String path = "D:/Download/image/pic/photo/2020";\n    File file = new File(path);\n    System.out.println(file.mkdir()); // false\n    System.out.println(file.mkdirs()); // true\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n6.使用 File 类列出指定目录下的文件\n\n 1. 在日常开发中，列出目录下的文件这个功能经常会用到，用 File[] listFiles() 方法可以列出目录下的文件或者文件夹，返回的是文件数组。通过循环遍历返回的文件数组就可以获取到每一个文件或者文件夹。listFiles() 方法使用的比较多。\n 2. 还有一个 String[] list() 方法，它可以列出目录下的文件或者文件夹的名称，这个在开发中不常用。\n\n@Test\n  public void test6() {\n    String path = "D:/Download/txt";\n    File file = new File(path);\n    if (file.exists()) {\n      // 列出指定目录下的文件或目录的名称字符串数组，不常用\n      String[] fileNmaes = file.list();\n      System.out.println(Arrays.deepToString(fileNmaes));\n      // 列出指定目录下的文件或目录的File对象数组，常用方法\n      File[] files = file.listFiles();\n      if (files != null) {\n        for (File f : files) {\n          System.out.println(f);\n        }\n      }\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n7.综合案例：列出指定目录下的全部内容 列出某个文件夹下面的所有文件\n\n@Test\n  public void test7() {\n    String path = "D:/Download/txt";\n    File file = new File(path);\n    print(file);\n  }\n\n  // 递归方法输出指定目录下的文件内容\n  public static void print(File file) {\n    if (file != null && file.exists()) {\n      if (file.isDirectory()) {\n        // 如果是目录的话，首先输出路径，然后继续获取该目录下的内容\n        System.out.println(file);\n        File[] files = file.listFiles();\n        if (files != null) { // for循环前判空是个良好的开发习惯\n          for (File f : files) {\n            print(f); // 递归的函数体内要调用自己\n          }\n        }\n      } else {// 直接打印文件的绝对路径，也就是递归结束的条件\n        System.out.println(file);\n      }\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 二.字节流和字符流\n\n参考：点击 1.IO 操作的套路 Java 中 IO 操作也是有套路的，有标准的操作步骤，主要的操作步骤如下： 1、使用 File 类与文件建立联系 2、选择对应的输入流或者输出流 3、进行读或写操作 4、关闭资源 2.字节流（可以对任何文件进行读写） 　在 Java 中 字节输入流用 InputStream 表示，字节输出流用 OutputStream 表示。 使用字节流进行拷贝文件\n\n@Test\n  public void testCopy() throws IOException {\n    // 1、使用File类与文件建立联系\n    File srcFile = new File("D:/file/image/tomcat.png");\n    File destFile = new File("D:/file/image/tomcat1.jpg");\n    // 2、选择对应的输入流或者输出流\n    InputStream is = new FileInputStream(srcFile);\n    OutputStream os = new FileOutputStream(destFile);\n      // 3、进行读或写操作\n      byte[] b = new byte[1024];\n      int len = 0;\n      while ((len = is.read(b)) != -1) {\n        // 判断每次读取的内容长度，如果不等于-1，表示文件没有读完\n        // 选择带参数的write方法，就是为了避免byte缓存比实际内容多的时候，输出多余的空内容\n        os.write(b, 0, len);\n      }\n    os.flush();\n    // 4、关闭资源，先创建的后关闭\n    os.close();\n    is.close();\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n3.字符流FileReader、FileWrite（只允许对纯文本文件读写）\n\n@Test\n  public void testTxtCopy() throws IOException {\n    // 1、使用File类与文件建立联系\n    File srcFile = new File("D:/file/txt/output_char.txt");\n    File destFile = new File("D:/file/txt/output_char1.txt");\n    // 2、选择对应的输入流或者输出流\n    Reader read = new FileReader(srcFile);\n    Writer write = new FileWriter(destFile);\n    // 3、进行读写操作\n    char[] cbuf = new char[1024];\n    int len = 0;\n    while ((len = read.read(cbuf)) != -1) {\n      write.write(cbuf, 0, len); //将一个字符数组输出\n    }\n    write.flush();\n    // 4、关闭资源\n    write.close();\n    read.close();\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n4.字节流和字符流的区别\n\n 1. 字节流可以对任何文件进行操作，字符流只允许对纯文本文件操作\n 2. 字符流会使用缓存区\n\n\n# 三.流的高级处理\n\n参考：点击 1.缓冲流 因为缓冲流可以提高文件操作的性能，所以在以后的开发中，大家尽量要用缓冲流对节点流进行包装，不要直接使用字节流和字符流去操作文件。 　1.1字节缓冲流BufferedInputStream和BufferedOutputStream\n\n@Test\n  public void testCopy() throws IOException {\n    // 1、使用File类与文件建立联系\n    File src = new File("D:/file/image/tomcat.png");\n    File dest = new File("D:/file/image/tomcat2.jpg");\n    // 2、选择对应的输入流或者输出流\n    InputStream is = new BufferedInputStream(new FileInputStream(src)); // 用缓冲流包裹节点流\n    OutputStream os = new BufferedOutputStream(new FileOutputStream(dest)); // 用缓冲流包裹节点流\n    // 3、进行读写操作\n    byte[] b = new byte[1024];\n    int len = 0;\n    while ((len = is.read(b)) != -1) {\n      os.write(b, 0, len);\n    }\n    os.flush();\n    // 4、关闭资源\n    os.close();\n    is.close();\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n1.2字符缓冲流BufferedReader 和BufferedWriter\n\n/**\n   * 字符缓冲流只能处理纯文本的copy\n   */\n  @Test\n  public void testCopy1() throws IOException {\n    // 1、使用File类与文件建立联系\n    File src = new File("D:/file/txt/output_char.txt");\n    File dest = new File("D:/file/image/output_char_coppy.txt");\n    // 2、选择对应的输入流或者输出流\n    // 想使用新增的readLine方法（不能发生多态）\n    BufferedReader reader = new BufferedReader(new FileReader(src));// 用缓冲流包裹节点流\n    BufferedWriter writer = new BufferedWriter(new FileWriter(dest, true));// 用缓冲流包裹节点流\n    // 3、进行读或写操作\n    String line = null;\n    while ((line = reader.readLine()) != null) {\n      writer.write(line);\n      writer.newLine(); // 类似于writer.append("\\r\\n");\n    }\n    writer.flush(); // 强制刷出\n    // 4、关闭资源\n    writer.close();\n    reader.close();\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n2.转换流：InputStreamReader和OutputStreamWriter 作用:把字节流转换为字符流，因为字符流没办法进行编码设置，所以可以先通过字节流设置字符，然后转换为字符流。\n\n/**\n   * 转换流：字节转为字符<br>\n   * 1、输入流 InputStreamReader 解码<br>\n   * 2、输出流 OutputStreamWriter 编码<br>\n   * 仔细体会注释的文字\n   */\n  @Test\n  public void test2() throws IOException {\n    String srcPath = "D:/file/txt/output_char.txt";\n    String destPath = "D:/file/txt/output_char_convert.txt";\n    // FileReader（字符流）不能解码，FileInputStream（字节流）才能解码\n//    BufferedReader br = new BufferedReader(new FileReader(new File(srcPath)));  \n    // 字符流FileReader要换成字节流FileInputStream，但是字节流与字符流不能直接操作，需要通过转换流InputStreamReader来实现\n    BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(srcPath)), "UTF-8")); // 指定解码字符集\n    // FileWriter（字符流）不能编码，FileOutputStream（字节流）才能编码\n//    BufferedWriter writer = new BufferedWriter(new FileWriter(new File(destPath))); \n    // 字符流FileWriter要换成字节流FileOutputStream，但是字节流与字符流不能直接操作，需要通过转换流OutputStreamWriter来实现\n    BufferedWriter wr = new BufferedWriter(\n        new OutputStreamWriter(new FileOutputStream(new File(destPath)), "UTF-8"));// 指定编码字符集\n    // 读取并写出\n    String line = null;\n    while ((line = br.readLine()) != null) {\n      wr.write(line);\n      wr.newLine();\n    }\n    wr.flush();\n    wr.close();\n    br.close();\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n3.数据处理流:DataInputStream 和DataOutputStream 主要是处理java的基本数据类型和String类型\n\n@Test\n  public void test() throws IOException {\n    write("D:/file/txt/data.txt"); // 写到文件\n    read("D:/file/txt/data.txt"); // 从文件读取\n  }\n  /**\n   * 基本数据类型+String类型输出到文件\n   */\n  public static void write(String destPath) throws IOException {\n    int intNum = 100;\n    long longNum = 999L;\n    float floatNum = 3.14f;\n    double doubleNum = 5.50;\n    String str = "基本数据类型+String类型输出到文件";\n    File dest = new File(destPath);\n    DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(dest)));\n    // 操作：注意写出的顺序，读取要和写出的顺序一致\n    dos.writeInt(intNum);\n    dos.writeLong(longNum);\n    dos.writeFloat(floatNum);\n    dos.writeDouble(doubleNum);\n    dos.writeUTF(str);\n    dos.flush();\n    dos.close();\n  }\n  /**\n   * 从文件里读取基本数据类型+String类型\n   */\n  public static void read(String srcPath) throws IOException {\n    File src = new File(srcPath);\n    DataInputStream dis = new DataInputStream(new BufferedInputStream(new FileInputStream(src)));\n    int intNum = dis.readInt();\n    long longNum = dis.readLong();\n    float floatNum = dis.readFloat();\n    double doubleNum = dis.readDouble();\n    String str = dis.readUTF();\n    dis.close();\n    // 100----\x3e999----\x3e3.14----\x3e5.5----\x3e基本数据类型+String类型输出到文件\n    System.out.println(intNum + "----\x3e" + longNum + "----\x3e" + floatNum + "----\x3e" + doubleNum + "----\x3e" + str);\n  }  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n4.对象处理流:ObjectOutputStream和ObjectInputStream 　对象处理流就是我们常说的对象序列号，要想对对象读写首先对象要实现Serializable 接口，通过设置一个serialVersionUID 常亮，防止反序列化的时候出现问题。 　为了减少保存对象的使用空间，可以把一个类的某个属性设置为不被序列化，当实现 Serializable 接口实现序列化的时候，可以使用 transient 关键字进行声明。\n\n/**\n   * 对象的序列化以及反序列化操作\n   */\n  @Test\n  public void test() throws FileNotFoundException, IOException, ClassNotFoundException {\n    String filePath = "D:/file/txt/object.txt";\n    serializa(filePath);\n    Object object = UnSerializa(filePath);\n    if (object instanceof User) {\n      object = (User) object;\n    }\n    // User [name=JPM, age=18, address=null]，因为address属性被transient修饰，没有被序列化，所以为null\n    System.out.println(object.toString());\n  }\n \n \n  /**\n   * 对象序列化：对象变为二进制流的方法\n   */\n  public static void serializa(String destPath) throws FileNotFoundException, IOException {\n    File dest = new File(destPath);\n    ObjectOutputStream oos = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(dest)));\n    User user = new User("JPM", 18, "中国，北京！");\n    oos.writeObject(user);\n    oos.flush();\n    oos.close();\n  }\n \n \n  /**\n   * 对象反序列化：使用对象输入流读取对象数据\n   */\n  public static Object UnSerializa(String srcPath) throws FileNotFoundException, IOException, ClassNotFoundException {\n    Object object = null;\n    File scr = new File(srcPath);\n    ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(new FileInputStream(scr)));\n    object = ois.readObject();\n    ois.close();\n    return object;\n  }\n  \n/**\n * 序列化与反序列化的对象，必须实现Serializable接口\n */\npublic class User implements Serializable {\n \n \n  private static final long serialVersionUID = -6954786920974801199L;\n \n \n  private String name;\n  private int age;\n  // transient修饰的属性不会被序列化\n  private transient String address; \n \n \n  public User() {\n    super();\n  }\n \n \n  public User(String name, int age, String address) {\n    super();\n    this.name = name;\n    this.age = age;\n    this.address = address;\n  }\n \n \n  public String getName() {\n    return name;\n  }\n \n \n  public void setName(String name) {\n    this.name = name;\n  }\n \n \n  public int getAge() {\n    return age;\n  }\n \n \n  public void setAge(int age) {\n    this.age = age;\n  }\n \n \n  public String getAddress() {\n    return address;\n  }\n \n \n  public void setAddress(String address) {\n    this.address = address;\n  }\n \n \n  @Override\n  public String toString() {\n    return "User [name=" + name + ", age=" + age + ", address=" + address + "]";\n  }\n \n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n',normalizedContent:'# 一.file类（主要是与文件路径进行绑定）\n\n参考：点击 1、file 类的基本介绍\n\nfile 类是文件和目录路径名的抽象表示，一个 file 对象的建立不等于创建了一个文件或者目录，而是指与文件或者目录建立了联系，通过 file 类的对象可以访问文件的属性、创建空文件和目录、以及删除文件和目录等操作。 2.file类的两个常量\n\n 1. file.pathseparator 表示系统默认路径分隔符，windows 中使用“;”表示，linux中使用“:”表示；\n 2. file.separator 表示系统默认名称分隔符，windows 中使用“\\”表示，linux中使用“/”表示。\n\n在开发中推荐大家使用“”/”来做目录名称的分隔符，不管是什么系统都可以使用比如：“d:/download/image/tomcat.png”。\n\n@test\n  public void test2()\n    // 路径分隔符 windows(;) linux(:)\n    system.out.println(file.pathseparator); \n    // 名称分隔符 windows(\\) linux(/)\n    system.out.println(file.separator); \n    // 路径的几种表示形式\n    // windows 的方式\n    string path = "d:\\\\download\\\\image\\\\tomcat.png"; \n    // 动态生成推荐使用这种方式\n    path = "d:" + file.separator + "download" + file.separator + "image" + file.separator + "tomcat.png"; \n    // 推荐使用的方式，什么平台都能用\n    path = "d:/download/image/tomcat.png"; \n    system.out.println(path);\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n3.使用 file 类进行文件的判断操作\n\n@test\n  public void test3() {\n    string path = "d:/download/image/tomcat.png";\n    file file = new file(path);  // 建立与文件的联系\n    system.out.println("文件是否存在：" + file.exists());\n    system.out.println("文件是否是文件：" + file.isfile());\n    system.out.println("文件是否是文件夹：" + file.isdirectory());\n    // 返回字节数，如果是文件夹则读不出来长度\n    system.out.println("文件的长度是：" + file.length());\n    system.out.println("文件是否可写：" + file.canwrite());\n    system.out.println("文件是否可读：" + file.canread());\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n4.使用 file 类进行文件的创建与删除\n\n@test\n  public void test4() throws ioexception, interruptedexception {\n    string path = "d:/download/image/tomcat.jpg";\n    file file = new file(path); // 建立文件的联系\n    if (!file.exists()) {\n      boolean flag = file.createnewfile(); // 文件不存在则创建新文件，存在则返回false\n      system.out.println(flag ? "文件创建成功" : "文件创建失败");\n    }\n    if (file.exists()) {\n      boolean flag = file.delete(); // 文件不存在返回false\n      system.out.println(flag ? "文件删除成功" : "文件删除失败");\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n5.使用 file 类进行目录的操作 file.mkdir()创建文件\nfile.mkdirs()递归创建文件\n\n\n@test\n  public void test5() throws ioexception, interruptedexception {\n    // 本地存在pic目录，但是没有photo和2020目录\n    string path = "d:/download/image/pic/photo/2020";\n    file file = new file(path);\n    system.out.println(file.mkdir()); // false\n    system.out.println(file.mkdirs()); // true\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n6.使用 file 类列出指定目录下的文件\n\n 1. 在日常开发中，列出目录下的文件这个功能经常会用到，用 file[] listfiles() 方法可以列出目录下的文件或者文件夹，返回的是文件数组。通过循环遍历返回的文件数组就可以获取到每一个文件或者文件夹。listfiles() 方法使用的比较多。\n 2. 还有一个 string[] list() 方法，它可以列出目录下的文件或者文件夹的名称，这个在开发中不常用。\n\n@test\n  public void test6() {\n    string path = "d:/download/txt";\n    file file = new file(path);\n    if (file.exists()) {\n      // 列出指定目录下的文件或目录的名称字符串数组，不常用\n      string[] filenmaes = file.list();\n      system.out.println(arrays.deeptostring(filenmaes));\n      // 列出指定目录下的文件或目录的file对象数组，常用方法\n      file[] files = file.listfiles();\n      if (files != null) {\n        for (file f : files) {\n          system.out.println(f);\n        }\n      }\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n7.综合案例：列出指定目录下的全部内容 列出某个文件夹下面的所有文件\n\n@test\n  public void test7() {\n    string path = "d:/download/txt";\n    file file = new file(path);\n    print(file);\n  }\n\n  // 递归方法输出指定目录下的文件内容\n  public static void print(file file) {\n    if (file != null && file.exists()) {\n      if (file.isdirectory()) {\n        // 如果是目录的话，首先输出路径，然后继续获取该目录下的内容\n        system.out.println(file);\n        file[] files = file.listfiles();\n        if (files != null) { // for循环前判空是个良好的开发习惯\n          for (file f : files) {\n            print(f); // 递归的函数体内要调用自己\n          }\n        }\n      } else {// 直接打印文件的绝对路径，也就是递归结束的条件\n        system.out.println(file);\n      }\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 二.字节流和字符流\n\n参考：点击 1.io 操作的套路 java 中 io 操作也是有套路的，有标准的操作步骤，主要的操作步骤如下： 1、使用 file 类与文件建立联系 2、选择对应的输入流或者输出流 3、进行读或写操作 4、关闭资源 2.字节流（可以对任何文件进行读写） 　在 java 中 字节输入流用 inputstream 表示，字节输出流用 outputstream 表示。 使用字节流进行拷贝文件\n\n@test\n  public void testcopy() throws ioexception {\n    // 1、使用file类与文件建立联系\n    file srcfile = new file("d:/file/image/tomcat.png");\n    file destfile = new file("d:/file/image/tomcat1.jpg");\n    // 2、选择对应的输入流或者输出流\n    inputstream is = new fileinputstream(srcfile);\n    outputstream os = new fileoutputstream(destfile);\n      // 3、进行读或写操作\n      byte[] b = new byte[1024];\n      int len = 0;\n      while ((len = is.read(b)) != -1) {\n        // 判断每次读取的内容长度，如果不等于-1，表示文件没有读完\n        // 选择带参数的write方法，就是为了避免byte缓存比实际内容多的时候，输出多余的空内容\n        os.write(b, 0, len);\n      }\n    os.flush();\n    // 4、关闭资源，先创建的后关闭\n    os.close();\n    is.close();\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n3.字符流filereader、filewrite（只允许对纯文本文件读写）\n\n@test\n  public void testtxtcopy() throws ioexception {\n    // 1、使用file类与文件建立联系\n    file srcfile = new file("d:/file/txt/output_char.txt");\n    file destfile = new file("d:/file/txt/output_char1.txt");\n    // 2、选择对应的输入流或者输出流\n    reader read = new filereader(srcfile);\n    writer write = new filewriter(destfile);\n    // 3、进行读写操作\n    char[] cbuf = new char[1024];\n    int len = 0;\n    while ((len = read.read(cbuf)) != -1) {\n      write.write(cbuf, 0, len); //将一个字符数组输出\n    }\n    write.flush();\n    // 4、关闭资源\n    write.close();\n    read.close();\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n4.字节流和字符流的区别\n\n 1. 字节流可以对任何文件进行操作，字符流只允许对纯文本文件操作\n 2. 字符流会使用缓存区\n\n\n# 三.流的高级处理\n\n参考：点击 1.缓冲流 因为缓冲流可以提高文件操作的性能，所以在以后的开发中，大家尽量要用缓冲流对节点流进行包装，不要直接使用字节流和字符流去操作文件。 　1.1字节缓冲流bufferedinputstream和bufferedoutputstream\n\n@test\n  public void testcopy() throws ioexception {\n    // 1、使用file类与文件建立联系\n    file src = new file("d:/file/image/tomcat.png");\n    file dest = new file("d:/file/image/tomcat2.jpg");\n    // 2、选择对应的输入流或者输出流\n    inputstream is = new bufferedinputstream(new fileinputstream(src)); // 用缓冲流包裹节点流\n    outputstream os = new bufferedoutputstream(new fileoutputstream(dest)); // 用缓冲流包裹节点流\n    // 3、进行读写操作\n    byte[] b = new byte[1024];\n    int len = 0;\n    while ((len = is.read(b)) != -1) {\n      os.write(b, 0, len);\n    }\n    os.flush();\n    // 4、关闭资源\n    os.close();\n    is.close();\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n1.2字符缓冲流bufferedreader 和bufferedwriter\n\n/**\n   * 字符缓冲流只能处理纯文本的copy\n   */\n  @test\n  public void testcopy1() throws ioexception {\n    // 1、使用file类与文件建立联系\n    file src = new file("d:/file/txt/output_char.txt");\n    file dest = new file("d:/file/image/output_char_coppy.txt");\n    // 2、选择对应的输入流或者输出流\n    // 想使用新增的readline方法（不能发生多态）\n    bufferedreader reader = new bufferedreader(new filereader(src));// 用缓冲流包裹节点流\n    bufferedwriter writer = new bufferedwriter(new filewriter(dest, true));// 用缓冲流包裹节点流\n    // 3、进行读或写操作\n    string line = null;\n    while ((line = reader.readline()) != null) {\n      writer.write(line);\n      writer.newline(); // 类似于writer.append("\\r\\n");\n    }\n    writer.flush(); // 强制刷出\n    // 4、关闭资源\n    writer.close();\n    reader.close();\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n2.转换流：inputstreamreader和outputstreamwriter 作用:把字节流转换为字符流，因为字符流没办法进行编码设置，所以可以先通过字节流设置字符，然后转换为字符流。\n\n/**\n   * 转换流：字节转为字符<br>\n   * 1、输入流 inputstreamreader 解码<br>\n   * 2、输出流 outputstreamwriter 编码<br>\n   * 仔细体会注释的文字\n   */\n  @test\n  public void test2() throws ioexception {\n    string srcpath = "d:/file/txt/output_char.txt";\n    string destpath = "d:/file/txt/output_char_convert.txt";\n    // filereader（字符流）不能解码，fileinputstream（字节流）才能解码\n//    bufferedreader br = new bufferedreader(new filereader(new file(srcpath)));  \n    // 字符流filereader要换成字节流fileinputstream，但是字节流与字符流不能直接操作，需要通过转换流inputstreamreader来实现\n    bufferedreader br = new bufferedreader(new inputstreamreader(new fileinputstream(new file(srcpath)), "utf-8")); // 指定解码字符集\n    // filewriter（字符流）不能编码，fileoutputstream（字节流）才能编码\n//    bufferedwriter writer = new bufferedwriter(new filewriter(new file(destpath))); \n    // 字符流filewriter要换成字节流fileoutputstream，但是字节流与字符流不能直接操作，需要通过转换流outputstreamwriter来实现\n    bufferedwriter wr = new bufferedwriter(\n        new outputstreamwriter(new fileoutputstream(new file(destpath)), "utf-8"));// 指定编码字符集\n    // 读取并写出\n    string line = null;\n    while ((line = br.readline()) != null) {\n      wr.write(line);\n      wr.newline();\n    }\n    wr.flush();\n    wr.close();\n    br.close();\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n3.数据处理流:datainputstream 和dataoutputstream 主要是处理java的基本数据类型和string类型\n\n@test\n  public void test() throws ioexception {\n    write("d:/file/txt/data.txt"); // 写到文件\n    read("d:/file/txt/data.txt"); // 从文件读取\n  }\n  /**\n   * 基本数据类型+string类型输出到文件\n   */\n  public static void write(string destpath) throws ioexception {\n    int intnum = 100;\n    long longnum = 999l;\n    float floatnum = 3.14f;\n    double doublenum = 5.50;\n    string str = "基本数据类型+string类型输出到文件";\n    file dest = new file(destpath);\n    dataoutputstream dos = new dataoutputstream(new bufferedoutputstream(new fileoutputstream(dest)));\n    // 操作：注意写出的顺序，读取要和写出的顺序一致\n    dos.writeint(intnum);\n    dos.writelong(longnum);\n    dos.writefloat(floatnum);\n    dos.writedouble(doublenum);\n    dos.writeutf(str);\n    dos.flush();\n    dos.close();\n  }\n  /**\n   * 从文件里读取基本数据类型+string类型\n   */\n  public static void read(string srcpath) throws ioexception {\n    file src = new file(srcpath);\n    datainputstream dis = new datainputstream(new bufferedinputstream(new fileinputstream(src)));\n    int intnum = dis.readint();\n    long longnum = dis.readlong();\n    float floatnum = dis.readfloat();\n    double doublenum = dis.readdouble();\n    string str = dis.readutf();\n    dis.close();\n    // 100----\x3e999----\x3e3.14----\x3e5.5----\x3e基本数据类型+string类型输出到文件\n    system.out.println(intnum + "----\x3e" + longnum + "----\x3e" + floatnum + "----\x3e" + doublenum + "----\x3e" + str);\n  }  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n4.对象处理流:objectoutputstream和objectinputstream 　对象处理流就是我们常说的对象序列号，要想对对象读写首先对象要实现serializable 接口，通过设置一个serialversionuid 常亮，防止反序列化的时候出现问题。 　为了减少保存对象的使用空间，可以把一个类的某个属性设置为不被序列化，当实现 serializable 接口实现序列化的时候，可以使用 transient 关键字进行声明。\n\n/**\n   * 对象的序列化以及反序列化操作\n   */\n  @test\n  public void test() throws filenotfoundexception, ioexception, classnotfoundexception {\n    string filepath = "d:/file/txt/object.txt";\n    serializa(filepath);\n    object object = unserializa(filepath);\n    if (object instanceof user) {\n      object = (user) object;\n    }\n    // user [name=jpm, age=18, address=null]，因为address属性被transient修饰，没有被序列化，所以为null\n    system.out.println(object.tostring());\n  }\n \n \n  /**\n   * 对象序列化：对象变为二进制流的方法\n   */\n  public static void serializa(string destpath) throws filenotfoundexception, ioexception {\n    file dest = new file(destpath);\n    objectoutputstream oos = new objectoutputstream(new bufferedoutputstream(new fileoutputstream(dest)));\n    user user = new user("jpm", 18, "中国，北京！");\n    oos.writeobject(user);\n    oos.flush();\n    oos.close();\n  }\n \n \n  /**\n   * 对象反序列化：使用对象输入流读取对象数据\n   */\n  public static object unserializa(string srcpath) throws filenotfoundexception, ioexception, classnotfoundexception {\n    object object = null;\n    file scr = new file(srcpath);\n    objectinputstream ois = new objectinputstream(new bufferedinputstream(new fileinputstream(scr)));\n    object = ois.readobject();\n    ois.close();\n    return object;\n  }\n  \n/**\n * 序列化与反序列化的对象，必须实现serializable接口\n */\npublic class user implements serializable {\n \n \n  private static final long serialversionuid = -6954786920974801199l;\n \n \n  private string name;\n  private int age;\n  // transient修饰的属性不会被序列化\n  private transient string address; \n \n \n  public user() {\n    super();\n  }\n \n \n  public user(string name, int age, string address) {\n    super();\n    this.name = name;\n    this.age = age;\n    this.address = address;\n  }\n \n \n  public string getname() {\n    return name;\n  }\n \n \n  public void setname(string name) {\n    this.name = name;\n  }\n \n \n  public int getage() {\n    return age;\n  }\n \n \n  public void setage(int age) {\n    this.age = age;\n  }\n \n \n  public string getaddress() {\n    return address;\n  }\n \n \n  public void setaddress(string address) {\n    this.address = address;\n  }\n \n \n  @override\n  public string tostring() {\n    return "user [name=" + name + ", age=" + age + ", address=" + address + "]";\n  }\n \n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n',charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"java 基础学习",frontmatter:{title:"java 基础学习",date:"2021-07-09T15:44:19.000Z",permalink:"/pages/122101/",categories:["后端","java"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/00.java/00.java%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.html",relativePath:"01.后端/00.java/00.java 基础学习.md",key:"v-3cf10cf0",path:"/pages/122101/",headers:[{level:2,title:"1.变量和数据类型",slug:"_1-变量和数据类型",normalizedTitle:"1.变量和数据类型",charIndex:16},{level:3,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:18},{level:2,title:"2.数组",slug:"_2-数组",normalizedTitle:"2.数组",charIndex:304},{level:3,title:"数组的定义：",slug:"数组的定义",normalizedTitle:"数组的定义：",charIndex:313},{level:3,title:"数组排序",slug:"数组排序",normalizedTitle:"数组排序",charIndex:603},{level:2,title:"3.对象",slug:"_3-对象",normalizedTitle:"3.对象",charIndex:1255},{level:3,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:4334},{level:3,title:"重载",slug:"重载",normalizedTitle:"重载",charIndex:4369},{level:3,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:4415},{level:3,title:"多肽",slug:"多肽",normalizedTitle:"多肽",charIndex:4525},{level:3,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:5681},{level:3,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:5717},{level:3,title:"静态字段、静态方法",slug:"静态字段、静态方法",normalizedTitle:"静态字段、静态方法",charIndex:5807},{level:3,title:"包",slug:"包",normalizedTitle:"包",charIndex:5700},{level:3,title:"作用域",slug:"作用域",normalizedTitle:"作用域",charIndex:296},{level:3,title:"内部类",slug:"内部类",normalizedTitle:"内部类",charIndex:6124},{level:2,title:"4.Java核心类",slug:"_4-java核心类",normalizedTitle:"4.java核心类",charIndex:6217},{level:3,title:"string / stringbuilder / stringbuffer",slug:"string-stringbuilder-stringbuffer",normalizedTitle:"string / stringbuilder / stringbuffer",charIndex:6231},{level:3,title:"BIgDecimal",slug:"bigdecimal",normalizedTitle:"bigdecimal",charIndex:6664},{level:3,title:"Math",slug:"math",normalizedTitle:"math",charIndex:7754},{level:3,title:"Arrays",slug:"arrays",normalizedTitle:"arrays",charIndex:687},{level:2,title:"5.JAVA异常",slug:"_5-java异常",normalizedTitle:"5.java异常",charIndex:7774},{level:3,title:"异常的处理",slug:"异常的处理",normalizedTitle:"异常的处理",charIndex:9200},{level:3,title:"多catch语句",slug:"多catch语句",normalizedTitle:"多catch语句",charIndex:10393},{level:3,title:"自定义异常",slug:"自定义异常",normalizedTitle:"自定义异常",charIndex:10667},{level:2,title:"6.反射",slug:"_6-反射",normalizedTitle:"6.反射",charIndex:11303},{level:3,title:"获取class",slug:"获取class",normalizedTitle:"获取class",charIndex:11342},{level:3,title:"访问字段",slug:"访问字段",normalizedTitle:"访问字段",charIndex:11632},{level:3,title:"访问方法",slug:"访问方法",normalizedTitle:"访问方法",charIndex:12437},{level:2,title:"7.泛型",slug:"_7-泛型",normalizedTitle:"7.泛型",charIndex:12944},{level:3,title:"多个泛型类型",slug:"多个泛型类型",normalizedTitle:"多个泛型类型",charIndex:13168},{level:2,title:"8.集合",slug:"_8-集合",normalizedTitle:"8.集合",charIndex:13580},{level:3,title:"List",slug:"list",normalizedTitle:"list",charIndex:13006},{level:3,title:"重写equals方法",slug:"重写equals方法",normalizedTitle:"重写equals方法",charIndex:15877},{level:3,title:"Map",slug:"map",normalizedTitle:"map",charIndex:13694},{level:3,title:"set",slug:"set",normalizedTitle:"set",charIndex:1472},{level:3,title:"Collections",slug:"collections",normalizedTitle:"collections",charIndex:14843},{level:2,title:"9.IO",slug:"_9-io",normalizedTitle:"9.io",charIndex:20102},{level:3,title:"File",slug:"file",normalizedTitle:"file",charIndex:20164},{level:3,title:"InputStream",slug:"inputstream",normalizedTitle:"inputstream",charIndex:20112},{level:3,title:"OutputStream",slug:"outputstream",normalizedTitle:"outputstream",charIndex:20126},{level:3,title:"Reader",slug:"reader",normalizedTitle:"reader",charIndex:20144},{level:3,title:"Wirter",slug:"wirter",normalizedTitle:"wirter",charIndex:25796},{level:2,title:"10.多线程",slug:"_10-多线程",normalizedTitle:"10.多线程",charIndex:26311},{level:3,title:"创建线程",slug:"创建线程",normalizedTitle:"创建线程",charIndex:26355},{level:3,title:"线程的状态",slug:"线程的状态",normalizedTitle:"线程的状态",charIndex:30041},{level:3,title:"中断线程",slug:"中断线程",normalizedTitle:"中断线程",charIndex:30578},{level:3,title:"线程同步",slug:"线程同步",normalizedTitle:"线程同步",charIndex:31125}],headersStr:"1.变量和数据类型 变量 2.数组 数组的定义： 数组排序 3.对象 构造方法 重载 继承 多肽 抽象类 接口 静态字段、静态方法 包 作用域 内部类 4.Java核心类 string / stringbuilder / stringbuffer BIgDecimal Math Arrays 5.JAVA异常 异常的处理 多catch语句 自定义异常 6.反射 获取class 访问字段 访问方法 7.泛型 多个泛型类型 8.集合 List 重写equals方法 Map set Collections 9.IO File InputStream OutputStream Reader Wirter 10.多线程 创建线程 线程的状态 中断线程 线程同步",content:'# java 基础学习\n\n\n# 1.变量和数据类型\n\n\n# 变量\n\nint a = 1;\n\nint b;\n\nb = 1;\n\n\n\n# 基本类型的变量\n\n整数类型：byte，short，int，long\n\n浮点数类型：float，double\n\n字符类型：char\n\n布尔类型：boolean\n\n# 变量长度\n\nbyte：一个字节，8位2进制数，8bit，-128 ~ 127\n\nshort：2字节\n\nint：4字节\n\nfloat：4字节\n\ndouble：8字节\n\nchar：2字节\n\n# 引用类型的变量\n\nString，stringbuffer，stringbuilder，var\n\n# 变量的作用域\n\n\n# 2.数组\n\n\n# 数组的定义：\n\n//一维数组声明，必须初始化长度\nint [] c = new int[4];\nint []d = {1,2,3,4};\n\n// 二维数组\nint [][]k = new int[3][4];\n\nint [][]t = new int[3][];\nt[1] = c;\n\n\n// 遍历数组\nfor (int n : d) {\n    System.out.print(n + ", ");\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n练习\n\n定义一个长度为10，10的二维数据，数组值为1-100，并倒序打印\n\n\n# 数组排序\n\nint[] t = {28, 12, 89, 73, 65, 18, 96, 50, 8, 36};\n// 排序前:\nSystem.out.println(Arrays.toString(t));\nfor (int i = 0; i < t.length - 1; i++) {\n    for (int j = 0; j < t.length - i - 1; j++) {\n        if (t[j] > t[j + 1]) {\n            // 交换ns[j]和ns[j+1]:\n            int tmp = t[j];\n            t[j] = t[j + 1];\n            t[j + 1] = tmp;\n        }\n    }\n}\n// 排序后:\nSystem.out.println(Arrays.toString(t));\n\n\n// java提供Arrays.sort()实现排序\nint []a = {28, 12, 89, 73, 65, 18, 96, 50, 8, 36};\nArrays.sort(a);\nSystem.out.println(Arrays.toString(a));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n练习\n\n一维数组倒序打印；\n\n随机生成一个长度为10，10的二维数据，并实现排序\n\n\n# 3.对象\n\n类与实例\n\n类：按照某种规则，抽象出来的一个模板，数据类型的一种\n\n实例：类的具体化\n\npublic class Person {\n    private String name;\n    private int age;\n    private String sex;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n类的属性，用来表示类的一个特征\n\n类的方法，用来完成某个动作\n\n类的属性一般用private关键字修饰，通过get/set方法访问和给属性赋值\n\n思考：一下两种情况输出值？\n\npublic class study {\n    public static void main(String[] args) {\n        Person p = new Person();\n        String bob = "Bob";\n        p.setName(bob);\n        System.out.println(p.getName());\n        bob = "Alice";\n        System.out.println(p.getName()); // "Bob"还是"Alice"?\n\n        String[] fullname = new String[] { "Homer", "Simpson" };\n        p.setFullName(fullname);\n        System.out.println(p.getFullName());\n        fullname[0] = "Bart";\n        System.out.println(p.getFullName()); // "Homer Simpson"还是"Bart Simpson"?\n    }\n}\n\nclass Person {\n    private String name;\n\n    private String []fullName;\n\n    public String getName() {\n        return this.name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getFullName() {\n        return this.fullName[0] + " " + this.fullName[1];\n    }\n\n    public void setFullName(String [] fullName) {\n        this.fullName = fullName;\n    }\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\nimport java.util.Arrays;\n\npublic class study {\n    public static void main(String[] args) {\n        Person p = new Person();\n        String bob = "Bob";\n        p.setName(bob);\n        System.out.println(bob.hashCode());\n        System.out.println(p.getName().hashCode());\n        bob = "Alice";\n        System.out.println(bob.hashCode());\n        System.out.println(p.getName().hashCode()); // "Bob"还是"Alice"?\n\n        String[] fullname = new String[] { "Homer", "Simpson" };\n        p.setFullName(fullname);\n        System.out.println(fullname[0].hashCode());\n        System.out.println(p.getFullName().hashCode());\n        fullname[0] = "Bart";\n        System.out.println(fullname[0].hashCode());\n        System.out.println(p.getFullName().hashCode()); // "Homer Simpson"还是"Bart Simpson"?\n    }\n}\n\nclass Person {\n    private String name;\n\n    private String []fullName;\n\n    public String getName() {\n        return this.name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getFullName() {\n        return this.fullName[0] + " " + this.fullName[1];\n    }\n\n    public void setFullName(String [] fullName) {\n        this.fullName = fullName;\n    }\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 构造方法\n\n默认提供无参构造方法\n\n可自定义带参数的构造方法\n\n\n# 重载\n\n方法名相同，但各自的参数不同，称为方法重载\n\n无参构造方法与带参的构造方法\n\n\n# 继承\n\nextends关键字\n\n子类可继承父类属性与方法，子类自动获得了父类的所有字段，严禁定义与父类重名的字段！\n\nJava不支持多继承，所有的类都是Object类的子类\n\nfinal关键字修饰的类不可被继承\n\n\n# 多肽\n\n子类中对父类的方法重写（方法名，入参，返回均相同）\n\n多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法\n\n// Person类\nclass Person {\n    private String name;\n\n    private String []fullName;\n\n    public String getName() {\n        return this.name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getFullName() {\n        return this.fullName[0] + " " + this.fullName[1];\n    }\n\n    public void setFullName(String [] fullName) {\n        this.fullName = fullName;\n    }\n\n    public String say(){\n        return "hello";\n    }\n}\n\n\n// Student类\npublic class Student extends Person {\n\n    private String school;\n\n    public String getSchool() {\n        return school;\n    }\n\n    public void setSchool(String school) {\n        this.school = school;\n    }\n\n    public String say() {\n        return "hi";\n    }\n}\n\n//测试方法\npublic class study {\n    public static void main(String[] args) {\n\n        Person p = new Student();\n        System.out.println(p.say());\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n练习\n\n父子类定义练习，方法的重载与重写\n\n\n# 抽象类\n\nabstract关键字修饰，包含至少一个抽象方法的类\n\n\n# 接口\n\ninterface关键字修饰，所有的方法都是抽象方法，且没有属性字段\n\nJava只支持单继承，但可以实现多个抽象类\n\nclass A extends ClassB\n\n\n# 静态字段、静态方法\n\nstatic关键字修饰，静态资源不属于实例化对象\n\n不需要实例化类，类名.字段名/类名.方法名即可访问\n\n接口类可定义静态字段\n\n\n# 包\n\npackage，每个类都是在包下，同一个包下不允许出现同名的类\n\n规范的文件目录有助于代码的管理\n\n\n# 作用域\n\npublic：可以被任何类访问到\n\nprotected：常见于继承关系中，可以被子类及其更下级子类访问\n\nprivate：无法被其他类访问\n\npackage：同一个包下，省略public/private/protected修饰的方法与字段，可被同包下代码访问\n\nfinal：修饰类，不可被继承\n\n修饰方法，不可被子类重写\n\n修饰属性，不可被更新\n\n\n# 内部类\n\n存在于另一个类内部\n\nclass A {\n    class B {\n        // 定义了一个Inner Class\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.Java核心类\n\n\n# string / stringbuilder / stringbuffer\n\n字符串的比较：equals() 与 ==, equalsIgnoreCase()\n\nlength()\n\ncontains()\n\ntrim()\n\nisEmpty()\n\nisBlank()\n\nreplace()\n\nsplit()\n\nstring转int：Integer.parseInt("123");\n\nint转String：int n = 1; n.toString()\n\nstring转char：char[] n = "dsad".toCharArray();\n\n// 修改数组内容，string不会改变\nchar[] cs = "Hello".toCharArray();\nString s = new String(cs);\nSystem.out.println(s);\ncs[0] = \'X\';\nSystem.out.println(s);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# BIgDecimal\n\n表示一个任意大小且精度完全准确的浮点数\n\nBigDecimal num1 = new BigDecimal(0.005);\nBigDecimal num2 = new BigDecimal(1000000);\nBigDecimal num3 = new BigDecimal(-1000000);\n//尽量用字符串的形式初始化\nBigDecimal num12 = new BigDecimal("0.005");\nBigDecimal num22 = new BigDecimal("1000000");\nBigDecimal num32 = new BigDecimal("-1000000");\n\n//加法\nBigDecimal result1 = num1.add(num2);\nBigDecimal result12 = num12.add(num22);\n\n//减法\nBigDecimal result2 = num1.subtract(num2);\nBigDecimal result22 = num12.subtract(num22);\n\n//乘法\nBigDecimal result3 = num1.multiply(num2);\nBigDecimal result32 = num12.multiply(num22);\n\n//绝对值\nBigDecimal result4 = num3.abs();\nBigDecimal result42 = num32.abs();\n\n//除法（一定要设置精度）\nBigDecimal result5 = num2.divide(num1,20,BigDecimal.ROUND_HALF_UP);\nBigDecimal result52 = num22.divide(num12,20,BigDecimal.ROUND_HALF_UP);\n\n//比较大小\nBigDecimal a = new BigDecimal("123");\nBigDecimal b = new BigDecimal("123.00");\nSystem.out.println(a.equals(b));\nSystem.out.println(a.compareTo(b));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n练习\n\n自行学习java其他常见的工具类\n\n\n# Math\n\n\n# Arrays\n\n\n# 5.JAVA异常\n\nException：NullPointerException，IndexOutOfBoundException\n\nerror：OutOfMemoryException,NoClassDefFoundError,StackOverflowError\n\nint a[] =  {1,2,3};\nSystem.out.println(a[4]);\n\n\n1\n2\n\n\n                     ┌───────────┐\n                     │  Object   │\n                     └───────────┘\n                           ▲\n                           │\n                     ┌───────────┐\n                     │ Throwable │\n                     └───────────┘\n                           ▲\n                 ┌─────────┴─────────┐\n                 │                   │\n           ┌───────────┐       ┌───────────┐\n           │   Error   │       │ Exception │\n           └───────────┘       └───────────┘\n                 ▲                   ▲\n         ┌───────┘              ┌────┴──────────┐\n         │                      │               │\n┌─────────────────┐    ┌─────────────────┐┌───────────┐\n│OutOfMemoryError │... │RuntimeException ││IOException│...\n└─────────────────┘    └─────────────────┘└───────────┘\n                                ▲\n                    ┌───────────┴─────────────┐\n                    │                         │\n         ┌─────────────────────┐ ┌─────────────────────────┐\n         │NullPointerException │ │IllegalArgumentException │...\n         └─────────────────────┘ └─────────────────────────┘                         \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 异常的处理\n\nthrows关键字抛至外层\n\ntry catcah模块化处理\n\n// throws关键字抛至外层\npublic static void main(String[] args) throws UnsupportedEncodingException {\n    byte[] bs = toGBK("中文");\n    System.out.println(Arrays.toString(bs));\n}\n\nstatic byte[] toGBK(String s) throws UnsupportedEncodingException {\n\n    return s.getBytes("GBK");\n}\n\n// try catcah模块化处理\npublic static void main(String[] args) {\n    byte[] bs = toGBK("中文");\n    System.out.println(Arrays.toString(bs));\n}\n\nstatic byte[] toGBK(String s) {\n    try {\n        // 用指定编码转换String为byte[]:\n        return s.getBytes("GBK");\n    } catch (UnsupportedEncodingException e) {\n        // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:\n        e.printStackTrace(); // 打印异常信息\n        return s.getBytes(); // 尝试使用用默认编码\n    }\n}\n\n// 抛至外层做异常捕获\npublic static void main(String[] args){\n    try {\n        byte[] bs = toGBK("中文");\n        System.out.println(Arrays.toString(bs));\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\nstatic byte[] toGBK(String s) throws UnsupportedEncodingException {\n\n    return s.getBytes("GBK");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 多catch语句\n\n针对每种错误做个性化处理\n\ntry {\n\t// 程序处理\n\n} catch (IOException e) {\n\n\te.printStackTrace();\n\n} catch (NullPointerException e) {\n\n\te.printStackTrace();\n} catch (SQLException e ) {\n\n\te.printStackTrace();\n} finally {\n\t// 其他处理逻辑\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 自定义异常\n\n实际项目中，会有很多业务上的校验逻辑，这时候需要自定义异常\n\npublic class TestException extends RuntimeException {\n\n\n    public TestException() {\n    }\n\n    public TestException(String message) {\n        super(message);\n    }\n\n    public TestException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public TestException(Throwable cause) {\n        super(cause);\n    }\n\n    public TestException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n        super(message, cause, enableSuppression, writableStackTrace);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 6.反射\n\nJava的反射是指程序在运行期可以拿到一个对象的所有信息\n\n\n# 获取class\n\n// 通过一个class的静态变量class获取\nClass cls1 = Person.class;\n\n// 通过该实例变量获取\nPerson p = new Person();\nClass cls2 = p.getClass();\n\n// 通过完整类名获取\nClass cls3 = Class.forName("Person");\n\n\nSystem.out.println(cls1 == cls2);\nSystem.out.println(cls1.equals(cls2));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 访问字段\n\n * Field getField(name)：根据字段名获取某个public的field（包括父类）\n * Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）\n * Field[] getFields()：获取所有public的field（包括父类）\n * Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）\n\n// 通过一个class的静态变量class获取\nClass cls1 = Person.class;\n\n// 通过该实例变量获取\nPerson p = new Student();\nClass cls2 = p.getClass();\n\n// 通过完整类名获取\nClass cls3 = Class.forName("Person");\n\nSystem.out.println(cls1.getName());\nSystem.out.println(cls1.getField("name"));\nSystem.out.println(cls1.getDeclaredField("fullName"));\n\n\n// 获取字段值，设置字段值\np.setName("hello");\nClass c = p.getClass();\nField f = c.getDeclaredField("name");\nSystem.out.println(f);\nf.setAccessible(true);\nObject value = f.get(p);\nf.set(p,"12123");\nSystem.out.println(value);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 访问方法\n\n * getMethod(name, Class...)：获取某个public的Method（包括父类）\n\n * getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）\n\n * getMethods()：获取所有public的Method（包括父类）\n\n * getDeclaredMethods()：获取当前类的所有Method（不包括父类）\n   \n   注意：前两个方法内的Class是指被反射方法的入参类型\n\nPerson p = new Person();\nMethod m1 = cls1.getMethod("getName");\nSystem.out.println(m1);\nSystem.out.println(m1.invoke(p));\n\n\nMethod m2 = cls1.getDeclaredMethod("setName", String.class);\nm2.invoke(p,"123");\nSystem.out.println(m1.invoke(p));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 7.泛型\n\n泛型就是编写模板代码来适应任意类型；\n\n泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查\n\nList<String> list1 = new ArrayList<>();\nList<Long> list2 = new ArrayList<>();\nList<Student> list3 = new ArrayList<>();\n\n\n1\n2\n3\n\n\n编写泛型类时，要特别注意，泛型类型<T>不能用于静态方法\n\n\n# 多个泛型类型\n\n泛型还可以定义多种类型。例如，我们希望Pair不总是存储两个类型一样的对象，就可以使用类型<T, K>：\n\npublic class Pair<T, K> {\n    private T first;\n    private K last;\n    public Pair(T first, K last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() { ... }\n    public K getLast() { ... }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用的时候，需要指出两种类型：\n\nPair<String, Integer> p = new Pair<>("test", 123);\n\n\n1\n\n\nextends , super 通配符\n\n\n# 8.集合\n\njava.util包主要提供了以下三种类型的集合\n\nList：一种有序列表的集合，例如，按索引排列的Student的List；\n\nSet：一种保证没有重复元素的集合，例如，所有无重复名称的Student的Set；\n\nMap：一种通过键值（key-value）查找的映射表集合，例如，根据Student的name查找对应Student Map。\n\n\n# List\n\n思考：用数组声明一个长度为5的集合，删除第三个元素，再依次打印\n\n用数组声明一个长度为5的集合，添加一个新的元素到第三个位置，并打印\n\n数组的长度在声明时已经固定，无法继续添加元素\n\nlist可以任意添加，list先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组；\n\nlist允许添加重复元素和空元素\n\n//遍历List\nList<String> list = Arrays.asList("apple", "pear", "banana");\nfor (int i=0; i<list.size(); i++) {\n    String s = list.get(i);\n    System.out.println(s);\n}\n\n// 迭代器遍历List\nfor (Iterator<String> it = list.iterator(); it.hasNext(); ) {\n    String s = it.next();\n    System.out.println(s);\n}\n\n// foreach\nfor (String s : list) {\n    System.out.println(s);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n实际上，只要实现了Iterable接口的集合类都可以直接用for each循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把for each循环变成Iterator的调用，原因就在于Iterable接口定义了一个Iterator<E> iterator()方法，强迫集合类必须返回一个Iterator实例\n\n练习\n\n给定一组连续的整数，例如：10，11，12，……，20，将其打乱后随机删除其中一个数字，试找出缺失的数字\n\npublic static void main(String[] args) {\n        // 构造从start到end的序列：\n        final int start = 10;\n        final int end = 20;\n        List<Integer> list = new ArrayList<>();\n        for (int i = start; i <= end; i++) {\n            list.add(i);\n        }\n        //打乱排序\n        Collections.shuffle(list);\n        System.out.println(list.toString());\n\n        // 随机删除List中的一个元素:\n        int index = (int) (Math.random() * list.size());\n        System.out.println(list.get(index));\n        int removed = list.remove(index);\n        int found = findMissingNumber(start, end, list);\n        System.out.println(list.toString());\n        System.out.println("missing number: " + found);\n        System.out.println(removed == found ? "测试成功" : "测试失败");\n    }\n\n    static int findMissingNumber(int start, int end, List<Integer> list) {\n\n        Collections.sort(list);\n        System.out.println(list.toString());\n        int count = 10;\n        for (Iterator<Integer> it = list.iterator();it.hasNext();) {\n\n            Integer a = it.next();\n            if (a > count) {\n                System.out.println(a-1);\n                return a-1;\n            }\n            count++;\n        }\n        return 1;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 重写equals方法\n\npublic static void main(String[] args) {\n    List<String> list = Arrays.asList("A", "B", "C");\n    System.out.println(list.contains(new String("C"))); // true or false?\n    System.out.println(list.indexOf(new String("C"))); // 2 or -1?\n\n    List<Person> pList = Arrays.asList(new Person("a"), new Person("b"), new Person("c"));\n    System.out.println(pList.contains(new Person("b")));\n    System.out.println(pList.indexOf(new Person("b")));\n}\n\nclass Person {\n    private String name;\n\n    private String []fullName;\n\n    public String getName() {\n        return this.name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getFullName() {\n        return this.fullName[0] + " " + this.fullName[1];\n    }\n\n    public void setFullName(String [] fullName) {\n        this.fullName = fullName;\n    }\n\n    public String say(){\n        return "hello";\n    }\n\n    public Person(String name) {\n        this.name = name;\n    \n        \n    public boolean equals(Object o) {\n        if (o instanceof Person) {\n            Person p = (Person) o;\n            return this.name.equals(p.name);\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n练习：拓展Person类equals方法，增加fullName属性判断\n\n\n# Map\n\nlist是一个顺序列表，常用访问方式是通过下标，如果需要根据name来查询集合中的某个元素呢？\n\npublic class Main {\n    public static void main(String[] args) {\n        Student s = new Student("Xiao Ming", 99);\n        Map<String, Student> map = new HashMap<>();\n        map.put("Xiao Ming", s); // 将"Xiao Ming"和Student实例映射并关联\n        Student target = map.get("Xiao Ming"); // 通过key查找并返回映射的Student实例\n        System.out.println(target == s); // true，同一个实例\n        System.out.println(target.score); // 99\n        Student another = map.get("Bob"); // 通过另一个key查找\n        System.out.println(another); // 未找到返回null\n    }\n}\n\nclass Student {\n    public String name;\n    public int score;\n    public Student(String name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nmap中key不允许重复，第二次输入的值回覆盖第一次，value可以重复\n\n遍历map\n\nMap<String, Integer> map = new HashMap<>();\nmap.put("apple", 123);\nmap.put("pear", 456);\nmap.put("banana", 789);\nfor (String key : map.keySet()) {\nInteger value = map.get(key);\nSystem.out.println(key + " = " + value);\n}\n\n\nfor (Map.Entry<String, Integer> entry : map.entrySet()) {\nString key = entry.getKey();\nInteger value = entry.getValue();\nSystem.out.println(key + " = " + value);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n练习：将学生成绩从高到底打印出来，并能根据name查找score\n\n\n# set\n\n常用方法：add()，remove()，contains()\n\nset内元素不可重复，相当于一个只存有key的map\n\nSet接口并不保证有序，而SortedSet接口则保证元素是有序的：\n\nHashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口；\n\nTreeSet是有序的，因为它实现了SortedSet接口\n\n Set<String> set = new TreeSet<>();\n // Set<String> set = new HashSet<>();\n\n set.add("apple");\n set.add("banana");\n set.add("pear");\n set.add("orange");\n for (String s : set) {\n System.out.println(s);\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n练习：声明一个长度为100，值范围为1-70的随机数集合，判断有多少个重复数字，每个重复数字各出现多少次\n\n\n# Collections\n\nCollections提供了一系列方法来创建空集合：\n\n * 创建空List：List<T> emptyList()\n * 创建空Map：Map<K, V> emptyMap()\n * 创建空Set：Set<T> emptySet()\n\n对List排序：Collections.sort()\n\n洗牌：Collections.shuffle(list)\n\nCollections还提供了一组方法把可变集合封装成不可变集合：\n\n * 封装成不可变List：List<T> unmodifiableList(List<? extends T> list)\n * 封装成不可变Set：Set<T> unmodifiableSet(Set<? extends T> set)\n * 封装成不可变Map：Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m)\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> mutable = new ArrayList<>();\n        mutable.add("apple");\n        mutable.add("pear");\n        // 变为不可变集合:\n        List<String> immutable = Collections.unmodifiableList(mutable);\n        immutable.add("orange"); // UnsupportedOperationException!\n        \n        // 可继续操作原List\n        mutable.add("orange");\n        System.out.println(immutable);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nCollections还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：\n\n * 变为线程安全的List：List<T> synchronizedList(List<T> list)\n * 变为线程安全的Set：Set<T> synchronizedSet(Set<T> s)\n * 变为线程安全的Map：Map<K,V> synchronizedMap(Map<K,V> m)\n\n\n# 9.IO\n\n字节流：InputStream / OutputStream\n\n字符流：Reader / Writer\n\n\n# File\n\npublic class Main {\n    public static void main(String[] args) {\n        //windows下用\\分割，linux下用/\n        File f = new File("C:\\\\Users\\\\10457\\\\Desktop\\\\1.xml");\n        System.out.println(f);\n        System.out.println(f.getPath());\n        System.out.println(f.getAbsolutePath());\n        System.out.println(f.getCanonicalPath());\n\n        // 假设当前目录是C:\\Docs\n        File f1 = new File("sub\\\\javac"); // 绝对路径是C:\\Docs\\sub\\javac\n        File f2 = new File(".\\\\sub\\\\javac"); // 绝对路径是C:\\Docs\\sub\\javac\n        File f3 = new File("..\\\\sub\\\\javac"); // 绝对路径是C:\\sub\\javac\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nFIle可指具体的文件，也可以指一个文件目录\n\nisFile()判断文件是否存在\n\nisDirectory()判断目录是否存在\n\n File f1 = new File("C:\\\\Windows");\n File f2 = new File("C:\\\\Windows\\\\notepad.exe");\n File f3 = new File("C:\\\\Windows\\\\nothing");\n System.out.println(f1.isFile());\n System.out.println(f1.isDirectory());\n System.out.println(f2.isFile());\n System.out.println(f2.isDirectory());\n System.out.println(f3.isFile());\n System.out.println(f3.isDirectory());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nboolean canRead()：是否可读；\n\nboolean canWrite()：是否可写；\n\nboolean canExecute()：是否可执行；\n\nlong length()：文件字节大小。\n\n// 创建/删除文件\nFile file = new File("D:\\\\file1");\nfile.createNewFile();\nfile.delete();\n\n\n// 提供临时文件的前缀和后缀\nFile f = File.createTempFile("tmp-", ".txt");\nf.deleteOnExit(); // JVM退出时自动删除\nSystem.out.println(f.isFile());\nSystem.out.println(f.getAbsolutePath());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 遍历文件和目录\n\npublic static void main(String[] args) throws Exception {\n        File f = new File("C:\\\\Windows");\n        File[] fs1 = f.listFiles(); // 列出所有文件和子目录\n\n        System.out.println("==========");\n        if (fs1 != null) {\n            for (File ff : fs1) {\n                System.out.println(ff);\n            }\n        }\n        System.out.println("==========");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# Path\n\nPath p1 = Paths.get(".", "project", "study"); // 构造一个Path对象\nSystem.out.println(p1);\nPath p2 = p1.toAbsolutePath(); // 转换为绝对路径\nSystem.out.println(p2);\nPath p3 = p2.normalize(); // 转换为规范路径\nSystem.out.println(p3);\nFile f = p3.toFile(); // 转换为File对象\nSystem.out.println(f);\nfor (Path p : Paths.get("..").toAbsolutePath()) { // 可以直接遍历Path\nSystem.out.println("  " + p);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n练习：列出某一目录下所有子目录及文件，并按层级打印\n\n\n# InputStream\n\npublic static void main(String[] args) throws Exception {\n    InputStream input = null;\n    try {\n        input = new FileInputStream("C:\\\\Users\\\\10457\\\\Desktop\\\\2.txt");\n        int n;\n        while ((n = input.read()) != -1) { // 利用while同时读取并判断\n            System.out.println(n);\n        }\n    } finally {\n        if (input != null) { input.close(); }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n缓冲:在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多\n\npublic static void main(String[] args) throws Exception {\n        InputStream input = null;\n        try {\n            input = new FileInputStream("C:\\\\Users\\\\10457\\\\Desktop\\\\2.txt");\n            byte[] buffer = new byte[1000];\n            int n;\n            while ((n = input.read(buffer)) != -1) { // 利用while同时读取并判断\n                System.out.println("read " + n + " bytes.");\n            }\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# OutputStream\n\n    public static void main(String[] args) throws Exception {\n        // 逐个字节写入\n        OutputStream output = new FileOutputStream("C:\\\\Users\\\\10457\\\\Desktop\\\\2.txt");\n        output.write(72); // H\n        output.write(101); // e\n        output.write(108); // l\n        output.write(108); // l\n        output.write(111); // o\n        output.close();\n        \n        // 多字节写入\n        output.write("Hello".getBytes("UTF-8")); // Hello\n        output.close();\n        \n        \n        try (OutputStream output = new FileOutputStream("C:\\\\Users\\\\10457\\\\Desktop\\\\2.txt")) {\n            output.write("Hello".getBytes("UTF-8"));\n            output.write("\\n".getBytes("UTF-8"));\n            output.write("world".getBytes("UTF-8"));\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n拓展： ByteArrayInputStream / ByteArrayOutputStream自行学习理解\n\n练习：编写一个复制文件的程序，要求使用缓冲，且无乱码\n\nInputStream input = null;\n        OutputStream output = null;\n        try {\n            input = new FileInputStream("C:\\\\Users\\\\10457\\\\Desktop\\\\2.txt");\n\n            output = new FileOutputStream("C:\\\\Users\\\\10457\\\\Desktop\\\\3.pdf");\n            byte[] buffer = new byte[1000];\n            int n;\n            while ((n = input.read(buffer)) != -1) { // 利用while同时读取并判断\n                output.write(buffer);\n            }\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n\n            try {\n                input.close();\n                output.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Reader\n\n字符输入流\n\n# FileReader\n\npublic static void main(String[] args) throws Exception {\n        // "C:\\\\Users\\\\10457\\\\Desktop\\\\2.txt"\n        try (Reader reader = new FileReader("C:\\\\Users\\\\10457\\\\Desktop\\\\2.txt")) {\n            char[] buffer = new char[1000];\n            int n;\n            while ((n = reader.read(buffer)) != -1) {\n                System.out.println(buffer);\n                System.out.println("read " + n + " chars.");\n            }\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# CharArrayReader\n\n# StringReader\n\n# InputStreamReader\n\n练习：自行学习使用其余几种reader\n\n\n# Wirter\n\n# FileWriter\n\n public static void main(String[] args) throws Exception {\n        // "C:\\\\Users\\\\10457\\\\Desktop\\\\2.txt"\n        try (Writer writer = new FileWriter("C:\\\\Users\\\\10457\\\\Desktop\\\\3.txt")) {\n            writer.write(\'H\'); // 写入单个字符\n            writer.write("测测试".toCharArray()); // 写入char[]\n            writer.write("Hand"); // 写入String\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# CharArrayWriter\n\n# StringWriter\n\n# OutputStreamWriter\n\n练习：自行学习使用其余几种writer\n\n练习：用reader/writer编写一个复制文件的程序，要求使用缓冲，且无乱码\n\n\n# 10.多线程\n\n在计算机中，我们把一个任务称为一个进程，进程内至少包含一个线程\n\n\n# 创建线程\n\n1.继承Thread类\n\npublic class study {\n    public static void main(String[] args) {\n        Thread t = new MyThread();\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println("start new thread!");\n    }\n}\n\n// lambda语法简写\npublic static void main(String[] args) {\n    Thread t = new Thread(() -> {\n        System.out.println("start new thread!");\n    });\n    t.start(); // 启动新线程\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n2.实现Runnable 接口\n\npublic class study {\n    public static void main(String[] args) {\n        Runnable t1 = new MyRunnable();\n        t1.run();\n\n    }\n}\n\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println("start new thread!");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n优先级：优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。\n\nThread.setPriority(1);\n\n3.使用线程池\n\n * FixedThreadPool：线程数固定的线程池；\n * CachedThreadPool：线程数根据任务动态调整的线程池；\n * SingleThreadExecutor：仅单线程执行的线程池。\n\npublic class study {\n    public static void main(String[] args) {\n        // 创建一个固定大小的线程池:\n        ExecutorService es = Executors.newFixedThreadPool(4);\n        for (int i = 0; i < 6; i++) {\n            es.submit(new Task("" + i));\n        }\n        // 关闭线程池:\n        es.shutdown();\n    }\n}\n\nclass Task implements Runnable {\n    private final String name;\n\n    public Task(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        System.out.println("start task " + name);\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n        }\n        System.out.println("end task " + name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nScheduledThreadPool：需要反复执行的任务\n\npublic class study {\n    public static void main(String[] args) {\n//        ExecutorService es = Executors.newSingleThreadExecutor();\n//        for (int i = 0; i < 6; i++) {\n//            es.submit(new Task("" + i));\n//        }\n//        // 关闭线程池:\n//        es.shutdown();\n\n\n        ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);\n        // 1秒后执行一次性任务\n        ses.schedule(new Task("one-time"), 1, TimeUnit.SECONDS);\n        // 2秒后执行定时任务，每3秒执行（不管每次任务执行多长时间）\n        ses.scheduleAtFixedRate(new Task("fixed-rate"), 2, 3, TimeUnit.SECONDS);\n        // 2秒后开始执行定时任务，以3秒为间隔执行（上一次任务结束后间隔3秒再次执行）\n        ses.scheduleWithFixedDelay(new Task("fixed-delay"), 2, 3, TimeUnit.SECONDS);\n    }\n}\n\nclass Task implements Runnable {\n    private final String name;\n\n    public Task(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        System.out.println("start task " + name);\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n        }\n        System.out.println("end task " + name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n思考：如果任务抛出了异常，后续任务是否继续执行\n\n4.callable接口\n\n与runable接口最大不同，callable接口有返回值\n\npublic class study {\n    public static void main(String[] args) throws Exception {\n        // 创建一个固定大小的线程池:\n        ExecutorService executor = Executors.newFixedThreadPool(4);\n        Callable<String> task = new Task();\n        Future<String> future = executor.submit(task);\n        String result = future.get(); // 可能阻塞\n        System.out.println(result);\n        executor.shutdown();\n    }\n}\n\nclass Task implements Callable<String> {\n    public String call() throws Exception {\n        return "123";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n练习：使用线程池分别计算1-100的加和，100-200的加和，以及前两项的加和；\n\n\n# 线程的状态\n\nNew：新创建的线程，尚未执行；\n\nRunnable：运行中的线程，正在执行run()方法的Java代码；\n\nBlocked：运行中的线程，因为某些操作被阻塞而挂起；\n\nWaiting：运行中的线程，因为某些操作等待中，或因执行sleep()方法正在计时等待；\n\nWaiting：运行中的线程，因为执行sleep()方法正在计时等待；\n\nTerminated：线程已终止，因为run()方法执行完毕。\n\n// 一个线程还可以等待另一个线程直到其运行结束\npublic static void main(String[] args) throws InterruptedException {\n        Thread t = new Thread(() -> {\n            System.out.println("hello");\n        });\n        System.out.println("start");\n        t.start();\n        t.join();\n        System.out.println("end");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 中断线程\n\npublic class study {\n    public static void main(String[] args) throws InterruptedException {\n        Thread t = new MyThread();\n        t.start();\n        Thread.sleep(1); // 暂停1毫秒\n        t.interrupt(); // 中断t线程\n        t.join(); // 等待t线程结束\n        System.out.println("end");\n    }\n}\n\nclass MyThread extends Thread {\n    public void run() {\n        int n = 0;\n        while (!isInterrupted()) {\n            n++;\n            System.out.println(n + " hello!");\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 线程同步\n\npublic class study {\n    public static void main(String[] args) throws InterruptedException {\n        Thread t = new MyThread();\n        Thread t2 = new MyThread2();\n        t.start();\n        t2.start();\n        t.join();\n        t2.join();\n        System.out.println(number.a);\n    }\n}\n\nclass number {\n    public static int a = 0;\n}\n\nclass MyThread extends Thread {\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            number.a += 1;\n        }\n    }\n}\n\nclass MyThread2 extends Thread {\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            number.a += 1;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n原子操作：保证每一次读写都是不可中断的\n\nsynchronized关键字加锁\n\npublic class study {\n    public static void main(String[] args) throws InterruptedException {\n        Thread t = new MyThread();\n        Thread t2 = new MyThread2();\n        t.start();\n        t2.start();\n        t.join();\n        t2.join();\n        System.out.println(number.a);\n    }\n}\n\nclass number {\n    public static final Object lock = new Object();\n    public static int a = 0;\n}\n\nclass MyThread extends Thread {\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            synchronized(number.lock){number.a += 1;}\n        }\n    }\n}\n\nclass MyThread2 extends Thread {\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            synchronized(number.lock){number.a += 1;}\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nsynchronized关键字修饰方法\n\npublic class study {\n    public static void main(String[] args) throws Exception {\n        Counter c1 = new Counter();\n        Counter c2 = new Counter();\n\n        // 对c1进行操作的线程:\n        new Thread(() -> {\n            c1.add();\n        }).start();\n        new Thread(() -> {\n            c1.dec();\n        }).start();\n\n        // 对c2进行操作的线程:\n        new Thread(() -> {\n            c2.add();\n        }).start();\n        new Thread(() -> {\n            c2.add();\n        }).start();\n\n\n        System.out.println(c1.get());\n        System.out.println(c2.get());\n\n    }\n}\n\n\nclass Counter {\n    private int count = 0;\n\n    public synchronized void add() {\n            count += 1;\n\n    }\n\n    public synchronized void dec() {\n            count -= 1;\n\n    }\n\n    public int get() {\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的，Java标准库的java.lang.StringBuffer是线程安全的。\n\n还有一些不变类，例如String，Integer，LocalDate，它们的所有成员变量都是final，多线程同时访问时只能读不能写，这些不变类也是线程安全的。\n\n最后，类似Math这些只提供静态方法，没有成员变量的类，也是线程安全的。\n\n除了上述几种少数情况，大部分类，例如ArrayList，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么ArrayList是可以安全地在线程间共享的。\n\n\n\n参考博客：https://www.liaoxuefeng.com/wiki/1252599548343744',normalizedContent:'# java 基础学习\n\n\n# 1.变量和数据类型\n\n\n# 变量\n\nint a = 1;\n\nint b;\n\nb = 1;\n\n\n\n# 基本类型的变量\n\n整数类型：byte，short，int，long\n\n浮点数类型：float，double\n\n字符类型：char\n\n布尔类型：boolean\n\n# 变量长度\n\nbyte：一个字节，8位2进制数，8bit，-128 ~ 127\n\nshort：2字节\n\nint：4字节\n\nfloat：4字节\n\ndouble：8字节\n\nchar：2字节\n\n# 引用类型的变量\n\nstring，stringbuffer，stringbuilder，var\n\n# 变量的作用域\n\n\n# 2.数组\n\n\n# 数组的定义：\n\n//一维数组声明，必须初始化长度\nint [] c = new int[4];\nint []d = {1,2,3,4};\n\n// 二维数组\nint [][]k = new int[3][4];\n\nint [][]t = new int[3][];\nt[1] = c;\n\n\n// 遍历数组\nfor (int n : d) {\n    system.out.print(n + ", ");\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n练习\n\n定义一个长度为10，10的二维数据，数组值为1-100，并倒序打印\n\n\n# 数组排序\n\nint[] t = {28, 12, 89, 73, 65, 18, 96, 50, 8, 36};\n// 排序前:\nsystem.out.println(arrays.tostring(t));\nfor (int i = 0; i < t.length - 1; i++) {\n    for (int j = 0; j < t.length - i - 1; j++) {\n        if (t[j] > t[j + 1]) {\n            // 交换ns[j]和ns[j+1]:\n            int tmp = t[j];\n            t[j] = t[j + 1];\n            t[j + 1] = tmp;\n        }\n    }\n}\n// 排序后:\nsystem.out.println(arrays.tostring(t));\n\n\n// java提供arrays.sort()实现排序\nint []a = {28, 12, 89, 73, 65, 18, 96, 50, 8, 36};\narrays.sort(a);\nsystem.out.println(arrays.tostring(a));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n练习\n\n一维数组倒序打印；\n\n随机生成一个长度为10，10的二维数据，并实现排序\n\n\n# 3.对象\n\n类与实例\n\n类：按照某种规则，抽象出来的一个模板，数据类型的一种\n\n实例：类的具体化\n\npublic class person {\n    private string name;\n    private int age;\n    private string sex;\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    public string getsex() {\n        return sex;\n    }\n\n    public void setsex(string sex) {\n        this.sex = sex;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n类的属性，用来表示类的一个特征\n\n类的方法，用来完成某个动作\n\n类的属性一般用private关键字修饰，通过get/set方法访问和给属性赋值\n\n思考：一下两种情况输出值？\n\npublic class study {\n    public static void main(string[] args) {\n        person p = new person();\n        string bob = "bob";\n        p.setname(bob);\n        system.out.println(p.getname());\n        bob = "alice";\n        system.out.println(p.getname()); // "bob"还是"alice"?\n\n        string[] fullname = new string[] { "homer", "simpson" };\n        p.setfullname(fullname);\n        system.out.println(p.getfullname());\n        fullname[0] = "bart";\n        system.out.println(p.getfullname()); // "homer simpson"还是"bart simpson"?\n    }\n}\n\nclass person {\n    private string name;\n\n    private string []fullname;\n\n    public string getname() {\n        return this.name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public string getfullname() {\n        return this.fullname[0] + " " + this.fullname[1];\n    }\n\n    public void setfullname(string [] fullname) {\n        this.fullname = fullname;\n    }\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\nimport java.util.arrays;\n\npublic class study {\n    public static void main(string[] args) {\n        person p = new person();\n        string bob = "bob";\n        p.setname(bob);\n        system.out.println(bob.hashcode());\n        system.out.println(p.getname().hashcode());\n        bob = "alice";\n        system.out.println(bob.hashcode());\n        system.out.println(p.getname().hashcode()); // "bob"还是"alice"?\n\n        string[] fullname = new string[] { "homer", "simpson" };\n        p.setfullname(fullname);\n        system.out.println(fullname[0].hashcode());\n        system.out.println(p.getfullname().hashcode());\n        fullname[0] = "bart";\n        system.out.println(fullname[0].hashcode());\n        system.out.println(p.getfullname().hashcode()); // "homer simpson"还是"bart simpson"?\n    }\n}\n\nclass person {\n    private string name;\n\n    private string []fullname;\n\n    public string getname() {\n        return this.name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public string getfullname() {\n        return this.fullname[0] + " " + this.fullname[1];\n    }\n\n    public void setfullname(string [] fullname) {\n        this.fullname = fullname;\n    }\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 构造方法\n\n默认提供无参构造方法\n\n可自定义带参数的构造方法\n\n\n# 重载\n\n方法名相同，但各自的参数不同，称为方法重载\n\n无参构造方法与带参的构造方法\n\n\n# 继承\n\nextends关键字\n\n子类可继承父类属性与方法，子类自动获得了父类的所有字段，严禁定义与父类重名的字段！\n\njava不支持多继承，所有的类都是object类的子类\n\nfinal关键字修饰的类不可被继承\n\n\n# 多肽\n\n子类中对父类的方法重写（方法名，入参，返回均相同）\n\n多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法\n\n// person类\nclass person {\n    private string name;\n\n    private string []fullname;\n\n    public string getname() {\n        return this.name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public string getfullname() {\n        return this.fullname[0] + " " + this.fullname[1];\n    }\n\n    public void setfullname(string [] fullname) {\n        this.fullname = fullname;\n    }\n\n    public string say(){\n        return "hello";\n    }\n}\n\n\n// student类\npublic class student extends person {\n\n    private string school;\n\n    public string getschool() {\n        return school;\n    }\n\n    public void setschool(string school) {\n        this.school = school;\n    }\n\n    public string say() {\n        return "hi";\n    }\n}\n\n//测试方法\npublic class study {\n    public static void main(string[] args) {\n\n        person p = new student();\n        system.out.println(p.say());\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n练习\n\n父子类定义练习，方法的重载与重写\n\n\n# 抽象类\n\nabstract关键字修饰，包含至少一个抽象方法的类\n\n\n# 接口\n\ninterface关键字修饰，所有的方法都是抽象方法，且没有属性字段\n\njava只支持单继承，但可以实现多个抽象类\n\nclass a extends classb\n\n\n# 静态字段、静态方法\n\nstatic关键字修饰，静态资源不属于实例化对象\n\n不需要实例化类，类名.字段名/类名.方法名即可访问\n\n接口类可定义静态字段\n\n\n# 包\n\npackage，每个类都是在包下，同一个包下不允许出现同名的类\n\n规范的文件目录有助于代码的管理\n\n\n# 作用域\n\npublic：可以被任何类访问到\n\nprotected：常见于继承关系中，可以被子类及其更下级子类访问\n\nprivate：无法被其他类访问\n\npackage：同一个包下，省略public/private/protected修饰的方法与字段，可被同包下代码访问\n\nfinal：修饰类，不可被继承\n\n修饰方法，不可被子类重写\n\n修饰属性，不可被更新\n\n\n# 内部类\n\n存在于另一个类内部\n\nclass a {\n    class b {\n        // 定义了一个inner class\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.java核心类\n\n\n# string / stringbuilder / stringbuffer\n\n字符串的比较：equals() 与 ==, equalsignorecase()\n\nlength()\n\ncontains()\n\ntrim()\n\nisempty()\n\nisblank()\n\nreplace()\n\nsplit()\n\nstring转int：integer.parseint("123");\n\nint转string：int n = 1; n.tostring()\n\nstring转char：char[] n = "dsad".tochararray();\n\n// 修改数组内容，string不会改变\nchar[] cs = "hello".tochararray();\nstring s = new string(cs);\nsystem.out.println(s);\ncs[0] = \'x\';\nsystem.out.println(s);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# bigdecimal\n\n表示一个任意大小且精度完全准确的浮点数\n\nbigdecimal num1 = new bigdecimal(0.005);\nbigdecimal num2 = new bigdecimal(1000000);\nbigdecimal num3 = new bigdecimal(-1000000);\n//尽量用字符串的形式初始化\nbigdecimal num12 = new bigdecimal("0.005");\nbigdecimal num22 = new bigdecimal("1000000");\nbigdecimal num32 = new bigdecimal("-1000000");\n\n//加法\nbigdecimal result1 = num1.add(num2);\nbigdecimal result12 = num12.add(num22);\n\n//减法\nbigdecimal result2 = num1.subtract(num2);\nbigdecimal result22 = num12.subtract(num22);\n\n//乘法\nbigdecimal result3 = num1.multiply(num2);\nbigdecimal result32 = num12.multiply(num22);\n\n//绝对值\nbigdecimal result4 = num3.abs();\nbigdecimal result42 = num32.abs();\n\n//除法（一定要设置精度）\nbigdecimal result5 = num2.divide(num1,20,bigdecimal.round_half_up);\nbigdecimal result52 = num22.divide(num12,20,bigdecimal.round_half_up);\n\n//比较大小\nbigdecimal a = new bigdecimal("123");\nbigdecimal b = new bigdecimal("123.00");\nsystem.out.println(a.equals(b));\nsystem.out.println(a.compareto(b));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n练习\n\n自行学习java其他常见的工具类\n\n\n# math\n\n\n# arrays\n\n\n# 5.java异常\n\nexception：nullpointerexception，indexoutofboundexception\n\nerror：outofmemoryexception,noclassdeffounderror,stackoverflowerror\n\nint a[] =  {1,2,3};\nsystem.out.println(a[4]);\n\n\n1\n2\n\n\n                     ┌───────────┐\n                     │  object   │\n                     └───────────┘\n                           ▲\n                           │\n                     ┌───────────┐\n                     │ throwable │\n                     └───────────┘\n                           ▲\n                 ┌─────────┴─────────┐\n                 │                   │\n           ┌───────────┐       ┌───────────┐\n           │   error   │       │ exception │\n           └───────────┘       └───────────┘\n                 ▲                   ▲\n         ┌───────┘              ┌────┴──────────┐\n         │                      │               │\n┌─────────────────┐    ┌─────────────────┐┌───────────┐\n│outofmemoryerror │... │runtimeexception ││ioexception│...\n└─────────────────┘    └─────────────────┘└───────────┘\n                                ▲\n                    ┌───────────┴─────────────┐\n                    │                         │\n         ┌─────────────────────┐ ┌─────────────────────────┐\n         │nullpointerexception │ │illegalargumentexception │...\n         └─────────────────────┘ └─────────────────────────┘                         \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 异常的处理\n\nthrows关键字抛至外层\n\ntry catcah模块化处理\n\n// throws关键字抛至外层\npublic static void main(string[] args) throws unsupportedencodingexception {\n    byte[] bs = togbk("中文");\n    system.out.println(arrays.tostring(bs));\n}\n\nstatic byte[] togbk(string s) throws unsupportedencodingexception {\n\n    return s.getbytes("gbk");\n}\n\n// try catcah模块化处理\npublic static void main(string[] args) {\n    byte[] bs = togbk("中文");\n    system.out.println(arrays.tostring(bs));\n}\n\nstatic byte[] togbk(string s) {\n    try {\n        // 用指定编码转换string为byte[]:\n        return s.getbytes("gbk");\n    } catch (unsupportedencodingexception e) {\n        // 如果系统不支持gbk编码，会捕获到unsupportedencodingexception:\n        e.printstacktrace(); // 打印异常信息\n        return s.getbytes(); // 尝试使用用默认编码\n    }\n}\n\n// 抛至外层做异常捕获\npublic static void main(string[] args){\n    try {\n        byte[] bs = togbk("中文");\n        system.out.println(arrays.tostring(bs));\n\n    } catch (exception e) {\n        e.printstacktrace();\n    }\n}\n\nstatic byte[] togbk(string s) throws unsupportedencodingexception {\n\n    return s.getbytes("gbk");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 多catch语句\n\n针对每种错误做个性化处理\n\ntry {\n\t// 程序处理\n\n} catch (ioexception e) {\n\n\te.printstacktrace();\n\n} catch (nullpointerexception e) {\n\n\te.printstacktrace();\n} catch (sqlexception e ) {\n\n\te.printstacktrace();\n} finally {\n\t// 其他处理逻辑\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 自定义异常\n\n实际项目中，会有很多业务上的校验逻辑，这时候需要自定义异常\n\npublic class testexception extends runtimeexception {\n\n\n    public testexception() {\n    }\n\n    public testexception(string message) {\n        super(message);\n    }\n\n    public testexception(string message, throwable cause) {\n        super(message, cause);\n    }\n\n    public testexception(throwable cause) {\n        super(cause);\n    }\n\n    public testexception(string message, throwable cause, boolean enablesuppression, boolean writablestacktrace) {\n        super(message, cause, enablesuppression, writablestacktrace);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 6.反射\n\njava的反射是指程序在运行期可以拿到一个对象的所有信息\n\n\n# 获取class\n\n// 通过一个class的静态变量class获取\nclass cls1 = person.class;\n\n// 通过该实例变量获取\nperson p = new person();\nclass cls2 = p.getclass();\n\n// 通过完整类名获取\nclass cls3 = class.forname("person");\n\n\nsystem.out.println(cls1 == cls2);\nsystem.out.println(cls1.equals(cls2));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 访问字段\n\n * field getfield(name)：根据字段名获取某个public的field（包括父类）\n * field getdeclaredfield(name)：根据字段名获取当前类的某个field（不包括父类）\n * field[] getfields()：获取所有public的field（包括父类）\n * field[] getdeclaredfields()：获取当前类的所有field（不包括父类）\n\n// 通过一个class的静态变量class获取\nclass cls1 = person.class;\n\n// 通过该实例变量获取\nperson p = new student();\nclass cls2 = p.getclass();\n\n// 通过完整类名获取\nclass cls3 = class.forname("person");\n\nsystem.out.println(cls1.getname());\nsystem.out.println(cls1.getfield("name"));\nsystem.out.println(cls1.getdeclaredfield("fullname"));\n\n\n// 获取字段值，设置字段值\np.setname("hello");\nclass c = p.getclass();\nfield f = c.getdeclaredfield("name");\nsystem.out.println(f);\nf.setaccessible(true);\nobject value = f.get(p);\nf.set(p,"12123");\nsystem.out.println(value);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 访问方法\n\n * getmethod(name, class...)：获取某个public的method（包括父类）\n\n * getdeclaredmethod(name, class...)：获取当前类的某个method（不包括父类）\n\n * getmethods()：获取所有public的method（包括父类）\n\n * getdeclaredmethods()：获取当前类的所有method（不包括父类）\n   \n   注意：前两个方法内的class是指被反射方法的入参类型\n\nperson p = new person();\nmethod m1 = cls1.getmethod("getname");\nsystem.out.println(m1);\nsystem.out.println(m1.invoke(p));\n\n\nmethod m2 = cls1.getdeclaredmethod("setname", string.class);\nm2.invoke(p,"123");\nsystem.out.println(m1.invoke(p));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 7.泛型\n\n泛型就是编写模板代码来适应任意类型；\n\n泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查\n\nlist<string> list1 = new arraylist<>();\nlist<long> list2 = new arraylist<>();\nlist<student> list3 = new arraylist<>();\n\n\n1\n2\n3\n\n\n编写泛型类时，要特别注意，泛型类型<t>不能用于静态方法\n\n\n# 多个泛型类型\n\n泛型还可以定义多种类型。例如，我们希望pair不总是存储两个类型一样的对象，就可以使用类型<t, k>：\n\npublic class pair<t, k> {\n    private t first;\n    private k last;\n    public pair(t first, k last) {\n        this.first = first;\n        this.last = last;\n    }\n    public t getfirst() { ... }\n    public k getlast() { ... }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用的时候，需要指出两种类型：\n\npair<string, integer> p = new pair<>("test", 123);\n\n\n1\n\n\nextends , super 通配符\n\n\n# 8.集合\n\njava.util包主要提供了以下三种类型的集合\n\nlist：一种有序列表的集合，例如，按索引排列的student的list；\n\nset：一种保证没有重复元素的集合，例如，所有无重复名称的student的set；\n\nmap：一种通过键值（key-value）查找的映射表集合，例如，根据student的name查找对应student map。\n\n\n# list\n\n思考：用数组声明一个长度为5的集合，删除第三个元素，再依次打印\n\n用数组声明一个长度为5的集合，添加一个新的元素到第三个位置，并打印\n\n数组的长度在声明时已经固定，无法继续添加元素\n\nlist可以任意添加，list先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组；\n\nlist允许添加重复元素和空元素\n\n//遍历list\nlist<string> list = arrays.aslist("apple", "pear", "banana");\nfor (int i=0; i<list.size(); i++) {\n    string s = list.get(i);\n    system.out.println(s);\n}\n\n// 迭代器遍历list\nfor (iterator<string> it = list.iterator(); it.hasnext(); ) {\n    string s = it.next();\n    system.out.println(s);\n}\n\n// foreach\nfor (string s : list) {\n    system.out.println(s);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n实际上，只要实现了iterable接口的集合类都可以直接用for each循环来遍历，java编译器本身并不知道如何遍历集合对象，但它会自动把for each循环变成iterator的调用，原因就在于iterable接口定义了一个iterator<e> iterator()方法，强迫集合类必须返回一个iterator实例\n\n练习\n\n给定一组连续的整数，例如：10，11，12，……，20，将其打乱后随机删除其中一个数字，试找出缺失的数字\n\npublic static void main(string[] args) {\n        // 构造从start到end的序列：\n        final int start = 10;\n        final int end = 20;\n        list<integer> list = new arraylist<>();\n        for (int i = start; i <= end; i++) {\n            list.add(i);\n        }\n        //打乱排序\n        collections.shuffle(list);\n        system.out.println(list.tostring());\n\n        // 随机删除list中的一个元素:\n        int index = (int) (math.random() * list.size());\n        system.out.println(list.get(index));\n        int removed = list.remove(index);\n        int found = findmissingnumber(start, end, list);\n        system.out.println(list.tostring());\n        system.out.println("missing number: " + found);\n        system.out.println(removed == found ? "测试成功" : "测试失败");\n    }\n\n    static int findmissingnumber(int start, int end, list<integer> list) {\n\n        collections.sort(list);\n        system.out.println(list.tostring());\n        int count = 10;\n        for (iterator<integer> it = list.iterator();it.hasnext();) {\n\n            integer a = it.next();\n            if (a > count) {\n                system.out.println(a-1);\n                return a-1;\n            }\n            count++;\n        }\n        return 1;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 重写equals方法\n\npublic static void main(string[] args) {\n    list<string> list = arrays.aslist("a", "b", "c");\n    system.out.println(list.contains(new string("c"))); // true or false?\n    system.out.println(list.indexof(new string("c"))); // 2 or -1?\n\n    list<person> plist = arrays.aslist(new person("a"), new person("b"), new person("c"));\n    system.out.println(plist.contains(new person("b")));\n    system.out.println(plist.indexof(new person("b")));\n}\n\nclass person {\n    private string name;\n\n    private string []fullname;\n\n    public string getname() {\n        return this.name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public string getfullname() {\n        return this.fullname[0] + " " + this.fullname[1];\n    }\n\n    public void setfullname(string [] fullname) {\n        this.fullname = fullname;\n    }\n\n    public string say(){\n        return "hello";\n    }\n\n    public person(string name) {\n        this.name = name;\n    \n        \n    public boolean equals(object o) {\n        if (o instanceof person) {\n            person p = (person) o;\n            return this.name.equals(p.name);\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n练习：拓展person类equals方法，增加fullname属性判断\n\n\n# map\n\nlist是一个顺序列表，常用访问方式是通过下标，如果需要根据name来查询集合中的某个元素呢？\n\npublic class main {\n    public static void main(string[] args) {\n        student s = new student("xiao ming", 99);\n        map<string, student> map = new hashmap<>();\n        map.put("xiao ming", s); // 将"xiao ming"和student实例映射并关联\n        student target = map.get("xiao ming"); // 通过key查找并返回映射的student实例\n        system.out.println(target == s); // true，同一个实例\n        system.out.println(target.score); // 99\n        student another = map.get("bob"); // 通过另一个key查找\n        system.out.println(another); // 未找到返回null\n    }\n}\n\nclass student {\n    public string name;\n    public int score;\n    public student(string name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nmap中key不允许重复，第二次输入的值回覆盖第一次，value可以重复\n\n遍历map\n\nmap<string, integer> map = new hashmap<>();\nmap.put("apple", 123);\nmap.put("pear", 456);\nmap.put("banana", 789);\nfor (string key : map.keyset()) {\ninteger value = map.get(key);\nsystem.out.println(key + " = " + value);\n}\n\n\nfor (map.entry<string, integer> entry : map.entryset()) {\nstring key = entry.getkey();\ninteger value = entry.getvalue();\nsystem.out.println(key + " = " + value);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n练习：将学生成绩从高到底打印出来，并能根据name查找score\n\n\n# set\n\n常用方法：add()，remove()，contains()\n\nset内元素不可重复，相当于一个只存有key的map\n\nset接口并不保证有序，而sortedset接口则保证元素是有序的：\n\nhashset是无序的，因为它实现了set接口，并没有实现sortedset接口；\n\ntreeset是有序的，因为它实现了sortedset接口\n\n set<string> set = new treeset<>();\n // set<string> set = new hashset<>();\n\n set.add("apple");\n set.add("banana");\n set.add("pear");\n set.add("orange");\n for (string s : set) {\n system.out.println(s);\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n练习：声明一个长度为100，值范围为1-70的随机数集合，判断有多少个重复数字，每个重复数字各出现多少次\n\n\n# collections\n\ncollections提供了一系列方法来创建空集合：\n\n * 创建空list：list<t> emptylist()\n * 创建空map：map<k, v> emptymap()\n * 创建空set：set<t> emptyset()\n\n对list排序：collections.sort()\n\n洗牌：collections.shuffle(list)\n\ncollections还提供了一组方法把可变集合封装成不可变集合：\n\n * 封装成不可变list：list<t> unmodifiablelist(list<? extends t> list)\n * 封装成不可变set：set<t> unmodifiableset(set<? extends t> set)\n * 封装成不可变map：map<k, v> unmodifiablemap(map<? extends k, ? extends v> m)\n\npublic class main {\n    public static void main(string[] args) {\n        list<string> mutable = new arraylist<>();\n        mutable.add("apple");\n        mutable.add("pear");\n        // 变为不可变集合:\n        list<string> immutable = collections.unmodifiablelist(mutable);\n        immutable.add("orange"); // unsupportedoperationexception!\n        \n        // 可继续操作原list\n        mutable.add("orange");\n        system.out.println(immutable);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ncollections还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：\n\n * 变为线程安全的list：list<t> synchronizedlist(list<t> list)\n * 变为线程安全的set：set<t> synchronizedset(set<t> s)\n * 变为线程安全的map：map<k,v> synchronizedmap(map<k,v> m)\n\n\n# 9.io\n\n字节流：inputstream / outputstream\n\n字符流：reader / writer\n\n\n# file\n\npublic class main {\n    public static void main(string[] args) {\n        //windows下用\\分割，linux下用/\n        file f = new file("c:\\\\users\\\\10457\\\\desktop\\\\1.xml");\n        system.out.println(f);\n        system.out.println(f.getpath());\n        system.out.println(f.getabsolutepath());\n        system.out.println(f.getcanonicalpath());\n\n        // 假设当前目录是c:\\docs\n        file f1 = new file("sub\\\\javac"); // 绝对路径是c:\\docs\\sub\\javac\n        file f2 = new file(".\\\\sub\\\\javac"); // 绝对路径是c:\\docs\\sub\\javac\n        file f3 = new file("..\\\\sub\\\\javac"); // 绝对路径是c:\\sub\\javac\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nfile可指具体的文件，也可以指一个文件目录\n\nisfile()判断文件是否存在\n\nisdirectory()判断目录是否存在\n\n file f1 = new file("c:\\\\windows");\n file f2 = new file("c:\\\\windows\\\\notepad.exe");\n file f3 = new file("c:\\\\windows\\\\nothing");\n system.out.println(f1.isfile());\n system.out.println(f1.isdirectory());\n system.out.println(f2.isfile());\n system.out.println(f2.isdirectory());\n system.out.println(f3.isfile());\n system.out.println(f3.isdirectory());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nboolean canread()：是否可读；\n\nboolean canwrite()：是否可写；\n\nboolean canexecute()：是否可执行；\n\nlong length()：文件字节大小。\n\n// 创建/删除文件\nfile file = new file("d:\\\\file1");\nfile.createnewfile();\nfile.delete();\n\n\n// 提供临时文件的前缀和后缀\nfile f = file.createtempfile("tmp-", ".txt");\nf.deleteonexit(); // jvm退出时自动删除\nsystem.out.println(f.isfile());\nsystem.out.println(f.getabsolutepath());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 遍历文件和目录\n\npublic static void main(string[] args) throws exception {\n        file f = new file("c:\\\\windows");\n        file[] fs1 = f.listfiles(); // 列出所有文件和子目录\n\n        system.out.println("==========");\n        if (fs1 != null) {\n            for (file ff : fs1) {\n                system.out.println(ff);\n            }\n        }\n        system.out.println("==========");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# path\n\npath p1 = paths.get(".", "project", "study"); // 构造一个path对象\nsystem.out.println(p1);\npath p2 = p1.toabsolutepath(); // 转换为绝对路径\nsystem.out.println(p2);\npath p3 = p2.normalize(); // 转换为规范路径\nsystem.out.println(p3);\nfile f = p3.tofile(); // 转换为file对象\nsystem.out.println(f);\nfor (path p : paths.get("..").toabsolutepath()) { // 可以直接遍历path\nsystem.out.println("  " + p);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n练习：列出某一目录下所有子目录及文件，并按层级打印\n\n\n# inputstream\n\npublic static void main(string[] args) throws exception {\n    inputstream input = null;\n    try {\n        input = new fileinputstream("c:\\\\users\\\\10457\\\\desktop\\\\2.txt");\n        int n;\n        while ((n = input.read()) != -1) { // 利用while同时读取并判断\n            system.out.println(n);\n        }\n    } finally {\n        if (input != null) { input.close(); }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n缓冲:在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多\n\npublic static void main(string[] args) throws exception {\n        inputstream input = null;\n        try {\n            input = new fileinputstream("c:\\\\users\\\\10457\\\\desktop\\\\2.txt");\n            byte[] buffer = new byte[1000];\n            int n;\n            while ((n = input.read(buffer)) != -1) { // 利用while同时读取并判断\n                system.out.println("read " + n + " bytes.");\n            }\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# outputstream\n\n    public static void main(string[] args) throws exception {\n        // 逐个字节写入\n        outputstream output = new fileoutputstream("c:\\\\users\\\\10457\\\\desktop\\\\2.txt");\n        output.write(72); // h\n        output.write(101); // e\n        output.write(108); // l\n        output.write(108); // l\n        output.write(111); // o\n        output.close();\n        \n        // 多字节写入\n        output.write("hello".getbytes("utf-8")); // hello\n        output.close();\n        \n        \n        try (outputstream output = new fileoutputstream("c:\\\\users\\\\10457\\\\desktop\\\\2.txt")) {\n            output.write("hello".getbytes("utf-8"));\n            output.write("\\n".getbytes("utf-8"));\n            output.write("world".getbytes("utf-8"));\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n拓展： bytearrayinputstream / bytearrayoutputstream自行学习理解\n\n练习：编写一个复制文件的程序，要求使用缓冲，且无乱码\n\ninputstream input = null;\n        outputstream output = null;\n        try {\n            input = new fileinputstream("c:\\\\users\\\\10457\\\\desktop\\\\2.txt");\n\n            output = new fileoutputstream("c:\\\\users\\\\10457\\\\desktop\\\\3.pdf");\n            byte[] buffer = new byte[1000];\n            int n;\n            while ((n = input.read(buffer)) != -1) { // 利用while同时读取并判断\n                output.write(buffer);\n            }\n        } catch (filenotfoundexception e) {\n            e.printstacktrace();\n        } catch (ioexception e) {\n            e.printstacktrace();\n        } finally {\n\n            try {\n                input.close();\n                output.close();\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# reader\n\n字符输入流\n\n# filereader\n\npublic static void main(string[] args) throws exception {\n        // "c:\\\\users\\\\10457\\\\desktop\\\\2.txt"\n        try (reader reader = new filereader("c:\\\\users\\\\10457\\\\desktop\\\\2.txt")) {\n            char[] buffer = new char[1000];\n            int n;\n            while ((n = reader.read(buffer)) != -1) {\n                system.out.println(buffer);\n                system.out.println("read " + n + " chars.");\n            }\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# chararrayreader\n\n# stringreader\n\n# inputstreamreader\n\n练习：自行学习使用其余几种reader\n\n\n# wirter\n\n# filewriter\n\n public static void main(string[] args) throws exception {\n        // "c:\\\\users\\\\10457\\\\desktop\\\\2.txt"\n        try (writer writer = new filewriter("c:\\\\users\\\\10457\\\\desktop\\\\3.txt")) {\n            writer.write(\'h\'); // 写入单个字符\n            writer.write("测测试".tochararray()); // 写入char[]\n            writer.write("hand"); // 写入string\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# chararraywriter\n\n# stringwriter\n\n# outputstreamwriter\n\n练习：自行学习使用其余几种writer\n\n练习：用reader/writer编写一个复制文件的程序，要求使用缓冲，且无乱码\n\n\n# 10.多线程\n\n在计算机中，我们把一个任务称为一个进程，进程内至少包含一个线程\n\n\n# 创建线程\n\n1.继承thread类\n\npublic class study {\n    public static void main(string[] args) {\n        thread t = new mythread();\n        t.start(); // 启动新线程\n    }\n}\n\nclass mythread extends thread {\n    @override\n    public void run() {\n        system.out.println("start new thread!");\n    }\n}\n\n// lambda语法简写\npublic static void main(string[] args) {\n    thread t = new thread(() -> {\n        system.out.println("start new thread!");\n    });\n    t.start(); // 启动新线程\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n2.实现runnable 接口\n\npublic class study {\n    public static void main(string[] args) {\n        runnable t1 = new myrunnable();\n        t1.run();\n\n    }\n}\n\nclass myrunnable implements runnable {\n    @override\n    public void run() {\n        system.out.println("start new thread!");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n优先级：优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。\n\nthread.setpriority(1);\n\n3.使用线程池\n\n * fixedthreadpool：线程数固定的线程池；\n * cachedthreadpool：线程数根据任务动态调整的线程池；\n * singlethreadexecutor：仅单线程执行的线程池。\n\npublic class study {\n    public static void main(string[] args) {\n        // 创建一个固定大小的线程池:\n        executorservice es = executors.newfixedthreadpool(4);\n        for (int i = 0; i < 6; i++) {\n            es.submit(new task("" + i));\n        }\n        // 关闭线程池:\n        es.shutdown();\n    }\n}\n\nclass task implements runnable {\n    private final string name;\n\n    public task(string name) {\n        this.name = name;\n    }\n\n    @override\n    public void run() {\n        system.out.println("start task " + name);\n        try {\n            thread.sleep(1000);\n        } catch (interruptedexception e) {\n        }\n        system.out.println("end task " + name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nscheduledthreadpool：需要反复执行的任务\n\npublic class study {\n    public static void main(string[] args) {\n//        executorservice es = executors.newsinglethreadexecutor();\n//        for (int i = 0; i < 6; i++) {\n//            es.submit(new task("" + i));\n//        }\n//        // 关闭线程池:\n//        es.shutdown();\n\n\n        scheduledexecutorservice ses = executors.newscheduledthreadpool(4);\n        // 1秒后执行一次性任务\n        ses.schedule(new task("one-time"), 1, timeunit.seconds);\n        // 2秒后执行定时任务，每3秒执行（不管每次任务执行多长时间）\n        ses.scheduleatfixedrate(new task("fixed-rate"), 2, 3, timeunit.seconds);\n        // 2秒后开始执行定时任务，以3秒为间隔执行（上一次任务结束后间隔3秒再次执行）\n        ses.schedulewithfixeddelay(new task("fixed-delay"), 2, 3, timeunit.seconds);\n    }\n}\n\nclass task implements runnable {\n    private final string name;\n\n    public task(string name) {\n        this.name = name;\n    }\n\n    @override\n    public void run() {\n        system.out.println("start task " + name);\n        try {\n            thread.sleep(1000);\n        } catch (interruptedexception e) {\n        }\n        system.out.println("end task " + name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n思考：如果任务抛出了异常，后续任务是否继续执行\n\n4.callable接口\n\n与runable接口最大不同，callable接口有返回值\n\npublic class study {\n    public static void main(string[] args) throws exception {\n        // 创建一个固定大小的线程池:\n        executorservice executor = executors.newfixedthreadpool(4);\n        callable<string> task = new task();\n        future<string> future = executor.submit(task);\n        string result = future.get(); // 可能阻塞\n        system.out.println(result);\n        executor.shutdown();\n    }\n}\n\nclass task implements callable<string> {\n    public string call() throws exception {\n        return "123";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n练习：使用线程池分别计算1-100的加和，100-200的加和，以及前两项的加和；\n\n\n# 线程的状态\n\nnew：新创建的线程，尚未执行；\n\nrunnable：运行中的线程，正在执行run()方法的java代码；\n\nblocked：运行中的线程，因为某些操作被阻塞而挂起；\n\nwaiting：运行中的线程，因为某些操作等待中，或因执行sleep()方法正在计时等待；\n\nwaiting：运行中的线程，因为执行sleep()方法正在计时等待；\n\nterminated：线程已终止，因为run()方法执行完毕。\n\n// 一个线程还可以等待另一个线程直到其运行结束\npublic static void main(string[] args) throws interruptedexception {\n        thread t = new thread(() -> {\n            system.out.println("hello");\n        });\n        system.out.println("start");\n        t.start();\n        t.join();\n        system.out.println("end");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 中断线程\n\npublic class study {\n    public static void main(string[] args) throws interruptedexception {\n        thread t = new mythread();\n        t.start();\n        thread.sleep(1); // 暂停1毫秒\n        t.interrupt(); // 中断t线程\n        t.join(); // 等待t线程结束\n        system.out.println("end");\n    }\n}\n\nclass mythread extends thread {\n    public void run() {\n        int n = 0;\n        while (!isinterrupted()) {\n            n++;\n            system.out.println(n + " hello!");\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 线程同步\n\npublic class study {\n    public static void main(string[] args) throws interruptedexception {\n        thread t = new mythread();\n        thread t2 = new mythread2();\n        t.start();\n        t2.start();\n        t.join();\n        t2.join();\n        system.out.println(number.a);\n    }\n}\n\nclass number {\n    public static int a = 0;\n}\n\nclass mythread extends thread {\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            number.a += 1;\n        }\n    }\n}\n\nclass mythread2 extends thread {\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            number.a += 1;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n原子操作：保证每一次读写都是不可中断的\n\nsynchronized关键字加锁\n\npublic class study {\n    public static void main(string[] args) throws interruptedexception {\n        thread t = new mythread();\n        thread t2 = new mythread2();\n        t.start();\n        t2.start();\n        t.join();\n        t2.join();\n        system.out.println(number.a);\n    }\n}\n\nclass number {\n    public static final object lock = new object();\n    public static int a = 0;\n}\n\nclass mythread extends thread {\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            synchronized(number.lock){number.a += 1;}\n        }\n    }\n}\n\nclass mythread2 extends thread {\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            synchronized(number.lock){number.a += 1;}\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nsynchronized关键字修饰方法\n\npublic class study {\n    public static void main(string[] args) throws exception {\n        counter c1 = new counter();\n        counter c2 = new counter();\n\n        // 对c1进行操作的线程:\n        new thread(() -> {\n            c1.add();\n        }).start();\n        new thread(() -> {\n            c1.dec();\n        }).start();\n\n        // 对c2进行操作的线程:\n        new thread(() -> {\n            c2.add();\n        }).start();\n        new thread(() -> {\n            c2.add();\n        }).start();\n\n\n        system.out.println(c1.get());\n        system.out.println(c2.get());\n\n    }\n}\n\n\nclass counter {\n    private int count = 0;\n\n    public synchronized void add() {\n            count += 1;\n\n    }\n\n    public synchronized void dec() {\n            count -= 1;\n\n    }\n\n    public int get() {\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的，java标准库的java.lang.stringbuffer是线程安全的。\n\n还有一些不变类，例如string，integer，localdate，它们的所有成员变量都是final，多线程同时访问时只能读不能写，这些不变类也是线程安全的。\n\n最后，类似math这些只提供静态方法，没有成员变量的类，也是线程安全的。\n\n除了上述几种少数情况，大部分类，例如arraylist，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么arraylist是可以安全地在线程间共享的。\n\n\n\n参考博客：https://www.liaoxuefeng.com/wiki/1252599548343744',charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"java反射",frontmatter:{title:"java反射",date:"2021-07-09T14:35:35.000Z",permalink:"/pages/2ec93c/",categories:["后端","java"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/00.java/02.java%E5%8F%8D%E5%B0%84.html",relativePath:"01.后端/00.java/02.java反射.md",key:"v-fcc0afa6",path:"/pages/2ec93c/",headers:[{level:2,title:"二.反射",slug:"二-反射",normalizedTitle:"二.反射",charIndex:2},{level:3,title:"2.1.获取字段",slug:"_2-1-获取字段",normalizedTitle:"2.1.获取字段",charIndex:11},{level:3,title:"2.2.获取private字段的值",slug:"_2-2-获取private字段的值",normalizedTitle:"2.2.获取private字段的值",charIndex:232},{level:3,title:"2.3.修改某个字段的值",slug:"_2-3-修改某个字段的值",normalizedTitle:"2.3.修改某个字段的值",charIndex:622},{level:3,title:"2.4.获取方法并调用",slug:"_2-4-获取方法并调用",normalizedTitle:"2.4.获取方法并调用",charIndex:1014},{level:3,title:"2.5.获取构造方法构造方法",slug:"_2-5-获取构造方法构造方法",normalizedTitle:"2.5.获取构造方法构造方法",charIndex:1543},{level:3,title:"2.2.动态代理",slug:"_2-2-动态代理",normalizedTitle:"2.2.动态代理",charIndex:2157}],headersStr:"二.反射 2.1.获取字段 2.2.获取private字段的值 2.3.修改某个字段的值 2.4.获取方法并调用 2.5.获取构造方法构造方法 2.2.动态代理",content:'# 二.反射\n\n\n# 2.1.获取字段\n\nField getField(name)：根据字段名获取某个public的field（包括父类）\nField getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）\nField[] getFields()：获取所有public的field（包括父类）\nField[] getDeclaredFields()：获取当前类的所有field（不包括父类）\n\n\n1\n2\n3\n4\n\n\n\n# 2.2.获取private字段的值\n\n反射可以获取public的值，若要获取private的值，必须设置name.setAccessible(true)\n\n        Parson parson=new Parson();\n        Class<? extends Parson> parson1 = parson.getClass();\n        \n        //获取private某个字段的值\n        Field name = parson1.getDeclaredField("name");\n        name.setAccessible(true);\n        Object o = name.get(parson);\n        System.out.println(o);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2.3.修改某个字段的值\n\n        Field name = parson1.getDeclaredField("name");\n        name.setAccessible(true);//private允许修改\n        Object o = name.get(parson);\n        System.out.println(o);\n        //修改某个字段的值\n        System.out.println("修改值");\n        name.set(parson,"xiaowang");\n        System.out.println(name.get(parson));\n        System.out.println(parson.getName());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2.4.获取方法并调用\n\nMethod getMethod(name, Class...)：获取某个public的Method（包括父类）\nMethod getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）\nMethod[] getMethods()：获取所有public的Method（包括父类）\nMethod[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）\n\n\n1\n2\n3\n4\n\n\n> 通过反射来调用String的substring方法\n\n\t\t//通过反射调用subString方法\n        String str="hello word";\n        Method substring = String.class.getMethod("substring", int.class);//获取方法 方法入参的类型\n        Object invoke = substring.invoke(str, 6);//调用方法并传参数\n        System.out.println(invoke);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.5.获取构造方法构造方法\n\n# 获取无参构造\n\nString p = String.class.newInstance();//\n\n\n1\n\n\n# 获取有参构造\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 获取构造方法Integer(int):\n        Constructor cons1 = Integer.class.getConstructor(int.class);\n        // 调用构造方法:\n        Integer n1 = (Integer) cons1.newInstance(123);\n        System.out.println(n1);\n\n        // 获取构造方法Integer(String)\n        Constructor cons2 = Integer.class.getConstructor(String.class);\n        Integer n2 = (Integer) cons2.newInstance("456");\n        System.out.println(n2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.2.动态代理\n\n> JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。\n\n// Main.java\npublic class Main {\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            create(args[0]);\n        }\n    }\n\n    static void create(String name) {\n        Person p = new Person(name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当执行Main.java时，由于用到了Main，因此，JVM首先会把Main.class加载到内存。然而，并不会加载Person.class，除非程序执行到create()方法，JVM发现需要加载Person类时，才会首次加载Person.class。如果没有执行create()方法，那么Person.class根本就不会被加载。\n\n> 动态加载class的特性对于Java程序非常重要。利用JVM动态加载class的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：\n\n// Commons Logging优先使用Log4j:\nLogFactory factory = null;\nif (isClassPresent("org.apache.logging.log4j.Logger")) {\n    factory = createLog4j();\n} else {\n    factory = createJdkLog();\n}\n\nboolean isClassPresent(String name) {\n    try {\n        Class.forName(name);\n        return true;\n    } catch (Exception e) {\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这就是为什么我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。\n\n> jdk动态代理：\n> \n> 定义一个接口，不需要接口的实现，直接在运行的时候调用该实现方法\n\npublic class Main {\n    public static void main(String[] args) {\n        InvocationHandler handler = new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(method);\n                if (method.getName().equals("morning")) {\n                    System.out.println("Good morning, " + args[0]);\n                }\n                return null;\n            }\n        };\n        Hello hello = (Hello) Proxy.newProxyInstance(\n            Hello.class.getClassLoader(), // 传入ClassLoader\n            new Class[] { Hello.class }, // 传入要实现的接口\n            handler); // 传入处理调用方法的InvocationHandler\n        hello.morning("Bob");\n    }\n}\n\ninterface Hello {\n    void morning(String name);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n',normalizedContent:'# 二.反射\n\n\n# 2.1.获取字段\n\nfield getfield(name)：根据字段名获取某个public的field（包括父类）\nfield getdeclaredfield(name)：根据字段名获取当前类的某个field（不包括父类）\nfield[] getfields()：获取所有public的field（包括父类）\nfield[] getdeclaredfields()：获取当前类的所有field（不包括父类）\n\n\n1\n2\n3\n4\n\n\n\n# 2.2.获取private字段的值\n\n反射可以获取public的值，若要获取private的值，必须设置name.setaccessible(true)\n\n        parson parson=new parson();\n        class<? extends parson> parson1 = parson.getclass();\n        \n        //获取private某个字段的值\n        field name = parson1.getdeclaredfield("name");\n        name.setaccessible(true);\n        object o = name.get(parson);\n        system.out.println(o);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2.3.修改某个字段的值\n\n        field name = parson1.getdeclaredfield("name");\n        name.setaccessible(true);//private允许修改\n        object o = name.get(parson);\n        system.out.println(o);\n        //修改某个字段的值\n        system.out.println("修改值");\n        name.set(parson,"xiaowang");\n        system.out.println(name.get(parson));\n        system.out.println(parson.getname());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2.4.获取方法并调用\n\nmethod getmethod(name, class...)：获取某个public的method（包括父类）\nmethod getdeclaredmethod(name, class...)：获取当前类的某个method（不包括父类）\nmethod[] getmethods()：获取所有public的method（包括父类）\nmethod[] getdeclaredmethods()：获取当前类的所有method（不包括父类）\n\n\n1\n2\n3\n4\n\n\n> 通过反射来调用string的substring方法\n\n\t\t//通过反射调用substring方法\n        string str="hello word";\n        method substring = string.class.getmethod("substring", int.class);//获取方法 方法入参的类型\n        object invoke = substring.invoke(str, 6);//调用方法并传参数\n        system.out.println(invoke);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.5.获取构造方法构造方法\n\n# 获取无参构造\n\nstring p = string.class.newinstance();//\n\n\n1\n\n\n# 获取有参构造\n\npublic class main {\n    public static void main(string[] args) throws exception {\n        // 获取构造方法integer(int):\n        constructor cons1 = integer.class.getconstructor(int.class);\n        // 调用构造方法:\n        integer n1 = (integer) cons1.newinstance(123);\n        system.out.println(n1);\n\n        // 获取构造方法integer(string)\n        constructor cons2 = integer.class.getconstructor(string.class);\n        integer n2 = (integer) cons2.newinstance("456");\n        system.out.println(n2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.2.动态代理\n\n> jvm在执行java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。\n\n// main.java\npublic class main {\n    public static void main(string[] args) {\n        if (args.length > 0) {\n            create(args[0]);\n        }\n    }\n\n    static void create(string name) {\n        person p = new person(name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当执行main.java时，由于用到了main，因此，jvm首先会把main.class加载到内存。然而，并不会加载person.class，除非程序执行到create()方法，jvm发现需要加载person类时，才会首次加载person.class。如果没有执行create()方法，那么person.class根本就不会被加载。\n\n> 动态加载class的特性对于java程序非常重要。利用jvm动态加载class的特性，我们才能在运行期根据条件加载不同的实现类。例如，commons logging总是优先使用log4j，只有当log4j不存在时，才使用jdk的logging。利用jvm动态加载特性，大致的实现代码如下：\n\n// commons logging优先使用log4j:\nlogfactory factory = null;\nif (isclasspresent("org.apache.logging.log4j.logger")) {\n    factory = createlog4j();\n} else {\n    factory = createjdklog();\n}\n\nboolean isclasspresent(string name) {\n    try {\n        class.forname(name);\n        return true;\n    } catch (exception e) {\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这就是为什么我们只需要把log4j的jar包放到classpath中，commons logging就会自动使用log4j的原因。\n\n> jdk动态代理：\n> \n> 定义一个接口，不需要接口的实现，直接在运行的时候调用该实现方法\n\npublic class main {\n    public static void main(string[] args) {\n        invocationhandler handler = new invocationhandler() {\n            @override\n            public object invoke(object proxy, method method, object[] args) throws throwable {\n                system.out.println(method);\n                if (method.getname().equals("morning")) {\n                    system.out.println("good morning, " + args[0]);\n                }\n                return null;\n            }\n        };\n        hello hello = (hello) proxy.newproxyinstance(\n            hello.class.getclassloader(), // 传入classloader\n            new class[] { hello.class }, // 传入要实现的接口\n            handler); // 传入处理调用方法的invocationhandler\n        hello.morning("bob");\n    }\n}\n\ninterface hello {\n    void morning(string name);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n',charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"java集合",frontmatter:{title:"java集合",date:"2021-07-08T19:10:05.000Z",permalink:"/pages/4400b9/",categories:["java"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/00.java/03.java%E9%9B%86%E5%90%88.html",relativePath:"01.后端/00.java/03.java集合.md",key:"v-65d0c5d8",path:"/pages/4400b9/",headers:[{level:2,title:"一.对HashMap排序（TreeMap只能对Key排序)",slug:"一-对hashmap排序-treemap只能对key排序",normalizedTitle:"一.对hashmap排序（treemap只能对key排序)",charIndex:11}],headersStr:"一.对HashMap排序（TreeMap只能对Key排序)",content:"# java\n\n\n# 一.对HashMap排序（TreeMap只能对Key排序)\n\n> map根据value倒序排序\n\nmap.entrySet().stream().sorted(Collections.reverseOrder(Map.Entry.comparingByValue())).forEach(System.out::println);\n\n\n1\n\n\n> map根据key倒序排序\n\nmap.entrySet().stream().sorted(Collections.reverseOrder(Map.Entry.comparingByKey())).forEach(System.out::println);\n\n\n1\n\n\n> map根据value正序排序\n\nmap.entrySet().stream().sorted(Comparator.comparing(e -> e.getValue())).forEach(System.out::println);\n\n\n1\n\n\n> map根据key正序排序\n\nmap.entrySet().stream().sorted(Comparator.comparing(e -> e.getKey())).forEach(System.out::println);\n\n\n1\n",normalizedContent:"# java\n\n\n# 一.对hashmap排序（treemap只能对key排序)\n\n> map根据value倒序排序\n\nmap.entryset().stream().sorted(collections.reverseorder(map.entry.comparingbyvalue())).foreach(system.out::println);\n\n\n1\n\n\n> map根据key倒序排序\n\nmap.entryset().stream().sorted(collections.reverseorder(map.entry.comparingbykey())).foreach(system.out::println);\n\n\n1\n\n\n> map根据value正序排序\n\nmap.entryset().stream().sorted(comparator.comparing(e -> e.getvalue())).foreach(system.out::println);\n\n\n1\n\n\n> map根据key正序排序\n\nmap.entryset().stream().sorted(comparator.comparing(e -> e.getkey())).foreach(system.out::println);\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"UUID唯一订单号",frontmatter:{title:"UUID唯一订单号",date:"2021-09-09T10:12:32.000Z",permalink:"/pages/38be09/",categories:["后端","java"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/00.java/06.UUID%E5%94%AF%E4%B8%80%E8%AE%A2%E5%8D%95%E5%8F%B7.html",relativePath:"01.后端/00.java/06.UUID唯一订单号.md",key:"v-52b1827e",path:"/pages/38be09/",headersStr:null,content:' * 前缀通过读取本地IP标识不同的实例\n * generateOrderNo()方法内不需要加锁，因为AtomicInteger内使用是CAS自旋转锁(保证可见性的同时也保证原子性,具体的请自行了解\n * getLocalIpSuffix()方法内不需要对不为null的逻辑加同步锁(双向校验锁，整体是一种安全的单例模式\n\npackage com.wcy.demo;\n\nimport org.apache.commons.lang3.RandomUtils;\n\nimport java.net.InetAddress;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class UUIDUtil {\n    private static final AtomicInteger SEQ = new AtomicInteger(1000);\n    private static final DateTimeFormatter DF_FMT_PREFIX = DateTimeFormatter.ofPattern("yyMMddHHmmssSS");\n    private static ZoneId ZONE_ID = ZoneId.of("Asia/Shanghai");//时区\n    private volatile static String IP_SUFFIX = null;//IP前缀\n    public static String generateOrderNo(){\n        LocalDateTime dataTime = LocalDateTime.now(ZONE_ID);\n        if(SEQ.intValue()>9990){\n            SEQ.getAndSet(1000);\n        }\n        return  getLocalIpSuffix()+dataTime.format(DF_FMT_PREFIX)+SEQ.getAndIncrement();\n    }\n    private static String getLocalIpSuffix (){\n        if(null != IP_SUFFIX){\n            return IP_SUFFIX;\n        }\n        try {\n            synchronized (UUIDUtil.class){\n                if(null != IP_SUFFIX){\n                    return IP_SUFFIX;\n                }\n                InetAddress addr = InetAddress.getLocalHost();\n                //  172.17.0.4  172.17.0.199 ,\n                String hostAddress = addr.getHostAddress();\n                if (null != hostAddress && hostAddress.length() > 4) {\n                    String ipSuffix = hostAddress.trim().split("\\\\.")[3];\n                    if (ipSuffix.length() == 2) {\n                        IP_SUFFIX = ipSuffix;\n                        return IP_SUFFIX;\n                    }\n                    ipSuffix = "0" + ipSuffix;\n                    IP_SUFFIX = ipSuffix.substring(ipSuffix.length() - 2);\n                    return IP_SUFFIX;\n                }\n                IP_SUFFIX = RandomUtils.nextInt(10, 20) + "";\n                return IP_SUFFIX;\n            }\n        }catch (Exception e){\n            System.out.println("获取IP失败:"+e.getMessage());\n            IP_SUFFIX =  RandomUtils.nextInt(10,20)+"";\n            return IP_SUFFIX;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n',normalizedContent:' * 前缀通过读取本地ip标识不同的实例\n * generateorderno()方法内不需要加锁，因为atomicinteger内使用是cas自旋转锁(保证可见性的同时也保证原子性,具体的请自行了解\n * getlocalipsuffix()方法内不需要对不为null的逻辑加同步锁(双向校验锁，整体是一种安全的单例模式\n\npackage com.wcy.demo;\n\nimport org.apache.commons.lang3.randomutils;\n\nimport java.net.inetaddress;\nimport java.time.localdatetime;\nimport java.time.zoneid;\nimport java.time.format.datetimeformatter;\nimport java.util.concurrent.atomic.atomicinteger;\n\npublic class uuidutil {\n    private static final atomicinteger seq = new atomicinteger(1000);\n    private static final datetimeformatter df_fmt_prefix = datetimeformatter.ofpattern("yymmddhhmmssss");\n    private static zoneid zone_id = zoneid.of("asia/shanghai");//时区\n    private volatile static string ip_suffix = null;//ip前缀\n    public static string generateorderno(){\n        localdatetime datatime = localdatetime.now(zone_id);\n        if(seq.intvalue()>9990){\n            seq.getandset(1000);\n        }\n        return  getlocalipsuffix()+datatime.format(df_fmt_prefix)+seq.getandincrement();\n    }\n    private static string getlocalipsuffix (){\n        if(null != ip_suffix){\n            return ip_suffix;\n        }\n        try {\n            synchronized (uuidutil.class){\n                if(null != ip_suffix){\n                    return ip_suffix;\n                }\n                inetaddress addr = inetaddress.getlocalhost();\n                //  172.17.0.4  172.17.0.199 ,\n                string hostaddress = addr.gethostaddress();\n                if (null != hostaddress && hostaddress.length() > 4) {\n                    string ipsuffix = hostaddress.trim().split("\\\\.")[3];\n                    if (ipsuffix.length() == 2) {\n                        ip_suffix = ipsuffix;\n                        return ip_suffix;\n                    }\n                    ipsuffix = "0" + ipsuffix;\n                    ip_suffix = ipsuffix.substring(ipsuffix.length() - 2);\n                    return ip_suffix;\n                }\n                ip_suffix = randomutils.nextint(10, 20) + "";\n                return ip_suffix;\n            }\n        }catch (exception e){\n            system.out.println("获取ip失败:"+e.getmessage());\n            ip_suffix =  randomutils.nextint(10,20)+"";\n            return ip_suffix;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n',charsets:{cjk:!0},lastUpdated:"2021/09/22, 16:16:17"},{title:"java stream",frontmatter:{title:"java stream",date:"2021-08-27T10:47:51.000Z",permalink:"/pages/394e33/",categories:["后端","java"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/00.java/05.java%20stream.html",relativePath:"01.后端/00.java/05.java stream.md",key:"v-ab811dba",path:"/pages/394e33/",headers:[{level:2,title:"1 Stream概述",slug:"_1-stream概述",normalizedTitle:"1 stream概述",charIndex:7},{level:2,title:"2.Stream的创建",slug:"_2-stream的创建",normalizedTitle:"2.stream的创建",charIndex:422},{level:2,title:"3.Stream操作",slug:"_3-stream操作",normalizedTitle:"3.stream操作",charIndex:1119},{level:3,title:"3.1.遍历（foreach/find/match）",slug:"_3-1-遍历-foreach-find-match",normalizedTitle:"3.1.遍历（foreach/find/match）",charIndex:2343},{level:3,title:"3.2.筛选（filter）",slug:"_3-2-筛选-filter",normalizedTitle:"3.2.筛选（filter）",charIndex:3336},{level:3,title:"3.3.聚合（max/min/count)",slug:"_3-3-聚合-max-min-count",normalizedTitle:"3.3.聚合（max/min/count)",charIndex:4082},{level:3,title:"3.4.映射(map/flatMap)",slug:"_3-4-映射-map-flatmap",normalizedTitle:"3.4.映射(map/flatmap)",charIndex:4909},{level:3,title:"3.5.归约(reduce)",slug:"_3-5-归约-reduce",normalizedTitle:"3.5.归约(reduce)",charIndex:6038},{level:3,title:"3.6.收集(collect)",slug:"_3-6-收集-collect",normalizedTitle:"3.6.收集(collect)",charIndex:7735},{level:3,title:"3.7.排序",slug:"_3-7-排序",normalizedTitle:"3.7.排序",charIndex:13588},{level:3,title:"3.8 提取/组合",slug:"_3-8-提取-组合",normalizedTitle:"3.8 提取/组合",charIndex:15203}],headersStr:"1 Stream概述 2.Stream的创建 3.Stream操作 3.1.遍历（foreach/find/match） 3.2.筛选（filter） 3.3.聚合（max/min/count) 3.4.映射(map/flatMap) 3.5.归约(reduce) 3.6.收集(collect) 3.7.排序 3.8 提取/组合",content:'参考\n\n\n# 1 Stream概述\n\nJava 8 是一个非常成功的版本，这个版本新增的Stream，配合同版本出现的 Lambda ，给我们操作集合（Collection）提供了极大的便利。\n\n那么什么是Stream？\n\n> Stream将要处理的元素集合看作一种流，在流的过程中，借助Stream API对流中的元素进行操作，比如：筛选、排序、聚合等。\n\nStream可以由数组或集合创建，对流的操作分为两种：\n\n中间操作，每次返回一个新的流，可以有多个。 终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。 另外，Stream有几个特性：\n\n 1. stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。\n 2. stream不会改变数据源，通常情况下会产生一个新的集合或一个值。\n 3. stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。\n\n\n# 2.Stream的创建\n\n1.通过 java.util.Collection.stream() 方法用集合创建流**（推荐）**\n\nList<String> list = Arrays.asList("a", "b", "c");\n// 创建一个顺序流\nStream<String> stream = list.stream();\n// 创建一个并行流\nStream<String> parallelStream = list.parallelStream();\n\n\n1\n2\n3\n4\n5\n\n\n2.使用java.util.Arrays.stream(T[] array)方法用数组创建流\n\nint[] array={1,3,5,6,8};\nIntStream stream = Arrays.stream(array);\n\n\n1\n2\n\n\n3.使用Stream的静态方法：of()、iterate()、generate()\n\nStream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6);\n\nStream<Integer> stream2 = Stream.iterate(0, (x) -> x + 3).limit(4);\nstream2.forEach(System.out::println);\n\nStream<Double> stream3 = Stream.generate(Math::random).limit(3);\nstream3.forEach(System.out::println);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.Stream操作\n\n涉及的相关DTO：\n\npackage com.wcy.demo.dto;\n\npublic class Person {\n    private String name;  // 姓名\n    private int salary; // 薪资\n    private int age; // 年龄\n    private String sex; //性别\n    private String area;  // 地区\n\n    // 构造方法\n    public Person(String name, int salary,String sex,String area) {\n        this.name = name;\n        this.salary = salary;\n        this.sex = sex;\n        this.area = area;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getSalary() {\n        return salary;\n    }\n\n    public void setSalary(int salary) {\n        this.salary = salary;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n\n    public String getArea() {\n        return area;\n    }\n\n    public void setArea(String area) {\n        this.area = area;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# 3.1.遍历（foreach/find/match）\n\npublic static void main(String[] args) {\n        List<Person> personList = new ArrayList<Person>();\n        personList.add(new Person("Tom", 8900, "male", "New York"));\n        personList.add(new Person("Jack", 7000, "male", "Washington"));\n        personList.add(new Person("Lily", 7800, "female", "Washington"));\n        personList.add(new Person("Anni", 8200, "female", "New York"));\n        personList.add(new Person("Owen", 9500, "male", "New York"));\n        personList.add(new Person("Alisa", 7900, "female", "New York"));\n\n        //遍历\n        personList.stream().forEach(System.out::print);\n        personList.stream().forEach((x)->{\n            System.out.print(x);\n        });\n\n        //匹配第一个\n        personList.stream().findFirst().get();\n\n        //匹配任意\n        personList.stream().findAny().get();\n\n        //是否满足某些条件\n        personList.stream().allMatch(x->x.getAge()>45);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 3.2.筛选（filter）\n\n筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集），后文有详细介绍。\n\n    public static void main(String[] args) {\n        List<Person> personList = new ArrayList<Person>();\n        personList.add(new Person("Tom", 8900, "male", "New York"));\n        personList.add(new Person("Jack", 7000, "male", "Washington"));\n        personList.add(new Person("Lily", 7800, "female", "Washington"));\n        personList.add(new Person("Anni", 8200, "female", "New York"));\n        personList.add(new Person("Owen", 9500, "male", "New York"));\n        personList.add(new Person("Alisa", 7900, "female", "New York"));\n\n        //过滤\n        personList.stream().filter(x->x.getSalary()>8000).collect(Collectors.toList());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.3.聚合（max/min/count)\n\n获取员工工资最高的人。\n\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person("Tom", 8900, 23, "male", "New York"));\n\t\tpersonList.add(new Person("Jack", 7000, 25, "male", "Washington"));\n\t\tpersonList.add(new Person("Lily", 7800, 21, "female", "Washington"));\n\t\tpersonList.add(new Person("Anni", 8200, 24, "female", "New York"));\n\t\tpersonList.add(new Person("Owen", 9500, 25, "male", "New York"));\n\t\tpersonList.add(new Person("Alisa", 7900, 26, "female", "New York"));\n\t\t\n\t\tOptional<Person> max = personList.stream().max(Comparator.comparingInt(Person::getSalary));\n\t\tSystem.out.println("员工工资最大值：" + max.get().getSalary());\n\t\t\n\t\tint count = personList.stream().count();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 3.4.映射(map/flatMap)\n\n将员工的薪资全部增加1000。\n\n    public static void main(String[] args) {\n        List<Person> personList = new ArrayList<Person>();\n        personList.add(new Person("Tom", 8900, "male", "New York"));\n        personList.add(new Person("Jack", 7000, "male", "Washington"));\n        personList.add(new Person("Lily", 7800, "female", "Washington"));\n        personList.add(new Person("Anni", 8200, "female", "New York"));\n        personList.add(new Person("Owen", 9500, "male", "New York"));\n        personList.add(new Person("Alisa", 7900, "female", "New York"));\n\n\t\t// 不改变原来员工集合的方式\n\t\tList<Person> personListNew = personList.stream().map(person -> {\n\t\t\tPerson personNew = new Person(person.getName(), 0, 0, null, null);\n\t\t\tpersonNew.setSalary(person.getSalary() + 10000);\n\t\t\treturn personNew;\n\t\t}).collect(Collectors.toList());\n\n        // 改变原来员工集合的方式\n        personList.stream().map((x) -> {\n            x.setSalary(x.getSalary()+1000);\n            return x;\n        }).forEach((x)->{\n            System.out.println(x.getSalary());\n        });\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 3.5.归约(reduce)\n\n求所有员工的工资之和和最高工资。\n\n//对BookAmount求和\nBigDecimal oneAmountAllTeam = mapList.stream().filter(a -> null != a.getBookAmount())\n        .map(CmfClmClaimNpcexpLine::getBookAmount).reduce(BigDecimal.ZERO, BigDecimal::add);\n\n\n1\n2\n3\n\n\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person("Tom", 8900, 23, "male", "New York"));\n\t\tpersonList.add(new Person("Jack", 7000, 25, "male", "Washington"));\n\t\tpersonList.add(new Person("Lily", 7800, 21, "female", "Washington"));\n\t\tpersonList.add(new Person("Anni", 8200, 24, "female", "New York"));\n\t\tpersonList.add(new Person("Owen", 9500, 25, "male", "New York"));\n\t\tpersonList.add(new Person("Alisa", 7900, 26, "female", "New York"));\n\n\t\t// 求工资之和方式1：\n\t\tOptional<Integer> sumSalary = personList.stream().map(Person::getSalary).reduce(Integer::sum);\n\t\t// 求工资之和方式2：\n\t\tInteger sumSalary2 = personList.stream().reduce(0, (sum, p) -> sum += p.getSalary(),\n\t\t\t\t(sum1, sum2) -> sum1 + sum2);\n\t\t// 求工资之和方式3：\n\t\tInteger sumSalary3 = personList.stream().reduce(0, (sum, p) -> sum += p.getSalary(), Integer::sum);\n\n\t\t// 求最高工资方式1：\n\t\tInteger maxSalary = personList.stream().reduce(0, (max, p) -> max > p.getSalary() ? max : p.getSalary(),\n\t\t\t\tInteger::max);\n\t\t// 求最高工资方式2：\n\t\tInteger maxSalary2 = personList.stream().reduce(0, (max, p) -> max > p.getSalary() ? max : p.getSalary(),\n\t\t\t\t(max1, max2) -> max1 > max2 ? max1 : max2);\n\n\t\tSystem.out.println("工资之和：" + sumSalary.get() + "," + sumSalary2 + "," + sumSalary3);\n\t\tSystem.out.println("最高工资：" + maxSalary + "," + maxSalary2);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 3.6.收集(collect)\n\ncollect，收集，可以说是内容最繁多、功能最丰富的部分了。从字面上去理解，就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合。\n\n> collect主要依赖java.util.stream.Collectors类内置的静态方法。\n\n# 3.6.1 归集(toList/toSet/toMap)\n\n因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。toList、toSet和toMap比较常用，另外还有toCollection、toConcurrentMap等复杂一些的用法。\n\n下面用一个案例演示toList、toSet和toMap：\n\n    public static void main(String[] args) {\n        List<Person> personList = new ArrayList<Person>();\n        personList.add(new Person("Tom", 8900, "male", "New York"));\n        personList.add(new Person("Jack", 7000, "male", "Washington"));\n        personList.add(new Person("Lily", 7800, "female", "Washington"));\n        personList.add(new Person("Anni", 8200, "female", "New York"));\n        personList.add(new Person("Owen", 9500, "male", "New York"));\n        personList.add(new Person("Alisa", 7900, "female", "New York"));\n\n        // 改变原来员工集合的方式\n        List<Person> collectList = personList.stream().collect(Collectors.toList());\n        Set<Person> collectSet = personList.stream().collect(Collectors.toSet());\n        Map<String, Person> collect = personList.stream().collect(Collectors.toMap((key) -> key.getName(), (value) -> value));\n        personList.stream().collect(Collectors.toMap(Person::getName,(value) -> value)));\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\ntomap：\n\nMap<Long, BigDecimal>  contractAmountMap = contractHeaders.stream()\n                .filter(o -> null != o.getContractHeaderId())\n                .collect(Collectors.toMap(CmfCmContractHeader::getContractHeaderId, CmfCmContractHeader::getSumAmount));\n\n\n1\n2\n3\n\n\n# 3.6.2.统计(count/averaging)\n\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person("Tom", 8900, 23, "male", "New York"));\n\t\tpersonList.add(new Person("Jack", 7000, 25, "male", "Washington"));\n\t\tpersonList.add(new Person("Lily", 7800, 21, "female", "Washington"));\n\n\t\t// 求总数\n\t\tLong count = personList.stream().collect(Collectors.counting());\n\t\t// 求平均工资\n\t\tDouble average = personList.stream().collect(Collectors.averagingDouble(Person::getSalary));\n\t\t// 求最高工资\n\t\tOptional<Integer> max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare));\n\t\t// 求工资之和\n\t\tInteger sum = personList.stream().collect(Collectors.summingInt(Person::getSalary));\n\t\t// 一次性统计所有信息\n\t\tDoubleSummaryStatistics collect = personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));\n\n\t\tSystem.out.println("员工总数：" + count);\n\t\tSystem.out.println("员工平均工资：" + average);\n\t\tSystem.out.println("员工工资总和：" + sum);\n\t\tSystem.out.println("员工工资所有统计：" + collect);\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 3.6.3 分组(partitioningBy/groupingBy)\n\n根据合同ID分组\n\nMap<Long, List<CmfClmWriteOffTmpLine>> writeOffContractMap = writeOffTmpLineList.stream()\n                    .filter(clmWriteOffTmpLine -> clmWriteOffTmpLine.getContractId() != null)\n                    .collect(Collectors.groupingBy(CmfClmWriteOffTmpLine::getContractId));\n\n\n1\n2\n3\n\n\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person("Tom", 8900, "male", "New York"));\n\t\tpersonList.add(new Person("Jack", 7000, "male", "Washington"));\n\t\tpersonList.add(new Person("Lily", 7800, "female", "Washington"));\n\t\tpersonList.add(new Person("Anni", 8200, "female", "New York"));\n\t\tpersonList.add(new Person("Owen", 9500, "male", "New York"));\n\t\tpersonList.add(new Person("Alisa", 7900, "female", "New York"));\n\n\t\t// 将员工按薪资是否高于8000分组\n        Map<Boolean, List<Person>> part = personList.stream().collect(Collectors.partitioningBy(x -> x.getSalary() > 8000));\n        // 将员工按性别分组\n        Map<String, List<Person>> group = personList.stream().collect(Collectors.groupingBy(Person::getSex));\n        // 将员工先按性别分组，再按地区分组\n        Map<String, Map<String, List<Person>>> group2 = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));\n        System.out.println("员工按薪资是否大于8000分组情况：" + part);\n        System.out.println("员工按性别分组情况：" + group);\n        System.out.println("员工按性别、地区：" + group2);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 3.6.4 接合(joining)\n\njoining可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。\n\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person("Tom", 8900, 23, "male", "New York"));\n\t\tpersonList.add(new Person("Jack", 7000, 25, "male", "Washington"));\n\t\tpersonList.add(new Person("Lily", 7800, 21, "female", "Washington"));\n\n\t\tString names = personList.stream().map(p -> p.getName()).collect(Collectors.joining(","));\n\t\tSystem.out.println("所有员工的姓名：" + names);\n\t\tList<String> list = Arrays.asList("A", "B", "C");\n\t\tString string = list.stream().collect(Collectors.joining("-"));\n\t\tSystem.out.println("拼接后的字符串：" + string);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n运行结果：\n\n> 所有员工的姓名：Tom,Jack,Lily 拼接后的字符串：A-B-C\n\n# 3.6.5 归约(reducing)\n\nCollectors类提供的reducing方法，相比于stream本身的reduce方法，增加了对自定义归约的支持。\n\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person("Tom", 8900, 23, "male", "New York"));\n\t\tpersonList.add(new Person("Jack", 7000, 25, "male", "Washington"));\n\t\tpersonList.add(new Person("Lily", 7800, 21, "female", "Washington"));\n\n\t\t// 每个员工减去起征点后的薪资之和（这个例子并不严谨，但一时没想到好的例子）\n\t\tInteger sum = personList.stream().collect(Collectors.reducing(0, Person::getSalary, (i, j) -> (i + j - 5000)));\n\t\tSystem.out.println("员工扣税薪资总和：" + sum);\n\n\t\t// stream的reduce\n\t\tOptional<Integer> sum2 = personList.stream().map(Person::getSalary).reduce(Integer::sum);\n\t\tSystem.out.println("员工薪资总和：" + sum2.get());\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 3.7.排序\n\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\n\t\tpersonList.add(new Person("Sherry", 9000, 24, "female", "New York"));\n\t\tpersonList.add(new Person("Tom", 8900, 22, "male", "Washington"));\n\t\tpersonList.add(new Person("Jack", 9000, 25, "male", "Washington"));\n\t\tpersonList.add(new Person("Lily", 8800, 26, "male", "New York"));\n\t\tpersonList.add(new Person("Alisa", 9000, 26, "female", "New York"));\n\n\t\t// 按工资升序排序（自然排序）\n\t\tList<String> newList = personList.stream().sorted(Comparator.comparing(Person::getSalary)).map(Person::getName)\n\t\t\t\t.collect(Collectors.toList());\n\t\t// 按工资倒序排序\n\t\tList<String> newList2 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed())\n\t\t\t\t.map(Person::getName).collect(Collectors.toList());\n\t\t// 先按工资再按年龄升序排序\n\t\tList<String> newList3 = personList.stream()\n\t\t\t\t.sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge)).map(Person::getName)\n\t\t\t\t.collect(Collectors.toList());\n\t\t// 先按工资再按年龄自定义排序（降序）\n\t\tList<String> newList4 = personList.stream().sorted((p1, p2) -> {\n\t\t\tif (p1.getSalary() == p2.getSalary()) {\n\t\t\t\treturn p2.getAge() - p1.getAge();\n\t\t\t} else {\n\t\t\t\treturn p2.getSalary() - p1.getSalary();\n\t\t\t}\n\t\t}).map(Person::getName).collect(Collectors.toList());\n\n\t\tSystem.out.println("按工资升序排序：" + newList);\n\t\tSystem.out.println("按工资降序排序：" + newList2);\n\t\tSystem.out.println("先按工资再按年龄升序排序：" + newList3);\n\t\tSystem.out.println("先按工资再按年龄自定义降序排序：" + newList4);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 3.8 提取/组合\n\n流也可以进行合并、去重、限制、跳过等操作。\n\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tString[] arr1 = { "a", "b", "c", "d" };\n\t\tString[] arr2 = { "d", "e", "f", "g" };\n\n\t\tStream<String> stream1 = Stream.of(arr1);\n\t\tStream<String> stream2 = Stream.of(arr2);\n\t\t// concat:合并两个流 distinct：去重\n\t\tList<String> newList = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());\n\t\t// limit：限制从流中获得前n个数据\n\t\tList<Integer> collect = Stream.iterate(1, x -> x + 2).limit(10).collect(Collectors.toList());\n\t\t// skip：跳过前n个数据\n\t\tList<Integer> collect2 = Stream.iterate(1, x -> x + 2).skip(1).limit(5).collect(Collectors.toList());\n\n\t\tSystem.out.println("流合并：" + newList);\n\t\tSystem.out.println("limit：" + collect);\n\t\tSystem.out.println("skip：" + collect2);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n运行结果：\n\n> 流合并：[a, b, c, d, e, f, g] limit：[1, 3, 5, 7, 9, 11, 13, 15, 17, 19] skip：[3, 5, 7, 9, 11]',normalizedContent:'参考\n\n\n# 1 stream概述\n\njava 8 是一个非常成功的版本，这个版本新增的stream，配合同版本出现的 lambda ，给我们操作集合（collection）提供了极大的便利。\n\n那么什么是stream？\n\n> stream将要处理的元素集合看作一种流，在流的过程中，借助stream api对流中的元素进行操作，比如：筛选、排序、聚合等。\n\nstream可以由数组或集合创建，对流的操作分为两种：\n\n中间操作，每次返回一个新的流，可以有多个。 终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。 另外，stream有几个特性：\n\n 1. stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。\n 2. stream不会改变数据源，通常情况下会产生一个新的集合或一个值。\n 3. stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。\n\n\n# 2.stream的创建\n\n1.通过 java.util.collection.stream() 方法用集合创建流**（推荐）**\n\nlist<string> list = arrays.aslist("a", "b", "c");\n// 创建一个顺序流\nstream<string> stream = list.stream();\n// 创建一个并行流\nstream<string> parallelstream = list.parallelstream();\n\n\n1\n2\n3\n4\n5\n\n\n2.使用java.util.arrays.stream(t[] array)方法用数组创建流\n\nint[] array={1,3,5,6,8};\nintstream stream = arrays.stream(array);\n\n\n1\n2\n\n\n3.使用stream的静态方法：of()、iterate()、generate()\n\nstream<integer> stream = stream.of(1, 2, 3, 4, 5, 6);\n\nstream<integer> stream2 = stream.iterate(0, (x) -> x + 3).limit(4);\nstream2.foreach(system.out::println);\n\nstream<double> stream3 = stream.generate(math::random).limit(3);\nstream3.foreach(system.out::println);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.stream操作\n\n涉及的相关dto：\n\npackage com.wcy.demo.dto;\n\npublic class person {\n    private string name;  // 姓名\n    private int salary; // 薪资\n    private int age; // 年龄\n    private string sex; //性别\n    private string area;  // 地区\n\n    // 构造方法\n    public person(string name, int salary,string sex,string area) {\n        this.name = name;\n        this.salary = salary;\n        this.sex = sex;\n        this.area = area;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public int getsalary() {\n        return salary;\n    }\n\n    public void setsalary(int salary) {\n        this.salary = salary;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    public string getsex() {\n        return sex;\n    }\n\n    public void setsex(string sex) {\n        this.sex = sex;\n    }\n\n    public string getarea() {\n        return area;\n    }\n\n    public void setarea(string area) {\n        this.area = area;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# 3.1.遍历（foreach/find/match）\n\npublic static void main(string[] args) {\n        list<person> personlist = new arraylist<person>();\n        personlist.add(new person("tom", 8900, "male", "new york"));\n        personlist.add(new person("jack", 7000, "male", "washington"));\n        personlist.add(new person("lily", 7800, "female", "washington"));\n        personlist.add(new person("anni", 8200, "female", "new york"));\n        personlist.add(new person("owen", 9500, "male", "new york"));\n        personlist.add(new person("alisa", 7900, "female", "new york"));\n\n        //遍历\n        personlist.stream().foreach(system.out::print);\n        personlist.stream().foreach((x)->{\n            system.out.print(x);\n        });\n\n        //匹配第一个\n        personlist.stream().findfirst().get();\n\n        //匹配任意\n        personlist.stream().findany().get();\n\n        //是否满足某些条件\n        personlist.stream().allmatch(x->x.getage()>45);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 3.2.筛选（filter）\n\n筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集），后文有详细介绍。\n\n    public static void main(string[] args) {\n        list<person> personlist = new arraylist<person>();\n        personlist.add(new person("tom", 8900, "male", "new york"));\n        personlist.add(new person("jack", 7000, "male", "washington"));\n        personlist.add(new person("lily", 7800, "female", "washington"));\n        personlist.add(new person("anni", 8200, "female", "new york"));\n        personlist.add(new person("owen", 9500, "male", "new york"));\n        personlist.add(new person("alisa", 7900, "female", "new york"));\n\n        //过滤\n        personlist.stream().filter(x->x.getsalary()>8000).collect(collectors.tolist());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.3.聚合（max/min/count)\n\n获取员工工资最高的人。\n\npublic class streamtest {\n\tpublic static void main(string[] args) {\n\t\tlist<person> personlist = new arraylist<person>();\n\t\tpersonlist.add(new person("tom", 8900, 23, "male", "new york"));\n\t\tpersonlist.add(new person("jack", 7000, 25, "male", "washington"));\n\t\tpersonlist.add(new person("lily", 7800, 21, "female", "washington"));\n\t\tpersonlist.add(new person("anni", 8200, 24, "female", "new york"));\n\t\tpersonlist.add(new person("owen", 9500, 25, "male", "new york"));\n\t\tpersonlist.add(new person("alisa", 7900, 26, "female", "new york"));\n\t\t\n\t\toptional<person> max = personlist.stream().max(comparator.comparingint(person::getsalary));\n\t\tsystem.out.println("员工工资最大值：" + max.get().getsalary());\n\t\t\n\t\tint count = personlist.stream().count();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 3.4.映射(map/flatmap)\n\n将员工的薪资全部增加1000。\n\n    public static void main(string[] args) {\n        list<person> personlist = new arraylist<person>();\n        personlist.add(new person("tom", 8900, "male", "new york"));\n        personlist.add(new person("jack", 7000, "male", "washington"));\n        personlist.add(new person("lily", 7800, "female", "washington"));\n        personlist.add(new person("anni", 8200, "female", "new york"));\n        personlist.add(new person("owen", 9500, "male", "new york"));\n        personlist.add(new person("alisa", 7900, "female", "new york"));\n\n\t\t// 不改变原来员工集合的方式\n\t\tlist<person> personlistnew = personlist.stream().map(person -> {\n\t\t\tperson personnew = new person(person.getname(), 0, 0, null, null);\n\t\t\tpersonnew.setsalary(person.getsalary() + 10000);\n\t\t\treturn personnew;\n\t\t}).collect(collectors.tolist());\n\n        // 改变原来员工集合的方式\n        personlist.stream().map((x) -> {\n            x.setsalary(x.getsalary()+1000);\n            return x;\n        }).foreach((x)->{\n            system.out.println(x.getsalary());\n        });\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 3.5.归约(reduce)\n\n求所有员工的工资之和和最高工资。\n\n//对bookamount求和\nbigdecimal oneamountallteam = maplist.stream().filter(a -> null != a.getbookamount())\n        .map(cmfclmclaimnpcexpline::getbookamount).reduce(bigdecimal.zero, bigdecimal::add);\n\n\n1\n2\n3\n\n\npublic class streamtest {\n\tpublic static void main(string[] args) {\n\t\tlist<person> personlist = new arraylist<person>();\n\t\tpersonlist.add(new person("tom", 8900, 23, "male", "new york"));\n\t\tpersonlist.add(new person("jack", 7000, 25, "male", "washington"));\n\t\tpersonlist.add(new person("lily", 7800, 21, "female", "washington"));\n\t\tpersonlist.add(new person("anni", 8200, 24, "female", "new york"));\n\t\tpersonlist.add(new person("owen", 9500, 25, "male", "new york"));\n\t\tpersonlist.add(new person("alisa", 7900, 26, "female", "new york"));\n\n\t\t// 求工资之和方式1：\n\t\toptional<integer> sumsalary = personlist.stream().map(person::getsalary).reduce(integer::sum);\n\t\t// 求工资之和方式2：\n\t\tinteger sumsalary2 = personlist.stream().reduce(0, (sum, p) -> sum += p.getsalary(),\n\t\t\t\t(sum1, sum2) -> sum1 + sum2);\n\t\t// 求工资之和方式3：\n\t\tinteger sumsalary3 = personlist.stream().reduce(0, (sum, p) -> sum += p.getsalary(), integer::sum);\n\n\t\t// 求最高工资方式1：\n\t\tinteger maxsalary = personlist.stream().reduce(0, (max, p) -> max > p.getsalary() ? max : p.getsalary(),\n\t\t\t\tinteger::max);\n\t\t// 求最高工资方式2：\n\t\tinteger maxsalary2 = personlist.stream().reduce(0, (max, p) -> max > p.getsalary() ? max : p.getsalary(),\n\t\t\t\t(max1, max2) -> max1 > max2 ? max1 : max2);\n\n\t\tsystem.out.println("工资之和：" + sumsalary.get() + "," + sumsalary2 + "," + sumsalary3);\n\t\tsystem.out.println("最高工资：" + maxsalary + "," + maxsalary2);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 3.6.收集(collect)\n\ncollect，收集，可以说是内容最繁多、功能最丰富的部分了。从字面上去理解，就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合。\n\n> collect主要依赖java.util.stream.collectors类内置的静态方法。\n\n# 3.6.1 归集(tolist/toset/tomap)\n\n因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。tolist、toset和tomap比较常用，另外还有tocollection、toconcurrentmap等复杂一些的用法。\n\n下面用一个案例演示tolist、toset和tomap：\n\n    public static void main(string[] args) {\n        list<person> personlist = new arraylist<person>();\n        personlist.add(new person("tom", 8900, "male", "new york"));\n        personlist.add(new person("jack", 7000, "male", "washington"));\n        personlist.add(new person("lily", 7800, "female", "washington"));\n        personlist.add(new person("anni", 8200, "female", "new york"));\n        personlist.add(new person("owen", 9500, "male", "new york"));\n        personlist.add(new person("alisa", 7900, "female", "new york"));\n\n        // 改变原来员工集合的方式\n        list<person> collectlist = personlist.stream().collect(collectors.tolist());\n        set<person> collectset = personlist.stream().collect(collectors.toset());\n        map<string, person> collect = personlist.stream().collect(collectors.tomap((key) -> key.getname(), (value) -> value));\n        personlist.stream().collect(collectors.tomap(person::getname,(value) -> value)));\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\ntomap：\n\nmap<long, bigdecimal>  contractamountmap = contractheaders.stream()\n                .filter(o -> null != o.getcontractheaderid())\n                .collect(collectors.tomap(cmfcmcontractheader::getcontractheaderid, cmfcmcontractheader::getsumamount));\n\n\n1\n2\n3\n\n\n# 3.6.2.统计(count/averaging)\n\npublic class streamtest {\n\tpublic static void main(string[] args) {\n\t\tlist<person> personlist = new arraylist<person>();\n\t\tpersonlist.add(new person("tom", 8900, 23, "male", "new york"));\n\t\tpersonlist.add(new person("jack", 7000, 25, "male", "washington"));\n\t\tpersonlist.add(new person("lily", 7800, 21, "female", "washington"));\n\n\t\t// 求总数\n\t\tlong count = personlist.stream().collect(collectors.counting());\n\t\t// 求平均工资\n\t\tdouble average = personlist.stream().collect(collectors.averagingdouble(person::getsalary));\n\t\t// 求最高工资\n\t\toptional<integer> max = personlist.stream().map(person::getsalary).collect(collectors.maxby(integer::compare));\n\t\t// 求工资之和\n\t\tinteger sum = personlist.stream().collect(collectors.summingint(person::getsalary));\n\t\t// 一次性统计所有信息\n\t\tdoublesummarystatistics collect = personlist.stream().collect(collectors.summarizingdouble(person::getsalary));\n\n\t\tsystem.out.println("员工总数：" + count);\n\t\tsystem.out.println("员工平均工资：" + average);\n\t\tsystem.out.println("员工工资总和：" + sum);\n\t\tsystem.out.println("员工工资所有统计：" + collect);\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 3.6.3 分组(partitioningby/groupingby)\n\n根据合同id分组\n\nmap<long, list<cmfclmwriteofftmpline>> writeoffcontractmap = writeofftmplinelist.stream()\n                    .filter(clmwriteofftmpline -> clmwriteofftmpline.getcontractid() != null)\n                    .collect(collectors.groupingby(cmfclmwriteofftmpline::getcontractid));\n\n\n1\n2\n3\n\n\npublic class streamtest {\n\tpublic static void main(string[] args) {\n\t\tlist<person> personlist = new arraylist<person>();\n\t\tpersonlist.add(new person("tom", 8900, "male", "new york"));\n\t\tpersonlist.add(new person("jack", 7000, "male", "washington"));\n\t\tpersonlist.add(new person("lily", 7800, "female", "washington"));\n\t\tpersonlist.add(new person("anni", 8200, "female", "new york"));\n\t\tpersonlist.add(new person("owen", 9500, "male", "new york"));\n\t\tpersonlist.add(new person("alisa", 7900, "female", "new york"));\n\n\t\t// 将员工按薪资是否高于8000分组\n        map<boolean, list<person>> part = personlist.stream().collect(collectors.partitioningby(x -> x.getsalary() > 8000));\n        // 将员工按性别分组\n        map<string, list<person>> group = personlist.stream().collect(collectors.groupingby(person::getsex));\n        // 将员工先按性别分组，再按地区分组\n        map<string, map<string, list<person>>> group2 = personlist.stream().collect(collectors.groupingby(person::getsex, collectors.groupingby(person::getarea)));\n        system.out.println("员工按薪资是否大于8000分组情况：" + part);\n        system.out.println("员工按性别分组情况：" + group);\n        system.out.println("员工按性别、地区：" + group2);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 3.6.4 接合(joining)\n\njoining可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。\n\npublic class streamtest {\n\tpublic static void main(string[] args) {\n\t\tlist<person> personlist = new arraylist<person>();\n\t\tpersonlist.add(new person("tom", 8900, 23, "male", "new york"));\n\t\tpersonlist.add(new person("jack", 7000, 25, "male", "washington"));\n\t\tpersonlist.add(new person("lily", 7800, 21, "female", "washington"));\n\n\t\tstring names = personlist.stream().map(p -> p.getname()).collect(collectors.joining(","));\n\t\tsystem.out.println("所有员工的姓名：" + names);\n\t\tlist<string> list = arrays.aslist("a", "b", "c");\n\t\tstring string = list.stream().collect(collectors.joining("-"));\n\t\tsystem.out.println("拼接后的字符串：" + string);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n运行结果：\n\n> 所有员工的姓名：tom,jack,lily 拼接后的字符串：a-b-c\n\n# 3.6.5 归约(reducing)\n\ncollectors类提供的reducing方法，相比于stream本身的reduce方法，增加了对自定义归约的支持。\n\npublic class streamtest {\n\tpublic static void main(string[] args) {\n\t\tlist<person> personlist = new arraylist<person>();\n\t\tpersonlist.add(new person("tom", 8900, 23, "male", "new york"));\n\t\tpersonlist.add(new person("jack", 7000, 25, "male", "washington"));\n\t\tpersonlist.add(new person("lily", 7800, 21, "female", "washington"));\n\n\t\t// 每个员工减去起征点后的薪资之和（这个例子并不严谨，但一时没想到好的例子）\n\t\tinteger sum = personlist.stream().collect(collectors.reducing(0, person::getsalary, (i, j) -> (i + j - 5000)));\n\t\tsystem.out.println("员工扣税薪资总和：" + sum);\n\n\t\t// stream的reduce\n\t\toptional<integer> sum2 = personlist.stream().map(person::getsalary).reduce(integer::sum);\n\t\tsystem.out.println("员工薪资总和：" + sum2.get());\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 3.7.排序\n\npublic class streamtest {\n\tpublic static void main(string[] args) {\n\t\tlist<person> personlist = new arraylist<person>();\n\n\t\tpersonlist.add(new person("sherry", 9000, 24, "female", "new york"));\n\t\tpersonlist.add(new person("tom", 8900, 22, "male", "washington"));\n\t\tpersonlist.add(new person("jack", 9000, 25, "male", "washington"));\n\t\tpersonlist.add(new person("lily", 8800, 26, "male", "new york"));\n\t\tpersonlist.add(new person("alisa", 9000, 26, "female", "new york"));\n\n\t\t// 按工资升序排序（自然排序）\n\t\tlist<string> newlist = personlist.stream().sorted(comparator.comparing(person::getsalary)).map(person::getname)\n\t\t\t\t.collect(collectors.tolist());\n\t\t// 按工资倒序排序\n\t\tlist<string> newlist2 = personlist.stream().sorted(comparator.comparing(person::getsalary).reversed())\n\t\t\t\t.map(person::getname).collect(collectors.tolist());\n\t\t// 先按工资再按年龄升序排序\n\t\tlist<string> newlist3 = personlist.stream()\n\t\t\t\t.sorted(comparator.comparing(person::getsalary).thencomparing(person::getage)).map(person::getname)\n\t\t\t\t.collect(collectors.tolist());\n\t\t// 先按工资再按年龄自定义排序（降序）\n\t\tlist<string> newlist4 = personlist.stream().sorted((p1, p2) -> {\n\t\t\tif (p1.getsalary() == p2.getsalary()) {\n\t\t\t\treturn p2.getage() - p1.getage();\n\t\t\t} else {\n\t\t\t\treturn p2.getsalary() - p1.getsalary();\n\t\t\t}\n\t\t}).map(person::getname).collect(collectors.tolist());\n\n\t\tsystem.out.println("按工资升序排序：" + newlist);\n\t\tsystem.out.println("按工资降序排序：" + newlist2);\n\t\tsystem.out.println("先按工资再按年龄升序排序：" + newlist3);\n\t\tsystem.out.println("先按工资再按年龄自定义降序排序：" + newlist4);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 3.8 提取/组合\n\n流也可以进行合并、去重、限制、跳过等操作。\n\npublic class streamtest {\n\tpublic static void main(string[] args) {\n\t\tstring[] arr1 = { "a", "b", "c", "d" };\n\t\tstring[] arr2 = { "d", "e", "f", "g" };\n\n\t\tstream<string> stream1 = stream.of(arr1);\n\t\tstream<string> stream2 = stream.of(arr2);\n\t\t// concat:合并两个流 distinct：去重\n\t\tlist<string> newlist = stream.concat(stream1, stream2).distinct().collect(collectors.tolist());\n\t\t// limit：限制从流中获得前n个数据\n\t\tlist<integer> collect = stream.iterate(1, x -> x + 2).limit(10).collect(collectors.tolist());\n\t\t// skip：跳过前n个数据\n\t\tlist<integer> collect2 = stream.iterate(1, x -> x + 2).skip(1).limit(5).collect(collectors.tolist());\n\n\t\tsystem.out.println("流合并：" + newlist);\n\t\tsystem.out.println("limit：" + collect);\n\t\tsystem.out.println("skip：" + collect2);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n运行结果：\n\n> 流合并：[a, b, c, d, e, f, g] limit：[1, 3, 5, 7, 9, 11, 13, 15, 17, 19] skip：[3, 5, 7, 9, 11]',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"JUC笔记",frontmatter:{title:"JUC笔记",date:"2021-07-12T16:34:47.000Z",permalink:"/pages/f99bc2/",categories:["后端","JUC"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.JUC/00.JUC%E7%AC%94%E8%AE%B0.html",relativePath:"01.后端/01.JUC/00.JUC笔记.md",key:"v-dd4ff4ac",path:"/pages/f99bc2/",headers:[{level:2,title:"一.并发题（售票员卖票）",slug:"一-并发题-售票员卖票",normalizedTitle:"一.并发题（售票员卖票）",charIndex:265},{level:3,title:"1.1.旧版写法synchronized：",slug:"_1-1-旧版写法synchronized",normalizedTitle:"1.1.旧版写法synchronized：",charIndex:282},{level:3,title:"1.2.新版写法Lock：",slug:"_1-2-新版写法lock",normalizedTitle:"1.2.新版写法lock：",charIndex:1196},{level:2,title:"二.复习lambda表达式",slug:"二-复习lambda表达式",normalizedTitle:"二.复习lambda表达式",charIndex:2585},{level:2,title:"三.生产者消费者模式",slug:"三-生产者消费者模式",normalizedTitle:"三.生产者消费者模式",charIndex:3805},{level:3,title:"3.1.Wait、notify的使用",slug:"_3-1-wait、notify的使用",normalizedTitle:"3.1.wait、notify的使用",charIndex:4002},{level:3,title:"3.2.lock、Condition的使用",slug:"_3-2-lock、condition的使用",normalizedTitle:"3.2.lock、condition的使用",charIndex:8622},{level:2,title:"四.Lock、condition实现精准通知",slug:"四-lock、condition实现精准通知",normalizedTitle:"四.lock、condition实现精准通知",charIndex:9848},{level:3,title:"4.1.使用wait、notify实现",slug:"_4-1-使用wait、notify实现",normalizedTitle:"4.1.使用wait、notify实现",charIndex:9922},{level:3,title:"4.2.使用lock、condition实现",slug:"_4-2-使用lock、condition实现",normalizedTitle:"4.2.使用lock、condition实现",charIndex:14439},{level:2,title:"五.8锁",slug:"五-8锁",normalizedTitle:"五.8锁",charIndex:19954},{level:2,title:"六.List",slug:"六-list",normalizedTitle:"六.list",charIndex:22038},{level:3,title:"6.1.ArrayList",slug:"_6-1-arraylist",normalizedTitle:"6.1.arraylist",charIndex:23272},{level:3,title:"6.2.Collections.synchronizedList(new ArrayList());",slug:"_6-2-collections-synchronizedlist-new-arraylist",normalizedTitle:"6.2.collections.synchronizedlist(new arraylist());",charIndex:null},{level:3,title:"6.3.CopyOnWriteArrayList",slug:"_6-3-copyonwritearraylist",normalizedTitle:"6.3.copyonwritearraylist",charIndex:23380},{level:2,title:"七.Set",slug:"七-set",normalizedTitle:"七.set",charIndex:23697},{level:3,title:"7.1.HashSet",slug:"_7-1-hashset",normalizedTitle:"7.1.hashset",charIndex:23707},{level:3,title:"7.2.Collections.synchronizedSet(new HashSet());",slug:"_7-2-collections-synchronizedset-new-hashset",normalizedTitle:"7.2.collections.synchronizedset(new hashset());",charIndex:null},{level:3,title:"7.3.CopyOnWriteArraySet",slug:"_7-3-copyonwritearrayset",normalizedTitle:"7.3.copyonwritearrayset",charIndex:23854},{level:2,title:"八.Map",slug:"八-map",normalizedTitle:"八.map",charIndex:23986},{level:3,title:"8.1.HashMap",slug:"_8-1-hashmap",normalizedTitle:"8.1.hashmap",charIndex:23996},{level:3,title:"8.2.HashTable",slug:"_8-2-hashtable",normalizedTitle:"8.2.hashtable",charIndex:24152},{level:3,title:"8.3.Collections.synchronizedMap(new HashMap());",slug:"_8-3-collections-synchronizedmap-new-hashmap-string-string",normalizedTitle:"8.3.collections.synchronizedmap(new hashmap());",charIndex:null},{level:3,title:"8.4.new ConcurrentHashMap();",slug:"_8-4-new-concurrenthashmap",normalizedTitle:"8.4.new concurrenthashmap();",charIndex:null},{level:2,title:"九.Callable",slug:"九-callable",normalizedTitle:"九.callable",charIndex:24316},{level:3,title:"9.1.callable和runable的区别：",slug:"_9-1-callable和runable的区别",normalizedTitle:"9.1.callable和runable的区别：",charIndex:24331},{level:3,title:"9.2.使用callable",slug:"_9-2-使用callable",normalizedTitle:"9.2.使用callable",charIndex:24417},{level:2,title:"十.等待多个子线程完成了，主线程再后续执行",slug:"十-等待多个子线程完成了-主线程再后续执行",normalizedTitle:"十.等待多个子线程完成了，主线程再后续执行",charIndex:25673},{level:3,title:"1.CountDownLatch(倒计时锁)",slug:"_1-countdownlatch-倒计时锁",normalizedTitle:"1.countdownlatch(倒计时锁)",charIndex:25699},{level:3,title:"2.CyclicBarrier（计数器）",slug:"_2-cyclicbarrier-计数器",normalizedTitle:"2.cyclicbarrier（计数器）",charIndex:26602},{level:2,title:"十一.Semaphore信号量",slug:"十一-semaphore信号量",normalizedTitle:"十一.semaphore信号量",charIndex:27282},{level:2,title:"十二.ReadWriteLock(读写锁)",slug:"十二-readwritelock-读写锁",normalizedTitle:"十二.readwritelock(读写锁)",charIndex:28519},{level:2,title:"十三.BlokingQueue阻塞队列种类",slug:"十三-blokingqueue阻塞队列种类",normalizedTitle:"十三.blokingqueue阻塞队列种类",charIndex:30510},{level:3,title:"13.1.阻塞队列：",slug:"_13-1-阻塞队列",normalizedTitle:"13.1.阻塞队列：",charIndex:30536},{level:3,title:"13.2.阻塞队列的种类：",slug:"_13-2-阻塞队列的种类",normalizedTitle:"13.2.阻塞队列的种类：",charIndex:30606},{level:3,title:"13.3.阻塞队列的操作：",slug:"_13-3-阻塞队列的操作",normalizedTitle:"13.3.阻塞队列的操作：",charIndex:30626},{level:2,title:"十四.了解java的值传递",slug:"十四-了解java的值传递",normalizedTitle:"十四.了解java的值传递",charIndex:30866},{level:2,title:"十五.线程池",slug:"十五-线程池",normalizedTitle:"十五.线程池",charIndex:31778},{level:3,title:"1.为什么使用多线程？",slug:"_1-为什么使用多线程",normalizedTitle:"1.为什么使用多线程？",charIndex:31789},{level:3,title:"2.线程池类图",slug:"_2-线程池类图",normalizedTitle:"2.线程池类图",charIndex:31807},{level:3,title:"3.线程池工具类（阿里巴巴强制说明不准使用，需自己new）",slug:"_3-线程池工具类-阿里巴巴强制说明不准使用-需自己new",normalizedTitle:"3.线程池工具类（阿里巴巴强制说明不准使用，需自己new）",charIndex:31865},{level:3,title:"4.线程池七大参数",slug:"_4-线程池七大参数",normalizedTitle:"4.线程池七大参数",charIndex:33231},{level:3,title:"5.线程池的执行流程",slug:"_5-线程池的执行流程",normalizedTitle:"5.线程池的执行流程",charIndex:34549},{level:3,title:"6.自定义线程池",slug:"_6-自定义线程池",normalizedTitle:"6.自定义线程池",charIndex:34983},{level:3,title:"7.拒绝策略",slug:"_7-拒绝策略",normalizedTitle:"7.拒绝策略",charIndex:36068},{level:3,title:"8.最大线程的值如何确认？",slug:"_8-最大线程的值如何确认",normalizedTitle:"8.最大线程的值如何确认？",charIndex:38843}],headersStr:"一.并发题（售票员卖票） 1.1.旧版写法synchronized： 1.2.新版写法Lock： 二.复习lambda表达式 三.生产者消费者模式 3.1.Wait、notify的使用 3.2.lock、Condition的使用 四.Lock、condition实现精准通知 4.1.使用wait、notify实现 4.2.使用lock、condition实现 五.8锁 六.List 6.1.ArrayList 6.2.Collections.synchronizedList(new ArrayList()); 6.3.CopyOnWriteArrayList 七.Set 7.1.HashSet 7.2.Collections.synchronizedSet(new HashSet()); 7.3.CopyOnWriteArraySet 八.Map 8.1.HashMap 8.2.HashTable 8.3.Collections.synchronizedMap(new HashMap()); 8.4.new ConcurrentHashMap(); 九.Callable 9.1.callable和runable的区别： 9.2.使用callable 十.等待多个子线程完成了，主线程再后续执行 1.CountDownLatch(倒计时锁) 2.CyclicBarrier（计数器） 十一.Semaphore信号量 十二.ReadWriteLock(读写锁) 十三.BlokingQueue阻塞队列种类 13.1.阻塞队列： 13.2.阻塞队列的种类： 13.3.阻塞队列的操作： 十四.了解java的值传递 十五.线程池 1.为什么使用多线程？ 2.线程池类图 3.线程池工具类（阿里巴巴强制说明不准使用，需自己new） 4.线程池七大参数 5.线程池的执行流程 6.自定义线程池 7.拒绝策略 8.最大线程的值如何确认？",content:'# JUC（尚硅谷阳哥）笔记\n\n2020权威_juc 与 jvm 并发编程 Java 必学_阳哥- 尚硅谷视频地址：\n\nhttps://www.bilibili.com/video/BV1vE411D7KE?p=38\n\n> 多线程编程企业级套路+模板\n> \n>  * 高内聚低耦合\n>  * 口诀：\n>    * 1、线程操作资源类\n>    * 2、若有横向通知，判断--干活--通知\n>    * 3、线程交互中，必须要防止多线程的虚假唤醒，也即（判断只用while，不能用f）\n>    * 4、需要顺序则用标志位\n\n\n# 一.并发题（售票员卖票）\n\n\n# 1.1.旧版写法synchronized：\n\npackage com.wcy.juc;\n\n/**\n * 三个售票员 卖20张票\n *\n * 多线程编程企业级套路+模板\n * 高内聚低耦合\n * 口诀： 线程    操作     资源类\n */\npublic class SaleTicket {\n    public static void main(String[] args) {\n        Ticket ticket=new Ticket();\n        for (int i = 0; i < 3; i++) {\n            new Thread(new Runnable() {//匿名内部类的写法\n                @Override\n                public void run() {\n                    for (int j = 0; j < 40; j++) {\n                        ticket.saleTicket();\n                    }\n                }\n            },i+"售票员").start();\n        }\n    }\n}\nclass Ticket{\n    private int ticketNum=30;//票数\n\n    public synchronized void saleTicket(){\n        if(this.ticketNum > 0){\n            System.out.println(Thread.currentThread().getName()+"卖出第"+ticketNum--+"票，还剩下"+ticketNum+"票");\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 1.2.新版写法Lock：\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * 三个售票员 卖20张票\n *\n * 多线程编程企业级套路+模板\n * 高内聚低耦合\n * 口诀： 线程    操作     资源类\n */\npublic class SaleTicket {\n    public static void main(String[] args) {\n        Ticket ticket=new Ticket();\n        for (int i = 0; i < 3; i++) {\n//            new Thread(new Runnable() {//匿名内部类的写法\n//                @Override\n//                public void run() {\n//                    for (int j = 0; j < 40; j++) {\n//                        ticket.saleTicket();\n//                    }\n//                }\n//            },i+"售票员").start();\n\n            //lamda表达式\n            new Thread(()->{\n                for (int j = 0; j < 40; j++) {\n                        ticket.saleTicket();\n                }\n            },i+"售票员").start();\n        }\n    }\n}\nclass Ticket{\n    private int ticketNum=30;//票数\n    private Lock lock=new ReentrantLock();\n\n    public void saleTicket(){\n        lock.lock();\n        try {\n            if(this.ticketNum > 0){\n                System.out.println(Thread.currentThread().getName()+"卖出第"+ticketNum--+"票，还剩下"+ticketNum+"票");\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 二.复习lambda表达式\n\n> 条件：接口必须只有一个方法\n> \n> 2.1.口诀：拷贝小括号，写死右箭头，落地大括号\n> \n> 2.2 @FunctionalInterface 表示是函数式接口，只允许一个方法的定义\n> \n> 2.3 default 可以使接口有实现方法 2.4 静态方法实现\n\npackage com.wcy.juc;\n\n/**\n * lambda表达式练习\n */\npublic class LambdaTest {\n    public static void main(String[] args) {\n//        Foo foo=new Foo() {\n//            @Override\n//            public void div() {\n//                System.out.println("匿名内部类写法");\n//            }\n//        };\n//        foo.div();\n\n        Foo foo=()->{\n            System.out.println("lambda表达式写法");\n        };\n        foo.div();\n        foo.mv();\n        foo.mv1();\n        Foo.staticTest();\n        Foo.staticTest1();\n    }\n}\n//表示该接口是函数式接口\n@FunctionalInterface\ninterface Foo{\n    public void div();\n    default void mv(){\n        System.out.println("我是默认的方法");\n    }\n    default void mv1(){\n        System.out.println("我也是默认的方法");\n    }\n    public static void staticTest(){\n        System.out.println("我是静态的方法");\n    }\n    public static void staticTest1(){\n        System.out.println("我也是静态的方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n强调：java的接口可以有实现方法吗？\n\njdk1.8之前不可以，jdk1.8以后支持，通过default关键字实现\n\n\n1\n\n\n\n# 三.生产者消费者模式\n\n> 口诀：\n> \n>  * 1、线程操作资源类\n>  * 2、若有横向通知，判断--干活--通知\n>  * 3、线程交互中，必须要防止多线程的虚假唤醒，也即（判断只用while，不能用f）\n>  * 4、需要顺序则用标志位\n\n题目：现在两个线程，可以操作初始值为零的一个变量，实现一个线程对该变量加扪，一个线程对该变量减1，实现交替，来10轮，变量初始值为零。\n\n\n# 3.1.Wait、notify的使用\n\n使用Wait、notify进行交互，典型生产者消费者模式：\n\n> Wait：释放CPU\n> \n> notify：通知其他线程\n\npackage com.wcy.juc;\n\n/**\n * Wait、notify实现生产者消费者模式:\n * 口诀：   判断/干活/通知\n *\n * 题目：现在两个线程，可以操作初始值为零的一个变量，\n * 实现一个线程对该变量加扪，一个线程对该变量减1，\n * 实现交替，来10轮，变量初始值为零。\n */\npublic class ThreadWaitNotifyDemo {\n    public static void main(String[] args) {\n        Num num=new Num();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                num.incrNum();//加1\n            }\n        },"A").start();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                num.decrNum();//-1\n            }\n        },"B").start();\n    }\n}\nclass Num{\n    private int num=0;\n    private Object object=new Object();\n\n    public void incrNum(){\n        synchronized(object){\n            if(num!=0){//等于1，则释放CPU\n                try {\n                    object.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    System.out.println("异常出错");\n                }\n            }\n            num++;\n            System.out.println(Thread.currentThread().getName()+"----\x3e"+num);\n            //通知别人\n            object.notifyAll();\n        }\n    }\n    public void decrNum(){\n        synchronized(object){\n            if(num == 0){//等于0，则释放CPU\n                try {\n                    object.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    System.out.println("异常出错");\n                }\n            }\n            num--;\n            System.out.println(Thread.currentThread().getName()+"----\x3e"+num);\n            //通知别人\n            object.notifyAll();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n存在的问题：由于线程间的交互，线程有虚假唤醒操作，导致结果不一致；比如把线程换成四个就出现问题\n\n    public void incrNum(){\n        synchronized(object){\n            if(num!=0){//等于1，则释放CPU\n         \t\t//线程有可能走到这儿之后被中断，再回来时间，可能num已经++了，就可能导致问题\n                try {\n                    object.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    System.out.println("异常出错");\n                }\n            }\n            num++;\n            System.out.println(Thread.currentThread().getName()+"----\x3e"+num);\n            //通知别人\n            object.notifyAll();\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n正确代码：\n\npackage com.wcy.juc;\n\n/**\n * Wait、notify实现生产者消费者模式:\n * 口诀：   判断/干活/通知\n *\n * 题目：现在两个线程，可以操作初始值为零的一个变量，\n * 实现一个线程对该变量加扪，一个线程对该变量减1，\n * 实现交替，来10轮，变量初始值为零。\n */\npublic class ThreadWaitNotifyDemo {\n    public static void main(String[] args) {\n        Num num=new Num();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                num.incrNum();//加1\n            }\n        },"A").start();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                num.decrNum();//-1\n            }\n        },"B").start();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                num.incrNum();//加1\n            }\n        },"C").start();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                num.decrNum();//-1\n            }\n        },"D").start();\n    }\n}\nclass Num{\n    private int num=0;\n    private Object object=new Object();\n\n    public void incrNum(){\n        synchronized(object){\n            while (num!=0){//等于1，则释放CPU\n                try {\n                    object.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    System.out.println("异常出错");\n                }\n            }\n            num++;\n            System.out.println(Thread.currentThread().getName()+"----\x3e"+num);\n            //通知别人\n            object.notifyAll();\n        }\n    }\n    public void decrNum(){\n        synchronized(object){\n            while (num == 0){//等于0，则释放CPU\n                try {\n                    object.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    System.out.println("异常出错");\n                }\n            }\n            num--;\n            System.out.println(Thread.currentThread().getName()+"----\x3e"+num);\n            //通知别人\n            object.notifyAll();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# 3.2.lock、Condition的使用\n\n//新版写法\nclass Num{\n    private int num=0;\n    private Lock lock=new ReentrantLock();\n    private Condition condition=lock.newCondition();\n\n    public void incrNum(){\n        lock.lock();\n        try {\n            //判断\n            while (num != 0){\n                condition.await();\n            }\n            //干活\n            num++;\n            System.out.println(Thread.currentThread().getName()+"-----\x3e>>"+num);\n            //通知\n            condition.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void decrNum(){\n        lock.lock();\n        try {\n            //判断\n            while (num == 0){\n                condition.await();\n            }\n            //干活\n            num--;\n            System.out.println(Thread.currentThread().getName()+"-----\x3e>>"+num);\n            //通知\n            condition.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 四.Lock、condition实现精准通知\n\n题目升级：ABC三个线程，A打印五次，B打印10次，C打印15次,顺序为Abc，打印10轮\n\n\n# 4.1.使用wait、notify实现\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * 题目：\n * ABC三个线程，A打印五次，B打印10次，C打印15次,顺序为Abc   打印10轮\n * 口径\n * 1、线程操作资源类\n * 2、若有横向通知，判断--干活--通知\n * 3、线程交互中，必须要防止多线程的虚假唤醒，也即（判断只用while，不能用f）\n * 4、需要顺序则用标志位\n */\npublic class ThreadConditionDemo {\n    public static void main(String[] args) {\n        SysNum sysNum=new SysNum();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                sysNum.print5(1);\n            }\n        },"A").start();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                sysNum.print10(2);\n            }\n        },"B").start();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                sysNum.print15(3);\n            }\n        },"C").start();\n    }\n}\n\nclass SysNum{\n    private int number=1;\n    private Object object=new Object();\n\n    public void print5(int num) {\n        synchronized (object){\n            //判断\n            while (num != number){\n                try {\n                    object.wait();//不是A线程执行\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            for (int i = 0; i < 5; i++) {\n                System.out.println(Thread.currentThread().getName()+"-----\x3e>>"+i);\n            }\n            number=2;\n            object.notifyAll();\n        }\n    }\n    public void print10(int num)  {\n        synchronized (object){\n            //判断\n            while (num != number){\n                try {\n                    object.wait();//不是B线程执行\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            for (int i = 0; i < 10; i++) {\n                System.out.println(Thread.currentThread().getName()+"-----\x3e>>"+i);\n            }\n            number=3;\n            object.notifyAll();\n        }\n    }\n    public void print15(int num) {\n        synchronized (object){\n            //判断\n            while (num != number){\n                try {\n                    object.wait();//不是C线程执行\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            for (int i = 0; i < 15; i++) {\n                System.out.println(Thread.currentThread().getName()+"-----\x3e>>"+i);\n            }\n            number=1;\n            object.notifyAll();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n优化\n\n上方是三个方法实现，可以用一个方法实现：\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * 题目：\n * ABC三个线程，A打印五次，B打印10次，C打印15次,顺序为Abc   打印10轮\n * 口径\n * 1、线程操作资源类\n * 2、若有横向通知，判断--干活--通知\n * 3、线程交互中，必须要防止多线程的虚假唤醒，也即（判断只用while，不能用f）\n * 4、需要顺序则用标志位\n */\npublic class ThreadConditionDemo {\n    public static void main(String[] args) {\n        SysNum sysNum=new SysNum();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                sysNum.print(1);\n            }\n        },"A").start();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                sysNum.print(2);\n            }\n        },"B").start();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                sysNum.print(3);\n            }\n        },"C").start();\n    }\n}\n\nclass SysNum{\n    private int number=1;\n    private Object object=new Object();\n\n    public void print(int num){\n        synchronized (object){\n            //判断\n            while (num != number){\n                try {\n                    object.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            //干活\n            for (int i = 0; i < 5*num; i++) {\n                System.out.println(Thread.currentThread().getName()+"-----\x3e>>"+i);\n            }\n            //通知\n            number=(number==3)?1:number+1;//为C的时候应改为A\n            object.notifyAll();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 4.2.使用lock、condition实现\n\n> 定义：Lock 、condition实现\n> \n> private Lock lock=new ReentrantLock(); private Condition condition1=lock.newCondition(); private Condition condition2=lock.newCondition(); private Condition condition3=lock.newCondition();\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * 题目：\n * ABC三个线程，A打印五次，B打印10次，C打印15次,顺序为Abc 打印10轮\n * 口径\n * 1、线程操作资源类\n * 2、若有横向通知，判断--干活--通知\n * 3、线程交互中，必须要防止多线程的虚假唤醒，也即（判断只用while，不能用f）\n * 4、需要顺序则用标志位\n */\npublic class ThreadConditionDemo {\n    public static void main(String[] args) {\n        PrintNum printNum=new PrintNum();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                printNum.print5();\n            }\n        },"A").start();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                printNum.print10();\n            }\n        },"B").start();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                printNum.print15();\n            }\n        },"C").start();\n    }\n}\n\nclass PrintNum{\n    private int number=1;//1:A  2:B  3:C\n    private Lock lock=new ReentrantLock();\n    private Condition condition1=lock.newCondition();\n    private Condition condition2=lock.newCondition();\n    private Condition condition3=lock.newCondition();\n\n    public void print5(){\n        lock.lock();\n        try {\n            //判断\n            while (number != 1){\n                condition1.await();//A等待\n            }\n            //干活\n            for (int i = 0; i < 5; i++) {\n                System.out.println(Thread.currentThread().getName()+"-----\x3e>>"+i);\n            }\n            //通知\n            number=2;//B开始干活\n            condition2.signal();//通知B\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void print10(){\n        lock.lock();\n        try {\n            //判断\n            while (number != 2){\n                condition2.await();//A等待\n            }\n            //干活\n            for (int i = 0; i < 10; i++) {\n                System.out.println(Thread.currentThread().getName()+"-----\x3e>>"+i);\n            }\n            //通知\n            number=3;//B开始干活\n            condition3.signal();//通知B\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void print15(){\n        lock.lock();\n        try {\n            //判断\n            while (number != 3){\n                condition3.await();//A等待\n            }\n            //干活\n            for (int i = 0; i < 15; i++) {\n                System.out.println(Thread.currentThread().getName()+"-----\x3e>>"+i);\n            }\n            //通知\n            number=1;//B开始干活\n            condition1.signal();//通知B\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n\n\n优化：\n\n上面使用了三个方法，其实这三个方法都是差不多的，所以改写成一个：\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * 题目：\n * ABC三个线程，A打印五次，B打印10次，C打印15次,顺序为Abc   打印10轮\n * 口径\n * 1、线程操作资源类\n * 2、若有横向通知，判断--干活--通知\n * 3、线程交互中，必须要防止多线程的虚假唤醒，也即（判断只用while，不能用f）\n * 4、需要顺序则用标志位\n */\npublic class ThreadConditionDemo {\n    public static void main(String[] args) {\n        PrintNum printNum=new PrintNum();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                printNum.print(1);\n            }\n        },"A").start();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                printNum.print(2);\n            }\n        },"B").start();\n        new Thread(()->{\n            for (int i = 0; i < 10; i++) {\n                printNum.print(3);\n            }\n        },"C").start();\n    }\n}\n\nclass PrintNum{\n    private int number=1;//1:A  2:B  3:C\n    private Lock lock=new ReentrantLock();\n    private Condition condition1=lock.newCondition();\n    private Condition condition2=lock.newCondition();\n    private Condition condition3=lock.newCondition();\n    private Condition[] conditions=new Condition[]{condition1,condition2,condition3};\n\n    /**\n     *\n     * @param num 线程   1:A  2:B  3:C\n     */\n    public void print(int num){\n        lock.lock();\n        try {\n            //判断\n            while (number != num){\n                //当不是自己处理 则释放该CPU\n                conditions[num-1].await();//数组0开始\n            }\n            //干活\n            for (int i = 0; i < 5*num; i++) {\n                System.out.println(Thread.currentThread().getName()+"----\x3e"+i);\n            }\n            //通知\n            number= (number==3)?1:number+1;//通知下一个\n            conditions[number-1].signal();//数组从0开始的 所以-1\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 五.8锁\n\n静态同步方法和同步方法锁的目标不一样，互不干扰，静态同步方法锁的是class、同步方法锁的是对象（实例）；\n\n> 题目:多线程8锁 1.标准访问，请问先打印邮件还是短信? 2.邮件方法暂停4秒钟，请问先打印邮件还是短信? 3.新增一个普通方法hello()，请问先打印邮件还是hello ? 4.两部手机，请问先打印邮件还是短信? 5.两个静态同步方法，同一部手机，请问先打印邮件还是短信? 6.两个静态同步方法，2部手机，请问先打印邮件还是短信? 7.1个普通同步方法,1个静态同步方法，1部手机，请问先打印邮件还是短信? 8.1个普通同步方法,1个静态同步方法，2部手机，请问先打印邮件还是短信?\n\n代码：\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 线程8锁\n *\n * 1.标准访问，请问先打印邮件还是短信?\n * 2.邮件方法暂停4秒钟，请问先打印邮件还是短信?\n * 3.新增一个普通方法hello()，请问先打印邮件还是hello ?\n * 4.两部手机，请问先打印邮件还是短信?\n * 5.两个静态同步方法，同一部手机，请问先打印邮件还是短信?\n * 6.两个静态同步方法，2部手机，请问先打印邮件还是短信?\n * 7.1个普通同步方法,1个静态同步方法，1部手机，请问先打印邮件还是短信?\n * 8.1个普通同步方法,1个静态同步方法，2部手机，请问先打印邮件还是短信?\n */\npublic class Thread8 {\n    public static void main(String[] args) throws Exception {\n        Phone phone=new Phone();\n        Phone phone1=new Phone();\n        new Thread(()->{\n            phone.sendEmail();\n        },"A").start();\n\n        TimeUnit.MILLISECONDS.sleep(1);//休眠1毫秒秒钟\n        new Thread(()->{\n//      2      phone.sendMsg();\n//    3        phone.hello();\n//     4       phone1.sendMsg();\n//     5       phone.sendMsg();\n//      6      phone1.sendMsg();\n            phone.sendMsg();\n//            phone1.sendMsg();\n        },"B").start();\n    }\n}\nclass Phone{\n    private static Object object=new Object();\n    public synchronized static void sendEmail(){\n            try {\n                TimeUnit.SECONDS.sleep(1);//休眠4秒\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println("sendEmail");\n    }\n    public synchronized void sendMsg(){\n            System.out.println("sendMsg");\n    }\n    public void hello(){\n        System.out.println("hello");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n题解：\n\n> 1.先打印邮件--标准访问\n> \n> 2.先打印邮件，sleep并不释放锁，同一个对象；\n> \n> 3.先打印hello，hello方法无锁，可以直接输出；\n> \n> 4.先打印短信，两个对象，两把锁，互不干扰，锁的对象；\n> \n> 5.先打印邮件，静态同步方法，锁的是class类，一把锁，邮件拿到锁不释放；\n> \n> 6.先打印邮件，静态同步方法，锁的是class类，一把锁，邮件拿到锁不释放；\n> \n> 7、8.先打印短信，锁对象不同\n\n\n\n\n# 六.List\n\n并发操作集合，常见异常java.util.ConcurrentModificationException\n\n\n\nlist集合并发使用：推荐使用CopyOnWriteArrayList，JUC下面的并发集合类\n\n>  * 1.new Vector<>(); 不提倡，其实就是ArrayList<>加了synchronized\n>  * 2.Collections.synchronizedList(new ArrayList<>());\n>  * 3.new CopyOnWriteArrayList<>();\n\npackage com.wcy.juc;\n\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * List并发集合类demo\n * 并发问题：\n * new ArrayList<>();不安全\n *\n * 解决办法：\n * 1.new Vector<>();  不提倡，其实就是ArrayList<>加了synchronized\n * 2.Collections.synchronizedList(new ArrayList<>());\n * 3.new CopyOnWriteArrayList<>();\n *\n */\npublic class ThreadListDemo {\n    public static void main(String[] args) {\n//        List<String> list=new ArrayList<>();\n//        List<String> list=new Vector<>();\n//        List<String> list= Collections.synchronizedList(new ArrayList<>());\n        List<String> list=new CopyOnWriteArrayList<>();\n        for (int i = 0; i < 30; i++) {\n            new Thread(()->{\n                list.add(UUID.randomUUID().toString().substring(0,8));\n                System.out.println(list);\n            },String.valueOf(i)).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 6.1.ArrayList\n\n\n\n\n# 6.2.Collections.synchronizedList(new ArrayList<>());\n\n底层通过synchonized实现的，遍历未加锁，写删加锁\n\n\n# 6.3.CopyOnWriteArrayList\n\n\n\n> 写时复制 Copyonwrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器object[]添加，而是先将当前容涨object[]进行icopy,复制出一个新的容器object[ ] newElements，然后新的容器object[ ] newELements里添加元素，添加完元素之后， 再将原容器的引用指向新的容器setArray(newELements);。这样做的好处是可以对欢CopyOnwrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以copyonerite容器也是一种读写分离的思想，读和写不同的容器。\n\n\n# 七.Set\n\n\n# 7.1.HashSet\n\n> hashSet底层是hashMap：key是值，value是一个object常量\n\n\n\n\n# 7.2.Collections.synchronizedSet(new HashSet<>());\n\n底层通过synchonized实现的，遍历未加锁，写删加锁\n\n\n# 7.3.CopyOnWriteArraySet\n\n底层的add方法：首先获取原数组，调用indexOf方法判断数组中是否已有，有则不添加，否则进入方法addIfAbsent\n\n\n\n走到了CopyOnWriteArrayList的addIfAbsent\n\n\n\n\n# 八.Map\n\n\n# 8.1.HashMap\n\n底层数组+链表+红黑树，长度为8链表变为红黑树，为6则红黑树变为链表；\n\n扩容机制为原来的两倍；\n\nhashMap的负载因子为0.75，可以修改，但是0.75使得hash冲突最小；\n\nHashMap的hash值通过高16位异或低16位，一旦有一位发送变化，hash值都会不同；\n\n\n# 8.2.HashTable\n\n其实就是HashMap每个方法加上了synchronized\n\n\n# 8.3.Collections.synchronizedMap(new HashMap<String,String>());\n\n遍历未加锁，修改加锁\n\n\n# 8.4.new ConcurrentHashMap<>();\n\n\n# 九.Callable\n\n\n# 9.1.callable和runable的区别：\n\n 1. 前者为call方法，后者为run方法\n 2. 前者有抛出异常，后者无\n 3. 前者有返回值，后者无\n\n\n\n\n# 9.2.使用callable\n\n> 1.get()方法会阻塞当前线程，所以get()方法一般放到最后\n> \n> 2.同一个FutureTask任务，即使多个线程也只会执行一次，有缓存；类似于：老师上课，喊同学去买水，第一次可以，第二次再交这位同学去买水就过分了；\n> \n> FutureTask futureTask=new FutureTask(new MyThread());\n> new Thread(futureTask,"A").start();\n> new Thread(futureTask,"B").start();\n> \n> \n> 1\n> 2\n> 3\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\n/**\n * 创建线程的第三种方式：\n * 实现callable接口\n */\npublic class CallableDemo {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        /**\n         * 利用多态性=》由于new Thread()的构造方法只支持传入Runnable接口，\n         * 找到Runnable的子接口FutureTask\n         * FutureTask的构造方法支持传入Callable\n         */\n        FutureTask futureTask=new FutureTask(new MyThread());\n        //启动线程\n        new Thread(futureTask,"A").start();\n        new Thread(futureTask,"B").start();\n        System.out.println(futureTask.get());//获取线程返回的数据  会阻塞当前线程\n    }\n}\n\nclass MyThread implements Callable{\n\n    @Override\n    public Object call() throws Exception {\n        System.out.println("*****com进来了****");\n        return 1024;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 十.等待多个子线程完成了，主线程再后续执行\n\n\n# 1.CountDownLatch(倒计时锁)\n\n> CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。\n> \n> 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)， 当计数器的值变为o时，因await方法阻塞的线程会被唤醒，继续执行\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.CountDownLatch;\n\n/**\n * 线程等待：\n * 比如：等待6个子线程完成了，主线程再后续执行\n * 解决：CountDownLatch：子线程完成一次调用一次countDownLatch.countDown()进行减一操作，最后通过await等待获取结果\n */\npublic class CountDownLatchDemo {\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch countDownLatch=new CountDownLatch(6);\n        for (int i = 1; i <= 6; i++) {\n            new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+"同学离开");\n                countDownLatch.countDown();//子线程完成一次减一\n            },i+"").start();\n        }\n        countDownLatch.await();\n        System.out.println("主线程结束");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 2.CyclicBarrier（计数器）\n\n    public static void main(String[] args) throws InterruptedException {\n        CyclicBarrier barrier=new CyclicBarrier(7,()-> System.out.println("集起七颗龙珠"));\n        for (int i = 0; i < 7; i++) {\n            int index=i;\n            new Thread(()->{\n                System.out.println("第"+index+"颗龙珠");\n                try {\n                    barrier.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            },""+i).start();\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 十一.Semaphore信号量\n\n> 在信号量上我们定义两种操作:\n> \n>  * acquire(获取）当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1）， 要么一直等下去，直到有线程释放信号量，或超时。\n> \n>  * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程\n>    \n>    信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。\n\nSemaphore semaphore=new Semaphore(1);其实就是synchronized，相当与锁\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 多个线程访问多个资源\n * 假设：六个小车抢占三个停车位\n * Semaphore 保证了资源只有三份，随便怎么抢\n */\npublic class SemaphoreDemo {\n    public static void main(String[] args) {\n        Semaphore semaphore=new Semaphore(3);//定义了三个资源\n        for (int i = 0; i < 6; i++) {\n            new Thread(()->{\n                try {\n                    semaphore.acquire();//抢占资源\n                    System.out.println(Thread.currentThread().getName()+"抢到了停车位");\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }finally {\n                    semaphore.release();//释放资源\n                    System.out.println(Thread.currentThread().getName()+"离开了停车位");\n                }\n            },i+"").start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 十二.ReadWriteLock(读写锁)\n\n 1. 读读不加锁\n 2. 读写枷锁\n 3. 写写加锁\n\n> 手写一个简单的缓存工具\n\npackage com.wcy.juc;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * 读写锁\n *  * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。\n *  * 但是，如果有一个线程想去写共享资源来，就不应该再有其他线程可以对改资源进行读或写\n *  * 小总结：\n *  *      读-读能共存\n *  *      读-写不能共存\n *  *      写-写不能共存\n */\npublic class ReadWriteLockDemo {\n    public static void main(String[] args) {\n        MyCache myCache=new MyCache();\n        for (int i = 0; i < 5; i++) {\n            final int item=i;\n            new Thread(()->{\n                myCache.put(item+"",item);\n            },i+"").start();\n        }\n        for (int i = 0; i < 5; i++) {\n            final int item=i;\n            new Thread(()->{\n                myCache.get(item+"");\n            },i+"").start();\n        }\n    }\n}\nclass MyCache{\n    //volatile:，保证可见性，不保证原子性，一个线程修改后，通知更新\n    private volatile Map<String,Object> map=new HashMap<>();\n    private ReadWriteLock lock=new ReentrantReadWriteLock();//读写锁\n\n    public void put(String key,Object value){\n        lock.writeLock().lock();//获取写锁\n        try {\n            System.out.println(Thread.currentThread().getName()+"---写入数据准备");\n            map.put(key,value);\n            System.out.println(Thread.currentThread().getName()+"---写入数据完成"+key);\n        }finally {\n            lock.writeLock().unlock();//释放写锁\n        }\n    }\n\n    public void get(String key){\n        lock.readLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName()+"---读取数据准备");\n            Object o = map.get(key);\n            System.out.println(Thread.currentThread().getName()+"---读取数据完成"+o);\n        }finally {\n            lock.readLock().unlock();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 十三.BlokingQueue阻塞队列种类\n\n\n# 13.1.阻塞队列：\n\n> 当队列为空的时候，从队列中取出元素会阻塞队列；\n> \n> 当队列是满的时候，从队列添加元素会阻塞队列；\n\n\n# 13.2.阻塞队列的种类：\n\n\n\n\n# 13.3.阻塞队列的操作：\n\n方法类型        抛出异常        特殊值        阻塞       超时\n插入          add(e)      offer(e)   put(e)   offer(e.time,unit)\n移除          remore()    poll()     take()   poll(time,unilt)\n检查（获取头元素）   element()   peek()     不可用      不可用\n\n\n\n\n# 十四.了解java的值传递\n\n 1. 基本数据类型是拷贝一份过去\n\n 2. 引用类型，传递过去的一份，但是大家是公用这一份的。\n    \n    \n\n 3. 字符串注意有常量池不会改变；\n\npublic class TestTransferValue {\n    public void changeValue1(int age){\n        age = 30;\n    }\n    public void changeValue2(Person person){\n        person.setPersonName("xxx");\n    }\n    public void changeValue3(String str){\n        str = "xxx";\n    }\n\n    public static void main(String[] args) {\n        TestTransferValue test = new TestTransferValue();\n        int age = 20;\n        test.changeValue1(age);\n        System.out.println("age----"+age);  //20\n\n        Person person = new Person("abc");\n        test.changeValue2(person);\n        System.out.println("personName-------"+person.getPersonName());  //xxx\n\n        String str = "abc";\n        test.changeValue3(str);\n        System.out.println("String-----"+str);  //abc\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 十五.线程池\n\n\n# 1.为什么使用多线程？\n\n\n\n\n# 2.线程池类图\n\n可以与List、Lists、Collections、Collection来类比记忆。\n\n\n\n\n# 3.线程池工具类（阿里巴巴强制说明不准使用，需自己new）\n\n\n\n# 1.Executors.newFixedThreadPool(5);\n\n长度固定的线程池\n\n    public static void main(String[] args) {\n        ExecutorService executorService=null;\n        try {\n            executorService = Executors.newFixedThreadPool(5);\n            for (int i = 0; i < 10; i++) {\n                executorService.execute(()->{\n                    System.out.println(Thread.currentThread().getName()+"处理业务");\n                });\n            }\n        }finally {\n            executorService.shutdown();//关闭线程池\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n\n\n1\n2\n3\n\n\n# 2.Executors.newSingleThreadExecutor();\n\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n\n\n1\n2\n3\n4\n\n\n一次只执行一个线程\n\n# 3.Executors.newCachedThreadPool();\n\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n\n\n1\n2\n3\n\n\n动态执行线程\n\n> 底层都是new ThreadPoolExecutro()实现的\n\n\n# 4.线程池七大参数\n\n源码：\n\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 1. corePoolSize：核心线程数（线程池中常驻的核心线程数）\n 2. maximumPoolSize：最大线程数，线程池中最大能容纳的线程数，当核心线程数、队列满了，开启线程\n 3. keepAliveTime：时间长短\n 4. unit：时间单位，配合keepAliveTime一起使用，用于回收核心线程数\n 5. workQueue：阻塞队列，当核心线程数满了，放到队列中\n 6. threadFactory：线程工厂（默认）\n 7. RejectedExecutorHandler：拒绝策略：当核心线程数、最大线程数、队列满了执行\n\n\n# 5.线程池的执行流程\n\n\n\n1、在创建了线程池后，开始等待请求。 2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断: 2.1如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务; 2.2如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列; 2.3如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务; 2.4如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。 3、当一个线程完成任务时，它会从队列中取下一个任务来执行。 4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断: 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。\n\n\n# 6.自定义线程池\n\n> 下面定义了核心线程数为2，最大线程数为5，队列长度为3的线程池，当线程数到9就会报：java.util.concurrent.RejectedExecutionException异常\n\npublic static void main(String[] args) {\n        ExecutorService executorService=null;\n        try {\n            executorService=new ThreadPoolExecutor(\n                    2,\n                    5,\n                    2L,\n                    TimeUnit.MINUTES,\n                    new ArrayBlockingQueue<>(3),\n                    Executors.defaultThreadFactory(),\n                    new ThreadPoolExecutor.AbortPolicy());\n            for (int i = 0; i < 9; i++) {\n                executorService.execute(()->{\n                    try {\n                        TimeUnit.SECONDS.sleep(1);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName()+"处理业务");\n                });\n            }\n        }finally {\n            executorService.shutdown();//关闭线程池\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 7.拒绝策略\n\n# 1.JDK内置四种拒绝策略\n\n 1. AbortPolicy（默认）：直接抛出RejectedExecutionException异常阻止系统正常运行\n\n 2. CallerRunsPolicy：不会抛弃任务也不会抛出异常，而是把任务回退到调用者(若线程池是主线程创建，则主线程执行任务),从而降低新任务的流量。\n    \n    \n\n 3. DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入到队列中尝试再次提交当前任务。\n\n 4. DiscardPolicy：直接抛弃异常，如果允许任务丢失，这是最好的一中策略；\n\n# 2.自定义拒绝策略\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * 自定义线程访问策略\n */\npublic class MyThreadPoolExecutor {\n    private ExecutorService service=null;\n\n    public ExecutorService init(){\n        if(service == null){\n            this.service=new ThreadPoolExecutor(\n                    2,\n                    3,\n                    2L,\n                    TimeUnit.MINUTES,\n                    new ArrayBlockingQueue<>(5),\n                    new MyThreadPoolExecutor.MyThreadFactory(), //自定义线程工厂\n                    new MyThreadPoolExecutor.MyPolicy() //自定义的拒绝策略\n            );\n        }\n        return service;\n    }\n\n    public void destory(){\n        if(this.service != null){\n            this.service.shutdown();//关闭线程池\n        }\n    }\n\n    /**\n     * 自定义线程工厂\n     */\n    class MyThreadFactory implements ThreadFactory{\n        private AtomicInteger account=new AtomicInteger(0);\n\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(r);\n            String threadName = MyThreadPoolExecutor.class.getSimpleName() + account.addAndGet(1);\n            //System.out.println(threadName);\n            t.setName(threadName);\n            return t;\n        }\n    }\n\n    /**\n     * 自定义拒绝策略\n     */\n    class MyPolicy implements RejectedExecutionHandler{\n\n        //当前任务执行到改地方 应该做什么\n        @Override\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n            try {\n                // 核心改造点，由blockingqueue的offer改成put阻塞方法\n                System.out.println("*****执行线程池拒绝策略*******");\n                executor.getQueue().put(r);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThreadPoolExecutor myExecutor = new MyThreadPoolExecutor();\n        ExecutorService executor=myExecutor.init();//获取自定义拒绝策略的线程池\n        try {\n            for (int i = 0; i < 10; i++) {\n                executor.execute(()->{\n                    System.out.println(Thread.currentThread().getName()+"执行了");\n                });\n            }\n        }finally {\n            myExecutor.destory();//调用关闭线程池\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n\n\n# 8.最大线程的值如何确认？\n\n> 根据CPU密集型和 IO密集型的任务确认：\n> \n>  1. CPU密集型的任务，最大线程数<=CPU的可用核心数。\n>  2. IO密集型的任务，最大线程数和CPU核心数没有很强的联系，根据任务量的大小和服务器的性能来设定一个值。如果平均IO任务量是100个，那么最大线程数可以设置为120，如果平均IO任务量非常大的话，那么，建议调整软件架构，采用分布式来处理吧，瓶颈已经不是什么线程池了。',normalizedContent:'# juc（尚硅谷阳哥）笔记\n\n2020权威_juc 与 jvm 并发编程 java 必学_阳哥- 尚硅谷视频地址：\n\nhttps://www.bilibili.com/video/bv1ve411d7ke?p=38\n\n> 多线程编程企业级套路+模板\n> \n>  * 高内聚低耦合\n>  * 口诀：\n>    * 1、线程操作资源类\n>    * 2、若有横向通知，判断--干活--通知\n>    * 3、线程交互中，必须要防止多线程的虚假唤醒，也即（判断只用while，不能用f）\n>    * 4、需要顺序则用标志位\n\n\n# 一.并发题（售票员卖票）\n\n\n# 1.1.旧版写法synchronized：\n\npackage com.wcy.juc;\n\n/**\n * 三个售票员 卖20张票\n *\n * 多线程编程企业级套路+模板\n * 高内聚低耦合\n * 口诀： 线程    操作     资源类\n */\npublic class saleticket {\n    public static void main(string[] args) {\n        ticket ticket=new ticket();\n        for (int i = 0; i < 3; i++) {\n            new thread(new runnable() {//匿名内部类的写法\n                @override\n                public void run() {\n                    for (int j = 0; j < 40; j++) {\n                        ticket.saleticket();\n                    }\n                }\n            },i+"售票员").start();\n        }\n    }\n}\nclass ticket{\n    private int ticketnum=30;//票数\n\n    public synchronized void saleticket(){\n        if(this.ticketnum > 0){\n            system.out.println(thread.currentthread().getname()+"卖出第"+ticketnum--+"票，还剩下"+ticketnum+"票");\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 1.2.新版写法lock：\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.locks.lock;\nimport java.util.concurrent.locks.reentrantlock;\n\n/**\n * 三个售票员 卖20张票\n *\n * 多线程编程企业级套路+模板\n * 高内聚低耦合\n * 口诀： 线程    操作     资源类\n */\npublic class saleticket {\n    public static void main(string[] args) {\n        ticket ticket=new ticket();\n        for (int i = 0; i < 3; i++) {\n//            new thread(new runnable() {//匿名内部类的写法\n//                @override\n//                public void run() {\n//                    for (int j = 0; j < 40; j++) {\n//                        ticket.saleticket();\n//                    }\n//                }\n//            },i+"售票员").start();\n\n            //lamda表达式\n            new thread(()->{\n                for (int j = 0; j < 40; j++) {\n                        ticket.saleticket();\n                }\n            },i+"售票员").start();\n        }\n    }\n}\nclass ticket{\n    private int ticketnum=30;//票数\n    private lock lock=new reentrantlock();\n\n    public void saleticket(){\n        lock.lock();\n        try {\n            if(this.ticketnum > 0){\n                system.out.println(thread.currentthread().getname()+"卖出第"+ticketnum--+"票，还剩下"+ticketnum+"票");\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 二.复习lambda表达式\n\n> 条件：接口必须只有一个方法\n> \n> 2.1.口诀：拷贝小括号，写死右箭头，落地大括号\n> \n> 2.2 @functionalinterface 表示是函数式接口，只允许一个方法的定义\n> \n> 2.3 default 可以使接口有实现方法 2.4 静态方法实现\n\npackage com.wcy.juc;\n\n/**\n * lambda表达式练习\n */\npublic class lambdatest {\n    public static void main(string[] args) {\n//        foo foo=new foo() {\n//            @override\n//            public void div() {\n//                system.out.println("匿名内部类写法");\n//            }\n//        };\n//        foo.div();\n\n        foo foo=()->{\n            system.out.println("lambda表达式写法");\n        };\n        foo.div();\n        foo.mv();\n        foo.mv1();\n        foo.statictest();\n        foo.statictest1();\n    }\n}\n//表示该接口是函数式接口\n@functionalinterface\ninterface foo{\n    public void div();\n    default void mv(){\n        system.out.println("我是默认的方法");\n    }\n    default void mv1(){\n        system.out.println("我也是默认的方法");\n    }\n    public static void statictest(){\n        system.out.println("我是静态的方法");\n    }\n    public static void statictest1(){\n        system.out.println("我也是静态的方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n强调：java的接口可以有实现方法吗？\n\njdk1.8之前不可以，jdk1.8以后支持，通过default关键字实现\n\n\n1\n\n\n\n# 三.生产者消费者模式\n\n> 口诀：\n> \n>  * 1、线程操作资源类\n>  * 2、若有横向通知，判断--干活--通知\n>  * 3、线程交互中，必须要防止多线程的虚假唤醒，也即（判断只用while，不能用f）\n>  * 4、需要顺序则用标志位\n\n题目：现在两个线程，可以操作初始值为零的一个变量，实现一个线程对该变量加扪，一个线程对该变量减1，实现交替，来10轮，变量初始值为零。\n\n\n# 3.1.wait、notify的使用\n\n使用wait、notify进行交互，典型生产者消费者模式：\n\n> wait：释放cpu\n> \n> notify：通知其他线程\n\npackage com.wcy.juc;\n\n/**\n * wait、notify实现生产者消费者模式:\n * 口诀：   判断/干活/通知\n *\n * 题目：现在两个线程，可以操作初始值为零的一个变量，\n * 实现一个线程对该变量加扪，一个线程对该变量减1，\n * 实现交替，来10轮，变量初始值为零。\n */\npublic class threadwaitnotifydemo {\n    public static void main(string[] args) {\n        num num=new num();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                num.incrnum();//加1\n            }\n        },"a").start();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                num.decrnum();//-1\n            }\n        },"b").start();\n    }\n}\nclass num{\n    private int num=0;\n    private object object=new object();\n\n    public void incrnum(){\n        synchronized(object){\n            if(num!=0){//等于1，则释放cpu\n                try {\n                    object.wait();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                    system.out.println("异常出错");\n                }\n            }\n            num++;\n            system.out.println(thread.currentthread().getname()+"----\x3e"+num);\n            //通知别人\n            object.notifyall();\n        }\n    }\n    public void decrnum(){\n        synchronized(object){\n            if(num == 0){//等于0，则释放cpu\n                try {\n                    object.wait();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                    system.out.println("异常出错");\n                }\n            }\n            num--;\n            system.out.println(thread.currentthread().getname()+"----\x3e"+num);\n            //通知别人\n            object.notifyall();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n存在的问题：由于线程间的交互，线程有虚假唤醒操作，导致结果不一致；比如把线程换成四个就出现问题\n\n    public void incrnum(){\n        synchronized(object){\n            if(num!=0){//等于1，则释放cpu\n         \t\t//线程有可能走到这儿之后被中断，再回来时间，可能num已经++了，就可能导致问题\n                try {\n                    object.wait();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                    system.out.println("异常出错");\n                }\n            }\n            num++;\n            system.out.println(thread.currentthread().getname()+"----\x3e"+num);\n            //通知别人\n            object.notifyall();\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n正确代码：\n\npackage com.wcy.juc;\n\n/**\n * wait、notify实现生产者消费者模式:\n * 口诀：   判断/干活/通知\n *\n * 题目：现在两个线程，可以操作初始值为零的一个变量，\n * 实现一个线程对该变量加扪，一个线程对该变量减1，\n * 实现交替，来10轮，变量初始值为零。\n */\npublic class threadwaitnotifydemo {\n    public static void main(string[] args) {\n        num num=new num();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                num.incrnum();//加1\n            }\n        },"a").start();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                num.decrnum();//-1\n            }\n        },"b").start();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                num.incrnum();//加1\n            }\n        },"c").start();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                num.decrnum();//-1\n            }\n        },"d").start();\n    }\n}\nclass num{\n    private int num=0;\n    private object object=new object();\n\n    public void incrnum(){\n        synchronized(object){\n            while (num!=0){//等于1，则释放cpu\n                try {\n                    object.wait();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                    system.out.println("异常出错");\n                }\n            }\n            num++;\n            system.out.println(thread.currentthread().getname()+"----\x3e"+num);\n            //通知别人\n            object.notifyall();\n        }\n    }\n    public void decrnum(){\n        synchronized(object){\n            while (num == 0){//等于0，则释放cpu\n                try {\n                    object.wait();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                    system.out.println("异常出错");\n                }\n            }\n            num--;\n            system.out.println(thread.currentthread().getname()+"----\x3e"+num);\n            //通知别人\n            object.notifyall();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# 3.2.lock、condition的使用\n\n//新版写法\nclass num{\n    private int num=0;\n    private lock lock=new reentrantlock();\n    private condition condition=lock.newcondition();\n\n    public void incrnum(){\n        lock.lock();\n        try {\n            //判断\n            while (num != 0){\n                condition.await();\n            }\n            //干活\n            num++;\n            system.out.println(thread.currentthread().getname()+"-----\x3e>>"+num);\n            //通知\n            condition.signalall();\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void decrnum(){\n        lock.lock();\n        try {\n            //判断\n            while (num == 0){\n                condition.await();\n            }\n            //干活\n            num--;\n            system.out.println(thread.currentthread().getname()+"-----\x3e>>"+num);\n            //通知\n            condition.signalall();\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 四.lock、condition实现精准通知\n\n题目升级：abc三个线程，a打印五次，b打印10次，c打印15次,顺序为abc，打印10轮\n\n\n# 4.1.使用wait、notify实现\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.locks.condition;\nimport java.util.concurrent.locks.lock;\nimport java.util.concurrent.locks.reentrantlock;\n\n/**\n * 题目：\n * abc三个线程，a打印五次，b打印10次，c打印15次,顺序为abc   打印10轮\n * 口径\n * 1、线程操作资源类\n * 2、若有横向通知，判断--干活--通知\n * 3、线程交互中，必须要防止多线程的虚假唤醒，也即（判断只用while，不能用f）\n * 4、需要顺序则用标志位\n */\npublic class threadconditiondemo {\n    public static void main(string[] args) {\n        sysnum sysnum=new sysnum();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                sysnum.print5(1);\n            }\n        },"a").start();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                sysnum.print10(2);\n            }\n        },"b").start();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                sysnum.print15(3);\n            }\n        },"c").start();\n    }\n}\n\nclass sysnum{\n    private int number=1;\n    private object object=new object();\n\n    public void print5(int num) {\n        synchronized (object){\n            //判断\n            while (num != number){\n                try {\n                    object.wait();//不是a线程执行\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n            for (int i = 0; i < 5; i++) {\n                system.out.println(thread.currentthread().getname()+"-----\x3e>>"+i);\n            }\n            number=2;\n            object.notifyall();\n        }\n    }\n    public void print10(int num)  {\n        synchronized (object){\n            //判断\n            while (num != number){\n                try {\n                    object.wait();//不是b线程执行\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n            for (int i = 0; i < 10; i++) {\n                system.out.println(thread.currentthread().getname()+"-----\x3e>>"+i);\n            }\n            number=3;\n            object.notifyall();\n        }\n    }\n    public void print15(int num) {\n        synchronized (object){\n            //判断\n            while (num != number){\n                try {\n                    object.wait();//不是c线程执行\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n            for (int i = 0; i < 15; i++) {\n                system.out.println(thread.currentthread().getname()+"-----\x3e>>"+i);\n            }\n            number=1;\n            object.notifyall();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n优化\n\n上方是三个方法实现，可以用一个方法实现：\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.locks.condition;\nimport java.util.concurrent.locks.lock;\nimport java.util.concurrent.locks.reentrantlock;\n\n/**\n * 题目：\n * abc三个线程，a打印五次，b打印10次，c打印15次,顺序为abc   打印10轮\n * 口径\n * 1、线程操作资源类\n * 2、若有横向通知，判断--干活--通知\n * 3、线程交互中，必须要防止多线程的虚假唤醒，也即（判断只用while，不能用f）\n * 4、需要顺序则用标志位\n */\npublic class threadconditiondemo {\n    public static void main(string[] args) {\n        sysnum sysnum=new sysnum();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                sysnum.print(1);\n            }\n        },"a").start();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                sysnum.print(2);\n            }\n        },"b").start();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                sysnum.print(3);\n            }\n        },"c").start();\n    }\n}\n\nclass sysnum{\n    private int number=1;\n    private object object=new object();\n\n    public void print(int num){\n        synchronized (object){\n            //判断\n            while (num != number){\n                try {\n                    object.wait();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n            //干活\n            for (int i = 0; i < 5*num; i++) {\n                system.out.println(thread.currentthread().getname()+"-----\x3e>>"+i);\n            }\n            //通知\n            number=(number==3)?1:number+1;//为c的时候应改为a\n            object.notifyall();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 4.2.使用lock、condition实现\n\n> 定义：lock 、condition实现\n> \n> private lock lock=new reentrantlock(); private condition condition1=lock.newcondition(); private condition condition2=lock.newcondition(); private condition condition3=lock.newcondition();\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.locks.condition;\nimport java.util.concurrent.locks.lock;\nimport java.util.concurrent.locks.reentrantlock;\n\n/**\n * 题目：\n * abc三个线程，a打印五次，b打印10次，c打印15次,顺序为abc 打印10轮\n * 口径\n * 1、线程操作资源类\n * 2、若有横向通知，判断--干活--通知\n * 3、线程交互中，必须要防止多线程的虚假唤醒，也即（判断只用while，不能用f）\n * 4、需要顺序则用标志位\n */\npublic class threadconditiondemo {\n    public static void main(string[] args) {\n        printnum printnum=new printnum();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                printnum.print5();\n            }\n        },"a").start();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                printnum.print10();\n            }\n        },"b").start();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                printnum.print15();\n            }\n        },"c").start();\n    }\n}\n\nclass printnum{\n    private int number=1;//1:a  2:b  3:c\n    private lock lock=new reentrantlock();\n    private condition condition1=lock.newcondition();\n    private condition condition2=lock.newcondition();\n    private condition condition3=lock.newcondition();\n\n    public void print5(){\n        lock.lock();\n        try {\n            //判断\n            while (number != 1){\n                condition1.await();//a等待\n            }\n            //干活\n            for (int i = 0; i < 5; i++) {\n                system.out.println(thread.currentthread().getname()+"-----\x3e>>"+i);\n            }\n            //通知\n            number=2;//b开始干活\n            condition2.signal();//通知b\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void print10(){\n        lock.lock();\n        try {\n            //判断\n            while (number != 2){\n                condition2.await();//a等待\n            }\n            //干活\n            for (int i = 0; i < 10; i++) {\n                system.out.println(thread.currentthread().getname()+"-----\x3e>>"+i);\n            }\n            //通知\n            number=3;//b开始干活\n            condition3.signal();//通知b\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void print15(){\n        lock.lock();\n        try {\n            //判断\n            while (number != 3){\n                condition3.await();//a等待\n            }\n            //干活\n            for (int i = 0; i < 15; i++) {\n                system.out.println(thread.currentthread().getname()+"-----\x3e>>"+i);\n            }\n            //通知\n            number=1;//b开始干活\n            condition1.signal();//通知b\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n\n\n优化：\n\n上面使用了三个方法，其实这三个方法都是差不多的，所以改写成一个：\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.locks.condition;\nimport java.util.concurrent.locks.lock;\nimport java.util.concurrent.locks.reentrantlock;\n\n/**\n * 题目：\n * abc三个线程，a打印五次，b打印10次，c打印15次,顺序为abc   打印10轮\n * 口径\n * 1、线程操作资源类\n * 2、若有横向通知，判断--干活--通知\n * 3、线程交互中，必须要防止多线程的虚假唤醒，也即（判断只用while，不能用f）\n * 4、需要顺序则用标志位\n */\npublic class threadconditiondemo {\n    public static void main(string[] args) {\n        printnum printnum=new printnum();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                printnum.print(1);\n            }\n        },"a").start();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                printnum.print(2);\n            }\n        },"b").start();\n        new thread(()->{\n            for (int i = 0; i < 10; i++) {\n                printnum.print(3);\n            }\n        },"c").start();\n    }\n}\n\nclass printnum{\n    private int number=1;//1:a  2:b  3:c\n    private lock lock=new reentrantlock();\n    private condition condition1=lock.newcondition();\n    private condition condition2=lock.newcondition();\n    private condition condition3=lock.newcondition();\n    private condition[] conditions=new condition[]{condition1,condition2,condition3};\n\n    /**\n     *\n     * @param num 线程   1:a  2:b  3:c\n     */\n    public void print(int num){\n        lock.lock();\n        try {\n            //判断\n            while (number != num){\n                //当不是自己处理 则释放该cpu\n                conditions[num-1].await();//数组0开始\n            }\n            //干活\n            for (int i = 0; i < 5*num; i++) {\n                system.out.println(thread.currentthread().getname()+"----\x3e"+i);\n            }\n            //通知\n            number= (number==3)?1:number+1;//通知下一个\n            conditions[number-1].signal();//数组从0开始的 所以-1\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 五.8锁\n\n静态同步方法和同步方法锁的目标不一样，互不干扰，静态同步方法锁的是class、同步方法锁的是对象（实例）；\n\n> 题目:多线程8锁 1.标准访问，请问先打印邮件还是短信? 2.邮件方法暂停4秒钟，请问先打印邮件还是短信? 3.新增一个普通方法hello()，请问先打印邮件还是hello ? 4.两部手机，请问先打印邮件还是短信? 5.两个静态同步方法，同一部手机，请问先打印邮件还是短信? 6.两个静态同步方法，2部手机，请问先打印邮件还是短信? 7.1个普通同步方法,1个静态同步方法，1部手机，请问先打印邮件还是短信? 8.1个普通同步方法,1个静态同步方法，2部手机，请问先打印邮件还是短信?\n\n代码：\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.timeunit;\n\n/**\n * 线程8锁\n *\n * 1.标准访问，请问先打印邮件还是短信?\n * 2.邮件方法暂停4秒钟，请问先打印邮件还是短信?\n * 3.新增一个普通方法hello()，请问先打印邮件还是hello ?\n * 4.两部手机，请问先打印邮件还是短信?\n * 5.两个静态同步方法，同一部手机，请问先打印邮件还是短信?\n * 6.两个静态同步方法，2部手机，请问先打印邮件还是短信?\n * 7.1个普通同步方法,1个静态同步方法，1部手机，请问先打印邮件还是短信?\n * 8.1个普通同步方法,1个静态同步方法，2部手机，请问先打印邮件还是短信?\n */\npublic class thread8 {\n    public static void main(string[] args) throws exception {\n        phone phone=new phone();\n        phone phone1=new phone();\n        new thread(()->{\n            phone.sendemail();\n        },"a").start();\n\n        timeunit.milliseconds.sleep(1);//休眠1毫秒秒钟\n        new thread(()->{\n//      2      phone.sendmsg();\n//    3        phone.hello();\n//     4       phone1.sendmsg();\n//     5       phone.sendmsg();\n//      6      phone1.sendmsg();\n            phone.sendmsg();\n//            phone1.sendmsg();\n        },"b").start();\n    }\n}\nclass phone{\n    private static object object=new object();\n    public synchronized static void sendemail(){\n            try {\n                timeunit.seconds.sleep(1);//休眠4秒\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println("sendemail");\n    }\n    public synchronized void sendmsg(){\n            system.out.println("sendmsg");\n    }\n    public void hello(){\n        system.out.println("hello");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n题解：\n\n> 1.先打印邮件--标准访问\n> \n> 2.先打印邮件，sleep并不释放锁，同一个对象；\n> \n> 3.先打印hello，hello方法无锁，可以直接输出；\n> \n> 4.先打印短信，两个对象，两把锁，互不干扰，锁的对象；\n> \n> 5.先打印邮件，静态同步方法，锁的是class类，一把锁，邮件拿到锁不释放；\n> \n> 6.先打印邮件，静态同步方法，锁的是class类，一把锁，邮件拿到锁不释放；\n> \n> 7、8.先打印短信，锁对象不同\n\n\n\n\n# 六.list\n\n并发操作集合，常见异常java.util.concurrentmodificationexception\n\n\n\nlist集合并发使用：推荐使用copyonwritearraylist，juc下面的并发集合类\n\n>  * 1.new vector<>(); 不提倡，其实就是arraylist<>加了synchronized\n>  * 2.collections.synchronizedlist(new arraylist<>());\n>  * 3.new copyonwritearraylist<>();\n\npackage com.wcy.juc;\n\nimport java.util.list;\nimport java.util.uuid;\nimport java.util.concurrent.copyonwritearraylist;\n\n/**\n * list并发集合类demo\n * 并发问题：\n * new arraylist<>();不安全\n *\n * 解决办法：\n * 1.new vector<>();  不提倡，其实就是arraylist<>加了synchronized\n * 2.collections.synchronizedlist(new arraylist<>());\n * 3.new copyonwritearraylist<>();\n *\n */\npublic class threadlistdemo {\n    public static void main(string[] args) {\n//        list<string> list=new arraylist<>();\n//        list<string> list=new vector<>();\n//        list<string> list= collections.synchronizedlist(new arraylist<>());\n        list<string> list=new copyonwritearraylist<>();\n        for (int i = 0; i < 30; i++) {\n            new thread(()->{\n                list.add(uuid.randomuuid().tostring().substring(0,8));\n                system.out.println(list);\n            },string.valueof(i)).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 6.1.arraylist\n\n\n\n\n# 6.2.collections.synchronizedlist(new arraylist<>());\n\n底层通过synchonized实现的，遍历未加锁，写删加锁\n\n\n# 6.3.copyonwritearraylist\n\n\n\n> 写时复制 copyonwrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器object[]添加，而是先将当前容涨object[]进行icopy,复制出一个新的容器object[ ] newelements，然后新的容器object[ ] newelements里添加元素，添加完元素之后， 再将原容器的引用指向新的容器setarray(newelements);。这样做的好处是可以对欢copyonwrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以copyonerite容器也是一种读写分离的思想，读和写不同的容器。\n\n\n# 七.set\n\n\n# 7.1.hashset\n\n> hashset底层是hashmap：key是值，value是一个object常量\n\n\n\n\n# 7.2.collections.synchronizedset(new hashset<>());\n\n底层通过synchonized实现的，遍历未加锁，写删加锁\n\n\n# 7.3.copyonwritearrayset\n\n底层的add方法：首先获取原数组，调用indexof方法判断数组中是否已有，有则不添加，否则进入方法addifabsent\n\n\n\n走到了copyonwritearraylist的addifabsent\n\n\n\n\n# 八.map\n\n\n# 8.1.hashmap\n\n底层数组+链表+红黑树，长度为8链表变为红黑树，为6则红黑树变为链表；\n\n扩容机制为原来的两倍；\n\nhashmap的负载因子为0.75，可以修改，但是0.75使得hash冲突最小；\n\nhashmap的hash值通过高16位异或低16位，一旦有一位发送变化，hash值都会不同；\n\n\n# 8.2.hashtable\n\n其实就是hashmap每个方法加上了synchronized\n\n\n# 8.3.collections.synchronizedmap(new hashmap<string,string>());\n\n遍历未加锁，修改加锁\n\n\n# 8.4.new concurrenthashmap<>();\n\n\n# 九.callable\n\n\n# 9.1.callable和runable的区别：\n\n 1. 前者为call方法，后者为run方法\n 2. 前者有抛出异常，后者无\n 3. 前者有返回值，后者无\n\n\n\n\n# 9.2.使用callable\n\n> 1.get()方法会阻塞当前线程，所以get()方法一般放到最后\n> \n> 2.同一个futuretask任务，即使多个线程也只会执行一次，有缓存；类似于：老师上课，喊同学去买水，第一次可以，第二次再交这位同学去买水就过分了；\n> \n> futuretask futuretask=new futuretask(new mythread());\n> new thread(futuretask,"a").start();\n> new thread(futuretask,"b").start();\n> \n> \n> 1\n> 2\n> 3\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.callable;\nimport java.util.concurrent.executionexception;\nimport java.util.concurrent.futuretask;\n\n/**\n * 创建线程的第三种方式：\n * 实现callable接口\n */\npublic class callabledemo {\n    public static void main(string[] args) throws executionexception, interruptedexception {\n        /**\n         * 利用多态性=》由于new thread()的构造方法只支持传入runnable接口，\n         * 找到runnable的子接口futuretask\n         * futuretask的构造方法支持传入callable\n         */\n        futuretask futuretask=new futuretask(new mythread());\n        //启动线程\n        new thread(futuretask,"a").start();\n        new thread(futuretask,"b").start();\n        system.out.println(futuretask.get());//获取线程返回的数据  会阻塞当前线程\n    }\n}\n\nclass mythread implements callable{\n\n    @override\n    public object call() throws exception {\n        system.out.println("*****com进来了****");\n        return 1024;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 十.等待多个子线程完成了，主线程再后续执行\n\n\n# 1.countdownlatch(倒计时锁)\n\n> countdownlatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。\n> \n> 其它线程调用countdown方法会将计数器减1(调用countdown方法的线程不会阻塞)， 当计数器的值变为o时，因await方法阻塞的线程会被唤醒，继续执行\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.countdownlatch;\n\n/**\n * 线程等待：\n * 比如：等待6个子线程完成了，主线程再后续执行\n * 解决：countdownlatch：子线程完成一次调用一次countdownlatch.countdown()进行减一操作，最后通过await等待获取结果\n */\npublic class countdownlatchdemo {\n    public static void main(string[] args) throws interruptedexception {\n        countdownlatch countdownlatch=new countdownlatch(6);\n        for (int i = 1; i <= 6; i++) {\n            new thread(()->{\n                system.out.println(thread.currentthread().getname()+"同学离开");\n                countdownlatch.countdown();//子线程完成一次减一\n            },i+"").start();\n        }\n        countdownlatch.await();\n        system.out.println("主线程结束");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 2.cyclicbarrier（计数器）\n\n    public static void main(string[] args) throws interruptedexception {\n        cyclicbarrier barrier=new cyclicbarrier(7,()-> system.out.println("集起七颗龙珠"));\n        for (int i = 0; i < 7; i++) {\n            int index=i;\n            new thread(()->{\n                system.out.println("第"+index+"颗龙珠");\n                try {\n                    barrier.await();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                } catch (brokenbarrierexception e) {\n                    e.printstacktrace();\n                }\n            },""+i).start();\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 十一.semaphore信号量\n\n> 在信号量上我们定义两种操作:\n> \n>  * acquire(获取）当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1）， 要么一直等下去，直到有线程释放信号量，或超时。\n> \n>  * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程\n>    \n>    信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。\n\nsemaphore semaphore=new semaphore(1);其实就是synchronized，相当与锁\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.semaphore;\nimport java.util.concurrent.timeunit;\n\n/**\n * 多个线程访问多个资源\n * 假设：六个小车抢占三个停车位\n * semaphore 保证了资源只有三份，随便怎么抢\n */\npublic class semaphoredemo {\n    public static void main(string[] args) {\n        semaphore semaphore=new semaphore(3);//定义了三个资源\n        for (int i = 0; i < 6; i++) {\n            new thread(()->{\n                try {\n                    semaphore.acquire();//抢占资源\n                    system.out.println(thread.currentthread().getname()+"抢到了停车位");\n                    timeunit.seconds.sleep(1);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }finally {\n                    semaphore.release();//释放资源\n                    system.out.println(thread.currentthread().getname()+"离开了停车位");\n                }\n            },i+"").start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 十二.readwritelock(读写锁)\n\n 1. 读读不加锁\n 2. 读写枷锁\n 3. 写写加锁\n\n> 手写一个简单的缓存工具\n\npackage com.wcy.juc;\n\nimport java.util.hashmap;\nimport java.util.map;\nimport java.util.concurrent.locks.readwritelock;\nimport java.util.concurrent.locks.reentrantreadwritelock;\n\n/**\n * 读写锁\n *  * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。\n *  * 但是，如果有一个线程想去写共享资源来，就不应该再有其他线程可以对改资源进行读或写\n *  * 小总结：\n *  *      读-读能共存\n *  *      读-写不能共存\n *  *      写-写不能共存\n */\npublic class readwritelockdemo {\n    public static void main(string[] args) {\n        mycache mycache=new mycache();\n        for (int i = 0; i < 5; i++) {\n            final int item=i;\n            new thread(()->{\n                mycache.put(item+"",item);\n            },i+"").start();\n        }\n        for (int i = 0; i < 5; i++) {\n            final int item=i;\n            new thread(()->{\n                mycache.get(item+"");\n            },i+"").start();\n        }\n    }\n}\nclass mycache{\n    //volatile:，保证可见性，不保证原子性，一个线程修改后，通知更新\n    private volatile map<string,object> map=new hashmap<>();\n    private readwritelock lock=new reentrantreadwritelock();//读写锁\n\n    public void put(string key,object value){\n        lock.writelock().lock();//获取写锁\n        try {\n            system.out.println(thread.currentthread().getname()+"---写入数据准备");\n            map.put(key,value);\n            system.out.println(thread.currentthread().getname()+"---写入数据完成"+key);\n        }finally {\n            lock.writelock().unlock();//释放写锁\n        }\n    }\n\n    public void get(string key){\n        lock.readlock().lock();\n        try {\n            system.out.println(thread.currentthread().getname()+"---读取数据准备");\n            object o = map.get(key);\n            system.out.println(thread.currentthread().getname()+"---读取数据完成"+o);\n        }finally {\n            lock.readlock().unlock();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 十三.blokingqueue阻塞队列种类\n\n\n# 13.1.阻塞队列：\n\n> 当队列为空的时候，从队列中取出元素会阻塞队列；\n> \n> 当队列是满的时候，从队列添加元素会阻塞队列；\n\n\n# 13.2.阻塞队列的种类：\n\n\n\n\n# 13.3.阻塞队列的操作：\n\n方法类型        抛出异常        特殊值        阻塞       超时\n插入          add(e)      offer(e)   put(e)   offer(e.time,unit)\n移除          remore()    poll()     take()   poll(time,unilt)\n检查（获取头元素）   element()   peek()     不可用      不可用\n\n\n\n\n# 十四.了解java的值传递\n\n 1. 基本数据类型是拷贝一份过去\n\n 2. 引用类型，传递过去的一份，但是大家是公用这一份的。\n    \n    \n\n 3. 字符串注意有常量池不会改变；\n\npublic class testtransfervalue {\n    public void changevalue1(int age){\n        age = 30;\n    }\n    public void changevalue2(person person){\n        person.setpersonname("xxx");\n    }\n    public void changevalue3(string str){\n        str = "xxx";\n    }\n\n    public static void main(string[] args) {\n        testtransfervalue test = new testtransfervalue();\n        int age = 20;\n        test.changevalue1(age);\n        system.out.println("age----"+age);  //20\n\n        person person = new person("abc");\n        test.changevalue2(person);\n        system.out.println("personname-------"+person.getpersonname());  //xxx\n\n        string str = "abc";\n        test.changevalue3(str);\n        system.out.println("string-----"+str);  //abc\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 十五.线程池\n\n\n# 1.为什么使用多线程？\n\n\n\n\n# 2.线程池类图\n\n可以与list、lists、collections、collection来类比记忆。\n\n\n\n\n# 3.线程池工具类（阿里巴巴强制说明不准使用，需自己new）\n\n\n\n# 1.executors.newfixedthreadpool(5);\n\n长度固定的线程池\n\n    public static void main(string[] args) {\n        executorservice executorservice=null;\n        try {\n            executorservice = executors.newfixedthreadpool(5);\n            for (int i = 0; i < 10; i++) {\n                executorservice.execute(()->{\n                    system.out.println(thread.currentthread().getname()+"处理业务");\n                });\n            }\n        }finally {\n            executorservice.shutdown();//关闭线程池\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n        return new threadpoolexecutor(nthreads, nthreads,\n                                      0l, timeunit.milliseconds,\n                                      new linkedblockingqueue<runnable>());\n\n\n1\n2\n3\n\n\n# 2.executors.newsinglethreadexecutor();\n\n        return new finalizabledelegatedexecutorservice\n            (new threadpoolexecutor(1, 1,\n                                    0l, timeunit.milliseconds,\n                                    new linkedblockingqueue<runnable>()));\n\n\n1\n2\n3\n4\n\n\n一次只执行一个线程\n\n# 3.executors.newcachedthreadpool();\n\n        return new threadpoolexecutor(0, integer.max_value,\n                                      60l, timeunit.seconds,\n                                      new synchronousqueue<runnable>());\n\n\n1\n2\n3\n\n\n动态执行线程\n\n> 底层都是new threadpoolexecutro()实现的\n\n\n# 4.线程池七大参数\n\n源码：\n\n    public threadpoolexecutor(int corepoolsize,\n                              int maximumpoolsize,\n                              long keepalivetime,\n                              timeunit unit,\n                              blockingqueue<runnable> workqueue,\n                              threadfactory threadfactory,\n                              rejectedexecutionhandler handler) {\n        if (corepoolsize < 0 ||\n            maximumpoolsize <= 0 ||\n            maximumpoolsize < corepoolsize ||\n            keepalivetime < 0)\n            throw new illegalargumentexception();\n        if (workqueue == null || threadfactory == null || handler == null)\n            throw new nullpointerexception();\n        this.corepoolsize = corepoolsize;\n        this.maximumpoolsize = maximumpoolsize;\n        this.workqueue = workqueue;\n        this.keepalivetime = unit.tonanos(keepalivetime);\n        this.threadfactory = threadfactory;\n        this.handler = handler;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 1. corepoolsize：核心线程数（线程池中常驻的核心线程数）\n 2. maximumpoolsize：最大线程数，线程池中最大能容纳的线程数，当核心线程数、队列满了，开启线程\n 3. keepalivetime：时间长短\n 4. unit：时间单位，配合keepalivetime一起使用，用于回收核心线程数\n 5. workqueue：阻塞队列，当核心线程数满了，放到队列中\n 6. threadfactory：线程工厂（默认）\n 7. rejectedexecutorhandler：拒绝策略：当核心线程数、最大线程数、队列满了执行\n\n\n# 5.线程池的执行流程\n\n\n\n1、在创建了线程池后，开始等待请求。 2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断: 2.1如果正在运行的线程数量小于corepoolsize，那么马上创建线程运行这个任务; 2.2如果正在运行的线程数量大于或等于corepoolsize，那么将这个任务放入队列; 2.3如果这个时候队列满了且正在运行的线程数量还小于maximumpoolsize，那么还是要创建非核心线程立刻运行这个任务; 2.4如果队列满了且正在运行的线程数量大于或等于maximumpoolsize，那么线程池会启动饱和拒绝策略来执行。 3、当一个线程完成任务时，它会从队列中取下一个任务来执行。 4、当一个线程无事可做超过一定的时间（keepalivetime）时，线程会判断: 如果当前运行的线程数大于corepoolsize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到corepoolsize的大小。\n\n\n# 6.自定义线程池\n\n> 下面定义了核心线程数为2，最大线程数为5，队列长度为3的线程池，当线程数到9就会报：java.util.concurrent.rejectedexecutionexception异常\n\npublic static void main(string[] args) {\n        executorservice executorservice=null;\n        try {\n            executorservice=new threadpoolexecutor(\n                    2,\n                    5,\n                    2l,\n                    timeunit.minutes,\n                    new arrayblockingqueue<>(3),\n                    executors.defaultthreadfactory(),\n                    new threadpoolexecutor.abortpolicy());\n            for (int i = 0; i < 9; i++) {\n                executorservice.execute(()->{\n                    try {\n                        timeunit.seconds.sleep(1);\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                    system.out.println(thread.currentthread().getname()+"处理业务");\n                });\n            }\n        }finally {\n            executorservice.shutdown();//关闭线程池\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 7.拒绝策略\n\n# 1.jdk内置四种拒绝策略\n\n 1. abortpolicy（默认）：直接抛出rejectedexecutionexception异常阻止系统正常运行\n\n 2. callerrunspolicy：不会抛弃任务也不会抛出异常，而是把任务回退到调用者(若线程池是主线程创建，则主线程执行任务),从而降低新任务的流量。\n    \n    \n\n 3. discardoldestpolicy：抛弃队列中等待最久的任务，然后把当前任务加入到队列中尝试再次提交当前任务。\n\n 4. discardpolicy：直接抛弃异常，如果允许任务丢失，这是最好的一中策略；\n\n# 2.自定义拒绝策略\n\npackage com.wcy.juc;\n\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.atomicinteger;\n\n/**\n * 自定义线程访问策略\n */\npublic class mythreadpoolexecutor {\n    private executorservice service=null;\n\n    public executorservice init(){\n        if(service == null){\n            this.service=new threadpoolexecutor(\n                    2,\n                    3,\n                    2l,\n                    timeunit.minutes,\n                    new arrayblockingqueue<>(5),\n                    new mythreadpoolexecutor.mythreadfactory(), //自定义线程工厂\n                    new mythreadpoolexecutor.mypolicy() //自定义的拒绝策略\n            );\n        }\n        return service;\n    }\n\n    public void destory(){\n        if(this.service != null){\n            this.service.shutdown();//关闭线程池\n        }\n    }\n\n    /**\n     * 自定义线程工厂\n     */\n    class mythreadfactory implements threadfactory{\n        private atomicinteger account=new atomicinteger(0);\n\n        @override\n        public thread newthread(runnable r) {\n            thread t = new thread(r);\n            string threadname = mythreadpoolexecutor.class.getsimplename() + account.addandget(1);\n            //system.out.println(threadname);\n            t.setname(threadname);\n            return t;\n        }\n    }\n\n    /**\n     * 自定义拒绝策略\n     */\n    class mypolicy implements rejectedexecutionhandler{\n\n        //当前任务执行到改地方 应该做什么\n        @override\n        public void rejectedexecution(runnable r, threadpoolexecutor executor) {\n            try {\n                // 核心改造点，由blockingqueue的offer改成put阻塞方法\n                system.out.println("*****执行线程池拒绝策略*******");\n                executor.getqueue().put(r);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n\n    public static void main(string[] args) {\n        mythreadpoolexecutor myexecutor = new mythreadpoolexecutor();\n        executorservice executor=myexecutor.init();//获取自定义拒绝策略的线程池\n        try {\n            for (int i = 0; i < 10; i++) {\n                executor.execute(()->{\n                    system.out.println(thread.currentthread().getname()+"执行了");\n                });\n            }\n        }finally {\n            myexecutor.destory();//调用关闭线程池\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n\n\n# 8.最大线程的值如何确认？\n\n> 根据cpu密集型和 io密集型的任务确认：\n> \n>  1. cpu密集型的任务，最大线程数<=cpu的可用核心数。\n>  2. io密集型的任务，最大线程数和cpu核心数没有很强的联系，根据任务量的大小和服务器的性能来设定一个值。如果平均io任务量是100个，那么最大线程数可以设置为120，如果平均io任务量非常大的话，那么，建议调整软件架构，采用分布式来处理吧，瓶颈已经不是什么线程池了。',charsets:{cjk:!0},lastUpdated:"2021/09/22, 16:16:17"},{title:"java主线程等待所有子线程执行完毕再执行",frontmatter:{title:"java主线程等待所有子线程执行完毕再执行",date:"2021-07-21T18:24:48.000Z",permalink:"/pages/c67291/",categories:["后端","JUC"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.JUC/10.java%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E6%89%80%E6%9C%89%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%86%8D%E6%89%A7%E8%A1%8C.html",relativePath:"01.后端/01.JUC/10.java主线程等待所有子线程执行完毕再执行.md",key:"v-44acf49a",path:"/pages/c67291/",headers:[{level:2,title:"1.使用sleep实现",slug:"_1-使用sleep实现",normalizedTitle:"1.使用sleep实现",charIndex:161},{level:2,title:"2.使用Thread的join()方法",slug:"_2-使用thread的join-方法",normalizedTitle:"2.使用thread的join()方法",charIndex:802},{level:2,title:"3.等待多线程完成的CountDownLatch",slug:"_3-等待多线程完成的countdownlatch",normalizedTitle:"3.等待多线程完成的countdownlatch",charIndex:1702},{level:2,title:"4.同步屏障CyclicBarrier",slug:"_4-同步屏障cyclicbarrier",normalizedTitle:"4.同步屏障cyclicbarrier",charIndex:2555},{level:2,title:"5.用java线程池",slug:"_5-用java线程池",normalizedTitle:"5.用java线程池",charIndex:3526}],headersStr:"1.使用sleep实现 2.使用Thread的join()方法 3.等待多线程完成的CountDownLatch 4.同步屏障CyclicBarrier 5.用java线程池",content:'# java主线程等待所有子线程执行完毕再执行\n\n> java主线程等待所有子线程执行完毕在执行，这个需求其实我们在工作中经常会用到，比如用户下单一个产品，后台会做一系列的处理，为了提高效率，每个处理都可以用一个线程来执行，所有处理完成了之后才会返回给用户下单成功，下面就说一下我能想到的方法，欢迎大家批评指正：\n\n\n# 1.使用sleep实现\n\n让主线程睡眠一段时间，当然这个睡眠时间是主观的时间，是我们自己定的，这个方法不推荐，但是在这里还是写一下，毕竟是解决方法。\n\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 10; i++) {\n            new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+"完成了");\n                try {\n                    TimeUnit.SECONDS.sleep(1);//休眠五秒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            },i+"").start();\n        }\n        TimeUnit.SECONDS.sleep(5);//休眠五秒\n        System.out.println("主线程完成");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.使用Thread的join()方法\n\n使用Thread的join()等待所有的子线程执行完毕，主线程在执行，thread.join()把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。\n\n    public static void main(String[] args) throws InterruptedException {\n        List<Thread> threads=new CopyOnWriteArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            Thread thread=new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+"完成了");\n                try {\n                    TimeUnit.SECONDS.sleep(1);//休眠五秒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            },i+"");\n            threads.add(thread);//加入到容器中\n            thread.start();\n        }\n        for (Thread thread:threads) {\n            thread.join();\n        }\n        System.out.println("主线程完成");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3.等待多线程完成的CountDownLatch\n\n在这里说明一点，countDownLatch不可能重新初始化或者修改CountDownLatch对象内部计数器的值，一个线程调用countdown方法happen-before另外一个线程调用await方法\n\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch countDownLatch=new CountDownLatch(10);//定义一个计数器\n        for (int i = 0; i < 10; i++) {\n            Thread thread=new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+"完成了");\n                try {\n                    TimeUnit.SECONDS.sleep(1);//休眠五秒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                countDownLatch.countDown();//完成一次减一\n            },i+"");\n            thread.start();\n        }\n        countDownLatch.await();\n        System.out.println("主线程完成");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 4.同步屏障CyclicBarrier\n\n    public static void main(String[] args) throws InterruptedException, BrokenBarrierException {\n        CyclicBarrier barrier=new CyclicBarrier(10);\n        for (int i = 0; i < 10; i++) {\n            Thread thread=new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+"完成了");\n                try {\n                    TimeUnit.SECONDS.sleep(1);//休眠五秒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                try {\n                    barrier.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            },i+"");\n            thread.start();\n        }\n        barrier.await();\n        System.out.println("主线程完成");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 5.用java线程池\n\n    public static void main(String[] args) throws InterruptedException, BrokenBarrierException {\n        ExecutorService executorService=Executors.newFixedThreadPool(2);\n        for (int i = 0; i < 10; i++) {\n            executorService.submit(()->{//提交任务\n                System.out.println(Thread.currentThread().getName()+"完成了");\n                try {\n                    TimeUnit.SECONDS.sleep(1);//休眠五秒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            },i+"");\n        }\n        executorService.shutdown();\n        //等待所有子线程执行完毕\n        while (true){\n            if(executorService.isTerminated()){\n                System.out.println("主线程完成");\n                break;\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# countDownLatch和cyclicBarrier区别：\n\n> countDownLatch只能使用一次，而CyclicBarrier方法可以使用reset()方法重置，所以CyclicBarrier方法可以能处理更为复杂的业务场景。\n\n我曾经在网上看到一个关于countDownLatch和cyclicBarrier的形象比喻，就是在百米赛跑的比赛中若使用 countDownLatch的话冲过终点线一个人就给评委发送一个人的成绩，10个人比赛发送10次，如果用CyclicBarrier，则只在最后一个人冲过终点线的时候发送所有人的数据，仅仅发送一次，这就是区别。',normalizedContent:'# java主线程等待所有子线程执行完毕再执行\n\n> java主线程等待所有子线程执行完毕在执行，这个需求其实我们在工作中经常会用到，比如用户下单一个产品，后台会做一系列的处理，为了提高效率，每个处理都可以用一个线程来执行，所有处理完成了之后才会返回给用户下单成功，下面就说一下我能想到的方法，欢迎大家批评指正：\n\n\n# 1.使用sleep实现\n\n让主线程睡眠一段时间，当然这个睡眠时间是主观的时间，是我们自己定的，这个方法不推荐，但是在这里还是写一下，毕竟是解决方法。\n\n    public static void main(string[] args) throws interruptedexception {\n        for (int i = 0; i < 10; i++) {\n            new thread(()->{\n                system.out.println(thread.currentthread().getname()+"完成了");\n                try {\n                    timeunit.seconds.sleep(1);//休眠五秒\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            },i+"").start();\n        }\n        timeunit.seconds.sleep(5);//休眠五秒\n        system.out.println("主线程完成");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.使用thread的join()方法\n\n使用thread的join()等待所有的子线程执行完毕，主线程在执行，thread.join()把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程b中调用了线程a的join()方法，直到线程a执行完毕后，才会继续执行线程b。\n\n    public static void main(string[] args) throws interruptedexception {\n        list<thread> threads=new copyonwritearraylist<>();\n        for (int i = 0; i < 10; i++) {\n            thread thread=new thread(()->{\n                system.out.println(thread.currentthread().getname()+"完成了");\n                try {\n                    timeunit.seconds.sleep(1);//休眠五秒\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            },i+"");\n            threads.add(thread);//加入到容器中\n            thread.start();\n        }\n        for (thread thread:threads) {\n            thread.join();\n        }\n        system.out.println("主线程完成");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3.等待多线程完成的countdownlatch\n\n在这里说明一点，countdownlatch不可能重新初始化或者修改countdownlatch对象内部计数器的值，一个线程调用countdown方法happen-before另外一个线程调用await方法\n\n    public static void main(string[] args) throws interruptedexception {\n        countdownlatch countdownlatch=new countdownlatch(10);//定义一个计数器\n        for (int i = 0; i < 10; i++) {\n            thread thread=new thread(()->{\n                system.out.println(thread.currentthread().getname()+"完成了");\n                try {\n                    timeunit.seconds.sleep(1);//休眠五秒\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n                countdownlatch.countdown();//完成一次减一\n            },i+"");\n            thread.start();\n        }\n        countdownlatch.await();\n        system.out.println("主线程完成");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 4.同步屏障cyclicbarrier\n\n    public static void main(string[] args) throws interruptedexception, brokenbarrierexception {\n        cyclicbarrier barrier=new cyclicbarrier(10);\n        for (int i = 0; i < 10; i++) {\n            thread thread=new thread(()->{\n                system.out.println(thread.currentthread().getname()+"完成了");\n                try {\n                    timeunit.seconds.sleep(1);//休眠五秒\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n                try {\n                    barrier.await();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                } catch (brokenbarrierexception e) {\n                    e.printstacktrace();\n                }\n            },i+"");\n            thread.start();\n        }\n        barrier.await();\n        system.out.println("主线程完成");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 5.用java线程池\n\n    public static void main(string[] args) throws interruptedexception, brokenbarrierexception {\n        executorservice executorservice=executors.newfixedthreadpool(2);\n        for (int i = 0; i < 10; i++) {\n            executorservice.submit(()->{//提交任务\n                system.out.println(thread.currentthread().getname()+"完成了");\n                try {\n                    timeunit.seconds.sleep(1);//休眠五秒\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            },i+"");\n        }\n        executorservice.shutdown();\n        //等待所有子线程执行完毕\n        while (true){\n            if(executorservice.isterminated()){\n                system.out.println("主线程完成");\n                break;\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# countdownlatch和cyclicbarrier区别：\n\n> countdownlatch只能使用一次，而cyclicbarrier方法可以使用reset()方法重置，所以cyclicbarrier方法可以能处理更为复杂的业务场景。\n\n我曾经在网上看到一个关于countdownlatch和cyclicbarrier的形象比喻，就是在百米赛跑的比赛中若使用 countdownlatch的话冲过终点线一个人就给评委发送一个人的成绩，10个人比赛发送10次，如果用cyclicbarrier，则只在最后一个人冲过终点线的时候发送所有人的数据，仅仅发送一次，这就是区别。',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"java并发编程之美（笔记）",frontmatter:{title:"java并发编程之美（笔记）",date:"2021-07-12T20:30:37.000Z",permalink:"/pages/dea0da/",categories:["后端","JUC"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.JUC/01.java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89.html",relativePath:"01.后端/01.JUC/01.java并发编程之美（笔记）.md",key:"v-67eee40d",path:"/pages/dea0da/",headers:[{level:2,title:"一.并发编程基础",slug:"一-并发编程基础",normalizedTitle:"一.并发编程基础",charIndex:17},{level:3,title:"1.1.什么是线程",slug:"_1-1-什么是线程",normalizedTitle:"1.1.什么是线程",charIndex:30},{level:3,title:"1.2.线程的创建方式",slug:"_1-2-线程的创建方式",normalizedTitle:"1.2.线程的创建方式",charIndex:545},{level:3,title:"1.7.线程中断",slug:"_1-7-线程中断",normalizedTitle:"1.7.线程中断",charIndex:825}],headersStr:"一.并发编程基础 1.1.什么是线程 1.2.线程的创建方式 1.7.线程中断",content:'# java并发编程之美\n\n\n# 一.并发编程基础\n\n\n# 1.1.什么是线程\n\n> 线程是CPU执行的最小单位，线程与线程之间互不干扰\n\n一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈区域。\n\n程序计数器，等下次轮到 己的时候再执行 那么如何知道之前程序执行到哪 了呢？另外需要注意的是，如果执行的是native方法，那么pc计数器记录的是undefined地址，只有执行的是Java代码时pc计数器记录的才是下一条指令的地址。\n\n那么为什么pc计数器记录的是undefined地址：\n\n> native方法就由原生平台直接执行，并不需要理会抽象的JVM层面上的“pc寄存器”概念——原生的CPU上真正的PC寄存器是怎样就是怎样。就像一个用C或C++写的多线程程序，它在线程切换的时候是怎样的，Java的native方法也就是怎样的。\n> \n> 其实这里有个误区，程序计数器保存的是下一条指令的地址，所以程序计数器为空其实表示的是下一条指令是native方法（这时候还没真正执行native方法），调用执行native方法后，会在程序计数器中保存下一条指令地址，所以并不用担心java线程执行完native方法后不知道下一条指令是啥。\n\n\n# 1.2.线程的创建方式\n\n 1. 继承Thread类\n 2. 实现Runbale接口\n 3. 实现callable接口\n 4. 通过线程池获取\n\n> 使用继承方式的好处是方便传参，你可以在子类里面添加成员变 ，通过 set 方法设置参数或者通过构造函数进行传递，而如果使用 Runnable 方式，则只能使用主线 程里面被声明为 final 变量。不好的地方是 Java 支持多继承，如果继承了 Thread 类， 那么子类不能再继承其他 ，而 Runable 则没有这个限制 。前两种方式都没办法拿到任务 的返回结果，但是 callable方式可以\n\n\n# 1.7.线程中断\n\nJava 中的线程中断是 种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行 而是被中断的线程根据中断状态自行处理。\n\n * void interrupt()方法:中断线程，例如，当线程A运行时，线程B可以调用线程A的 interrupt()方法来设置线程A的中断标志为true并立即返回。设置标志仅仅是设置标志，线程A实际并没有被中断，它会继续往下执行。如果线程A因为调用了wait系列函数、join方法或者sleep方法而被阻塞挂起，这时候若线程B调用线程A的interrupt()方法，线程A会在调用这些方法的地方抛出InterruptedException异常而返回。\n * boolean isInterrupted()方法:检测当前线程是否被中断，如果是返回true，否则返回false。\n * boolean interrupted()方法:检测当前线程是否被中断，如果是返回true，否则返回false。与isInterrupted不同的是，该方法如果发现当前线程被中断，则会清除中断标志，并且该方法是static方法，可以通过Thread类直接调用。另外从下面的代码可以知道，在 interrupted()内部是获取当前调用线程的中断标志而不是调用interrupted()方法的实例对象的中断标志。\n\n> isInterrupted()、interrupted（）的区别：\n> \n> isInterrupted()：谁调用了它则判断谁知否被中断\n> \n> interrupted（）：判断当前线程是否被中断\n\n        public static void main(String[] args) throws InterruptedExceptio口｛\n        Thread threadOne = new Thread (new Runnable () {\n            public void run() {\n                for( ; ; ) {  } \n            }\n        }\n\t\t\t\t／／ 启动线程\n                threadOne .start() ; \n\t\t\t\t／／ 标志\n                threadOne . interrupt () ; \n\t\t\t\t／／获取中断\n                System.out.println("sinterrupted :" + threadOne.isinterrupted()) ; \n\t\t\t\t／／ 标志并重置\n               \tSystem.out.println("is Interrupted : ” + threadOne.interrupted()) ; \n\t\t\t\t／／获取 断标 并重直\n                System.out.println("is I nterrupted : ” + Thread.interrupted( ) ) ; \n\t\t\t\t／／获取中断标志\n                System.out.println(" errupted" ＋ threadOne.isinterrupted () ) ;\n                threadOne. join () ;\n               System.out.println("  main thread  is over”);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 结果：\n> \n> true：判断调用的线程是否中断\n> \n> false：判断当前线程是否中断\n> \n> false：判断当前线程是否中断\n> \n> true：判断调用的线程是否中断',normalizedContent:'# java并发编程之美\n\n\n# 一.并发编程基础\n\n\n# 1.1.什么是线程\n\n> 线程是cpu执行的最小单位，线程与线程之间互不干扰\n\n一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈区域。\n\n程序计数器，等下次轮到 己的时候再执行 那么如何知道之前程序执行到哪 了呢？另外需要注意的是，如果执行的是native方法，那么pc计数器记录的是undefined地址，只有执行的是java代码时pc计数器记录的才是下一条指令的地址。\n\n那么为什么pc计数器记录的是undefined地址：\n\n> native方法就由原生平台直接执行，并不需要理会抽象的jvm层面上的“pc寄存器”概念——原生的cpu上真正的pc寄存器是怎样就是怎样。就像一个用c或c++写的多线程程序，它在线程切换的时候是怎样的，java的native方法也就是怎样的。\n> \n> 其实这里有个误区，程序计数器保存的是下一条指令的地址，所以程序计数器为空其实表示的是下一条指令是native方法（这时候还没真正执行native方法），调用执行native方法后，会在程序计数器中保存下一条指令地址，所以并不用担心java线程执行完native方法后不知道下一条指令是啥。\n\n\n# 1.2.线程的创建方式\n\n 1. 继承thread类\n 2. 实现runbale接口\n 3. 实现callable接口\n 4. 通过线程池获取\n\n> 使用继承方式的好处是方便传参，你可以在子类里面添加成员变 ，通过 set 方法设置参数或者通过构造函数进行传递，而如果使用 runnable 方式，则只能使用主线 程里面被声明为 final 变量。不好的地方是 java 支持多继承，如果继承了 thread 类， 那么子类不能再继承其他 ，而 runable 则没有这个限制 。前两种方式都没办法拿到任务 的返回结果，但是 callable方式可以\n\n\n# 1.7.线程中断\n\njava 中的线程中断是 种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行 而是被中断的线程根据中断状态自行处理。\n\n * void interrupt()方法:中断线程，例如，当线程a运行时，线程b可以调用线程a的 interrupt()方法来设置线程a的中断标志为true并立即返回。设置标志仅仅是设置标志，线程a实际并没有被中断，它会继续往下执行。如果线程a因为调用了wait系列函数、join方法或者sleep方法而被阻塞挂起，这时候若线程b调用线程a的interrupt()方法，线程a会在调用这些方法的地方抛出interruptedexception异常而返回。\n * boolean isinterrupted()方法:检测当前线程是否被中断，如果是返回true，否则返回false。\n * boolean interrupted()方法:检测当前线程是否被中断，如果是返回true，否则返回false。与isinterrupted不同的是，该方法如果发现当前线程被中断，则会清除中断标志，并且该方法是static方法，可以通过thread类直接调用。另外从下面的代码可以知道，在 interrupted()内部是获取当前调用线程的中断标志而不是调用interrupted()方法的实例对象的中断标志。\n\n> isinterrupted()、interrupted（）的区别：\n> \n> isinterrupted()：谁调用了它则判断谁知否被中断\n> \n> interrupted（）：判断当前线程是否被中断\n\n        public static void main(string[] args) throws interruptedexceptio口｛\n        thread threadone = new thread (new runnable () {\n            public void run() {\n                for( ; ; ) {  } \n            }\n        }\n\t\t\t\t／／ 启动线程\n                threadone .start() ; \n\t\t\t\t／／ 标志\n                threadone . interrupt () ; \n\t\t\t\t／／获取中断\n                system.out.println("sinterrupted :" + threadone.isinterrupted()) ; \n\t\t\t\t／／ 标志并重置\n               \tsystem.out.println("is interrupted : ” + threadone.interrupted()) ; \n\t\t\t\t／／获取 断标 并重直\n                system.out.println("is i nterrupted : ” + thread.interrupted( ) ) ; \n\t\t\t\t／／获取中断标志\n                system.out.println(" errupted" ＋ threadone.isinterrupted () ) ;\n                threadone. join () ;\n               system.out.println("  main thread  is over”);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 结果：\n> \n> true：判断调用的线程是否中断\n> \n> false：判断当前线程是否中断\n> \n> false：判断当前线程是否中断\n> \n> true：判断调用的线程是否中断',charsets:{cjk:!0},lastUpdated:"2021/09/22, 16:16:17"},{title:"过滤器、拦截器、AOP切面",frontmatter:{title:"过滤器、拦截器、AOP切面",date:"2021-07-08T19:09:58.000Z",permalink:"/pages/486416/",categories:["Spring全家桶","Spring"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/00.Spring/00.%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81AOP%E5%88%87%E9%9D%A2.html",relativePath:"01.后端/10.Spring全家桶/00.Spring/00.过滤器、拦截器、AOP切面.md",key:"v-51f48c41",path:"/pages/486416/",headers:[{level:2,title:"一.过滤器",slug:"一-过滤器",normalizedTitle:"一.过滤器",charIndex:336},{level:2,title:"二.拦截器",slug:"二-拦截器",normalizedTitle:"二.拦截器",charIndex:1163},{level:2,title:"三.Aspect切片",slug:"三-aspect切片",normalizedTitle:"三.aspect切片",charIndex:2145}],headersStr:"一.过滤器 二.拦截器 三.Aspect切片",content:"# 过滤器、拦截器、AOP切面\n\n参考：https://www.toutiao.com/i6727212676704895499/?tt_from=mobile_qq&utm_campaign=client_share&timestamp=1611029453&app=news_article&utm_source=mobile_qq&utm_medium=toutiao_android&use_new_style=1&req_id=202101191210520101350542043D9F1870&share_token=e94ddfbf-59c0-4ae2-9c28-1b7c26964552&group_id=6727212676704895499\n\n\n# 一.过滤器\n\n过滤器可以拦截到方法的请求和响应(ServletRequest request, ServletResponse response),并对请求响应做出过滤操作。\n\n> 过滤器依赖于servlet容器。在实现上，基于函数回调，它可以对几乎所有请求进行过滤，一个过滤器实例只能在容器初始化时调用一次。\n\n使用过滤器的目的是用来做一些过滤操作，获取我们想要获取的数据，比如：在过滤器中修改字符编码；在过滤器中修改HttpServletRequest的一些参数，包括：过滤低俗文字、危险字符等。\n\n\n\nFilter随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。\n\n> 1.启动服务器时加载过滤器的实例，并调用init()方法来初始化实例；\n> \n> 2.每一次请求时都只调用方法doFilter()进行处理；\n> \n> 3.停止服务器时调用destroy()方法，销毁实例。\n\n我们再来看看doFilter方法\n\n> doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\n从参数我们看到，filter里面是能够获取到请求的参数和响应的数据；但此方法是无法知道是哪一个Controller类中的哪个方法被执行。\n\n还有一点需要注意的是，filter中是没法使用注入的bean的，也就是无法使用@Autowired\n\n\n\n上面代码注入的值为null。这是为什么呢？\n\n> 其实Spring中，web应用启动的顺序是：listener->filter->servlet，先初始化listener，然后再来就filter的初始化，再接着才到我们的dispathServlet的初始化，因此，当我们需要在filter里注入一个注解的bean时，就会注入失败，**因为filter初始化时，注解的bean还没初始化，没法注入。\n\n\n# 二.拦截器\n\n依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在一个方法前，调用一个方法，或者在方法后，调用一个方法。\n\n\n\n在WebMvcConfigurationSupport配置一下\n\n\n\n执行结果\n\n\n\n我们发现拦截器中可以获取到Controller对象\n\npreHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\n\n1\n\n\nobject handler就是controller方法对象\n\nHandlerMethod handlerMethod = (HandlerMethod)handler;\nhandlerMethod.getBean().getClass().getName(); //获取类名\nhandlerMethod.getMethod().getName(); //获取方法名\n\n\n1\n2\n3\n\n\n但我们发现获取不到方法的参数值，这个是为什么呢？在DispatcherServlet类中，方法\n\ndoDispatch(HttpServletRequest request, HttpServletResponse response)\n\n\n\napplyPreHandle这个方法执行，就是执行的拦截器的preHandler方法，但这个过程中，controller方法没有从request中获取请求参数，组装方法参数；而是在ha.handle这个方法的时候，才会组装参数\n\n> 虽然没法得到方法的参数，但是可以获得IOC的bean哦。\n\n再说明一点的是postHandler方法\n\n> postHandler方法的执行，当controller内部有异常，posthandler方法是不会执行的。\n\nafterCompletion方法，不管controller内部是否有异常，都会执行此方法；此方法还会有个Exception ex这个参数；如果有异常，ex会有异常值；没有异常 此值为null\n\n> 注意点如果controller内部有异常，但异常被@ControllerAdvice 异常统一捕获的话，ex也会为null\n\n\n# 三.Aspect切片\n\nAOP操作可以对操作进行横向的拦截,最大的优势在于他可以获取执行方法的参数,对方法进行统一的处理。常见使用日志,事务,请求参数安全验证等\n\n\n\n上面的代码中，我们是可以获取方法的参数的\n\n\n\n虽然切面aop可以拿到方法参数，但拿不到response，request对象。\n\n\n# 总结\n\n我们这里来总结一下过滤器、拦截器、Aspect，看看区别\n\n\n\n如果三者方式同时采用，那他们的执行顺序是什么呢？\n\n> filter -> interceptor -> ControllerAdvice -> aspect -> controller\n\n返回值顺序，或异常返回顺序\n\n> controller -> aspect -> controllerAdvice -> Interceptor -> Filter\n\n\n\n用一个图描述一下执行顺序\n\n",normalizedContent:"# 过滤器、拦截器、aop切面\n\n参考：https://www.toutiao.com/i6727212676704895499/?tt_from=mobile_qq&utm_campaign=client_share&timestamp=1611029453&app=news_article&utm_source=mobile_qq&utm_medium=toutiao_android&use_new_style=1&req_id=202101191210520101350542043d9f1870&share_token=e94ddfbf-59c0-4ae2-9c28-1b7c26964552&group_id=6727212676704895499\n\n\n# 一.过滤器\n\n过滤器可以拦截到方法的请求和响应(servletrequest request, servletresponse response),并对请求响应做出过滤操作。\n\n> 过滤器依赖于servlet容器。在实现上，基于函数回调，它可以对几乎所有请求进行过滤，一个过滤器实例只能在容器初始化时调用一次。\n\n使用过滤器的目的是用来做一些过滤操作，获取我们想要获取的数据，比如：在过滤器中修改字符编码；在过滤器中修改httpservletrequest的一些参数，包括：过滤低俗文字、危险字符等。\n\n\n\nfilter随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。\n\n> 1.启动服务器时加载过滤器的实例，并调用init()方法来初始化实例；\n> \n> 2.每一次请求时都只调用方法dofilter()进行处理；\n> \n> 3.停止服务器时调用destroy()方法，销毁实例。\n\n我们再来看看dofilter方法\n\n> dofilter(servletrequest request, servletresponse response, filterchain chain)\n\n从参数我们看到，filter里面是能够获取到请求的参数和响应的数据；但此方法是无法知道是哪一个controller类中的哪个方法被执行。\n\n还有一点需要注意的是，filter中是没法使用注入的bean的，也就是无法使用@autowired\n\n\n\n上面代码注入的值为null。这是为什么呢？\n\n> 其实spring中，web应用启动的顺序是：listener->filter->servlet，先初始化listener，然后再来就filter的初始化，再接着才到我们的dispathservlet的初始化，因此，当我们需要在filter里注入一个注解的bean时，就会注入失败，**因为filter初始化时，注解的bean还没初始化，没法注入。\n\n\n# 二.拦截器\n\n依赖于web框架，在springmvc中就是依赖于springmvc框架。在实现上,基于java的反射机制，属于面向切面编程（aop）的一种运用，就是在一个方法前，调用一个方法，或者在方法后，调用一个方法。\n\n\n\n在webmvcconfigurationsupport配置一下\n\n\n\n执行结果\n\n\n\n我们发现拦截器中可以获取到controller对象\n\nprehandle(httpservletrequest request, httpservletresponse response, object handler)\n\n\n1\n\n\nobject handler就是controller方法对象\n\nhandlermethod handlermethod = (handlermethod)handler;\nhandlermethod.getbean().getclass().getname(); //获取类名\nhandlermethod.getmethod().getname(); //获取方法名\n\n\n1\n2\n3\n\n\n但我们发现获取不到方法的参数值，这个是为什么呢？在dispatcherservlet类中，方法\n\ndodispatch(httpservletrequest request, httpservletresponse response)\n\n\n\napplyprehandle这个方法执行，就是执行的拦截器的prehandler方法，但这个过程中，controller方法没有从request中获取请求参数，组装方法参数；而是在ha.handle这个方法的时候，才会组装参数\n\n> 虽然没法得到方法的参数，但是可以获得ioc的bean哦。\n\n再说明一点的是posthandler方法\n\n> posthandler方法的执行，当controller内部有异常，posthandler方法是不会执行的。\n\naftercompletion方法，不管controller内部是否有异常，都会执行此方法；此方法还会有个exception ex这个参数；如果有异常，ex会有异常值；没有异常 此值为null\n\n> 注意点如果controller内部有异常，但异常被@controlleradvice 异常统一捕获的话，ex也会为null\n\n\n# 三.aspect切片\n\naop操作可以对操作进行横向的拦截,最大的优势在于他可以获取执行方法的参数,对方法进行统一的处理。常见使用日志,事务,请求参数安全验证等\n\n\n\n上面的代码中，我们是可以获取方法的参数的\n\n\n\n虽然切面aop可以拿到方法参数，但拿不到response，request对象。\n\n\n# 总结\n\n我们这里来总结一下过滤器、拦截器、aspect，看看区别\n\n\n\n如果三者方式同时采用，那他们的执行顺序是什么呢？\n\n> filter -> interceptor -> controlleradvice -> aspect -> controller\n\n返回值顺序，或异常返回顺序\n\n> controller -> aspect -> controlleradvice -> interceptor -> filter\n\n\n\n用一个图描述一下执行顺序\n\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"Spring",frontmatter:{title:"Spring",date:"2021-07-19T10:29:37.000Z",permalink:"/pages/9f1398/",categories:["后端","Spring全家桶","Spring"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/00.Spring/10.Spring.html",relativePath:"01.后端/10.Spring全家桶/00.Spring/10.Spring.md",key:"v-95754022",path:"/pages/9f1398/",headers:[{level:2,title:"1.IOC底层原理",slug:"_1-ioc底层原理",normalizedTitle:"1.ioc底层原理",charIndex:15},{level:3,title:"1.1.以前对象中使用另一个对象的方式",slug:"_1-1-以前对象中使用另一个对象的方式",normalizedTitle:"1.1.以前对象中使用另一个对象的方式",charIndex:56},{level:3,title:"1.2.升级版（工厂模式）",slug:"_1-2-升级版-工厂模式",normalizedTitle:"1.2.升级版（工厂模式）",charIndex:82},{level:3,title:"1.3.IOC中调用对象",slug:"_1-3-ioc中调用对象",normalizedTitle:"1.3.ioc中调用对象",charIndex:102},{level:2,title:"2.IOC中的接口",slug:"_2-ioc中的接口",normalizedTitle:"2.ioc中的接口",charIndex:175},{level:2,title:"3.Bean管理",slug:"_3-bean管理",normalizedTitle:"3.bean管理",charIndex:570},{level:3,title:"3.1.基于XML管理bean（手动装配）",slug:"_3-1-基于xml管理bean-手动装配",normalizedTitle:"3.1.基于xml管理bean（手动装配）",charIndex:583},{level:3,title:"3.2.工厂Bean",slug:"_3-2-工厂bean",normalizedTitle:"3.2.工厂bean",charIndex:6787},{level:3,title:"3.3.bean的作用域",slug:"_3-3-bean的作用域",normalizedTitle:"3.3.bean的作用域",charIndex:8362},{level:3,title:"3.4.bean的生命周期",slug:"_3-4-bean的生命周期",normalizedTitle:"3.4.bean的生命周期",charIndex:8482},{level:3,title:"3.5.自动装配",slug:"_3-5-自动装配",normalizedTitle:"3.5.自动装配",charIndex:12280},{level:3,title:"3.6.引入外部配置文件（properties文件）",slug:"_3-6-引入外部配置文件-properties文件",normalizedTitle:"3.6.引入外部配置文件（properties文件）",charIndex:12930},{level:3,title:"3.7.基于注解管理bean",slug:"_3-7-基于注解管理bean",normalizedTitle:"3.7.基于注解管理bean",charIndex:15248},{level:3,title:"3.4.全注解开发",slug:"_3-4-全注解开发",normalizedTitle:"3.4.全注解开发",charIndex:18493},{level:2,title:"4.AOP",slug:"_4-aop",normalizedTitle:"4.aop",charIndex:19144},{level:3,title:"1.JDK动态代理（需要接口）",slug:"_1-jdk动态代理-需要接口",normalizedTitle:"1.jdk动态代理（需要接口）",charIndex:19234},{level:3,title:"2.CGlib动态代理（会创建子类）",slug:"_2-cglib动态代理-会创建子类",normalizedTitle:"2.cglib动态代理（会创建子类）",charIndex:21600},{level:3,title:"3.JDK动态代理和CGLIB字节码生成的区别？",slug:"_3-jdk动态代理和cglib字节码生成的区别",normalizedTitle:"3.jdk动态代理和cglib字节码生成的区别？",charIndex:23351},{level:3,title:"4.AOP的术语",slug:"_4-aop的术语",normalizedTitle:"4.aop的术语",charIndex:23481},{level:3,title:"5.Spring中使用AOP",slug:"_5-spring中使用aop",normalizedTitle:"5.spring中使用aop",charIndex:23496},{level:2,title:"5.Spring操作JDBC(不推荐)",slug:"_5-spring操作jdbc-不推荐",normalizedTitle:"5.spring操作jdbc(不推荐)",charIndex:31780},{level:3,title:"5.1.添加依赖",slug:"_5-1-添加依赖",normalizedTitle:"5.1.添加依赖",charIndex:31804},{level:3,title:"5.2.Spring的配置",slug:"_5-2-spring的配置",normalizedTitle:"5.2.spring的配置",charIndex:35967},{level:3,title:"5.3.测试",slug:"_5-3-测试",normalizedTitle:"5.3.测试",charIndex:37645},{level:2,title:"6.Spirng事务",slug:"_6-spirng事务",normalizedTitle:"6.spirng事务",charIndex:37909},{level:3,title:"6.1.什么是事务？",slug:"_6-1-什么是事务",normalizedTitle:"6.1.什么是事务？",charIndex:37924},{level:3,title:"6.2.事务特性",slug:"_6-2-事务特性",normalizedTitle:"6.2.事务特性",charIndex:37986},{level:3,title:"6.3.Spring中进行事务管理",slug:"_6-3-spring中进行事务管理",normalizedTitle:"6.3.spring中进行事务管理",charIndex:38074},{level:3,title:"6.4.基于注解的方式",slug:"_6-4-基于注解的方式",normalizedTitle:"6.4.基于注解的方式",charIndex:38366},{level:3,title:"6.5.事务传播行为",slug:"_6-5-事务传播行为",normalizedTitle:"6.5.事务传播行为",charIndex:38557},{level:3,title:"6.6.spring中七大事务传播：",slug:"_6-6-spring中七大事务传播",normalizedTitle:"6.6.spring中七大事务传播：",charIndex:38574},{level:3,title:"6.7.Spring中隔离级别",slug:"_6-7-spring中隔离级别",normalizedTitle:"6.7.spring中隔离级别",charIndex:38943},{level:3,title:"6.8.@Transactional其他参数设置",slug:"_6-8-transactional其他参数设置",normalizedTitle:"6.8.@transactional其他参数设置",charIndex:39456},{level:3,title:"6.9.注解的方式实现",slug:"_6-9-注解的方式实现",normalizedTitle:"6.9.注解的方式实现",charIndex:39775},{level:3,title:"6.10.XML文件的方式实现",slug:"_6-10-xml文件的方式实现",normalizedTitle:"6.10.xml文件的方式实现",charIndex:46609},{level:3,title:"6.11.完全注解开发",slug:"_6-11-完全注解开发",normalizedTitle:"6.11.完全注解开发",charIndex:49504}],headersStr:"1.IOC底层原理 1.1.以前对象中使用另一个对象的方式 1.2.升级版（工厂模式） 1.3.IOC中调用对象 2.IOC中的接口 3.Bean管理 3.1.基于XML管理bean（手动装配） 3.2.工厂Bean 3.3.bean的作用域 3.4.bean的生命周期 3.5.自动装配 3.6.引入外部配置文件（properties文件） 3.7.基于注解管理bean 3.4.全注解开发 4.AOP 1.JDK动态代理（需要接口） 2.CGlib动态代理（会创建子类） 3.JDK动态代理和CGLIB字节码生成的区别？ 4.AOP的术语 5.Spring中使用AOP 5.Spring操作JDBC(不推荐) 5.1.添加依赖 5.2.Spring的配置 5.3.测试 6.Spirng事务 6.1.什么是事务？ 6.2.事务特性 6.3.Spring中进行事务管理 6.4.基于注解的方式 6.5.事务传播行为 6.6.spring中七大事务传播： 6.7.Spring中隔离级别 6.8.@Transactional其他参数设置 6.9.注解的方式实现 6.10.XML文件的方式实现 6.11.完全注解开发",content:'# Spring笔记\n\n\n# 1.IOC底层原理\n\n> IOC底层原理设计：XML解析、工厂模式、反射\n\n\n# 1.1.以前对象中使用另一个对象的方式\n\n\n\n\n# 1.2.升级版（工厂模式）\n\n\n\n\n# 1.3.IOC中调用对象\n\n 1. XML文件，注册Bean\n 2. 创建工程，解析XML文件，获取类路径\n 3. 通过反射获取对象\n\n\n\n\n# 2.IOC中的接口\n\nIOC思想基于IOC容器完成，ICO容器底层就是对象工厂；\n\nIOC中提供两大接口：\n\n 1. BeanFactory：IOC容器底层使用的就是该接口，不提供开发人员进行使用；在加载配置文件的时候不会创建对象，在获取对象（getBean()）才会去创建对象；\n\n 2. ApplicationContext：BeanFactory的子接口，提供更强大的功能，一般由开发人员进行使用；加载配置文件时就会创建对象。（推荐使用，Tomcat启动就会去创建对象）\n    \n    ApplicationContext接口的实现：\n    \n    * FileSystemXmlApplicationContext：在磁盘了寻找（完整路径）\n    * ClassPathXmlApplicationContext：在项目的类路径寻找XML文件\n    \n    \n\n\n# 3.Bean管理\n\n\n# 3.1.基于XML管理bean（手动装配）\n\n# 3.1.1.基于XML文件创建对象\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">\n    <bean id="PersonService" class="com.hand.service.impl.PersonServiceImpl"></bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n# 3.1.2.基于XML文件注入属性（DI）\n\n * 构造器注入：\n   \n   提供对象、List、Set、Map、propertys等类型\n   \n   <?xml version="1.0" encoding="UTF-8"?>\n   <beans xmlns="http://www.springframework.org/schema/beans"\n          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n          xsi:schemaLocation="http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">\n       <bean id="User2" class="com.hand.dto.User">\n           <constructor-arg name="name" value="李四"></constructor-arg>\n           <constructor-arg name="age" value="22"></constructor-arg>\n           <constructor-arg name="testList" >\n               <list>\n                   <value>list1</value>\n                   <value>list2</value>\n                   <value>list3</value>\n               </list>\n           </constructor-arg>\n           <constructor-arg name="testSet">\n               <set>\n                   <value>set1</value>\n                   <value>set2</value>\n                   <value>set3</value>\n               </set>\n           </constructor-arg>\n           <constructor-arg name="testArrays">\n               <array>\n                   <value>array1</value>\n                   <value>array2</value>\n                   <value>array3</value>\n               </array>\n           </constructor-arg>\n           <constructor-arg name="testMap">\n               <map>\n                   <entry key="key1" value="val1"></entry>\n                   <entry key="key2" value="val2"></entry>\n                   <entry key="key3" value="val3"></entry>\n               </map>\n           </constructor-arg>\n           <constructor-arg name="testProperties">\n               <props>\n                   <prop key="key1">val1</prop>\n                   <prop key="key2">val2</prop>\n                   <prop key="key3">val3</prop>\n               </props>\n           </constructor-arg>\n       </bean>\n   </beans>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   \n\n * Set注入\n   \n   <?xml version="1.0" encoding="UTF-8"?>\n   <beans xmlns="http://www.springframework.org/schema/beans"\n          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n          xsi:schemaLocation="http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">\n       <bean id="User" class="com.hand.dto.User">\n           <property name="name" value="李四"></property>\n           <property name="age" value="21"></property>\n           <property name="testList">\n               <list>\n                   <value>list1</value>\n                   <value>list2</value>\n                   <value>list3</value>\n               </list>\n           </property>\n           <property name="testArrays">\n               <array>\n                   <value>array1</value>\n                   <value>array2</value>\n                   <value>array3</value>\n               </array>\n           </property>\n           <property name="testSet">\n               <set>\n                   <value>set1</value>\n                   <value>set2</value>\n                   <value>set3</value>\n               </set>\n           </property>\n           <property name="testMap">\n               <map>\n                   <entry key="key1" value="val1"></entry>\n                   <entry key="key2" value="val2"></entry>\n                   <entry key="key3" value="val3"></entry>\n               </map>\n           </property>\n           <property name="testProperties">\n               <props>\n                   <prop key="key1">val1</prop>\n                   <prop key="key2">val2</prop>\n                   <prop key="key3">val3</prop>\n               </props>\n           </property>\n       </bean>\n   </beans>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   \n\n * P命名空间注入（其实就是简化set注入）\n   \n   \n\n# 3.1.3.注入特殊符号\n\n 1. 注入空值\n    \n        <bean id="User2" class="com.hand.dto.User">\n            <property name="name">\n                <null></null>\n            </property>\n        </bean>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 注入特殊符号\n    \n    方法一：通过转义<>\n    \n        <bean id="User2" class="com.hand.dto.User">\n            <property name="name" value="&lt;南京&gt;">\n            </property>\n        </bean>\n    \n    \n    1\n    2\n    3\n    4\n    \n    \n    方法二:CDATA的方式\n    \n        <bean id="User2" class="com.hand.dto.User">\n            <property name="name" value="&lt;南京&gt;">\n            </property>\n            <property name="age" value="<![CDATA[<南京>]]>">\n            </property>\n        </bean>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n# 3.1.4.导入外部bean\n\n通过ref导入\n\n\n\n# 3.1.5.注入内部bean\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">\n\t\x3c!--注入内部bean--\x3e\n    <bean id="User" class="com.hand.dto.User">\n        <property name="objectTest">\n            <bean>\n                <property name="name" value="测试"></property>\n            </bean>\n        </property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3.2.工厂Bean\n\n> 返回类型与定义的类型可以不一致\n\npackage com.hand.factory;\n\nimport com.hand.dto.User;\nimport org.springframework.beans.factory.FactoryBean;\n\npublic class MyBean implements FactoryBean<User> {\n    //定义返回的类型\n    @Override\n    public User getObject() throws Exception {\n        User user=new User();\n        return user;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return null;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return false;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">\n\n    <bean id="mybean" class="com.hand.factory.MyBean"></bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n测试\n\npackage com.hand;\n\nimport com.hand.factory.MyBean;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Test1 {\n    @Test\n    public void test1(){\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");\n        MyBean myBean = (MyBean)applicationContext.getBean(MyBean.class);\n        System.out.println(myBean);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3.3.bean的作用域\n\n 1. singleton：单例（默认），启动项目后，就会创建bean\n 2. prototype：原型，每次使用都会创建新的对象\n 3. request：一次请求中\n 4. session：一次回话中\n\n\n# 3.4.bean的生命周期\n\n 1. 通过构造方法创建bean的实例\n 2. 为bean设置属性值和对其他的bean的引用（调用set方法）\n 3. 前置通知，在初始化之前执行（需要自己创建）\n 4. bean的初始化的方法（需要自己创建初始化的方法）\n 5. 后置通知，在初始化之后执行（需要自己创建）\n 6. bean就可以使用了（获取到对象）\n 7. 销毁bean（也需要自己创建）\n\n实现：\n\n>  1. 通过构造方法创建bean的实例\n>  2. 为bean设置属性值和对其他的bean的引用（调用set方法）\n>  3. 前置通知，在初始化之前执行（需要自己创建）\n>  4. bean的初始化的方法（需要自己创建初始化的方法）\n>  5. 后置通知，在初始化之后执行（需要自己创建）\n>  6. bean就可以使用了（获取到对象）\n>  7. 销毁bean（也需要自己创建）\n\n 1. 创建bean\n    \n    package com.hand.bean;\n    \n    /**\n     * bean的生命周期\n     */\n    public class BeanCycle {\n        private String name;\n    \n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            System.out.println("第二步：bean设置值");\n            this.name = name;\n        }\n    \n        public BeanCycle() {\n            System.out.println("第一步：构造方法执行");\n        }\n    \n        public void initMethod(){\n            System.out.println("第四步：初始化方法");\n        }\n    \n        public void destroyMethod(){\n            System.out.println("第七部：bean销毁方法");\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    \n\n 2. 创建后置bean\n    \n    package com.hand.bean;\n    \n    import org.springframework.beans.BeansException;\n    import org.springframework.beans.factory.config.BeanPostProcessor;\n    \n    /**\n     * bean的后置处理\n     */\n    public class BeanProcess implements BeanPostProcessor {\n        @Override\n        public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n            System.out.println("第三部：后置方法之前");\n            return bean;\n        }\n    \n        @Override\n        public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n            System.out.println("第五部：后置方法之后");\n            return bean;\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    \n\n 3. 注册bean，\n    \n    > 注意注意：后置方法 会作用于该文件的所有bean，也就是说所有的bean都会执行该方法\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n           xmlns:p="http://www.springframework.org/schema/p"\n           xsi:schemaLocation="http://www.springframework.org/schema/beans\n                            http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">\n        \x3c!--bean生命周期--\x3e\n        <bean id="beanCycle" class="com.hand.bean.BeanCycle" init-method="initMethod" destroy-method="destroyMethod">\n            <property name="name" value="测试"></property>\n        </bean>\n        \x3c!--后置方法 该配置文件的所有bean都会执行该后置方法--\x3e\n        <bean id="beanProcess" class="com.hand.bean.BeanProcess">\n        </bean>\n    </beans>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n 4. 测试：\n    \n    package com.hand;\n    \n    import com.hand.bean.BeanCycle;\n    import org.junit.jupiter.api.Test;\n    import org.springframework.context.support.ClassPathXmlApplicationContext;\n    \n    public class Test1 {\n        @Test\n        public void test1(){\n            ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");\n            BeanCycle myBean = (BeanCycle)applicationContext.getBean(BeanCycle.class);\n            System.out.println("第六步：可以使用bean了");\n            applicationContext.close();\n            System.out.println("第七步：销毁bean了");\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 5. 输出：\n    \n    \n\n\n# 3.5.自动装配\n\n> 手动装配：注册一个bean时，通过property进行赋值\n> \n>     <bean id="beanCycle" class="com.hand.bean.BeanCycle">\n>         <property name="name" ref="beanProcess"></property>\n>     </bean>\n>     <bean id="beanProcess" class="com.hand.bean.BeanProcess">\n>     </bean>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 自动装配：\n> \n>  1. autowire="byName"：bean的属性名和注册的bean的ID要一致\n>  2. autowire="byType"：根据bean的类型匹配\n> \n>     <bean id="beanCycle" class="com.hand.bean.BeanCycle" autowire="byName">\n>         <property name="name" ref="beanProcess"></property>\n>     </bean>\n>     <bean id="beanProcess" class="com.hand.bean.BeanProcess">\n>     </bean>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n\n# 3.6.引入外部配置文件（properties文件）\n\n> 常见的就是引入数据库连接池\n\n# 3.6.1.以前配置连接池信息：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/context\n                       http://www.springframework.org/schema/context/spring-context.xsd">\n\n    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>\n        <property name="url" value="jdbc:mysql://localhost:3306/userDB"></property>\n        <property name="username" value="root"></property>\n        <property name="password" value="root"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 3.6.2.新版写法引入外部文件\n\n配置文件：jdbc.properties\n\njdbc.driverClassName=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/userDB\njdbc.username=root\njdbc.password=root\n\n\n1\n2\n3\n4\n\n\napplicationContext.xml的配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/context\n                        http://www.springframework.org/schema/context/spring-context.xsd">\n    \x3c!--新版写法--\x3e\n    \x3c!--引入外部配置文件--\x3e\n    <context:property-placeholder location="jdbc.properties"/>\n    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n        <property name="driverClassName" value="${jdbc.driverClassName}"></property>\n        <property name="url" value="${jdbc.url}"></property>\n        <property name="username" value="${jdbc.username}"></property>\n        <property name="password" value="${jdbc.password}"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3.7.基于注解管理bean\n\n# 3.7.1.创建bean\n\n 1. 导入依赖\n    \n        <dependency>\n          <groupId>org.springframework</groupId>\n          <artifactId>spring-aop</artifactId>\n          <version>5.2.6.RELEASE</version>\n        </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 开启组件扫描\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n           xmlns:aop="http://www.springframework.org/schema/aop"\n           xmlns:context="http://www.springframework.org/schema/context"\n           xsi:schemaLocation="http://www.springframework.org/schema/beans\n                            http://www.springframework.org/schema/beans/spring-beans.xsd\n                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">\n        \x3c!--开启包扫描，多个包用逗号隔开--\x3e\n    \t<context:component-scan base-package="com.hand"></context:component-scan>--\x3e\n    </beans>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n    \n    扩展：\n    \n    示例一：扫描com.hand包，但是不使用默认的过滤器\n    \n    <context: component-scan base-package="com.hand" use-default-filters="false">\n       \x3c!--只扫描注解是Controller的类--\x3e\n       <context:include-filter type="annotation"\n        expression="org.springframework.stereotype.Controller"/>\n    </context:component-scan>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    示例二：\n    \n    \x3c!--下面配置扫描包所有内容,context:exclude-filter:设置哪些内容不进行扫描--\x3e\n    <context:component-scan base package="com.hand">\n        <context:exclude-filter type="annotation"\n        expression="org.springframework.stereotype.Controller"/>\n    </context:component-scan>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. 通过@Componet、@service、@Controller、@Repository注入到Spirng中\n\n# 3.7.2.属性注入\n\n 1. @Autowired：根据属性类型注入\n    \n    直接引入对象，内部封装了set方法\n\n 2. @Qualifier：根据名称注入\n    \n    必须配合@Autowired使用\n    \n    @Repository(value="userdaodaodao")\n    public UserDao{\n    \tpublic void add(){\n    \t\t...\n    \t}\n    }\n    \n    引用：\n    public UserService{\n    \t@Autowired\n    \t@Qualifier("userdaodaodao")\n    \tprivate UserDao userDao;\n    \tpublic void add(){\n    \t\tuserDao.add();\n    \t\t...\n    \t}\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 3. @Resourse：可以根据类型注入，也可以根据名称注入\n    \n    @Repository(value="userdaodaodao")\n    public UserDao{\n    \tpublic void add(){\n    \t\t...\n    \t}\n    }\n    \n    引用：\n    public UserService{\n    \t@Resourse("userdaodaodao")\n    \tprivate UserDao userDao;\n    \tpublic void add(){\n    \t\tuserDao.add();\n    \t\t...\n    \t}\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 4. @Value\n    \n    public UserService{\n    \t@Value("abc")\n    \tprivate String name;\n    \t@Resourse("userdaodaodao")\n    \tprivate UserDao userDao;\n    \tpublic void add(){\n    \t\tuserDao.add();\n    \t\t...\n    \t}\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n\n# 3.4.全注解开发\n\n配置文件改为配置类：\n\npackage com.hand.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\n\n@Configuration\n@ComponentScan("com.hand")  //扫包\n@EnableAspectJAutoProxy(proxyTargetClass=true) //开启AOP\npublic class AopConfig {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n测试：\n\n    @Test\n    public void test2(){\n        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AopConfig.class);\n        BeanCycle myBean = (BeanCycle)applicationContext.getBean(BeanCycle.class);\n    }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.AOP\n\nAOP：面向切面编程，是OOP的补充；比如我们可以把权限控制、事务控制、日志管理把这些重复的业务代码抽离出来，通过配置的方式（或注解）引入到需要的地方。\n\n\n\n\n# 1.JDK动态代理（需要接口）\n\n通过接口创建代理实现类，增强类的方法\n\n\n\n# 代码实现：\n\n 1. service、serviceimpl方法，需要植入到该类的方法中\n\n 2. 定义切面\n    \n    package com.hand.aspect;\n    \n    public class MyAspect {\n        public void before(){\n            System.out.println("方法执行前。。。。");\n        }\n        public void after(){\n            System.out.println("方法执行后。。。。");\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 3. 代理类\n\n 4. Proxy.newProxyInstance(类加载器，接口，InvocationHandler对象)方法获取代理对象\n    \n    package com.hand.aspect;\n    \n    import com.hand.service.IPersonService;\n    import org.springframework.context.ApplicationContext;\n    import org.springframework.context.support.ClassPathXmlApplicationContext;\n    \n    import java.lang.reflect.InvocationHandler;\n    import java.lang.reflect.Method;\n    import java.lang.reflect.Proxy;\n    \n    public class JdkProxy implements InvocationHandler {\n        private Object target ;//需要代理的目标对象\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            MyAspect myAspect=new MyAspect();\n            myAspect.before();//方法执行前\n            Object result = method.invoke(target, args);\n            myAspect.after();//方法执行后\n            return result;\n        }\n        //定义获取代理对象方法\n        private Object getJDKProxy(Object targetObject){\n            //为目标对象target赋值\n            this.target = targetObject;\n            //JDK动态代理只能针对实现了接口的类进行代理，newProxyInstance 函数所需参数就可看出\n            return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),\n                    targetObject.getClass().getInterfaces(),\n                    this);\n        }\n    \n        public static void main(String[] args) {\n            JdkProxy jdkProxy = new JdkProxy();//实例化JDKProxy对象\n            ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");\n            IPersonService personService = (UserManagerImpl)jdkProxy.getJDKProxy((UserManagerImpl) applicationContext.getBean("UserManagerImpl"));\n            personService.add();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    \n\n\n# 2.CGlib动态代理（会创建子类）\n\n\n\npackage com.hand.aspect;\n\nimport com.hand.service.IPersonService;\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport java.lang.reflect.Method;\n\npublic class CglibProxy implements MethodInterceptor {\n    private Object target ;//需要代理的目标对象\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        MyAspect myAspect=new MyAspect();\n        myAspect.before();//方法执行前\n        Object invoke = method.invoke(target, objects);\n        myAspect.after();//方法执行后\n        return invoke;\n    }\n    //定义获取代理对象方法\n    public Object getCglibProxy(Object objectTarget){\n        //为目标对象target赋值\n        this.target = objectTarget;\n        Enhancer enhancer = new Enhancer();\n        //设置父类,因为Cglib是针对指定的类生成一个子类，所以需要指定父类\n        enhancer.setSuperclass(objectTarget.getClass());\n        enhancer.setCallback(this);// 设置回调\n        Object result = enhancer.create();//创建并返回代理对象\n        return result;\n    }\n    public static void main(String[] args) {\n        CglibProxy cglibProxy = new CglibProxy();//实例化JDKProxy对象\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");\n        IPersonService personService = (IPersonService)cglibProxy.getCglibProxy((IPersonService) applicationContext.getBean("PersonService"));\n        personService.add();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 3.JDK动态代理和CGLIB字节码生成的区别？\n\n> （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类 （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 因为是继承，所以该类或方法最好不要声明成final\n\n\n# 4.AOP的术语\n\n\n\n\n# 5.Spring中使用AOP\n\n# 准备工作：\n\nAspectJ不是Spring的组成部分，独立的AOP框架，一般把AspectJ与Spring一起使用，进行AOP的操作\n\n# 实现方式\n\n 1. 基于XML文件实现\n 2. 基于注解的方式（常用）\n\n# 切入点表达式\n\n> execution(【权限控制】【返回类型】【包名】【方法名】（【参数】）)\n\n案列一:com.wcy.add的Person的add方法增强\n\nexecution(*com.wcy.Person.add(..))\n\n\n1\n\n\n案列二:com.wcy.add的Person的所有方法增强\n\nexecution(*com.wcy.Person.*(..))\n\n\n1\n\n\n案列三:com.wcy.add的所有类的所有方法增强\n\nxxxxxxxxxx execution(*com.wcy.*.*(..))\n\n\n1\n\n\n# 引入依赖\n\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n      <version>5.2.6.RELEASE</version>\n    </dependency>\n    \x3c!--AOP--\x3e\n    <dependency>\n      <groupId>org.aspectj</groupId>\n      <artifactId>aspectjweaver</artifactId>\n      <version>1.9.4</version>\n    </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 注解实现（重点）\n\n 1. 定义一个需要增强的类，比如UserService、UserServiceImpl\n\n 2. 开启包扫描、开启AOP\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n           xmlns:aop="http://www.springframework.org/schema/aop"\n           xmlns:context="http://www.springframework.org/schema/context"\n           xsi:schemaLocation="http://www.springframework.org/schema/beans\n                            http://www.springframework.org/schema/beans/spring-beans.xsd\n                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">\n        \x3c!--开启包扫描--\x3e\n        <context:component-scan base-package="com.hand"></context:component-scan>\n        \x3c!--开启AOP--\x3e\n        <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n    </beans>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n    \n    可以换成配置类实现：\n    \n    package com.hand.config;\n    \n    import org.springframework.context.annotation.ComponentScan;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.context.annotation.EnableAspectJAutoProxy;\n    \n    @Configuration\n    @ComponentScan("com.hand")  //扫包\n    @EnableAspectJAutoProxy(proxyTargetClass=true) //开启AOP\n    public class AopConfig {\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 3. 定义切面，定义通知类型\n    \n    * @Before("pointcut()")//前置通知\n    * @After("pointcut()")//后置通知 最终通知\n    * @AfterReturning("pointcut()")//返回结果才执行 异常不执行\n    * @AfterThrowing(value = "pointcut()", throwing = "ex") //异常通知\n    * @Around("pointcut()") //环绕通知 异常执行前半部分\n    \n    package com.hand.aspect;\n    \n    import org.aspectj.lang.JoinPoint;\n    import org.aspectj.lang.ProceedingJoinPoint;\n    import org.aspectj.lang.annotation.*;\n    import org.springframework.core.annotation.Order;\n    import org.springframework.stereotype.Component;\n    \n    import java.io.PrintWriter;\n    import java.io.StringWriter;\n    import java.util.Arrays;\n    import java.util.List;\n    \n    @Component\n    @Aspect\n    @Order(1) //多个切面定义优先级，越小优先级越高\n    public class AnnotationProxy {\n        @Pointcut("execution(* com.hand.*.*.*(..))")\n        public void pointcut() {\n    \n        }\n    \n        @Before("pointcut()")//前置通知\n        public static void before(JoinPoint joinPoint) {\n            //方法名\n            String method = joinPoint.getSignature().getName();\n            //参数\n            List<Object> args = Arrays.asList(joinPoint.getArgs());\n    \n            System.out.println("方法执行前");\n        }\n    \n        @After("pointcut()")//后置通知 最终通知\n        public static void after() {\n            System.out.println("方法执行后");\n        }\n        @AfterReturning("pointcut()")//返回结果才执行  异常不执行\n        public static void afterReturning() {\n            System.out.println("方法返回后");\n        }\n    \n        //异常执行\n        @AfterThrowing(value = "pointcut()", throwing = "ex")\n        public static void afterException(Exception ex) {\n            StringWriter sw = new StringWriter();\n            ex.printStackTrace(new PrintWriter(sw, true));\n            System.out.println("异常通知:" + sw.getBuffer().toString());\n        }\n    \n    \n        //环绕通知\n        @Around("pointcut()")\n        public static void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n            System.out.println("环绕之前");\n            proceedingJoinPoint.proceed();\n            System.out.println("环绕之后");\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    \n\n 4. 测试\n    \n    package com.hand;\n    \n    import com.hand.service.IPersonService;\n    import org.junit.jupiter.api.Test;\n    import org.springframework.context.ApplicationContext;\n    import org.springframework.context.support.ClassPathXmlApplicationContext;\n    \n    public class Test1 {\n        @Test\n        public void test1(){\n            ApplicationContext applicationContext = new ClassPathXmlApplicationContext("aop.xml");//获取上方的配置的xml文件\n            IPersonService personService = (IPersonService)applicationContext.getBean(IPersonService.class);\n            personService.add();\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n    \n    \n\n# XML文件实现\n\n 1. 需要增强的类\n    \n    package com.hand.aop.xml;\n    \n    public class UserService {\n        public void add(){\n            System.out.println("添加方法");\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 2. 增强的方法\n    \n    package com.hand.aop.xml;\n    \n    public class XmlAspect {\n        public void before(){\n            System.out.println("前置通知");\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. 配置\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n           xmlns:aop="http://www.springframework.org/schema/aop"\n           xmlns:context="http://www.springframework.org/schema/context"\n           xsi:schemaLocation="http://www.springframework.org/schema/beans\n                            http://www.springframework.org/schema/beans/spring-beans.xsd\n                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">\n    \n        <bean id="userService" class="com.hand.aop.xml.UserService"></bean>\n        <bean id="xmlAspect" class="com.hand.aop.xml.XmlAspect"></bean>\n    \n        <aop:config>\n            \x3c!--切入点--\x3e\n            <aop:pointcut id="MyAop" expression="execution(* com.hand.aop.xml.UserService.add(..))"/>\n            \x3c!--定义切面 ref增强的类--\x3e\n            <aop:aspect ref="xmlAspect">\n                \x3c!--哪个切入点--\x3e\n                <aop:before method="before" pointcut-ref="MyAop"></aop:before>\n            </aop:aspect>\n        </aop:config>\n    </beans>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    \n\n 4. 测试\n    \n    package com.hand;\n    \n    import com.hand.aop.xml.UserService;\n    import org.junit.jupiter.api.Test;\n    import org.springframework.context.ApplicationContext;\n    import org.springframework.context.support.ClassPathXmlApplicationContext;\n    \n    public class Test1 {\n        @Test\n        public void test1(){\n            ApplicationContext applicationContext = new ClassPathXmlApplicationContext("aop.xml");\n            UserService personService = (UserService)applicationContext.getBean(UserService.class);\n            personService.add();\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 5.Spring操作JDBC(不推荐)\n\n\n# 5.1.添加依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.hande</groupId>\n  <artifactId>SSM_demo</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>war</packaging>\n\n  <name>SSM_demo Maven Webapp</name>\n  \x3c!-- FIXME change it to the project\'s website --\x3e\n  <url>http://www.example.com</url>\n\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n\n    \x3c!--spring核心依赖--\x3e\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n      <version>5.2.6.RELEASE</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-core</artifactId>\n      <version>5.2.6.RELEASE</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-aop</artifactId>\n      <version>5.2.6.RELEASE</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-orm</artifactId>\n      <version>5.2.6.RELEASE</version>\n    </dependency>\n    \x3c!--AOP--\x3e\n    <dependency>\n      <groupId>org.aspectj</groupId>\n      <artifactId>aspectjweaver</artifactId>\n      <version>1.9.4</version>\n    </dependency>\n\n\n\n\n    \x3c!--阿里巴巴连接池--\x3e\n    <dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>druid</artifactId>\n      <version>1.1.10</version>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>5.1.25</version>\n    </dependency>\n\n\n\n    \x3c!--junit测试依赖--\x3e\n    <dependency>\n      <groupId>org.hamcrest</groupId>\n      <artifactId>hamcrest-core</artifactId>\n      <version>2.2</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.junit.jupiter</groupId>\n      <artifactId>junit-jupiter-api</artifactId>\n      <version>RELEASE</version>\n    </dependency>\n\n\x3c!--    <dependency>--\x3e\n\x3c!--      <groupId>junit</groupId>--\x3e\n\x3c!--      <artifactId>junit</artifactId>--\x3e\n\x3c!--      <version>4.11</version>--\x3e\n\x3c!--      <scope>test</scope>--\x3e\n\x3c!--    </dependency>--\x3e\n  </dependencies>\n\n  <build>\n    <finalName>SSM_demo</finalName>\n    <pluginManagement>\x3c!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --\x3e\n      <plugins>\n        <plugin>\n          <artifactId>maven-clean-plugin</artifactId>\n          <version>3.1.0</version>\n        </plugin>\n        \x3c!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --\x3e\n        <plugin>\n          <artifactId>maven-resources-plugin</artifactId>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-compiler-plugin</artifactId>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-surefire-plugin</artifactId>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-war-plugin</artifactId>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-install-plugin</artifactId>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-deploy-plugin</artifactId>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n\n\n\n# 5.2.Spring的配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n\txmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txmlns:p="http://www.springframework.org/schema/p"\n\txmlns:context="http://www.springframework.org/schema/context"\n\txmlns:aop="http://www.springframework.org/schema/aop"\n\txmlns:tx="http://www.springframework.org/schema/tx"\n\txsi:schemaLocation="http://www.springframework.org/schema/beans\n    \t http://www.springframework.org/schema/beans/spring-beans.xsd\n     \t http://www.springframework.org/schema/context\n         http://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/aop\n         http://www.springframework.org/schema/aop/spring-aop.xsd\n         http://www.springframework.org/schema/tx\n     \t http://www.springframework.org/schema/tx/spring-tx.xsd">\n\n\t\x3c!-- 开启注解 --\x3e\n\t<context:component-scan\n\t\tbase-package="com.hand"></context:component-scan>\n\t\x3c!-- 1. 数据源对象: C3P0连接池 --\x3e\n\t<bean id="dataSource"\n\t\tclass="com.alibaba.druid.pool.DruidDataSource">\n\t\t\x3c!-- 基本属性 url、user、password --\x3e\n\t\t<property name="driverClassName" value="com.mysql.jdbc.Driver" />\n\t\t<property name="url" value="jdbc:mysql://192.168.188.128:3306/hand_ceshi?useUnicode=true&amp;characterEncoding=UTF-8" />\n\t\t<property name="username" value="root" />\n\t\t<property name="password" value="2452952178" />\n\t</bean>\n\t\n\t\x3c!-- 配置jdbc数据源 --\x3e\n\t<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n\t\t<property name="dataSource" ref="dataSource"></property>\n\t</bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 5.3.测试\n\n    @Test\n    public void test3(){\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");\n        System.out.println(applicationContext.getBean(JdbcTemplate.class));\n    }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 6.Spirng事务\n\n\n# 6.1.什么是事务？\n\n> 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。\n\n\n# 6.2.事务特性\n\n 1. 原子性：要么都成功，要么都失败\n 2. 一致性：操作前前后数据一致性\n 3. 隔离性：多个事务之间不会产生影响\n 4. 持久性：保存到库中\n\n\n# 6.3.Spring中进行事务管理\n\nSpring中进行事务管理有两种方式：\n\n 1. 编程式事务：硬编码，在代码中添加事务、提交事务等\n 2. 声明式事务：\n    1. 基于注解方式（推荐）\n    2. 基于XML文件方式\n\n> Spring中进行声明式事务是通过AOP来实现的\n\nSpirng中提供PlatformTransactionManager接口来实现事务：\n\n 1. DataSourceTransactionManager：默认事务、mybatis也使用该事务\n 2. HibernateTransactionManager：Hibernate的事务\n\n\n\n\n# 6.4.基于注解的方式\n\n@Transactional即可实现事务\n\n> 在service类上面(或者service类里面方法上面)添加事务注解\n> \n> (1）@Transactional，这个注解添加到类上面，也可以添加方法上面·\n> \n> (2）如果把这个注解添加类上面，这个类里面所有的方法都添加事务\n> \n> (3）如果把这个注解添加方法上面，为这个方法添加事务\n\n\n# 6.5.事务传播行为\n\n\n\n\n# 6.6.spring中七大事务传播：\n\n传播属性            描述\nREQUIRED        如果有事务在运行，新方法则就用该方法的事务\nREQUIRES_NEW    不管有没有事务，都会另起事务\nSUPPORTS        如果有事务在运行，当前的方法就在这个事务内运行.否则它可以不\nNOT_SUPPORTED   当前方法不应该运行在事务中，如果有运行的事务，把它挂起\nMANDATORY       当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常\nNEVER           当前方法不应该运行在事务中，如果有运行的事务，就抛出异常\nNESTED          如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行\n\n\n# 6.7.Spring中隔离级别\n\n事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题\n\n> 有三个读问题:脏读、不可重复读、虚（幻）读 (1）脏读:一个未提交事务读取到另一个未提交事务的数据\n> \n> (2) 不可重复读：两次读取到修改的数据\n> \n> (3) 幻读：两次读取到添加（或删除）的数据\n\n事务的隔离级别：\n\n                               脏读   不可重复读   幻读\nREAD_UNCOMMITTED（读未提交）         有    有       有\nREAD_COMMITTED（读提交） oracle默认   无    有       有\nREPEATABLE_READ（可重复读）mysql默认   无    无       有\nSERIALIZABLE（串行化）              无    无       无\n\nSpring设置隔离级别：\n\nSpirng隔离级别默认为数据库的隔离级别，当然也可以修改\n\n@Transactional(isolation= Isolation.REPEATABLE_READ)\n\n\n1\n\n\n\n# 6.8.@Transactional其他参数设置\n\n 1. timeout：设置超时时间\n    \n    > (1)事务需要在一定时间内进行提交，如果不提交进行回滚·\n    > \n    > (2）默认值是-1，设置时间以秒单位进行计算\n\n 2. readOnly：设置只读\n    \n    > (1）读:查询操作，写:添加修改删除操作 (2) readOnly默认值false，表示可以查询，可以添加修改删除操作\n    > \n    > (3）设置readOnly值是true，设置成true之后，只能查询\n\n 3. rollbackFor：设置哪种异常才回滚\n\n 4. noRollbackFor：设置哪种异常不回滚\n\n\n# 6.9.注解的方式实现\n\n# 1.引入依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.hande</groupId>\n  <artifactId>SSM_demo</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>war</packaging>\n\n  <name>SSM_demo Maven Webapp</name>\n  \x3c!-- FIXME change it to the project\'s website --\x3e\n  <url>http://www.example.com</url>\n\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n\n    \x3c!--spring核心依赖--\x3e\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n      <version>5.2.6.RELEASE</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-core</artifactId>\n      <version>5.2.6.RELEASE</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-aop</artifactId>\n      <version>5.2.6.RELEASE</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-orm</artifactId>\n      <version>5.2.6.RELEASE</version>\n    </dependency>\n    \x3c!--AOP--\x3e\n    <dependency>\n      <groupId>org.aspectj</groupId>\n      <artifactId>aspectjweaver</artifactId>\n      <version>1.9.4</version>\n    </dependency>\n\n\n\n    \x3c!--阿里巴巴连接池--\x3e\n    <dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>druid</artifactId>\n      <version>1.1.10</version>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>5.1.25</version>\n    </dependency>\n\n\n    \x3c!--junit测试依赖--\x3e\n    <dependency>\n      <groupId>org.hamcrest</groupId>\n      <artifactId>hamcrest-core</artifactId>\n      <version>2.2</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.junit.jupiter</groupId>\n      <artifactId>junit-jupiter-api</artifactId>\n      <version>RELEASE</version>\n    </dependency>\n\n  </dependencies>\n\n  <build>\n    <finalName>SSM_demo</finalName>\n    <pluginManagement>\x3c!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --\x3e\n      <plugins>\n        <plugin>\n          <artifactId>maven-clean-plugin</artifactId>\n          <version>3.1.0</version>\n        </plugin>\n        \x3c!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --\x3e\n        <plugin>\n          <artifactId>maven-resources-plugin</artifactId>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-compiler-plugin</artifactId>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-surefire-plugin</artifactId>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-war-plugin</artifactId>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-install-plugin</artifactId>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-deploy-plugin</artifactId>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n\n\n# 2.spring配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/context\n                        http://www.springframework.org/schema/context/spring-context.xsd\n                        http://www.springframework.org/schema/tx\n                        http://www.springframework.org/schema/tx/spring-tx.xsd">\n\n    \x3c!-- 开启注解扫包 --\x3e\n    <context:component-scan\n            base-package="com.hand"></context:component-scan>\n        \x3c!-- 数据源 --\x3e    \n    <bean id="dataSource"\n          class="com.alibaba.druid.pool.DruidDataSource">\n        \x3c!-- 基本属性 url、user、password --\x3e\n        <property name="driverClassName" value="com.mysql.jdbc.Driver" />\n        <property name="url" value="jdbc:mysql://192.168.188.128:3306/hand_ceshi?useUnicode=true&amp;characterEncoding=UTF-8" />\n        <property name="username" value="root" />\n        <property name="password" value="2452952178" />\n    </bean>\n\n    \x3c!-- 配置jdbc数据源 --\x3e\n    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n        <property name="dataSource" ref="dataSource"></property>\n    </bean>\n    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"></property>\n    </bean>\n    \x3c!--开启事务注解--\x3e\n    <tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n# 3.servicedemo\n\npackage com.hand.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\n@Transactional\npublic class TransactionalService {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    public void transactionalDemo(){\n        jdbcTemplate.update("update user set usex=20 where uid=1");\n        int a=1/0;\n        jdbcTemplate.update("update user set usex=20 where uid=4");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n4.测试\n\n    //事务测试\n    @Test\n    public void test4(){\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");\n        TransactionalService bean = applicationContext.getBean(TransactionalService.class);\n        bean.transactionalDemo();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 6.10.XML文件的方式实现\n\n与上方一样，不过spring的配置文件不同：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/context\n                        http://www.springframework.org/schema/context/spring-context.xsd\n                        http://www.springframework.org/schema/tx\n                        http://www.springframework.org/schema/tx/spring-tx.xsd\n                        http://www.springframework.org/schema/aop\n                        http://www.springframework.org/schema/aop/spring-aop.xsd">\n    \x3c!-- 开启注解扫包 --\x3e\n    <context:component-scan\n            base-package="com.hand"></context:component-scan>\n    \x3c!-- 1. 数据源对象: C3P0连接池 --\x3e\n    <bean id="dataSource"\n          class="com.alibaba.druid.pool.DruidDataSource">\n        \x3c!-- 基本属性 url、user、password --\x3e\n        <property name="driverClassName" value="com.mysql.jdbc.Driver" />\n        <property name="url" value="jdbc:mysql://192.168.188.128:3306/hand_ceshi?useUnicode=true&amp;characterEncoding=UTF-8" />\n        <property name="username" value="root" />\n        <property name="password" value="2452952178" />\n    </bean>\n\n    \x3c!-- 配置jdbc数据源 --\x3e\n    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n        <property name="dataSource" ref="dataSource"></property>\n    </bean>\n    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"></property>\n    </bean>\n    \x3c!--XML文件的方式--\x3e\n\n    \x3c!--定义增强 对事务进行增强（通知），需要编写切入点和具体执行事务的细节--\x3e\n    <tx:advice id="myAdvice">\n        <tx:attributes>\n            \x3c!-- 给切入点方法添加事务详情，name表示方法名称，*表示任意方法名称，\n            propagation用于设置传播行为，read-only表示隔离级别，是否只读 --\x3e\n            <tx:method name="find*" propagation="SUPPORTS"\n                       rollback-for="Exception" />\n            <tx:method name="*" propagation="REQUIRED" isolation="DEFAULT"\n                       read-only="false" />\n        </tx:attributes>\n    </tx:advice>\n    \x3c!--aop--\x3e\n    <aop:config>\n        \x3c!--定义切入点，哪些地方需要被增强--\x3e\n        <aop:pointcut id="myPoint" expression="execution(* com.hand.*.*.*(..))"/>\n        \x3c!--将切入点与通知(事务)整合--\x3e\n        <aop:advisor advice-ref="myAdvice" pointcut-ref="myPoint"></aop:advisor>\n    </aop:config>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 6.11.完全注解开发\n\n# 1.spring配置文件换成配置类\n\n注意注意：有可能有多个配置类，一定要注意@ComponentScan(basePackages = "com.hand") 只能注册一定，不然会重复注册bean；\n\npackage com.hand.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport javax.sql.DataSource;\n\n@Configuration//配置类\n@ComponentScan(basePackages = "com.hand")  //扫包\n@EnableTransactionManagement //开启事务\npublic class TransactionalConfig {\n    /**\n     * 配置数据源\n     * @return\n     */\n    @Bean(name = "dataSource")\n    public DataSource getDruidDataSource(){\n        DruidDataSource druidDataSource=new DruidDataSource();\n        druidDataSource.setDriverClassName("com.mysql.jdbc.Driver");\n        druidDataSource.setUrl("jdbc:mysql://192.168.188.128:3306/hand_ceshi?useUnicode=true&amp;characterEncoding=UTF-8");\n        druidDataSource.setUsername("root");\n        druidDataSource.setPassword("2452952178");\n        return druidDataSource;\n    }\n\n    /**\n     * 配置JdbcTemplate\n     * @param dataSource\n     * @return\n     */\n    @Bean\n    public JdbcTemplate getJdbcTemplate(DataSource dataSource){\n        JdbcTemplate jdbcTemplate=new JdbcTemplate();\n        jdbcTemplate.setDataSource(dataSource);\n        return jdbcTemplate;\n    }\n\n    /**\n     * 配置事务管理器\n     * @param dataSource\n     * @return\n     */\n    @Bean\n    public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource){\n        DataSourceTransactionManager transactionManager=new DataSourceTransactionManager();\n        transactionManager.setDataSource(dataSource);\n        return transactionManager;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n# 2.测试\n\n    //事务全注解测试\n    @Test\n    public void test5(){\n        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(TransactionalConfig.class);\n        TransactionalService bean = applicationContext.getBean(TransactionalService.class);\n        bean.transactionalDemo();\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',normalizedContent:'# spring笔记\n\n\n# 1.ioc底层原理\n\n> ioc底层原理设计：xml解析、工厂模式、反射\n\n\n# 1.1.以前对象中使用另一个对象的方式\n\n\n\n\n# 1.2.升级版（工厂模式）\n\n\n\n\n# 1.3.ioc中调用对象\n\n 1. xml文件，注册bean\n 2. 创建工程，解析xml文件，获取类路径\n 3. 通过反射获取对象\n\n\n\n\n# 2.ioc中的接口\n\nioc思想基于ioc容器完成，ico容器底层就是对象工厂；\n\nioc中提供两大接口：\n\n 1. beanfactory：ioc容器底层使用的就是该接口，不提供开发人员进行使用；在加载配置文件的时候不会创建对象，在获取对象（getbean()）才会去创建对象；\n\n 2. applicationcontext：beanfactory的子接口，提供更强大的功能，一般由开发人员进行使用；加载配置文件时就会创建对象。（推荐使用，tomcat启动就会去创建对象）\n    \n    applicationcontext接口的实现：\n    \n    * filesystemxmlapplicationcontext：在磁盘了寻找（完整路径）\n    * classpathxmlapplicationcontext：在项目的类路径寻找xml文件\n    \n    \n\n\n# 3.bean管理\n\n\n# 3.1.基于xml管理bean（手动装配）\n\n# 3.1.1.基于xml文件创建对象\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">\n    <bean id="personservice" class="com.hand.service.impl.personserviceimpl"></bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n# 3.1.2.基于xml文件注入属性（di）\n\n * 构造器注入：\n   \n   提供对象、list、set、map、propertys等类型\n   \n   <?xml version="1.0" encoding="utf-8"?>\n   <beans xmlns="http://www.springframework.org/schema/beans"\n          xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n          xsi:schemalocation="http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">\n       <bean id="user2" class="com.hand.dto.user">\n           <constructor-arg name="name" value="李四"></constructor-arg>\n           <constructor-arg name="age" value="22"></constructor-arg>\n           <constructor-arg name="testlist" >\n               <list>\n                   <value>list1</value>\n                   <value>list2</value>\n                   <value>list3</value>\n               </list>\n           </constructor-arg>\n           <constructor-arg name="testset">\n               <set>\n                   <value>set1</value>\n                   <value>set2</value>\n                   <value>set3</value>\n               </set>\n           </constructor-arg>\n           <constructor-arg name="testarrays">\n               <array>\n                   <value>array1</value>\n                   <value>array2</value>\n                   <value>array3</value>\n               </array>\n           </constructor-arg>\n           <constructor-arg name="testmap">\n               <map>\n                   <entry key="key1" value="val1"></entry>\n                   <entry key="key2" value="val2"></entry>\n                   <entry key="key3" value="val3"></entry>\n               </map>\n           </constructor-arg>\n           <constructor-arg name="testproperties">\n               <props>\n                   <prop key="key1">val1</prop>\n                   <prop key="key2">val2</prop>\n                   <prop key="key3">val3</prop>\n               </props>\n           </constructor-arg>\n       </bean>\n   </beans>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   \n\n * set注入\n   \n   <?xml version="1.0" encoding="utf-8"?>\n   <beans xmlns="http://www.springframework.org/schema/beans"\n          xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n          xsi:schemalocation="http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">\n       <bean id="user" class="com.hand.dto.user">\n           <property name="name" value="李四"></property>\n           <property name="age" value="21"></property>\n           <property name="testlist">\n               <list>\n                   <value>list1</value>\n                   <value>list2</value>\n                   <value>list3</value>\n               </list>\n           </property>\n           <property name="testarrays">\n               <array>\n                   <value>array1</value>\n                   <value>array2</value>\n                   <value>array3</value>\n               </array>\n           </property>\n           <property name="testset">\n               <set>\n                   <value>set1</value>\n                   <value>set2</value>\n                   <value>set3</value>\n               </set>\n           </property>\n           <property name="testmap">\n               <map>\n                   <entry key="key1" value="val1"></entry>\n                   <entry key="key2" value="val2"></entry>\n                   <entry key="key3" value="val3"></entry>\n               </map>\n           </property>\n           <property name="testproperties">\n               <props>\n                   <prop key="key1">val1</prop>\n                   <prop key="key2">val2</prop>\n                   <prop key="key3">val3</prop>\n               </props>\n           </property>\n       </bean>\n   </beans>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   \n\n * p命名空间注入（其实就是简化set注入）\n   \n   \n\n# 3.1.3.注入特殊符号\n\n 1. 注入空值\n    \n        <bean id="user2" class="com.hand.dto.user">\n            <property name="name">\n                <null></null>\n            </property>\n        </bean>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 注入特殊符号\n    \n    方法一：通过转义<>\n    \n        <bean id="user2" class="com.hand.dto.user">\n            <property name="name" value="&lt;南京&gt;">\n            </property>\n        </bean>\n    \n    \n    1\n    2\n    3\n    4\n    \n    \n    方法二:cdata的方式\n    \n        <bean id="user2" class="com.hand.dto.user">\n            <property name="name" value="&lt;南京&gt;">\n            </property>\n            <property name="age" value="<![cdata[<南京>]]>">\n            </property>\n        </bean>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n# 3.1.4.导入外部bean\n\n通过ref导入\n\n\n\n# 3.1.5.注入内部bean\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">\n\t\x3c!--注入内部bean--\x3e\n    <bean id="user" class="com.hand.dto.user">\n        <property name="objecttest">\n            <bean>\n                <property name="name" value="测试"></property>\n            </bean>\n        </property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3.2.工厂bean\n\n> 返回类型与定义的类型可以不一致\n\npackage com.hand.factory;\n\nimport com.hand.dto.user;\nimport org.springframework.beans.factory.factorybean;\n\npublic class mybean implements factorybean<user> {\n    //定义返回的类型\n    @override\n    public user getobject() throws exception {\n        user user=new user();\n        return user;\n    }\n\n    @override\n    public class<?> getobjecttype() {\n        return null;\n    }\n\n    @override\n    public boolean issingleton() {\n        return false;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">\n\n    <bean id="mybean" class="com.hand.factory.mybean"></bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n测试\n\npackage com.hand;\n\nimport com.hand.factory.mybean;\nimport org.junit.jupiter.api.test;\nimport org.springframework.context.applicationcontext;\nimport org.springframework.context.support.classpathxmlapplicationcontext;\n\npublic class test1 {\n    @test\n    public void test1(){\n        applicationcontext applicationcontext = new classpathxmlapplicationcontext("applicationcontext.xml");\n        mybean mybean = (mybean)applicationcontext.getbean(mybean.class);\n        system.out.println(mybean);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3.3.bean的作用域\n\n 1. singleton：单例（默认），启动项目后，就会创建bean\n 2. prototype：原型，每次使用都会创建新的对象\n 3. request：一次请求中\n 4. session：一次回话中\n\n\n# 3.4.bean的生命周期\n\n 1. 通过构造方法创建bean的实例\n 2. 为bean设置属性值和对其他的bean的引用（调用set方法）\n 3. 前置通知，在初始化之前执行（需要自己创建）\n 4. bean的初始化的方法（需要自己创建初始化的方法）\n 5. 后置通知，在初始化之后执行（需要自己创建）\n 6. bean就可以使用了（获取到对象）\n 7. 销毁bean（也需要自己创建）\n\n实现：\n\n>  1. 通过构造方法创建bean的实例\n>  2. 为bean设置属性值和对其他的bean的引用（调用set方法）\n>  3. 前置通知，在初始化之前执行（需要自己创建）\n>  4. bean的初始化的方法（需要自己创建初始化的方法）\n>  5. 后置通知，在初始化之后执行（需要自己创建）\n>  6. bean就可以使用了（获取到对象）\n>  7. 销毁bean（也需要自己创建）\n\n 1. 创建bean\n    \n    package com.hand.bean;\n    \n    /**\n     * bean的生命周期\n     */\n    public class beancycle {\n        private string name;\n    \n        public string getname() {\n            return name;\n        }\n        public void setname(string name) {\n            system.out.println("第二步：bean设置值");\n            this.name = name;\n        }\n    \n        public beancycle() {\n            system.out.println("第一步：构造方法执行");\n        }\n    \n        public void initmethod(){\n            system.out.println("第四步：初始化方法");\n        }\n    \n        public void destroymethod(){\n            system.out.println("第七部：bean销毁方法");\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    \n\n 2. 创建后置bean\n    \n    package com.hand.bean;\n    \n    import org.springframework.beans.beansexception;\n    import org.springframework.beans.factory.config.beanpostprocessor;\n    \n    /**\n     * bean的后置处理\n     */\n    public class beanprocess implements beanpostprocessor {\n        @override\n        public object postprocessbeforeinitialization(object bean, string beanname) throws beansexception {\n            system.out.println("第三部：后置方法之前");\n            return bean;\n        }\n    \n        @override\n        public object postprocessafterinitialization(object bean, string beanname) throws beansexception {\n            system.out.println("第五部：后置方法之后");\n            return bean;\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    \n\n 3. 注册bean，\n    \n    > 注意注意：后置方法 会作用于该文件的所有bean，也就是说所有的bean都会执行该方法\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n           xmlns:p="http://www.springframework.org/schema/p"\n           xsi:schemalocation="http://www.springframework.org/schema/beans\n                            http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">\n        \x3c!--bean生命周期--\x3e\n        <bean id="beancycle" class="com.hand.bean.beancycle" init-method="initmethod" destroy-method="destroymethod">\n            <property name="name" value="测试"></property>\n        </bean>\n        \x3c!--后置方法 该配置文件的所有bean都会执行该后置方法--\x3e\n        <bean id="beanprocess" class="com.hand.bean.beanprocess">\n        </bean>\n    </beans>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n 4. 测试：\n    \n    package com.hand;\n    \n    import com.hand.bean.beancycle;\n    import org.junit.jupiter.api.test;\n    import org.springframework.context.support.classpathxmlapplicationcontext;\n    \n    public class test1 {\n        @test\n        public void test1(){\n            classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("applicationcontext.xml");\n            beancycle mybean = (beancycle)applicationcontext.getbean(beancycle.class);\n            system.out.println("第六步：可以使用bean了");\n            applicationcontext.close();\n            system.out.println("第七步：销毁bean了");\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 5. 输出：\n    \n    \n\n\n# 3.5.自动装配\n\n> 手动装配：注册一个bean时，通过property进行赋值\n> \n>     <bean id="beancycle" class="com.hand.bean.beancycle">\n>         <property name="name" ref="beanprocess"></property>\n>     </bean>\n>     <bean id="beanprocess" class="com.hand.bean.beanprocess">\n>     </bean>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 自动装配：\n> \n>  1. autowire="byname"：bean的属性名和注册的bean的id要一致\n>  2. autowire="bytype"：根据bean的类型匹配\n> \n>     <bean id="beancycle" class="com.hand.bean.beancycle" autowire="byname">\n>         <property name="name" ref="beanprocess"></property>\n>     </bean>\n>     <bean id="beanprocess" class="com.hand.bean.beanprocess">\n>     </bean>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n\n# 3.6.引入外部配置文件（properties文件）\n\n> 常见的就是引入数据库连接池\n\n# 3.6.1.以前配置连接池信息：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/context\n                       http://www.springframework.org/schema/context/spring-context.xsd">\n\n    <bean id="datasource" class="com.alibaba.druid.pool.druiddatasource">\n        <property name="driverclassname" value="com.mysql.jdbc.driver"></property>\n        <property name="url" value="jdbc:mysql://localhost:3306/userdb"></property>\n        <property name="username" value="root"></property>\n        <property name="password" value="root"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 3.6.2.新版写法引入外部文件\n\n配置文件：jdbc.properties\n\njdbc.driverclassname=com.mysql.jdbc.driver\njdbc.url=jdbc:mysql://localhost:3306/userdb\njdbc.username=root\njdbc.password=root\n\n\n1\n2\n3\n4\n\n\napplicationcontext.xml的配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/context\n                        http://www.springframework.org/schema/context/spring-context.xsd">\n    \x3c!--新版写法--\x3e\n    \x3c!--引入外部配置文件--\x3e\n    <context:property-placeholder location="jdbc.properties"/>\n    <bean id="datasource" class="com.alibaba.druid.pool.druiddatasource">\n        <property name="driverclassname" value="${jdbc.driverclassname}"></property>\n        <property name="url" value="${jdbc.url}"></property>\n        <property name="username" value="${jdbc.username}"></property>\n        <property name="password" value="${jdbc.password}"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3.7.基于注解管理bean\n\n# 3.7.1.创建bean\n\n 1. 导入依赖\n    \n        <dependency>\n          <groupid>org.springframework</groupid>\n          <artifactid>spring-aop</artifactid>\n          <version>5.2.6.release</version>\n        </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 开启组件扫描\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n           xmlns:aop="http://www.springframework.org/schema/aop"\n           xmlns:context="http://www.springframework.org/schema/context"\n           xsi:schemalocation="http://www.springframework.org/schema/beans\n                            http://www.springframework.org/schema/beans/spring-beans.xsd\n                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">\n        \x3c!--开启包扫描，多个包用逗号隔开--\x3e\n    \t<context:component-scan base-package="com.hand"></context:component-scan>--\x3e\n    </beans>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n    \n    扩展：\n    \n    示例一：扫描com.hand包，但是不使用默认的过滤器\n    \n    <context: component-scan base-package="com.hand" use-default-filters="false">\n       \x3c!--只扫描注解是controller的类--\x3e\n       <context:include-filter type="annotation"\n        expression="org.springframework.stereotype.controller"/>\n    </context:component-scan>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    示例二：\n    \n    \x3c!--下面配置扫描包所有内容,context:exclude-filter:设置哪些内容不进行扫描--\x3e\n    <context:component-scan base package="com.hand">\n        <context:exclude-filter type="annotation"\n        expression="org.springframework.stereotype.controller"/>\n    </context:component-scan>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. 通过@componet、@service、@controller、@repository注入到spirng中\n\n# 3.7.2.属性注入\n\n 1. @autowired：根据属性类型注入\n    \n    直接引入对象，内部封装了set方法\n\n 2. @qualifier：根据名称注入\n    \n    必须配合@autowired使用\n    \n    @repository(value="userdaodaodao")\n    public userdao{\n    \tpublic void add(){\n    \t\t...\n    \t}\n    }\n    \n    引用：\n    public userservice{\n    \t@autowired\n    \t@qualifier("userdaodaodao")\n    \tprivate userdao userdao;\n    \tpublic void add(){\n    \t\tuserdao.add();\n    \t\t...\n    \t}\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 3. @resourse：可以根据类型注入，也可以根据名称注入\n    \n    @repository(value="userdaodaodao")\n    public userdao{\n    \tpublic void add(){\n    \t\t...\n    \t}\n    }\n    \n    引用：\n    public userservice{\n    \t@resourse("userdaodaodao")\n    \tprivate userdao userdao;\n    \tpublic void add(){\n    \t\tuserdao.add();\n    \t\t...\n    \t}\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 4. @value\n    \n    public userservice{\n    \t@value("abc")\n    \tprivate string name;\n    \t@resourse("userdaodaodao")\n    \tprivate userdao userdao;\n    \tpublic void add(){\n    \t\tuserdao.add();\n    \t\t...\n    \t}\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n\n# 3.4.全注解开发\n\n配置文件改为配置类：\n\npackage com.hand.config;\n\nimport org.springframework.context.annotation.componentscan;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.context.annotation.enableaspectjautoproxy;\n\n@configuration\n@componentscan("com.hand")  //扫包\n@enableaspectjautoproxy(proxytargetclass=true) //开启aop\npublic class aopconfig {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n测试：\n\n    @test\n    public void test2(){\n        applicationcontext applicationcontext = new annotationconfigapplicationcontext(aopconfig.class);\n        beancycle mybean = (beancycle)applicationcontext.getbean(beancycle.class);\n    }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.aop\n\naop：面向切面编程，是oop的补充；比如我们可以把权限控制、事务控制、日志管理把这些重复的业务代码抽离出来，通过配置的方式（或注解）引入到需要的地方。\n\n\n\n\n# 1.jdk动态代理（需要接口）\n\n通过接口创建代理实现类，增强类的方法\n\n\n\n# 代码实现：\n\n 1. service、serviceimpl方法，需要植入到该类的方法中\n\n 2. 定义切面\n    \n    package com.hand.aspect;\n    \n    public class myaspect {\n        public void before(){\n            system.out.println("方法执行前。。。。");\n        }\n        public void after(){\n            system.out.println("方法执行后。。。。");\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 3. 代理类\n\n 4. proxy.newproxyinstance(类加载器，接口，invocationhandler对象)方法获取代理对象\n    \n    package com.hand.aspect;\n    \n    import com.hand.service.ipersonservice;\n    import org.springframework.context.applicationcontext;\n    import org.springframework.context.support.classpathxmlapplicationcontext;\n    \n    import java.lang.reflect.invocationhandler;\n    import java.lang.reflect.method;\n    import java.lang.reflect.proxy;\n    \n    public class jdkproxy implements invocationhandler {\n        private object target ;//需要代理的目标对象\n        @override\n        public object invoke(object proxy, method method, object[] args) throws throwable {\n            myaspect myaspect=new myaspect();\n            myaspect.before();//方法执行前\n            object result = method.invoke(target, args);\n            myaspect.after();//方法执行后\n            return result;\n        }\n        //定义获取代理对象方法\n        private object getjdkproxy(object targetobject){\n            //为目标对象target赋值\n            this.target = targetobject;\n            //jdk动态代理只能针对实现了接口的类进行代理，newproxyinstance 函数所需参数就可看出\n            return proxy.newproxyinstance(targetobject.getclass().getclassloader(),\n                    targetobject.getclass().getinterfaces(),\n                    this);\n        }\n    \n        public static void main(string[] args) {\n            jdkproxy jdkproxy = new jdkproxy();//实例化jdkproxy对象\n            applicationcontext applicationcontext = new classpathxmlapplicationcontext("applicationcontext.xml");\n            ipersonservice personservice = (usermanagerimpl)jdkproxy.getjdkproxy((usermanagerimpl) applicationcontext.getbean("usermanagerimpl"));\n            personservice.add();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    \n\n\n# 2.cglib动态代理（会创建子类）\n\n\n\npackage com.hand.aspect;\n\nimport com.hand.service.ipersonservice;\nimport org.springframework.cglib.proxy.enhancer;\nimport org.springframework.cglib.proxy.methodinterceptor;\nimport org.springframework.cglib.proxy.methodproxy;\nimport org.springframework.context.applicationcontext;\nimport org.springframework.context.support.classpathxmlapplicationcontext;\n\nimport java.lang.reflect.method;\n\npublic class cglibproxy implements methodinterceptor {\n    private object target ;//需要代理的目标对象\n    @override\n    public object intercept(object o, method method, object[] objects, methodproxy methodproxy) throws throwable {\n        myaspect myaspect=new myaspect();\n        myaspect.before();//方法执行前\n        object invoke = method.invoke(target, objects);\n        myaspect.after();//方法执行后\n        return invoke;\n    }\n    //定义获取代理对象方法\n    public object getcglibproxy(object objecttarget){\n        //为目标对象target赋值\n        this.target = objecttarget;\n        enhancer enhancer = new enhancer();\n        //设置父类,因为cglib是针对指定的类生成一个子类，所以需要指定父类\n        enhancer.setsuperclass(objecttarget.getclass());\n        enhancer.setcallback(this);// 设置回调\n        object result = enhancer.create();//创建并返回代理对象\n        return result;\n    }\n    public static void main(string[] args) {\n        cglibproxy cglibproxy = new cglibproxy();//实例化jdkproxy对象\n        applicationcontext applicationcontext = new classpathxmlapplicationcontext("applicationcontext.xml");\n        ipersonservice personservice = (ipersonservice)cglibproxy.getcglibproxy((ipersonservice) applicationcontext.getbean("personservice"));\n        personservice.add();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 3.jdk动态代理和cglib字节码生成的区别？\n\n> （1）jdk动态代理只能对实现了接口的类生成代理，而不能针对类 （2）cglib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 因为是继承，所以该类或方法最好不要声明成final\n\n\n# 4.aop的术语\n\n\n\n\n# 5.spring中使用aop\n\n# 准备工作：\n\naspectj不是spring的组成部分，独立的aop框架，一般把aspectj与spring一起使用，进行aop的操作\n\n# 实现方式\n\n 1. 基于xml文件实现\n 2. 基于注解的方式（常用）\n\n# 切入点表达式\n\n> execution(【权限控制】【返回类型】【包名】【方法名】（【参数】）)\n\n案列一:com.wcy.add的person的add方法增强\n\nexecution(*com.wcy.person.add(..))\n\n\n1\n\n\n案列二:com.wcy.add的person的所有方法增强\n\nexecution(*com.wcy.person.*(..))\n\n\n1\n\n\n案列三:com.wcy.add的所有类的所有方法增强\n\nxxxxxxxxxx execution(*com.wcy.*.*(..))\n\n\n1\n\n\n# 引入依赖\n\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-context</artifactid>\n      <version>5.2.6.release</version>\n    </dependency>\n    \x3c!--aop--\x3e\n    <dependency>\n      <groupid>org.aspectj</groupid>\n      <artifactid>aspectjweaver</artifactid>\n      <version>1.9.4</version>\n    </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 注解实现（重点）\n\n 1. 定义一个需要增强的类，比如userservice、userserviceimpl\n\n 2. 开启包扫描、开启aop\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n           xmlns:aop="http://www.springframework.org/schema/aop"\n           xmlns:context="http://www.springframework.org/schema/context"\n           xsi:schemalocation="http://www.springframework.org/schema/beans\n                            http://www.springframework.org/schema/beans/spring-beans.xsd\n                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">\n        \x3c!--开启包扫描--\x3e\n        <context:component-scan base-package="com.hand"></context:component-scan>\n        \x3c!--开启aop--\x3e\n        <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n    </beans>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n    \n    可以换成配置类实现：\n    \n    package com.hand.config;\n    \n    import org.springframework.context.annotation.componentscan;\n    import org.springframework.context.annotation.configuration;\n    import org.springframework.context.annotation.enableaspectjautoproxy;\n    \n    @configuration\n    @componentscan("com.hand")  //扫包\n    @enableaspectjautoproxy(proxytargetclass=true) //开启aop\n    public class aopconfig {\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 3. 定义切面，定义通知类型\n    \n    * @before("pointcut()")//前置通知\n    * @after("pointcut()")//后置通知 最终通知\n    * @afterreturning("pointcut()")//返回结果才执行 异常不执行\n    * @afterthrowing(value = "pointcut()", throwing = "ex") //异常通知\n    * @around("pointcut()") //环绕通知 异常执行前半部分\n    \n    package com.hand.aspect;\n    \n    import org.aspectj.lang.joinpoint;\n    import org.aspectj.lang.proceedingjoinpoint;\n    import org.aspectj.lang.annotation.*;\n    import org.springframework.core.annotation.order;\n    import org.springframework.stereotype.component;\n    \n    import java.io.printwriter;\n    import java.io.stringwriter;\n    import java.util.arrays;\n    import java.util.list;\n    \n    @component\n    @aspect\n    @order(1) //多个切面定义优先级，越小优先级越高\n    public class annotationproxy {\n        @pointcut("execution(* com.hand.*.*.*(..))")\n        public void pointcut() {\n    \n        }\n    \n        @before("pointcut()")//前置通知\n        public static void before(joinpoint joinpoint) {\n            //方法名\n            string method = joinpoint.getsignature().getname();\n            //参数\n            list<object> args = arrays.aslist(joinpoint.getargs());\n    \n            system.out.println("方法执行前");\n        }\n    \n        @after("pointcut()")//后置通知 最终通知\n        public static void after() {\n            system.out.println("方法执行后");\n        }\n        @afterreturning("pointcut()")//返回结果才执行  异常不执行\n        public static void afterreturning() {\n            system.out.println("方法返回后");\n        }\n    \n        //异常执行\n        @afterthrowing(value = "pointcut()", throwing = "ex")\n        public static void afterexception(exception ex) {\n            stringwriter sw = new stringwriter();\n            ex.printstacktrace(new printwriter(sw, true));\n            system.out.println("异常通知:" + sw.getbuffer().tostring());\n        }\n    \n    \n        //环绕通知\n        @around("pointcut()")\n        public static void around(proceedingjoinpoint proceedingjoinpoint) throws throwable {\n            system.out.println("环绕之前");\n            proceedingjoinpoint.proceed();\n            system.out.println("环绕之后");\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    \n\n 4. 测试\n    \n    package com.hand;\n    \n    import com.hand.service.ipersonservice;\n    import org.junit.jupiter.api.test;\n    import org.springframework.context.applicationcontext;\n    import org.springframework.context.support.classpathxmlapplicationcontext;\n    \n    public class test1 {\n        @test\n        public void test1(){\n            applicationcontext applicationcontext = new classpathxmlapplicationcontext("aop.xml");//获取上方的配置的xml文件\n            ipersonservice personservice = (ipersonservice)applicationcontext.getbean(ipersonservice.class);\n            personservice.add();\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n    \n    \n\n# xml文件实现\n\n 1. 需要增强的类\n    \n    package com.hand.aop.xml;\n    \n    public class userservice {\n        public void add(){\n            system.out.println("添加方法");\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 2. 增强的方法\n    \n    package com.hand.aop.xml;\n    \n    public class xmlaspect {\n        public void before(){\n            system.out.println("前置通知");\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. 配置\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n           xmlns:aop="http://www.springframework.org/schema/aop"\n           xmlns:context="http://www.springframework.org/schema/context"\n           xsi:schemalocation="http://www.springframework.org/schema/beans\n                            http://www.springframework.org/schema/beans/spring-beans.xsd\n                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">\n    \n        <bean id="userservice" class="com.hand.aop.xml.userservice"></bean>\n        <bean id="xmlaspect" class="com.hand.aop.xml.xmlaspect"></bean>\n    \n        <aop:config>\n            \x3c!--切入点--\x3e\n            <aop:pointcut id="myaop" expression="execution(* com.hand.aop.xml.userservice.add(..))"/>\n            \x3c!--定义切面 ref增强的类--\x3e\n            <aop:aspect ref="xmlaspect">\n                \x3c!--哪个切入点--\x3e\n                <aop:before method="before" pointcut-ref="myaop"></aop:before>\n            </aop:aspect>\n        </aop:config>\n    </beans>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    \n\n 4. 测试\n    \n    package com.hand;\n    \n    import com.hand.aop.xml.userservice;\n    import org.junit.jupiter.api.test;\n    import org.springframework.context.applicationcontext;\n    import org.springframework.context.support.classpathxmlapplicationcontext;\n    \n    public class test1 {\n        @test\n        public void test1(){\n            applicationcontext applicationcontext = new classpathxmlapplicationcontext("aop.xml");\n            userservice personservice = (userservice)applicationcontext.getbean(userservice.class);\n            personservice.add();\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 5.spring操作jdbc(不推荐)\n\n\n# 5.1.添加依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <groupid>com.hande</groupid>\n  <artifactid>ssm_demo</artifactid>\n  <version>1.0-snapshot</version>\n  <packaging>war</packaging>\n\n  <name>ssm_demo maven webapp</name>\n  \x3c!-- fixme change it to the project\'s website --\x3e\n  <url>http://www.example.com</url>\n\n  <properties>\n    <project.build.sourceencoding>utf-8</project.build.sourceencoding>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n\n    \x3c!--spring核心依赖--\x3e\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-context</artifactid>\n      <version>5.2.6.release</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-core</artifactid>\n      <version>5.2.6.release</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-aop</artifactid>\n      <version>5.2.6.release</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-orm</artifactid>\n      <version>5.2.6.release</version>\n    </dependency>\n    \x3c!--aop--\x3e\n    <dependency>\n      <groupid>org.aspectj</groupid>\n      <artifactid>aspectjweaver</artifactid>\n      <version>1.9.4</version>\n    </dependency>\n\n\n\n\n    \x3c!--阿里巴巴连接池--\x3e\n    <dependency>\n      <groupid>com.alibaba</groupid>\n      <artifactid>druid</artifactid>\n      <version>1.1.10</version>\n    </dependency>\n    <dependency>\n      <groupid>mysql</groupid>\n      <artifactid>mysql-connector-java</artifactid>\n      <version>5.1.25</version>\n    </dependency>\n\n\n\n    \x3c!--junit测试依赖--\x3e\n    <dependency>\n      <groupid>org.hamcrest</groupid>\n      <artifactid>hamcrest-core</artifactid>\n      <version>2.2</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupid>org.junit.jupiter</groupid>\n      <artifactid>junit-jupiter-api</artifactid>\n      <version>release</version>\n    </dependency>\n\n\x3c!--    <dependency>--\x3e\n\x3c!--      <groupid>junit</groupid>--\x3e\n\x3c!--      <artifactid>junit</artifactid>--\x3e\n\x3c!--      <version>4.11</version>--\x3e\n\x3c!--      <scope>test</scope>--\x3e\n\x3c!--    </dependency>--\x3e\n  </dependencies>\n\n  <build>\n    <finalname>ssm_demo</finalname>\n    <pluginmanagement>\x3c!-- lock down plugins versions to avoid using maven defaults (may be moved to parent pom) --\x3e\n      <plugins>\n        <plugin>\n          <artifactid>maven-clean-plugin</artifactid>\n          <version>3.1.0</version>\n        </plugin>\n        \x3c!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#plugin_bindings_for_war_packaging --\x3e\n        <plugin>\n          <artifactid>maven-resources-plugin</artifactid>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-compiler-plugin</artifactid>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-surefire-plugin</artifactid>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-war-plugin</artifactid>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-install-plugin</artifactid>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-deploy-plugin</artifactid>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginmanagement>\n  </build>\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n\n\n\n# 5.2.spring的配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n\txmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n\txmlns:p="http://www.springframework.org/schema/p"\n\txmlns:context="http://www.springframework.org/schema/context"\n\txmlns:aop="http://www.springframework.org/schema/aop"\n\txmlns:tx="http://www.springframework.org/schema/tx"\n\txsi:schemalocation="http://www.springframework.org/schema/beans\n    \t http://www.springframework.org/schema/beans/spring-beans.xsd\n     \t http://www.springframework.org/schema/context\n         http://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/aop\n         http://www.springframework.org/schema/aop/spring-aop.xsd\n         http://www.springframework.org/schema/tx\n     \t http://www.springframework.org/schema/tx/spring-tx.xsd">\n\n\t\x3c!-- 开启注解 --\x3e\n\t<context:component-scan\n\t\tbase-package="com.hand"></context:component-scan>\n\t\x3c!-- 1. 数据源对象: c3p0连接池 --\x3e\n\t<bean id="datasource"\n\t\tclass="com.alibaba.druid.pool.druiddatasource">\n\t\t\x3c!-- 基本属性 url、user、password --\x3e\n\t\t<property name="driverclassname" value="com.mysql.jdbc.driver" />\n\t\t<property name="url" value="jdbc:mysql://192.168.188.128:3306/hand_ceshi?useunicode=true&amp;characterencoding=utf-8" />\n\t\t<property name="username" value="root" />\n\t\t<property name="password" value="2452952178" />\n\t</bean>\n\t\n\t\x3c!-- 配置jdbc数据源 --\x3e\n\t<bean id="jdbctemplate" class="org.springframework.jdbc.core.jdbctemplate">\n\t\t<property name="datasource" ref="datasource"></property>\n\t</bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 5.3.测试\n\n    @test\n    public void test3(){\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("applicationcontext.xml");\n        system.out.println(applicationcontext.getbean(jdbctemplate.class));\n    }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 6.spirng事务\n\n\n# 6.1.什么是事务？\n\n> 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。\n\n\n# 6.2.事务特性\n\n 1. 原子性：要么都成功，要么都失败\n 2. 一致性：操作前前后数据一致性\n 3. 隔离性：多个事务之间不会产生影响\n 4. 持久性：保存到库中\n\n\n# 6.3.spring中进行事务管理\n\nspring中进行事务管理有两种方式：\n\n 1. 编程式事务：硬编码，在代码中添加事务、提交事务等\n 2. 声明式事务：\n    1. 基于注解方式（推荐）\n    2. 基于xml文件方式\n\n> spring中进行声明式事务是通过aop来实现的\n\nspirng中提供platformtransactionmanager接口来实现事务：\n\n 1. datasourcetransactionmanager：默认事务、mybatis也使用该事务\n 2. hibernatetransactionmanager：hibernate的事务\n\n\n\n\n# 6.4.基于注解的方式\n\n@transactional即可实现事务\n\n> 在service类上面(或者service类里面方法上面)添加事务注解\n> \n> (1）@transactional，这个注解添加到类上面，也可以添加方法上面·\n> \n> (2）如果把这个注解添加类上面，这个类里面所有的方法都添加事务\n> \n> (3）如果把这个注解添加方法上面，为这个方法添加事务\n\n\n# 6.5.事务传播行为\n\n\n\n\n# 6.6.spring中七大事务传播：\n\n传播属性            描述\nrequired        如果有事务在运行，新方法则就用该方法的事务\nrequires_new    不管有没有事务，都会另起事务\nsupports        如果有事务在运行，当前的方法就在这个事务内运行.否则它可以不\nnot_supported   当前方法不应该运行在事务中，如果有运行的事务，把它挂起\nmandatory       当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常\nnever           当前方法不应该运行在事务中，如果有运行的事务，就抛出异常\nnested          如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行\n\n\n# 6.7.spring中隔离级别\n\n事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题\n\n> 有三个读问题:脏读、不可重复读、虚（幻）读 (1）脏读:一个未提交事务读取到另一个未提交事务的数据\n> \n> (2) 不可重复读：两次读取到修改的数据\n> \n> (3) 幻读：两次读取到添加（或删除）的数据\n\n事务的隔离级别：\n\n                               脏读   不可重复读   幻读\nread_uncommitted（读未提交）         有    有       有\nread_committed（读提交） oracle默认   无    有       有\nrepeatable_read（可重复读）mysql默认   无    无       有\nserializable（串行化）              无    无       无\n\nspring设置隔离级别：\n\nspirng隔离级别默认为数据库的隔离级别，当然也可以修改\n\n@transactional(isolation= isolation.repeatable_read)\n\n\n1\n\n\n\n# 6.8.@transactional其他参数设置\n\n 1. timeout：设置超时时间\n    \n    > (1)事务需要在一定时间内进行提交，如果不提交进行回滚·\n    > \n    > (2）默认值是-1，设置时间以秒单位进行计算\n\n 2. readonly：设置只读\n    \n    > (1）读:查询操作，写:添加修改删除操作 (2) readonly默认值false，表示可以查询，可以添加修改删除操作\n    > \n    > (3）设置readonly值是true，设置成true之后，只能查询\n\n 3. rollbackfor：设置哪种异常才回滚\n\n 4. norollbackfor：设置哪种异常不回滚\n\n\n# 6.9.注解的方式实现\n\n# 1.引入依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <groupid>com.hande</groupid>\n  <artifactid>ssm_demo</artifactid>\n  <version>1.0-snapshot</version>\n  <packaging>war</packaging>\n\n  <name>ssm_demo maven webapp</name>\n  \x3c!-- fixme change it to the project\'s website --\x3e\n  <url>http://www.example.com</url>\n\n  <properties>\n    <project.build.sourceencoding>utf-8</project.build.sourceencoding>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n\n    \x3c!--spring核心依赖--\x3e\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-context</artifactid>\n      <version>5.2.6.release</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-core</artifactid>\n      <version>5.2.6.release</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-aop</artifactid>\n      <version>5.2.6.release</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-orm</artifactid>\n      <version>5.2.6.release</version>\n    </dependency>\n    \x3c!--aop--\x3e\n    <dependency>\n      <groupid>org.aspectj</groupid>\n      <artifactid>aspectjweaver</artifactid>\n      <version>1.9.4</version>\n    </dependency>\n\n\n\n    \x3c!--阿里巴巴连接池--\x3e\n    <dependency>\n      <groupid>com.alibaba</groupid>\n      <artifactid>druid</artifactid>\n      <version>1.1.10</version>\n    </dependency>\n    <dependency>\n      <groupid>mysql</groupid>\n      <artifactid>mysql-connector-java</artifactid>\n      <version>5.1.25</version>\n    </dependency>\n\n\n    \x3c!--junit测试依赖--\x3e\n    <dependency>\n      <groupid>org.hamcrest</groupid>\n      <artifactid>hamcrest-core</artifactid>\n      <version>2.2</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupid>org.junit.jupiter</groupid>\n      <artifactid>junit-jupiter-api</artifactid>\n      <version>release</version>\n    </dependency>\n\n  </dependencies>\n\n  <build>\n    <finalname>ssm_demo</finalname>\n    <pluginmanagement>\x3c!-- lock down plugins versions to avoid using maven defaults (may be moved to parent pom) --\x3e\n      <plugins>\n        <plugin>\n          <artifactid>maven-clean-plugin</artifactid>\n          <version>3.1.0</version>\n        </plugin>\n        \x3c!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#plugin_bindings_for_war_packaging --\x3e\n        <plugin>\n          <artifactid>maven-resources-plugin</artifactid>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-compiler-plugin</artifactid>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-surefire-plugin</artifactid>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-war-plugin</artifactid>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-install-plugin</artifactid>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-deploy-plugin</artifactid>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginmanagement>\n  </build>\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n\n\n# 2.spring配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/context\n                        http://www.springframework.org/schema/context/spring-context.xsd\n                        http://www.springframework.org/schema/tx\n                        http://www.springframework.org/schema/tx/spring-tx.xsd">\n\n    \x3c!-- 开启注解扫包 --\x3e\n    <context:component-scan\n            base-package="com.hand"></context:component-scan>\n        \x3c!-- 数据源 --\x3e    \n    <bean id="datasource"\n          class="com.alibaba.druid.pool.druiddatasource">\n        \x3c!-- 基本属性 url、user、password --\x3e\n        <property name="driverclassname" value="com.mysql.jdbc.driver" />\n        <property name="url" value="jdbc:mysql://192.168.188.128:3306/hand_ceshi?useunicode=true&amp;characterencoding=utf-8" />\n        <property name="username" value="root" />\n        <property name="password" value="2452952178" />\n    </bean>\n\n    \x3c!-- 配置jdbc数据源 --\x3e\n    <bean id="jdbctemplate" class="org.springframework.jdbc.core.jdbctemplate">\n        <property name="datasource" ref="datasource"></property>\n    </bean>\n    <bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource"></property>\n    </bean>\n    \x3c!--开启事务注解--\x3e\n    <tx:annotation-driven transaction-manager="transactionmanager"></tx:annotation-driven>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n# 3.servicedemo\n\npackage com.hand.service;\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.jdbc.core.jdbctemplate;\nimport org.springframework.stereotype.service;\nimport org.springframework.transaction.annotation.transactional;\n\n@service\n@transactional\npublic class transactionalservice {\n    @autowired\n    private jdbctemplate jdbctemplate;\n\n    public void transactionaldemo(){\n        jdbctemplate.update("update user set usex=20 where uid=1");\n        int a=1/0;\n        jdbctemplate.update("update user set usex=20 where uid=4");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n4.测试\n\n    //事务测试\n    @test\n    public void test4(){\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("applicationcontext.xml");\n        transactionalservice bean = applicationcontext.getbean(transactionalservice.class);\n        bean.transactionaldemo();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 6.10.xml文件的方式实现\n\n与上方一样，不过spring的配置文件不同：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/context\n                        http://www.springframework.org/schema/context/spring-context.xsd\n                        http://www.springframework.org/schema/tx\n                        http://www.springframework.org/schema/tx/spring-tx.xsd\n                        http://www.springframework.org/schema/aop\n                        http://www.springframework.org/schema/aop/spring-aop.xsd">\n    \x3c!-- 开启注解扫包 --\x3e\n    <context:component-scan\n            base-package="com.hand"></context:component-scan>\n    \x3c!-- 1. 数据源对象: c3p0连接池 --\x3e\n    <bean id="datasource"\n          class="com.alibaba.druid.pool.druiddatasource">\n        \x3c!-- 基本属性 url、user、password --\x3e\n        <property name="driverclassname" value="com.mysql.jdbc.driver" />\n        <property name="url" value="jdbc:mysql://192.168.188.128:3306/hand_ceshi?useunicode=true&amp;characterencoding=utf-8" />\n        <property name="username" value="root" />\n        <property name="password" value="2452952178" />\n    </bean>\n\n    \x3c!-- 配置jdbc数据源 --\x3e\n    <bean id="jdbctemplate" class="org.springframework.jdbc.core.jdbctemplate">\n        <property name="datasource" ref="datasource"></property>\n    </bean>\n    <bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource"></property>\n    </bean>\n    \x3c!--xml文件的方式--\x3e\n\n    \x3c!--定义增强 对事务进行增强（通知），需要编写切入点和具体执行事务的细节--\x3e\n    <tx:advice id="myadvice">\n        <tx:attributes>\n            \x3c!-- 给切入点方法添加事务详情，name表示方法名称，*表示任意方法名称，\n            propagation用于设置传播行为，read-only表示隔离级别，是否只读 --\x3e\n            <tx:method name="find*" propagation="supports"\n                       rollback-for="exception" />\n            <tx:method name="*" propagation="required" isolation="default"\n                       read-only="false" />\n        </tx:attributes>\n    </tx:advice>\n    \x3c!--aop--\x3e\n    <aop:config>\n        \x3c!--定义切入点，哪些地方需要被增强--\x3e\n        <aop:pointcut id="mypoint" expression="execution(* com.hand.*.*.*(..))"/>\n        \x3c!--将切入点与通知(事务)整合--\x3e\n        <aop:advisor advice-ref="myadvice" pointcut-ref="mypoint"></aop:advisor>\n    </aop:config>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 6.11.完全注解开发\n\n# 1.spring配置文件换成配置类\n\n注意注意：有可能有多个配置类，一定要注意@componentscan(basepackages = "com.hand") 只能注册一定，不然会重复注册bean；\n\npackage com.hand.config;\n\nimport com.alibaba.druid.pool.druiddatasource;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.componentscan;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.jdbc.core.jdbctemplate;\nimport org.springframework.jdbc.datasource.datasourcetransactionmanager;\nimport org.springframework.transaction.annotation.enabletransactionmanagement;\n\nimport javax.sql.datasource;\n\n@configuration//配置类\n@componentscan(basepackages = "com.hand")  //扫包\n@enabletransactionmanagement //开启事务\npublic class transactionalconfig {\n    /**\n     * 配置数据源\n     * @return\n     */\n    @bean(name = "datasource")\n    public datasource getdruiddatasource(){\n        druiddatasource druiddatasource=new druiddatasource();\n        druiddatasource.setdriverclassname("com.mysql.jdbc.driver");\n        druiddatasource.seturl("jdbc:mysql://192.168.188.128:3306/hand_ceshi?useunicode=true&amp;characterencoding=utf-8");\n        druiddatasource.setusername("root");\n        druiddatasource.setpassword("2452952178");\n        return druiddatasource;\n    }\n\n    /**\n     * 配置jdbctemplate\n     * @param datasource\n     * @return\n     */\n    @bean\n    public jdbctemplate getjdbctemplate(datasource datasource){\n        jdbctemplate jdbctemplate=new jdbctemplate();\n        jdbctemplate.setdatasource(datasource);\n        return jdbctemplate;\n    }\n\n    /**\n     * 配置事务管理器\n     * @param datasource\n     * @return\n     */\n    @bean\n    public datasourcetransactionmanager getdatasourcetransactionmanager(datasource datasource){\n        datasourcetransactionmanager transactionmanager=new datasourcetransactionmanager();\n        transactionmanager.setdatasource(datasource);\n        return transactionmanager;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n# 2.测试\n\n    //事务全注解测试\n    @test\n    public void test5(){\n        applicationcontext applicationcontext = new annotationconfigapplicationcontext(transactionalconfig.class);\n        transactionalservice bean = applicationcontext.getbean(transactionalservice.class);\n        bean.transactionaldemo();\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"SSM环境搭建",frontmatter:{title:"SSM环境搭建",date:"2021-07-21T10:43:30.000Z",permalink:"/pages/7f80ea/",categories:["后端","Spring全家桶","Spring"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/00.Spring/11.SSM%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",relativePath:"01.后端/10.Spring全家桶/00.Spring/11.SSM环境搭建.md",key:"v-5bf22270",path:"/pages/7f80ea/",headers:[{level:2,title:"1.创建简单的web项目",slug:"_1-创建简单的web项目",normalizedTitle:"1.创建简单的web项目",charIndex:14},{level:2,title:"2.路径结构如下",slug:"_2-路径结构如下",normalizedTitle:"2.路径结构如下",charIndex:33},{level:2,title:"3.导入依赖",slug:"_3-导入依赖",normalizedTitle:"3.导入依赖",charIndex:48},{level:2,title:"4.数据库的配置",slug:"_4-数据库的配置",normalizedTitle:"4.数据库的配置",charIndex:6306},{level:2,title:"5.Spring的配置",slug:"_5-spring的配置",normalizedTitle:"5.spring的配置",charIndex:6514},{level:2,title:"6.Spirngmvc的配置",slug:"_6-spirngmvc的配置",normalizedTitle:"6.spirngmvc的配置",charIndex:9041},{level:2,title:"7.日志的配置",slug:"_7-日志的配置",normalizedTitle:"7.日志的配置",charIndex:10413},{level:2,title:"8.web.xml文件配置",slug:"_8-web-xml文件配置",normalizedTitle:"8.web.xml文件配置",charIndex:11210},{level:2,title:"9.配置tomcat",slug:"_9-配置tomcat",normalizedTitle:"9.配置tomcat",charIndex:12855},{level:2,title:"10.controller测试",slug:"_10-controller测试",normalizedTitle:"10.controller测试",charIndex:12888},{level:2,title:"1.引入validation并进行全局异常捕获",slug:"_1-引入validation并进行全局异常捕获",normalizedTitle:"1.引入validation并进行全局异常捕获",charIndex:13423},{level:3,title:"1.引入依赖",slug:"_1-引入依赖",normalizedTitle:"1.引入依赖",charIndex:13453},{level:3,title:"2.引入全局异常",slug:"_2-引入全局异常",normalizedTitle:"2.引入全局异常",charIndex:13881},{level:3,title:"3.springmvc-config.xml注入bean",slug:"_3-springmvc-config-xml注入bean",normalizedTitle:"3.springmvc-config.xml注入bean",charIndex:15796},{level:3,title:"4.controller添加@Validated即可",slug:"_4-controller添加-validated即可",normalizedTitle:"4.controller添加@validated即可",charIndex:15946}],headersStr:"1.创建简单的web项目 2.路径结构如下 3.导入依赖 4.数据库的配置 5.Spring的配置 6.Spirngmvc的配置 7.日志的配置 8.web.xml文件配置 9.配置tomcat 10.controller测试 1.引入validation并进行全局异常捕获 1.引入依赖 2.引入全局异常 3.springmvc-config.xml注入bean 4.controller添加@Validated即可",content:'# 搭建SSM环境\n\n\n# 1.创建简单的web项目\n\n\n\n\n# 2.路径结构如下\n\n\n\n\n# 3.导入依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.wcy</groupId>\n  <artifactId>SSM_Style</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>war</packaging>\n\n  <name>SSM_Style Maven Webapp</name>\n  \x3c!-- FIXME change it to the project\'s website --\x3e\n  <url>http://www.example.com</url>\n\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n    \x3c!--Spring版本--\x3e\n    <spring.version>5.2.6.RELEASE</spring.version>\n    \x3c!-- mybatis版本号 --\x3e\n    <mybatis.version>3.2.6</mybatis.version>\n  </properties>\n\n  <dependencies>\n    \x3c!-- spring核心包 --\x3e\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-core</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-web</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-oxm</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-tx</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-jdbc</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-webmvc</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-aop</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context-support</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-test</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    \x3c!-- mybatis核心包 --\x3e\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n      <version>${mybatis.version}</version>\n    </dependency>\n    \x3c!-- mybatis/spring包 --\x3e\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis-spring</artifactId>\n      <version>1.2.2</version>\n    </dependency>\n    \x3c!--AOP--\x3e\n    <dependency>\n      <groupId>org.aspectj</groupId>\n      <artifactId>aspectjweaver</artifactId>\n      <version>1.9.4</version>\n    </dependency>\n    \x3c!-- 导入Mysql数据库链接jar包 --\x3e\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>5.1.30</version>\n    </dependency>\n    \x3c!--阿里巴巴连接池--\x3e\n    <dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>druid</artifactId>\n      <version>1.1.10</version>\n    </dependency>\n\n    <dependency>\n      <groupId>javax</groupId>\n      <artifactId>javaee-api</artifactId>\n      <version>7.0</version>\n    </dependency>\n    \x3c!-- JSTL标签类 --\x3e\n    <dependency>\n      <groupId>jstl</groupId>\n      <artifactId>jstl</artifactId>\n      <version>1.2</version>\n    </dependency>\n    \x3c!-- 日志文件管理包 --\x3e\n    \x3c!-- log start --\x3e\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <version>1.2.17</version>\n    </dependency>\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-api</artifactId>\n      <version>1.7.7</version>\n    </dependency>\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-log4j12</artifactId>\n      <version>1.7.7</version>\n    </dependency>\n    <dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>fastjson</artifactId>\n      <version>1.1.41</version>\n    </dependency>\n\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <finalName>SSM_Style</finalName>\n    <pluginManagement>\x3c!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --\x3e\n      <plugins>\n        <plugin>\n          <artifactId>maven-clean-plugin</artifactId>\n          <version>3.1.0</version>\n        </plugin>\n        \x3c!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --\x3e\n        <plugin>\n          <artifactId>maven-resources-plugin</artifactId>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-compiler-plugin</artifactId>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-surefire-plugin</artifactId>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-war-plugin</artifactId>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-install-plugin</artifactId>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-deploy-plugin</artifactId>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n\n\n\n# 4.数据库的配置\n\n#com.mysql.cj.jdbc.Driver\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://192.168.188.128:3306/hand_ceshi?characterEncoding=utf8\njdbc.username=root\njdbc.password=2452952178\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5.Spring的配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p"\n       xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\n    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd\n    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">\n\n\n    \x3c!--读取数据库配置文件--\x3e\n    <context:property-placeholder location="classpath:db.properties"/>\n\n    \x3c!-- 配置数据源 --\x3e\n    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n        <property name="driverClassName" value="${jdbc.driver}"/>\n        <property name="url" value="${jdbc.url}"/>\n        <property name="username" value="${jdbc.username}"/>\n        <property name="password" value="${jdbc.password}"/>\n    </bean>\n\n    \x3c!-- 事务管理器 --\x3e\n    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!-- 开启事务注解 --\x3e\n    <tx:annotation-driven transaction-manager="transactionManager" />\n\n    <bean id="SqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean" >\n        \x3c!--  注入数据源  --\x3e\n        <property name="dataSource" ref="dataSource" />\n        \x3c!--  指定mybatis配置文件位置  --\x3e\n        <property name="configLocation" value="classpath:mybatis-config.xml"></property>\n        \x3c!--  指定mapper文件位置  --\x3e\n        <property name="mapperLocations" value="classpath:mapper/*.xml"></property>\n    </bean>\n\n    \x3c!-- 配置mapper扫描器 --\x3e\n    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">\n        <property name="basePackage" value="com.hand.mapper" />\n    </bean>\n    \x3c!-- 扫描Service --\x3e\n    <context:component-scan base-package="com.hand.service" />\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 6.Spirngmvc的配置\n\n> 静态文件放到webapp/static下边，注意一定要为static，否则要去pom.xml文件配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">\n\n    \x3c!-- 配置包扫描 @Controller注解类--\x3e\n    <context:component-scan base-package="com.hand.controller"/>\n\n    \x3c!-- 开启mvc注解 --\x3e\n    <mvc:annotation-driven/>\n\n    \x3c!-- 视图解析器 --\x3e\n    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">\n        <property name="prefix" value="/WEB-INF/jsp/" />\n        <property name="suffix" value=".jsp"/>\n    </bean>\n        \x3c!-- 配置Json注解驱动 --\x3e\n    <mvc:annotation-driven/>\n    \x3c!--静态资源映射--\x3e\n    <mvc:resources location="/static/" mapping="/static/**" />\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 7.日志的配置\n\n#log4j.rootCategory=DEBUG, stdout , R\n#log4j.appender.stdout=org.apache.log4j.ConsoleAppender\n#log4j.appender.stdout.layout=org.apache.log4j.PatternLayout\n#log4j.appender.stdout.layout.ConversionPattern=[QC] %p [%t] %C.%M(%L) | %m%n\n#log4j.appender.R=org.apache.log4j.DailyRollingFileAppender\n#log4j.appender.R.layout=org.apache.log4j.PatternLayout\n#log4j.appender.R.layout.ConversionPattern=%d-[TS] %p %t %c - %m%n\n\n# Global logging configuration\nlog4j.rootLogger=ERROR,stdout\n# MyBatis logging configuration...\nlog4j.logger.com.mybatis=DEBUG\n# Console output...\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 8.web.xml文件配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n         version="4.0">\n\n  \x3c!-- 配置加载Spring文件的监听 --\x3e\n  <context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>classpath:applicationContext.xml</param-value>\n  </context-param>\n  <listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n\n  \x3c!-- 编码过滤器 --\x3e\n  <filter>\n    <filter-name>encoding</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n      <param-name>encoding</param-name>\n      <param-value>UTF-8</param-value>\n    </init-param>\n  </filter>\n  <filter-mapping>\n    <filter-name>encoding</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n\n  \x3c!-- 配置SprigMVC前端核心控制器 --\x3e\n  <servlet>\n    <servlet-name>springMVC</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:springmvc-config.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>springMVC</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n\n\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 9.配置tomcat\n\n\n\n\n\n选择第二个开启热部署\n\n\n\n\n# 10.controller测试\n\npackage com.hand.controller;\n\nimport com.hand.dto.User;\nimport com.hand.mapper.UserMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\n\nimport javax.servlet.http.HttpSession;\n\n@Controller\npublic class TestController {\n\n    @GetMapping("/hello")\n    public String toHello(HttpSession session){\n        return "hello";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 二.引入其他环境\n\n\n# 1.引入validation并进行全局异常捕获\n\n\n\n\n# 1.引入依赖\n\n    \x3c!-- validation begin引入数据校验 --\x3e\n    <dependency>\n      <groupId>javax.validation</groupId>\n      <artifactId>validation-api</artifactId>\n      <version>1.1.0.Final</version>\n    </dependency>\n    <dependency>\n      <groupId>org.hibernate</groupId>\n      <artifactId>hibernate-validator</artifactId>\n      <version>5.4.0.Final</version>\n    </dependency>\n    \x3c!-- validation end --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.引入全局异常\n\npackage com.hand.exception;\n\nimport com.hand.page.AjaxResult;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.validation.BindException;\nimport org.springframework.validation.ObjectError;\nimport org.springframework.web.HttpRequestMethodNotSupportedException;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\n\n/**\n * 全局异常处理器\n * \n * @author ruoyi\n */\n@RestControllerAdvice\npublic class GlobalExceptionHandler\n{\n    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    private ObjectError objectError;\n\n    /**\n     * 请求方式不支持\n     */\n    @ExceptionHandler({ HttpRequestMethodNotSupportedException.class })\n    public AjaxResult handleException(HttpRequestMethodNotSupportedException e)\n    {\n        log.error(e.getMessage(), e);\n        return AjaxResult.error("不支持\' " + e.getMethod() + "\'请求");\n    }\n\n    /**\n     * 拦截未知的运行时异常\n     */\n    @ExceptionHandler(RuntimeException.class)\n    public AjaxResult notFount(RuntimeException e)\n    {\n        log.error("运行时异常:", e);\n        return AjaxResult.error("运行时异常:" + e.getMessage());\n    }\n\n    /**\n     * 系统异常\n     */\n    @ExceptionHandler(Exception.class)\n    public AjaxResult handleException(Exception e)\n    {\n        log.error(e.getMessage(), e);\n        return AjaxResult.error("服务器错误，请联系管理员");\n    }\n\n    /**\n     * 自定义验证异常\n     */\n    @ExceptionHandler(BindException.class)\n    public AjaxResult validatedBindException(BindException e)\n    {\n        log.error(e.getMessage(), e);\n        String message = e.getAllErrors().get(0).getDefaultMessage();\n        return AjaxResult.error(message);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n# 3.springmvc-config.xml注入bean\n\n    \x3c!--全局异常处理类--\x3e\n    <bean id="exceptionHandler" class="com.hand.exception.GlobalExceptionHandler"></bean>\n\n\n1\n2\n\n\n\n# 4.controller添加@Validated即可\n\n    @PostMapping("/add")\n    @ResponseBody\n    public AjaxResult addSave(@Validated SsmAccount ssmAccount)\n    {\n    }\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# 搭建ssm环境\n\n\n# 1.创建简单的web项目\n\n\n\n\n# 2.路径结构如下\n\n\n\n\n# 3.导入依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <groupid>com.wcy</groupid>\n  <artifactid>ssm_style</artifactid>\n  <version>1.0-snapshot</version>\n  <packaging>war</packaging>\n\n  <name>ssm_style maven webapp</name>\n  \x3c!-- fixme change it to the project\'s website --\x3e\n  <url>http://www.example.com</url>\n\n  <properties>\n    <project.build.sourceencoding>utf-8</project.build.sourceencoding>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n    \x3c!--spring版本--\x3e\n    <spring.version>5.2.6.release</spring.version>\n    \x3c!-- mybatis版本号 --\x3e\n    <mybatis.version>3.2.6</mybatis.version>\n  </properties>\n\n  <dependencies>\n    \x3c!-- spring核心包 --\x3e\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-core</artifactid>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-web</artifactid>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-oxm</artifactid>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-tx</artifactid>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-jdbc</artifactid>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-webmvc</artifactid>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-aop</artifactid>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-context-support</artifactid>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-test</artifactid>\n      <version>${spring.version}</version>\n    </dependency>\n    \x3c!-- mybatis核心包 --\x3e\n    <dependency>\n      <groupid>org.mybatis</groupid>\n      <artifactid>mybatis</artifactid>\n      <version>${mybatis.version}</version>\n    </dependency>\n    \x3c!-- mybatis/spring包 --\x3e\n    <dependency>\n      <groupid>org.mybatis</groupid>\n      <artifactid>mybatis-spring</artifactid>\n      <version>1.2.2</version>\n    </dependency>\n    \x3c!--aop--\x3e\n    <dependency>\n      <groupid>org.aspectj</groupid>\n      <artifactid>aspectjweaver</artifactid>\n      <version>1.9.4</version>\n    </dependency>\n    \x3c!-- 导入mysql数据库链接jar包 --\x3e\n    <dependency>\n      <groupid>mysql</groupid>\n      <artifactid>mysql-connector-java</artifactid>\n      <version>5.1.30</version>\n    </dependency>\n    \x3c!--阿里巴巴连接池--\x3e\n    <dependency>\n      <groupid>com.alibaba</groupid>\n      <artifactid>druid</artifactid>\n      <version>1.1.10</version>\n    </dependency>\n\n    <dependency>\n      <groupid>javax</groupid>\n      <artifactid>javaee-api</artifactid>\n      <version>7.0</version>\n    </dependency>\n    \x3c!-- jstl标签类 --\x3e\n    <dependency>\n      <groupid>jstl</groupid>\n      <artifactid>jstl</artifactid>\n      <version>1.2</version>\n    </dependency>\n    \x3c!-- 日志文件管理包 --\x3e\n    \x3c!-- log start --\x3e\n    <dependency>\n      <groupid>log4j</groupid>\n      <artifactid>log4j</artifactid>\n      <version>1.2.17</version>\n    </dependency>\n    <dependency>\n      <groupid>org.slf4j</groupid>\n      <artifactid>slf4j-api</artifactid>\n      <version>1.7.7</version>\n    </dependency>\n    <dependency>\n      <groupid>org.slf4j</groupid>\n      <artifactid>slf4j-log4j12</artifactid>\n      <version>1.7.7</version>\n    </dependency>\n    <dependency>\n      <groupid>com.alibaba</groupid>\n      <artifactid>fastjson</artifactid>\n      <version>1.1.41</version>\n    </dependency>\n\n    <dependency>\n      <groupid>junit</groupid>\n      <artifactid>junit</artifactid>\n      <version>4.11</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <finalname>ssm_style</finalname>\n    <pluginmanagement>\x3c!-- lock down plugins versions to avoid using maven defaults (may be moved to parent pom) --\x3e\n      <plugins>\n        <plugin>\n          <artifactid>maven-clean-plugin</artifactid>\n          <version>3.1.0</version>\n        </plugin>\n        \x3c!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#plugin_bindings_for_war_packaging --\x3e\n        <plugin>\n          <artifactid>maven-resources-plugin</artifactid>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-compiler-plugin</artifactid>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-surefire-plugin</artifactid>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-war-plugin</artifactid>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-install-plugin</artifactid>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-deploy-plugin</artifactid>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginmanagement>\n  </build>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n\n\n\n# 4.数据库的配置\n\n#com.mysql.cj.jdbc.driver\njdbc.driver=com.mysql.jdbc.driver\njdbc.url=jdbc:mysql://192.168.188.128:3306/hand_ceshi?characterencoding=utf8\njdbc.username=root\njdbc.password=2452952178\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5.spring的配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p"\n       xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\n    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd\n    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">\n\n\n    \x3c!--读取数据库配置文件--\x3e\n    <context:property-placeholder location="classpath:db.properties"/>\n\n    \x3c!-- 配置数据源 --\x3e\n    <bean id="datasource" class="com.alibaba.druid.pool.druiddatasource">\n        <property name="driverclassname" value="${jdbc.driver}"/>\n        <property name="url" value="${jdbc.url}"/>\n        <property name="username" value="${jdbc.username}"/>\n        <property name="password" value="${jdbc.password}"/>\n    </bean>\n\n    \x3c!-- 事务管理器 --\x3e\n    <bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource"/>\n    </bean>\n\n    \x3c!-- 开启事务注解 --\x3e\n    <tx:annotation-driven transaction-manager="transactionmanager" />\n\n    <bean id="sqlsessionfactory" class="org.mybatis.spring.sqlsessionfactorybean" >\n        \x3c!--  注入数据源  --\x3e\n        <property name="datasource" ref="datasource" />\n        \x3c!--  指定mybatis配置文件位置  --\x3e\n        <property name="configlocation" value="classpath:mybatis-config.xml"></property>\n        \x3c!--  指定mapper文件位置  --\x3e\n        <property name="mapperlocations" value="classpath:mapper/*.xml"></property>\n    </bean>\n\n    \x3c!-- 配置mapper扫描器 --\x3e\n    <bean class="org.mybatis.spring.mapper.mapperscannerconfigurer">\n        <property name="basepackage" value="com.hand.mapper" />\n    </bean>\n    \x3c!-- 扫描service --\x3e\n    <context:component-scan base-package="com.hand.service" />\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 6.spirngmvc的配置\n\n> 静态文件放到webapp/static下边，注意一定要为static，否则要去pom.xml文件配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance" xmlns:p="http://www.springframework.org/schema/p"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">\n\n    \x3c!-- 配置包扫描 @controller注解类--\x3e\n    <context:component-scan base-package="com.hand.controller"/>\n\n    \x3c!-- 开启mvc注解 --\x3e\n    <mvc:annotation-driven/>\n\n    \x3c!-- 视图解析器 --\x3e\n    <bean class="org.springframework.web.servlet.view.internalresourceviewresolver">\n        <property name="prefix" value="/web-inf/jsp/" />\n        <property name="suffix" value=".jsp"/>\n    </bean>\n        \x3c!-- 配置json注解驱动 --\x3e\n    <mvc:annotation-driven/>\n    \x3c!--静态资源映射--\x3e\n    <mvc:resources location="/static/" mapping="/static/**" />\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 7.日志的配置\n\n#log4j.rootcategory=debug, stdout , r\n#log4j.appender.stdout=org.apache.log4j.consoleappender\n#log4j.appender.stdout.layout=org.apache.log4j.patternlayout\n#log4j.appender.stdout.layout.conversionpattern=[qc] %p [%t] %c.%m(%l) | %m%n\n#log4j.appender.r=org.apache.log4j.dailyrollingfileappender\n#log4j.appender.r.layout=org.apache.log4j.patternlayout\n#log4j.appender.r.layout.conversionpattern=%d-[ts] %p %t %c - %m%n\n\n# global logging configuration\nlog4j.rootlogger=error,stdout\n# mybatis logging configuration...\nlog4j.logger.com.mybatis=debug\n# console output...\nlog4j.appender.stdout=org.apache.log4j.consoleappender\nlog4j.appender.stdout.layout=org.apache.log4j.patternlayout\nlog4j.appender.stdout.layout.conversionpattern=%5p [%t] - %m%n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 8.web.xml文件配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n         version="4.0">\n\n  \x3c!-- 配置加载spring文件的监听 --\x3e\n  <context-param>\n    <param-name>contextconfiglocation</param-name>\n    <param-value>classpath:applicationcontext.xml</param-value>\n  </context-param>\n  <listener>\n    <listener-class>org.springframework.web.context.contextloaderlistener</listener-class>\n  </listener>\n\n  \x3c!-- 编码过滤器 --\x3e\n  <filter>\n    <filter-name>encoding</filter-name>\n    <filter-class>org.springframework.web.filter.characterencodingfilter</filter-class>\n    <init-param>\n      <param-name>encoding</param-name>\n      <param-value>utf-8</param-value>\n    </init-param>\n  </filter>\n  <filter-mapping>\n    <filter-name>encoding</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n\n  \x3c!-- 配置sprigmvc前端核心控制器 --\x3e\n  <servlet>\n    <servlet-name>springmvc</servlet-name>\n    <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n    <init-param>\n      <param-name>contextconfiglocation</param-name>\n      <param-value>classpath:springmvc-config.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>springmvc</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n\n\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 9.配置tomcat\n\n\n\n\n\n选择第二个开启热部署\n\n\n\n\n# 10.controller测试\n\npackage com.hand.controller;\n\nimport com.hand.dto.user;\nimport com.hand.mapper.usermapper;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.controller;\nimport org.springframework.web.bind.annotation.getmapping;\n\nimport javax.servlet.http.httpsession;\n\n@controller\npublic class testcontroller {\n\n    @getmapping("/hello")\n    public string tohello(httpsession session){\n        return "hello";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 二.引入其他环境\n\n\n# 1.引入validation并进行全局异常捕获\n\n\n\n\n# 1.引入依赖\n\n    \x3c!-- validation begin引入数据校验 --\x3e\n    <dependency>\n      <groupid>javax.validation</groupid>\n      <artifactid>validation-api</artifactid>\n      <version>1.1.0.final</version>\n    </dependency>\n    <dependency>\n      <groupid>org.hibernate</groupid>\n      <artifactid>hibernate-validator</artifactid>\n      <version>5.4.0.final</version>\n    </dependency>\n    \x3c!-- validation end --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.引入全局异常\n\npackage com.hand.exception;\n\nimport com.hand.page.ajaxresult;\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.validation.bindexception;\nimport org.springframework.validation.objecterror;\nimport org.springframework.web.httprequestmethodnotsupportedexception;\nimport org.springframework.web.bind.annotation.exceptionhandler;\nimport org.springframework.web.bind.annotation.restcontrolleradvice;\n\n/**\n * 全局异常处理器\n * \n * @author ruoyi\n */\n@restcontrolleradvice\npublic class globalexceptionhandler\n{\n    private static final logger log = loggerfactory.getlogger(globalexceptionhandler.class);\n    private objecterror objecterror;\n\n    /**\n     * 请求方式不支持\n     */\n    @exceptionhandler({ httprequestmethodnotsupportedexception.class })\n    public ajaxresult handleexception(httprequestmethodnotsupportedexception e)\n    {\n        log.error(e.getmessage(), e);\n        return ajaxresult.error("不支持\' " + e.getmethod() + "\'请求");\n    }\n\n    /**\n     * 拦截未知的运行时异常\n     */\n    @exceptionhandler(runtimeexception.class)\n    public ajaxresult notfount(runtimeexception e)\n    {\n        log.error("运行时异常:", e);\n        return ajaxresult.error("运行时异常:" + e.getmessage());\n    }\n\n    /**\n     * 系统异常\n     */\n    @exceptionhandler(exception.class)\n    public ajaxresult handleexception(exception e)\n    {\n        log.error(e.getmessage(), e);\n        return ajaxresult.error("服务器错误，请联系管理员");\n    }\n\n    /**\n     * 自定义验证异常\n     */\n    @exceptionhandler(bindexception.class)\n    public ajaxresult validatedbindexception(bindexception e)\n    {\n        log.error(e.getmessage(), e);\n        string message = e.getallerrors().get(0).getdefaultmessage();\n        return ajaxresult.error(message);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n# 3.springmvc-config.xml注入bean\n\n    \x3c!--全局异常处理类--\x3e\n    <bean id="exceptionhandler" class="com.hand.exception.globalexceptionhandler"></bean>\n\n\n1\n2\n\n\n\n# 4.controller添加@validated即可\n\n    @postmapping("/add")\n    @responsebody\n    public ajaxresult addsave(@validated ssmaccount ssmaccount)\n    {\n    }\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"SSM的问题",frontmatter:{title:"SSM的问题",date:"2021-07-24T18:02:06.000Z",permalink:"/pages/1f16ed/",categories:["后端","Spring全家桶","Spring"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/00.Spring/12.SSM%E7%9A%84%E9%97%AE%E9%A2%98.html",relativePath:"01.后端/10.Spring全家桶/00.Spring/12.SSM的问题.md",key:"v-172994e6",path:"/pages/1f16ed/",headers:[{level:2,title:"1.配置了DispatcherServlet静态资源被拦截",slug:"_1-配置了dispatcherservlet静态资源被拦截",normalizedTitle:"1.配置了dispatcherservlet静态资源被拦截",charIndex:13},{level:2,title:"2.AOP拦截controller的请求",slug:"_2-aop拦截controller的请求",normalizedTitle:"2.aop拦截controller的请求",charIndex:224}],headersStr:"1.配置了DispatcherServlet静态资源被拦截 2.AOP拦截controller的请求",content:'# SSM的问题\n\n\n# 1.配置了DispatcherServlet静态资源被拦截\n\nSpringMVC.xml不拦截static下面的静态资源\n\n    \x3c!-- 配置Json注解驱动 --\x3e\n    <mvc:annotation-driven/>\n    \x3c!--静态资源映射--\x3e\n    <mvc:resources location="/static/" mapping="/static/**" />\n\n\n1\n2\n3\n4\n\n\n\n# 2.AOP拦截controller的请求\n\n问题：在Spring的配置文件中配置了AOP的相关配置，始终没法拦截controller的请求\n\n> 原因：\n> \n> 因为Spring的Bean扫描和Spring-MVC的Bean扫描是分开的, 两者的Bean位于两个不同的Application, 而且Spring-MVC的Bean扫描要早于Spring的Bean扫描, 所以当Controller Bean生成完成后, 再执行Spring的Bean扫描,Spring会发现要被AOP代理的Controller Bean已经在容器中存在, 配置AOP就无效了.\n> \n> 同样这样的情况也存在于数据库事务中, 如果Service的Bean扫描配置在spring-mvc.xml中, 而数据库事务管理器配置在application.xml中, 会导致数据库事务失效, 原理一样.\n> \n> 所以这里 ,我们需要把AOP放置在Controller扫描配置的文件中.\n\nSpringMVC的配置：\n\n    \n    \x3c!-- 配置包扫描 @Controller注解类--\x3e\n    <context:component-scan base-package="com.hand.controller"/>\n   \x3c!-- 扫描切面 --\x3e\n    <context:component-scan base-package="com.hand.aspectj" />\n    \x3c!--开启AOP--\x3e\n    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n\n\n1\n2\n3\n4\n5\n6\n7\n',normalizedContent:'# ssm的问题\n\n\n# 1.配置了dispatcherservlet静态资源被拦截\n\nspringmvc.xml不拦截static下面的静态资源\n\n    \x3c!-- 配置json注解驱动 --\x3e\n    <mvc:annotation-driven/>\n    \x3c!--静态资源映射--\x3e\n    <mvc:resources location="/static/" mapping="/static/**" />\n\n\n1\n2\n3\n4\n\n\n\n# 2.aop拦截controller的请求\n\n问题：在spring的配置文件中配置了aop的相关配置，始终没法拦截controller的请求\n\n> 原因：\n> \n> 因为spring的bean扫描和spring-mvc的bean扫描是分开的, 两者的bean位于两个不同的application, 而且spring-mvc的bean扫描要早于spring的bean扫描, 所以当controller bean生成完成后, 再执行spring的bean扫描,spring会发现要被aop代理的controller bean已经在容器中存在, 配置aop就无效了.\n> \n> 同样这样的情况也存在于数据库事务中, 如果service的bean扫描配置在spring-mvc.xml中, 而数据库事务管理器配置在application.xml中, 会导致数据库事务失效, 原理一样.\n> \n> 所以这里 ,我们需要把aop放置在controller扫描配置的文件中.\n\nspringmvc的配置：\n\n    \n    \x3c!-- 配置包扫描 @controller注解类--\x3e\n    <context:component-scan base-package="com.hand.controller"/>\n   \x3c!-- 扫描切面 --\x3e\n    <context:component-scan base-package="com.hand.aspectj" />\n    \x3c!--开启aop--\x3e\n    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n\n\n1\n2\n3\n4\n5\n6\n7\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"SpringSecurity",frontmatter:{title:"SpringSecurity",date:"2021-09-02T16:13:25.000Z",permalink:"/pages/04d292/",categories:["后端","Spring全家桶","Spring"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/00.Spring/20.SpringSecurity.html",relativePath:"01.后端/10.Spring全家桶/00.Spring/20.SpringSecurity.md",key:"v-44e904ad",path:"/pages/04d292/",headers:[{level:2,title:"1.SpringSecurity是干嘛的",slug:"_1-springsecurity是干嘛的",normalizedTitle:"1.springsecurity是干嘛的",charIndex:131},{level:2,title:"2.SSM搭建SpringSecurity入门案例",slug:"_2-ssm搭建springsecurity入门案例",normalizedTitle:"2.ssm搭建springsecurity入门案例",charIndex:245},{level:3,title:"1.首先要有SSM的基础环境",slug:"_1-首先要有ssm的基础环境",normalizedTitle:"1.首先要有ssm的基础环境",charIndex:275},{level:3,title:"2.导入依赖",slug:"_2-导入依赖",normalizedTitle:"2.导入依赖",charIndex:294},{level:3,title:"3.配置web.xml文件",slug:"_3-配置web-xml文件",normalizedTitle:"3.配置web.xml文件",charIndex:667},{level:3,title:"4.配置spring-security.xml",slug:"_4-配置spring-security-xml",normalizedTitle:"4.配置spring-security.xml",charIndex:1459},{level:3,title:"5.spring引入security配置文件",slug:"_5-spring引入security配置文件",normalizedTitle:"5.spring引入security配置文件",charIndex:3520},{level:3,title:"6.启动项目",slug:"_6-启动项目",normalizedTitle:"6.启动项目",charIndex:3643},{level:2,title:"3.spring Security常用过滤器介绍",slug:"_3-spring-security常用过滤器介绍",normalizedTitle:"3.spring security常用过滤器介绍",charIndex:3770},{level:2,title:"4. spring security过滤器链加载原理",slug:"_4-spring-security过滤器链加载原理",normalizedTitle:"4. spring security过滤器链加载原理",charIndex:6086},{level:2,title:"5.使用自定义登录页面",slug:"_5-使用自定义登录页面",normalizedTitle:"5.使用自定义登录页面",charIndex:9432},{level:3,title:"1.方式一：关闭csrf",slug:"_1-方式一-关闭csrf",normalizedTitle:"1.方式一：关闭csrf",charIndex:12827},{level:3,title:"2.方式二：打开csrf，修改登录页面",slug:"_2-方式二-打开csrf-修改登录页面",normalizedTitle:"2.方式二：打开csrf，修改登录页面",charIndex:14293},{level:2,title:"6.注销功能",slug:"_6-注销功能",normalizedTitle:"6.注销功能",charIndex:14752},{level:2,title:"7.自定义认证流程",slug:"_7-自定义认证流程",normalizedTitle:"7.自定义认证流程",charIndex:15079},{level:2,title:"8.使用加密认证",slug:"_8-使用加密认证",normalizedTitle:"8.使用加密认证",charIndex:18141},{level:3,title:"1.注入security的BCryptPasswordEncoder加密工具类",slug:"_1-注入security的bcryptpasswordencoder加密工具类",normalizedTitle:"1.注入security的bcryptpasswordencoder加密工具类",charIndex:18154},{level:3,title:"2.修改认证的方法",slug:"_2-修改认证的方法",normalizedTitle:"2.修改认证的方法",charIndex:19111},{level:3,title:"3.修改用户登录的操作",slug:"_3-修改用户登录的操作",normalizedTitle:"3.修改用户登录的操作",charIndex:20004},{level:3,title:"4.修改数据库的密码",slug:"_4-修改数据库的密码",normalizedTitle:"4.修改数据库的密码",charIndex:20209},{level:2,title:"9.设置用户状态",slug:"_9-设置用户状态",normalizedTitle:"9.设置用户状态",charIndex:20826},{level:2,title:"10.Remember-me",slug:"_10-remember-me",normalizedTitle:"10.remember-me",charIndex:22133},{level:3,title:"1.源码分析",slug:"_1-源码分析",normalizedTitle:"1.源码分析",charIndex:22152}],headersStr:"1.SpringSecurity是干嘛的 2.SSM搭建SpringSecurity入门案例 1.首先要有SSM的基础环境 2.导入依赖 3.配置web.xml文件 4.配置spring-security.xml 5.spring引入security配置文件 6.启动项目 3.spring Security常用过滤器介绍 4. spring security过滤器链加载原理 5.使用自定义登录页面 1.方式一：关闭csrf 2.方式二：打开csrf，修改登录页面 6.注销功能 7.自定义认证流程 8.使用加密认证 1.注入security的BCryptPasswordEncoder加密工具类 2.修改认证的方法 3.修改用户登录的操作 4.修改数据库的密码 9.设置用户状态 10.Remember-me 1.源码分析",content:'> https://www.bilibili.com/video/BV1vt4y1i7zA?from=search&seid=13091247183594790798&spm_id_from=333.337.0.0\n\n\n# SpringSecurity\n\n\n# 1.SpringSecurity是干嘛的\n\nSpring Security是spring采用AOP思想，基于servlet过滤器实现的安全框架。它提供了完善的认证机制和方法级的 授权功能。是一款非常优秀的权限管理框架。\n\n\n# 2.SSM搭建SpringSecurity入门案例\n\n\n# 1.首先要有SSM的基础环境\n\n\n# 2.导入依赖\n\n<dependency>\n    <groupId>org.springframework.security</groupId>\n    <artifactId>spring-security-taglibs</artifactId>\n    <version>5.1.5.RELEASE</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework.security</groupId>\n    <artifactId>spring-security-config</artifactId>\n    <version>5.1.5.RELEASE</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 3.配置web.xml文件\n\n * 配置springSecurity的过滤器\n\n<web-app xmlns="http://java.sun.com/xml/ns/javaee"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee\n    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"\n    version="3.0">\n    <display-name>Archetype Created Web Application</display-name>\n    \x3c!--Spring Security过滤器链，注意过滤器名称必须叫springSecurityFilterChain--\x3e\n    <filter>\n        <filter-name>springSecurityFilterChain</filter-name>\n        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>springSecurityFilterChain</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 4.配置spring-security.xml\n\n * 配置要拦截的url，需要哪些权限\n * security:authentication-manager:固定用户认证信息，通过账号user密码user进行登录\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:security="http://www.springframework.org/schema/security"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context.xsd\n    http://www.springframework.org/schema/aop\n    http://www.springframework.org/schema/aop/spring-aop.xsd\n    http://www.springframework.org/schema/tx\n    http://www.springframework.org/schema/tx/spring-tx.xsd\n    http://www.springframework.org/schema/security\n    http://www.springframework.org/schema/security/spring-security.xsd">\n    \x3c!--设置可以用spring的el表达式配置Spring Security并自动生成对应配置组件（过滤器）--\x3e\n    <security:http auto-config="true" use-expressions="true">\n        \x3c!--使用spring的el表达式来指定项目所有资源访问都必须有ROLE_USER或ROLE_ADMIN角色--\x3e\n        <security:intercept-url pattern="/**" access="hasAnyRole(\'ROLE_USER\',\'ROLE_ADMIN\')"/>\n    </security:http>\n\n    \x3c!--设置Spring Security认证用户信息的来源--\x3e\n    <security:authentication-manager>\n        <security:authentication-provider>\n            <security:user-service>\n                <security:user name="user" password="{noop}user"\n                               authorities="ROLE_USER" />\n                <security:user name="admin" password="{noop}admin"\n                               authorities="ROLE_ADMIN" />\n            </security:user-service>\n        </security:authentication-provider>\n    </security:authentication-manager>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 5.spring引入security配置文件\n\n    \x3c!--引入SpringSecurity主配置文件--\x3e\n    <import resource="classpath:spring-security.xml"/>\n\n\n1\n2\n\n\n\n# 6.启动项目\n\n好了！开始启动项目了，万众期待看到index.jsp中的内容！\n\n> 会被拦截，跳转到security自带的登录页面\n> \n> 我们在这个登录页面上输入用户名user，密码user，点击Sign in，好了，总算再次看到首页了！\n\n\n# 3.spring Security常用过滤器介绍\n\n过滤器是一种典型的AOP思想，关于什么是过滤器，就不赘述了，谁还不知道凡是web工程都能用过滤器？ 接下来咱们就一起看看Spring Security中这些过滤器都是干啥用的，源码我就不贴出来了，有名字，大家可以自 己在idea中Double Shift去。我也会在后续的学习过程中穿插详细解释。\n\n 1.  org.springframework.security.web.context.SecurityContextPersistenceFilter 首当其冲的一个过滤器，作用之重要，自不必多言。 SecurityContextPersistenceFilter主要是使用SecurityContextRepository在session中保存或更新一个 SecurityContext，并将SecurityContext给以后的过滤器使用，来为后续filter建立所需的上下文。 SecurityContext中存储了当前用户的认证以及权限信息。\n 2.  org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter 此过滤器用于集成SecurityContext到Spring异步执行机制中的WebAsyncManager\n 3.  org.springframework.security.web.header.HeaderWriterFilter 向请求的Header中添加相应的信息,可在http标签内部使用security:headers来控制\n 4.  org.springframework.security.web.csrf.CsrfFilter csrf又称跨域请求伪造，SpringSecurity会对所有post请求验证是否包含系统生成的csrf的token信息， 如果不包含，则报错。起到防止csrf攻击的效果。\n 5.  org.springframework.security.web.authentication.logout.LogoutFilter 匹配URL为/logout的请求，实现用户退出,清除认证信息。\n 6.  org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter 认证操作全靠这个过滤器，默认匹配URL为/login且必须为POST请求。\n 7.  org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter 如果没有在配置文件中指定认证页面，则由该过滤器生成一个默认认证页面。\n 8.  org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter 由此过滤器可以生产一个默认的退出登录页面\n 9.  org.springframework.security.web.authentication.www.BasicAuthenticationFilter 此过滤器会自动解析HTTP请求中头部名字为Authentication，且以Basic开头的头信息。\n 10. org.springframework.security.web.savedrequest.RequestCacheAwareFilter 通过HttpSessionRequestCache内部维护了一个RequestCache，用于缓存HttpServletRequest\n 11. org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter 针对ServletRequest进行了一次包装，使得request具有更加丰富的API\n 12. org.springframework.security.web.authentication.AnonymousAuthenticationFilter 当SecurityContextHolder中认证信息为空,则会创建一个匿名用户存入到SecurityContextHolder中。 spring security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。\n 13. org.springframework.security.web.session.SessionManagementFilter SecurityContextRepository限制同一用户开启多个会话的数量\n 14. org.springframework.security.web.access.ExceptionTranslationFilter 异常转换过滤器位于整个springSecurityFilterChain的后方，用来转换整个链路中出现的异常\n 15. org.springframework.security.web.access.intercept.FilterSecurityInterceptor 获取所配置资源访问的授权信息，根据SecurityContextHolder中存储的用户信息来决定其是否有权 限。\n\n\n# 4. spring security过滤器链加载原理\n\n 1. 根据web.xml文件中配置的security的org.springframework.web.filter.DelegatingFilterProxy过滤器\n\n 2. 找到DelegatingFilterProxy该类的doFilter方法this.initDelegate(wac);\n    \n        public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n            Filter delegateToUse = this.delegate;\n            if (delegateToUse == null) {\n                synchronized(this.delegateMonitor) {\n                    delegateToUse = this.delegate;\n                    if (delegateToUse == null) {\n                        WebApplicationContext wac = this.findWebApplicationContext();\n                        if (wac == null) {\n                            throw new IllegalStateException("No WebApplicationContext found: no ContextLoaderListener or DispatcherServlet registered?");\n                        }\n    \t\t\t\t\t//初始化过滤器\n                        delegateToUse = this.initDelegate(wac);\n                    }\n    \n                    this.delegate = delegateToUse;\n                }\n            }\n    \n            this.invokeDelegate(delegateToUse, request, response, filterChain);\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n 3. Filter delegate = (Filter)wac.getBean(targetBeanName, Filter.class);获取了一个Filter\n    \n        protected Filter initDelegate(WebApplicationContext wac) throws ServletException {\n            String targetBeanName = this.getTargetBeanName();\n            Assert.state(targetBeanName != null, "No target bean name set");\n            Filter delegate = (Filter)wac.getBean(targetBeanName, Filter.class);\n            if (this.isTargetFilterLifecycle()) {\n                delegate.init(this.getFilterConfig());\n            }\n    \n            return delegate;\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 4. 打个断电\n    \n    \n\n 5. idea搜索org.springframework.security.filterChainProxy\n    \n        private void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n            FirewalledRequest fwRequest = this.firewall.getFirewalledRequest((HttpServletRequest)request);\n            HttpServletResponse fwResponse = this.firewall.getFirewalledResponse((HttpServletResponse)response);\n            //获取所有的过滤器\n            List<Filter> filters = this.getFilters((HttpServletRequest)fwRequest);\n            if (filters != null && filters.size() != 0) {\n                FilterChainProxy.VirtualFilterChain vfc = new FilterChainProxy.VirtualFilterChain(fwRequest, chain, filters);\n                vfc.doFilter(fwRequest, fwResponse);\n            } else {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(UrlUtils.buildRequestUrl(fwRequest) + (filters == null ? " has no matching filters" : " has an empty filter list"));\n                }\n    \n                fwRequest.reset();\n                chain.doFilter(fwRequest, fwResponse);\n            }\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n    \n        //每个过滤器都放在filterChains中\n        private List<SecurityFilterChain> filterChains;\n    \n    \n    1\n    2\n    \n\n\n# 5.使用自定义登录页面\n\n修改spring-security.xml配置文件\n\n * 静态资源不被security拦截\n * login.jsp页面不被security拦截\n * 配置登录相关配置\n * 配置登出相关配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:security="http://www.springframework.org/schema/security"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context.xsd\n    http://www.springframework.org/schema/aop\n    http://www.springframework.org/schema/aop/spring-aop.xsd\n    http://www.springframework.org/schema/tx\n    http://www.springframework.org/schema/tx/spring-tx.xsd\n    http://www.springframework.org/schema/security\n    http://www.springframework.org/schema/security/spring-security.xsd">\n\n    \x3c!--直接释放无需经过SpringSecurity过滤器的静态资源--\x3e\n    <security:http pattern="/css/**" security="none"/>\n    <security:http pattern="/img/**" security="none"/>\n    <security:http pattern="/plugins/**" security="none"/>\n    <security:http pattern="/failer.jsp" security="none"/>\n    <security:http pattern="/favicon.ico" security="none"/>\n\n\n    \x3c!--设置可以用spring的el表达式配置Spring Security并自动生成对应配置组件（过滤器）--\x3e\n    <security:http auto-config="true" use-expressions="true">\n        \x3c!--指定login.jsp页面可以被匿名访问--\x3e\n        <security:intercept-url pattern="/login.jsp" access="permitAll()"></security:intercept-url>\n\n        \x3c!--使用spring的el表达式来指定项目所有资源访问都必须有ROLE_USER或ROLE_ADMIN角色--\x3e\n        <security:intercept-url pattern="/**" access="hasAnyRole(\'ROLE_USER\')"/>\n\n        \x3c!--指定自定义的认证页面\n            1.login-page="login.jsp"自定义登录页面\n            2.login-processing-url="/login"登录处理的controller请求\n            3.default-target-url="/index.jsp"登陆成功跳转默认页面\n            4.authentication-failure-url="/failer.jsp"没有权限跳转页面\n        --\x3e\n        <security:form-login login-page="/login.jsp"\n            login-processing-url="/login"\n            default-target-url="/index.jsp"\n            authentication-failure-url="/failer.jsp"></security:form-login>\n\n        \x3c!--指定退出登录后跳转的页面\n            1.logout-url="/logout"退出处理的controller请求\n            2.logout-success-url="login.jsp"退出后跳转页面\n        --\x3e\n        <security:logout logout-url="/logout"\n            logout-success-url="/login.jsp"></security:logout>\n    </security:http>\n\n    \x3c!--设置Spring Security认证用户信息的来源--\x3e\n    <security:authentication-manager>\n        <security:authentication-provider>\n            <security:user-service>\n                <security:user name="user" password="{noop}user"\n                               authorities="ROLE_USER" />\n                <security:user name="admin" password="{noop}admin"\n                               authorities="ROLE_ADMIN" />\n            </security:user-service>\n        </security:authentication-provider>\n    </security:authentication-manager>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n启动上方配置依然没有办法登录成功\n\n所有的post、put、delete请求都会被csrf拦截，必须附带csrf\n\n\n# 1.方式一：关闭csrf\n\n 1. 修改登录页面的表单处理action\n    \n    <form action="${pageContext.request.contextPath}/login" method="post">\n    \n    \n    1\n    \n\n 2. 关闭csrf\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:security="http://www.springframework.org/schema/security"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context.xsd\n    http://www.springframework.org/schema/aop\n    http://www.springframework.org/schema/aop/spring-aop.xsd\n    http://www.springframework.org/schema/tx\n    http://www.springframework.org/schema/tx/spring-tx.xsd\n    http://www.springframework.org/schema/security\n    http://www.springframework.org/schema/security/spring-security.xsd">\n    \n    \x3c!--设置可以用spring的el表达式配置Spring Security并自动生成对应配置组件（过滤器）--\x3e\n    <security:http auto-config="true" use-expressions="true">\n        \x3c!--关闭csrf--\x3e\n        <security:csrf disabled="true"></security:csrf>\n    </security:http>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.方式二：打开csrf，修改登录页面\n\n 1. 打开csrf校验\n\n 2. 登录页面添加csf的input框\n    \n    \n    <%@taglib uri="http://www.springframework.org/security/tags" prefix="security"%>\n    \t\t\x3c!-- /.login-logo --\x3e\n    \t\t<div class="login-box-body">\n    \t\t\t<p class="login-box-msg">登录系统</p>\n    \t\t\t<form action="${pageContext.request.contextPath}/login" method="post">\n    \t\t\t\t\x3c!--添加csrf input框--\x3e\n    \t\t\t\t<security:csrfInput/>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n\n# 6.注销功能\n\n> 由于开启了csrf，secitity认为logout也应该被csrf校验，所以注销功能也需要为post请求\n\n登出页面：\n\n\x3c!--引入csrf标签库--\x3e\n<%@taglib uri="http://www.springframework.org/security/tags" prefix="security"%>\n<form action="${pageContext.request.contextPath}/logout" method="post">\n\t<security:csrfInput/>\n\t<button type="submit">注销</button>\n</form>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 7.自定义认证流程\n\n 1. 实现UserDetailsService接口即可\n    \n    * 查询该用户\n    * 获取所有的角色\n    * 使用非加密的密码\n    \n    package com.itheima.service.impl;\n    \n    import com.itheima.dao.UserDao;\n    import com.itheima.domain.SysRole;\n    import com.itheima.domain.SysUser;\n    import com.itheima.service.RoleService;\n    import com.itheima.service.UserService;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.security.core.GrantedAuthority;\n    import org.springframework.security.core.authority.SimpleGrantedAuthority;\n    import org.springframework.security.core.userdetails.User;\n    import org.springframework.security.core.userdetails.UserDetails;\n    import org.springframework.security.core.userdetails.UsernameNotFoundException;\n    import org.springframework.stereotype.Service;\n    import org.springframework.transaction.annotation.Transactional;\n    \n    import java.util.*;\n    \n    @Service\n    @Transactional\n    public class UserServiceImpl implements UserService {\n        @Autowired\n        private UserDao userDao;\n        /**\n         * secutiry的认证方法\n         * @param username\n         * @return\n         * @throws UsernameNotFoundException\n         */\n        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n            SysUser user = userDao.findByName(username);\n            if(user == null){\n                //若用户名不对，直接返回null，表示认证失败。\n                return null;\n            }else{\n                List<SimpleGrantedAuthority> authorities=new ArrayList<SimpleGrantedAuthority>();\n                for(SysRole role:user.getRoles()){\n                    authorities.add(new SimpleGrantedAuthority(role.getRoleName()));\n                }\n                //最终需要返回一个SpringSecurity的UserDetails对象，{noop}表示不加密认证。\n                UserDetails userDetails=new User(username,"{noop}"+user.getPassword(),authorities);\n                return userDetails;\n            }\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    \n\n 2. security配置自定义的userService\n    \n        \x3c!--设置Spring Security认证用户信息的来源--\x3e\n        <security:authentication-manager>\n            <security:authentication-provider user-service-ref="userServiceImpl">\n    \x3c!--            <security:user-service>--\x3e\n    \x3c!--                <security:user name="user" password="{noop}user"--\x3e\n    \x3c!--                               authorities="ROLE_USER" />--\x3e\n    \x3c!--                <security:user name="admin" password="{noop}admin"--\x3e\n    \x3c!--                               authorities="ROLE_ADMIN" />--\x3e\n    \x3c!--            </security:user-service>--\x3e\n            </security:authentication-provider>\n        </security:authentication-manager>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n\n# 8.使用加密认证\n\n\n# 1.注入security的BCryptPasswordEncoder加密工具类\n\n    \x3c!--security内置的加密工具类--\x3e\n    <bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"></bean>\n\n    \x3c!--设置Spring Security认证用户信息的来源--\x3e\n    <security:authentication-manager>\n        <security:authentication-provider user-service-ref="userServiceImpl">\n            \x3c!--使用security内置的加密工具类--\x3e\n            <security:password-encoder ref="passwordEncoder"></security:password-encoder>\n\x3c!--            <security:user-service>--\x3e\n\x3c!--                <security:user name="user" password="{noop}user"--\x3e\n\x3c!--                               authorities="ROLE_USER" />--\x3e\n\x3c!--                <security:user name="admin" password="{noop}admin"--\x3e\n\x3c!--                               authorities="ROLE_ADMIN" />--\x3e\n\x3c!--            </security:user-service>--\x3e\n        </security:authentication-provider>\n    </security:authentication-manager>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2.修改认证的方法\n\n    /**\n     * secutiry的认证方法\n     * @param username\n     * @return\n     * @throws UsernameNotFoundException\n     */\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        SysUser user = userDao.findByName(username);\n        if(user == null){\n            //若用户名不对，直接返回null，表示认证失败。\n            return null;\n        }else{\n            List<SimpleGrantedAuthority> authorities=new ArrayList<SimpleGrantedAuthority>();\n            for(SysRole role:user.getRoles()){\n                authorities.add(new SimpleGrantedAuthority(role.getRoleName()));\n            }\n            //最终需要返回一个SpringSecurity的UserDetails对象，{noop}表示不加密认证。\n            UserDetails userDetails=new User(username,user.getPassword(),authorities);\n            return userDetails;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 3.修改用户登录的操作\n\n    @Override\n    public void save(SysUser user) {\n        //保存加密的密码\n        user.setPassword(passwordEncoder.encode(user.getPassword()));\n        userDao.save(user);\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.修改数据库的密码\n\n自己写个测试类，修改数据库的密码\n\n    /**\n     * 每次运行密码都不相同\n     * $2a$10$Swune4iLf8rJx1WNFgUzB.WCqZ2I3Gvg5jX53DVxRU6f.U9YLrMOW\n     * $2a$10$EW4sTDUrDhXZxE5LoEgypOINOFXie9TDKS4iTkZ20Qn4FMaln3l4u\n     * $2a$10$KaskTciynULoM75HyE72VersiOQmuQ0CKKX6qLX8o13.Y0bXbKe3m\n     * @param args\n     */\n    public static void main(String[] args) {\n        BCryptPasswordEncoder encoder=new BCryptPasswordEncoder();\n        System.out.println(encoder.encode("123456"));\n        System.out.println(encoder.matches("123456","$2a$10$KaskTciynULoM75HyE72VersiOQmuQ0CKKX6qLX8o13.Y0bXbKe3m"));\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n\n# 9.设置用户状态\n\n用户认证时封装的UserDetails对应的User的构造方法支持设置用户状态\n\n * enabled：是否开启\n * accountNonExpired：账户是否失效\n * credentialsNonExpired：密码是否失效\n * accountNonLocked：账户是否被锁定\n\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        SysUser user = userDao.findByName(username);\n        if(user == null){\n            //若用户名不对，直接返回null，表示认证失败。\n            return null;\n        }else{\n            List<SimpleGrantedAuthority> authorities=new ArrayList<SimpleGrantedAuthority>();\n            for(SysRole role:user.getRoles()){\n                authorities.add(new SimpleGrantedAuthority(role.getRoleName()));\n            }\n            //最终需要返回一个SpringSecurity的UserDetails对象，{noop}表示不加密认证。\n            UserDetails userDetails=new User(username,\n                    user.getPassword(),\n                    authorities);\n            return userDetails;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n修改：\n\n            //最终需要返回一个SpringSecurity的UserDetails对象，{noop}表示不加密认证。\n            UserDetails userDetails=new User(username,\n                    user.getPassword(),\n                    user.getStatus()==1,//是否启用\n                    true,  //账户是否失效\n                    true,//密码是否失效\n                    true,//账户是否被锁定\n                    authorities);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 10.Remember-me\n\n\n# 1.源码分析\n\n1.springSecurity都是通过过滤器实现的，查看RememberMeAuthenticationFilter类\n\npublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\t\tHttpServletRequest request = (HttpServletRequest) req;\n\t\tHttpServletResponse response = (HttpServletResponse) res;\n\t\t\n\t\tif (SecurityContextHolder.getContext().getAuthentication() == null) \n\t\t\t//读取是否开启了记住我功能\n\t\t\tAuthentication rememberMeAuth = rememberMeServices.autoLogin(request,\n\t\t\t\t\tresponse);\n\n\t\t\tif (rememberMeAuth != null) {\n\t\t\t\t// Attempt authenticaton via AuthenticationManager\n\t\t\t\ttry {\n\t\t\t\t\t//模拟登陆\n\t\t\t\t\trememberMeAuth = authenticationManager.authenticate(rememberMeAuth);\n\n\t\t\t\t\t// Store to SecurityContextHolder\n\t\t\t\t\tSecurityContextHolder.getContext().setAuthentication(rememberMeAuth);\n\n\t\t\t\t\tonSuccessfulAuthentication(request, response, rememberMeAuth);\n\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug("SecurityContextHolder populated with remember-me token: \'"\n\t\t\t\t\t\t\t\t+ SecurityContextHolder.getContext().getAuthentication()\n\t\t\t\t\t\t\t\t+ "\'");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fire event\n\t\t\t\t\tif (this.eventPublisher != null) {\n\t\t\t\t\t\teventPublisher\n\t\t\t\t\t\t\t\t.publishEvent(new InteractiveAuthenticationSuccessEvent(\n\t\t\t\t\t\t\t\t\t\tSecurityContextHolder.getContext()\n\t\t\t\t\t\t\t\t\t\t\t\t.getAuthentication(), this.getClass()));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (successHandler != null) {\n\t\t\t\t\t\tsuccessHandler.onAuthenticationSuccess(request, response,\n\t\t\t\t\t\t\t\trememberMeAuth);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tcatch (AuthenticationException authenticationException) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t"SecurityContextHolder not populated with remember-me token, as "\n\t\t\t\t\t\t\t\t\t\t+ "AuthenticationManager rejected Authentication returned by RememberMeServices: \'"\n\t\t\t\t\t\t\t\t\t\t+ rememberMeAuth\n\t\t\t\t\t\t\t\t\t\t+ "\'; invalidating remember-me token",\n\t\t\t\t\t\t\t\tauthenticationException);\n\t\t\t\t\t}\n\n\t\t\t\t\trememberMeServices.loginFail(request, response);\n\n\t\t\t\t\tonUnsuccessfulAuthentication(request, response,\n\t\t\t\t\t\t\tauthenticationException);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchain.doFilter(request, response);\n\t\t}\n\t\telse {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug("SecurityContextHolder not populated with remember-me token, as it already contained: \'"\n\t\t\t\t\t\t+ SecurityContextHolder.getContext().getAuthentication() + "\'");\n\t\t\t}\n\n\t\t\tchain.doFilter(request, response);\n\t\t}\n\t}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n2.rememberMeServices.autoLogin(request,response)方法\n\npublic final Authentication autoLogin(HttpServletRequest request,\n\t\t\tHttpServletResponse response) {\n\t\tString rememberMeCookie = extractRememberMeCookie(request);\n\t\t//判断是否有cookie\n\t\tif (rememberMeCookie == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlogger.debug("Remember-me cookie detected");\n\n\t\tif (rememberMeCookie.length() == 0) {\n\t\t\tlogger.debug("Cookie was empty");\n\t\t\tcancelCookie(request, response);\n\t\t\treturn null;\n\t\t}\n\n\t\tUserDetails user = null;\n\n\t\ttry {\n\t\t\tString[] cookieTokens = decodeCookie(rememberMeCookie);\n\t\t\tuser = processAutoLoginCookie(cookieTokens, request, response);\n\t\t\tuserDetailsChecker.check(user);\n\n\t\t\tlogger.debug("Remember-me cookie accepted");\n\n\t\t\treturn createSuccessfulAuthentication(request, user);\n\t\t}\n\n\t\tcancelCookie(request, response);\n\t\treturn null;\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n',normalizedContent:'> https://www.bilibili.com/video/bv1vt4y1i7za?from=search&seid=13091247183594790798&spm_id_from=333.337.0.0\n\n\n# springsecurity\n\n\n# 1.springsecurity是干嘛的\n\nspring security是spring采用aop思想，基于servlet过滤器实现的安全框架。它提供了完善的认证机制和方法级的 授权功能。是一款非常优秀的权限管理框架。\n\n\n# 2.ssm搭建springsecurity入门案例\n\n\n# 1.首先要有ssm的基础环境\n\n\n# 2.导入依赖\n\n<dependency>\n    <groupid>org.springframework.security</groupid>\n    <artifactid>spring-security-taglibs</artifactid>\n    <version>5.1.5.release</version>\n</dependency>\n<dependency>\n    <groupid>org.springframework.security</groupid>\n    <artifactid>spring-security-config</artifactid>\n    <version>5.1.5.release</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 3.配置web.xml文件\n\n * 配置springsecurity的过滤器\n\n<web-app xmlns="http://java.sun.com/xml/ns/javaee"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xsi:schemalocation="http://java.sun.com/xml/ns/javaee\n    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"\n    version="3.0">\n    <display-name>archetype created web application</display-name>\n    \x3c!--spring security过滤器链，注意过滤器名称必须叫springsecurityfilterchain--\x3e\n    <filter>\n        <filter-name>springsecurityfilterchain</filter-name>\n        <filter-class>org.springframework.web.filter.delegatingfilterproxy</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>springsecurityfilterchain</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 4.配置spring-security.xml\n\n * 配置要拦截的url，需要哪些权限\n * security:authentication-manager:固定用户认证信息，通过账号user密码user进行登录\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:security="http://www.springframework.org/schema/security"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context.xsd\n    http://www.springframework.org/schema/aop\n    http://www.springframework.org/schema/aop/spring-aop.xsd\n    http://www.springframework.org/schema/tx\n    http://www.springframework.org/schema/tx/spring-tx.xsd\n    http://www.springframework.org/schema/security\n    http://www.springframework.org/schema/security/spring-security.xsd">\n    \x3c!--设置可以用spring的el表达式配置spring security并自动生成对应配置组件（过滤器）--\x3e\n    <security:http auto-config="true" use-expressions="true">\n        \x3c!--使用spring的el表达式来指定项目所有资源访问都必须有role_user或role_admin角色--\x3e\n        <security:intercept-url pattern="/**" access="hasanyrole(\'role_user\',\'role_admin\')"/>\n    </security:http>\n\n    \x3c!--设置spring security认证用户信息的来源--\x3e\n    <security:authentication-manager>\n        <security:authentication-provider>\n            <security:user-service>\n                <security:user name="user" password="{noop}user"\n                               authorities="role_user" />\n                <security:user name="admin" password="{noop}admin"\n                               authorities="role_admin" />\n            </security:user-service>\n        </security:authentication-provider>\n    </security:authentication-manager>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 5.spring引入security配置文件\n\n    \x3c!--引入springsecurity主配置文件--\x3e\n    <import resource="classpath:spring-security.xml"/>\n\n\n1\n2\n\n\n\n# 6.启动项目\n\n好了！开始启动项目了，万众期待看到index.jsp中的内容！\n\n> 会被拦截，跳转到security自带的登录页面\n> \n> 我们在这个登录页面上输入用户名user，密码user，点击sign in，好了，总算再次看到首页了！\n\n\n# 3.spring security常用过滤器介绍\n\n过滤器是一种典型的aop思想，关于什么是过滤器，就不赘述了，谁还不知道凡是web工程都能用过滤器？ 接下来咱们就一起看看spring security中这些过滤器都是干啥用的，源码我就不贴出来了，有名字，大家可以自 己在idea中double shift去。我也会在后续的学习过程中穿插详细解释。\n\n 1.  org.springframework.security.web.context.securitycontextpersistencefilter 首当其冲的一个过滤器，作用之重要，自不必多言。 securitycontextpersistencefilter主要是使用securitycontextrepository在session中保存或更新一个 securitycontext，并将securitycontext给以后的过滤器使用，来为后续filter建立所需的上下文。 securitycontext中存储了当前用户的认证以及权限信息。\n 2.  org.springframework.security.web.context.request.async.webasyncmanagerintegrationfilter 此过滤器用于集成securitycontext到spring异步执行机制中的webasyncmanager\n 3.  org.springframework.security.web.header.headerwriterfilter 向请求的header中添加相应的信息,可在http标签内部使用security:headers来控制\n 4.  org.springframework.security.web.csrf.csrffilter csrf又称跨域请求伪造，springsecurity会对所有post请求验证是否包含系统生成的csrf的token信息， 如果不包含，则报错。起到防止csrf攻击的效果。\n 5.  org.springframework.security.web.authentication.logout.logoutfilter 匹配url为/logout的请求，实现用户退出,清除认证信息。\n 6.  org.springframework.security.web.authentication.usernamepasswordauthenticationfilter 认证操作全靠这个过滤器，默认匹配url为/login且必须为post请求。\n 7.  org.springframework.security.web.authentication.ui.defaultloginpagegeneratingfilter 如果没有在配置文件中指定认证页面，则由该过滤器生成一个默认认证页面。\n 8.  org.springframework.security.web.authentication.ui.defaultlogoutpagegeneratingfilter 由此过滤器可以生产一个默认的退出登录页面\n 9.  org.springframework.security.web.authentication.www.basicauthenticationfilter 此过滤器会自动解析http请求中头部名字为authentication，且以basic开头的头信息。\n 10. org.springframework.security.web.savedrequest.requestcacheawarefilter 通过httpsessionrequestcache内部维护了一个requestcache，用于缓存httpservletrequest\n 11. org.springframework.security.web.servletapi.securitycontextholderawarerequestfilter 针对servletrequest进行了一次包装，使得request具有更加丰富的api\n 12. org.springframework.security.web.authentication.anonymousauthenticationfilter 当securitycontextholder中认证信息为空,则会创建一个匿名用户存入到securitycontextholder中。 spring security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。\n 13. org.springframework.security.web.session.sessionmanagementfilter securitycontextrepository限制同一用户开启多个会话的数量\n 14. org.springframework.security.web.access.exceptiontranslationfilter 异常转换过滤器位于整个springsecurityfilterchain的后方，用来转换整个链路中出现的异常\n 15. org.springframework.security.web.access.intercept.filtersecurityinterceptor 获取所配置资源访问的授权信息，根据securitycontextholder中存储的用户信息来决定其是否有权 限。\n\n\n# 4. spring security过滤器链加载原理\n\n 1. 根据web.xml文件中配置的security的org.springframework.web.filter.delegatingfilterproxy过滤器\n\n 2. 找到delegatingfilterproxy该类的dofilter方法this.initdelegate(wac);\n    \n        public void dofilter(servletrequest request, servletresponse response, filterchain filterchain) throws servletexception, ioexception {\n            filter delegatetouse = this.delegate;\n            if (delegatetouse == null) {\n                synchronized(this.delegatemonitor) {\n                    delegatetouse = this.delegate;\n                    if (delegatetouse == null) {\n                        webapplicationcontext wac = this.findwebapplicationcontext();\n                        if (wac == null) {\n                            throw new illegalstateexception("no webapplicationcontext found: no contextloaderlistener or dispatcherservlet registered?");\n                        }\n    \t\t\t\t\t//初始化过滤器\n                        delegatetouse = this.initdelegate(wac);\n                    }\n    \n                    this.delegate = delegatetouse;\n                }\n            }\n    \n            this.invokedelegate(delegatetouse, request, response, filterchain);\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n 3. filter delegate = (filter)wac.getbean(targetbeanname, filter.class);获取了一个filter\n    \n        protected filter initdelegate(webapplicationcontext wac) throws servletexception {\n            string targetbeanname = this.gettargetbeanname();\n            assert.state(targetbeanname != null, "no target bean name set");\n            filter delegate = (filter)wac.getbean(targetbeanname, filter.class);\n            if (this.istargetfilterlifecycle()) {\n                delegate.init(this.getfilterconfig());\n            }\n    \n            return delegate;\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 4. 打个断电\n    \n    \n\n 5. idea搜索org.springframework.security.filterchainproxy\n    \n        private void dofilterinternal(servletrequest request, servletresponse response, filterchain chain) throws ioexception, servletexception {\n            firewalledrequest fwrequest = this.firewall.getfirewalledrequest((httpservletrequest)request);\n            httpservletresponse fwresponse = this.firewall.getfirewalledresponse((httpservletresponse)response);\n            //获取所有的过滤器\n            list<filter> filters = this.getfilters((httpservletrequest)fwrequest);\n            if (filters != null && filters.size() != 0) {\n                filterchainproxy.virtualfilterchain vfc = new filterchainproxy.virtualfilterchain(fwrequest, chain, filters);\n                vfc.dofilter(fwrequest, fwresponse);\n            } else {\n                if (logger.isdebugenabled()) {\n                    logger.debug(urlutils.buildrequesturl(fwrequest) + (filters == null ? " has no matching filters" : " has an empty filter list"));\n                }\n    \n                fwrequest.reset();\n                chain.dofilter(fwrequest, fwresponse);\n            }\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n    \n        //每个过滤器都放在filterchains中\n        private list<securityfilterchain> filterchains;\n    \n    \n    1\n    2\n    \n\n\n# 5.使用自定义登录页面\n\n修改spring-security.xml配置文件\n\n * 静态资源不被security拦截\n * login.jsp页面不被security拦截\n * 配置登录相关配置\n * 配置登出相关配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:security="http://www.springframework.org/schema/security"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context.xsd\n    http://www.springframework.org/schema/aop\n    http://www.springframework.org/schema/aop/spring-aop.xsd\n    http://www.springframework.org/schema/tx\n    http://www.springframework.org/schema/tx/spring-tx.xsd\n    http://www.springframework.org/schema/security\n    http://www.springframework.org/schema/security/spring-security.xsd">\n\n    \x3c!--直接释放无需经过springsecurity过滤器的静态资源--\x3e\n    <security:http pattern="/css/**" security="none"/>\n    <security:http pattern="/img/**" security="none"/>\n    <security:http pattern="/plugins/**" security="none"/>\n    <security:http pattern="/failer.jsp" security="none"/>\n    <security:http pattern="/favicon.ico" security="none"/>\n\n\n    \x3c!--设置可以用spring的el表达式配置spring security并自动生成对应配置组件（过滤器）--\x3e\n    <security:http auto-config="true" use-expressions="true">\n        \x3c!--指定login.jsp页面可以被匿名访问--\x3e\n        <security:intercept-url pattern="/login.jsp" access="permitall()"></security:intercept-url>\n\n        \x3c!--使用spring的el表达式来指定项目所有资源访问都必须有role_user或role_admin角色--\x3e\n        <security:intercept-url pattern="/**" access="hasanyrole(\'role_user\')"/>\n\n        \x3c!--指定自定义的认证页面\n            1.login-page="login.jsp"自定义登录页面\n            2.login-processing-url="/login"登录处理的controller请求\n            3.default-target-url="/index.jsp"登陆成功跳转默认页面\n            4.authentication-failure-url="/failer.jsp"没有权限跳转页面\n        --\x3e\n        <security:form-login login-page="/login.jsp"\n            login-processing-url="/login"\n            default-target-url="/index.jsp"\n            authentication-failure-url="/failer.jsp"></security:form-login>\n\n        \x3c!--指定退出登录后跳转的页面\n            1.logout-url="/logout"退出处理的controller请求\n            2.logout-success-url="login.jsp"退出后跳转页面\n        --\x3e\n        <security:logout logout-url="/logout"\n            logout-success-url="/login.jsp"></security:logout>\n    </security:http>\n\n    \x3c!--设置spring security认证用户信息的来源--\x3e\n    <security:authentication-manager>\n        <security:authentication-provider>\n            <security:user-service>\n                <security:user name="user" password="{noop}user"\n                               authorities="role_user" />\n                <security:user name="admin" password="{noop}admin"\n                               authorities="role_admin" />\n            </security:user-service>\n        </security:authentication-provider>\n    </security:authentication-manager>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n启动上方配置依然没有办法登录成功\n\n所有的post、put、delete请求都会被csrf拦截，必须附带csrf\n\n\n# 1.方式一：关闭csrf\n\n 1. 修改登录页面的表单处理action\n    \n    <form action="${pagecontext.request.contextpath}/login" method="post">\n    \n    \n    1\n    \n\n 2. 关闭csrf\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:security="http://www.springframework.org/schema/security"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context.xsd\n    http://www.springframework.org/schema/aop\n    http://www.springframework.org/schema/aop/spring-aop.xsd\n    http://www.springframework.org/schema/tx\n    http://www.springframework.org/schema/tx/spring-tx.xsd\n    http://www.springframework.org/schema/security\n    http://www.springframework.org/schema/security/spring-security.xsd">\n    \n    \x3c!--设置可以用spring的el表达式配置spring security并自动生成对应配置组件（过滤器）--\x3e\n    <security:http auto-config="true" use-expressions="true">\n        \x3c!--关闭csrf--\x3e\n        <security:csrf disabled="true"></security:csrf>\n    </security:http>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.方式二：打开csrf，修改登录页面\n\n 1. 打开csrf校验\n\n 2. 登录页面添加csf的input框\n    \n    \n    <%@taglib uri="http://www.springframework.org/security/tags" prefix="security"%>\n    \t\t\x3c!-- /.login-logo --\x3e\n    \t\t<div class="login-box-body">\n    \t\t\t<p class="login-box-msg">登录系统</p>\n    \t\t\t<form action="${pagecontext.request.contextpath}/login" method="post">\n    \t\t\t\t\x3c!--添加csrf input框--\x3e\n    \t\t\t\t<security:csrfinput/>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n\n# 6.注销功能\n\n> 由于开启了csrf，secitity认为logout也应该被csrf校验，所以注销功能也需要为post请求\n\n登出页面：\n\n\x3c!--引入csrf标签库--\x3e\n<%@taglib uri="http://www.springframework.org/security/tags" prefix="security"%>\n<form action="${pagecontext.request.contextpath}/logout" method="post">\n\t<security:csrfinput/>\n\t<button type="submit">注销</button>\n</form>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 7.自定义认证流程\n\n 1. 实现userdetailsservice接口即可\n    \n    * 查询该用户\n    * 获取所有的角色\n    * 使用非加密的密码\n    \n    package com.itheima.service.impl;\n    \n    import com.itheima.dao.userdao;\n    import com.itheima.domain.sysrole;\n    import com.itheima.domain.sysuser;\n    import com.itheima.service.roleservice;\n    import com.itheima.service.userservice;\n    import org.springframework.beans.factory.annotation.autowired;\n    import org.springframework.security.core.grantedauthority;\n    import org.springframework.security.core.authority.simplegrantedauthority;\n    import org.springframework.security.core.userdetails.user;\n    import org.springframework.security.core.userdetails.userdetails;\n    import org.springframework.security.core.userdetails.usernamenotfoundexception;\n    import org.springframework.stereotype.service;\n    import org.springframework.transaction.annotation.transactional;\n    \n    import java.util.*;\n    \n    @service\n    @transactional\n    public class userserviceimpl implements userservice {\n        @autowired\n        private userdao userdao;\n        /**\n         * secutiry的认证方法\n         * @param username\n         * @return\n         * @throws usernamenotfoundexception\n         */\n        public userdetails loaduserbyusername(string username) throws usernamenotfoundexception {\n            sysuser user = userdao.findbyname(username);\n            if(user == null){\n                //若用户名不对，直接返回null，表示认证失败。\n                return null;\n            }else{\n                list<simplegrantedauthority> authorities=new arraylist<simplegrantedauthority>();\n                for(sysrole role:user.getroles()){\n                    authorities.add(new simplegrantedauthority(role.getrolename()));\n                }\n                //最终需要返回一个springsecurity的userdetails对象，{noop}表示不加密认证。\n                userdetails userdetails=new user(username,"{noop}"+user.getpassword(),authorities);\n                return userdetails;\n            }\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    \n\n 2. security配置自定义的userservice\n    \n        \x3c!--设置spring security认证用户信息的来源--\x3e\n        <security:authentication-manager>\n            <security:authentication-provider user-service-ref="userserviceimpl">\n    \x3c!--            <security:user-service>--\x3e\n    \x3c!--                <security:user name="user" password="{noop}user"--\x3e\n    \x3c!--                               authorities="role_user" />--\x3e\n    \x3c!--                <security:user name="admin" password="{noop}admin"--\x3e\n    \x3c!--                               authorities="role_admin" />--\x3e\n    \x3c!--            </security:user-service>--\x3e\n            </security:authentication-provider>\n        </security:authentication-manager>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n\n# 8.使用加密认证\n\n\n# 1.注入security的bcryptpasswordencoder加密工具类\n\n    \x3c!--security内置的加密工具类--\x3e\n    <bean id="passwordencoder" class="org.springframework.security.crypto.bcrypt.bcryptpasswordencoder"></bean>\n\n    \x3c!--设置spring security认证用户信息的来源--\x3e\n    <security:authentication-manager>\n        <security:authentication-provider user-service-ref="userserviceimpl">\n            \x3c!--使用security内置的加密工具类--\x3e\n            <security:password-encoder ref="passwordencoder"></security:password-encoder>\n\x3c!--            <security:user-service>--\x3e\n\x3c!--                <security:user name="user" password="{noop}user"--\x3e\n\x3c!--                               authorities="role_user" />--\x3e\n\x3c!--                <security:user name="admin" password="{noop}admin"--\x3e\n\x3c!--                               authorities="role_admin" />--\x3e\n\x3c!--            </security:user-service>--\x3e\n        </security:authentication-provider>\n    </security:authentication-manager>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2.修改认证的方法\n\n    /**\n     * secutiry的认证方法\n     * @param username\n     * @return\n     * @throws usernamenotfoundexception\n     */\n    @override\n    public userdetails loaduserbyusername(string username) throws usernamenotfoundexception {\n        sysuser user = userdao.findbyname(username);\n        if(user == null){\n            //若用户名不对，直接返回null，表示认证失败。\n            return null;\n        }else{\n            list<simplegrantedauthority> authorities=new arraylist<simplegrantedauthority>();\n            for(sysrole role:user.getroles()){\n                authorities.add(new simplegrantedauthority(role.getrolename()));\n            }\n            //最终需要返回一个springsecurity的userdetails对象，{noop}表示不加密认证。\n            userdetails userdetails=new user(username,user.getpassword(),authorities);\n            return userdetails;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 3.修改用户登录的操作\n\n    @override\n    public void save(sysuser user) {\n        //保存加密的密码\n        user.setpassword(passwordencoder.encode(user.getpassword()));\n        userdao.save(user);\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.修改数据库的密码\n\n自己写个测试类，修改数据库的密码\n\n    /**\n     * 每次运行密码都不相同\n     * $2a$10$swune4ilf8rjx1wnfguzb.wcqz2i3gvg5jx53dvxru6f.u9ylrmow\n     * $2a$10$ew4stdurdhxzxe5loegypoinofxie9tdks4itkz20qn4fmaln3l4u\n     * $2a$10$kasktciynulom75hye72versioqmuq0ckkx6qlx8o13.y0bxbke3m\n     * @param args\n     */\n    public static void main(string[] args) {\n        bcryptpasswordencoder encoder=new bcryptpasswordencoder();\n        system.out.println(encoder.encode("123456"));\n        system.out.println(encoder.matches("123456","$2a$10$kasktciynulom75hye72versioqmuq0ckkx6qlx8o13.y0bxbke3m"));\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n\n# 9.设置用户状态\n\n用户认证时封装的userdetails对应的user的构造方法支持设置用户状态\n\n * enabled：是否开启\n * accountnonexpired：账户是否失效\n * credentialsnonexpired：密码是否失效\n * accountnonlocked：账户是否被锁定\n\n    public userdetails loaduserbyusername(string username) throws usernamenotfoundexception {\n        sysuser user = userdao.findbyname(username);\n        if(user == null){\n            //若用户名不对，直接返回null，表示认证失败。\n            return null;\n        }else{\n            list<simplegrantedauthority> authorities=new arraylist<simplegrantedauthority>();\n            for(sysrole role:user.getroles()){\n                authorities.add(new simplegrantedauthority(role.getrolename()));\n            }\n            //最终需要返回一个springsecurity的userdetails对象，{noop}表示不加密认证。\n            userdetails userdetails=new user(username,\n                    user.getpassword(),\n                    authorities);\n            return userdetails;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n修改：\n\n            //最终需要返回一个springsecurity的userdetails对象，{noop}表示不加密认证。\n            userdetails userdetails=new user(username,\n                    user.getpassword(),\n                    user.getstatus()==1,//是否启用\n                    true,  //账户是否失效\n                    true,//密码是否失效\n                    true,//账户是否被锁定\n                    authorities);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 10.remember-me\n\n\n# 1.源码分析\n\n1.springsecurity都是通过过滤器实现的，查看remembermeauthenticationfilter类\n\npublic void dofilter(servletrequest req, servletresponse res, filterchain chain)\n\t\t\tthrows ioexception, servletexception {\n\t\thttpservletrequest request = (httpservletrequest) req;\n\t\thttpservletresponse response = (httpservletresponse) res;\n\t\t\n\t\tif (securitycontextholder.getcontext().getauthentication() == null) \n\t\t\t//读取是否开启了记住我功能\n\t\t\tauthentication remembermeauth = remembermeservices.autologin(request,\n\t\t\t\t\tresponse);\n\n\t\t\tif (remembermeauth != null) {\n\t\t\t\t// attempt authenticaton via authenticationmanager\n\t\t\t\ttry {\n\t\t\t\t\t//模拟登陆\n\t\t\t\t\tremembermeauth = authenticationmanager.authenticate(remembermeauth);\n\n\t\t\t\t\t// store to securitycontextholder\n\t\t\t\t\tsecuritycontextholder.getcontext().setauthentication(remembermeauth);\n\n\t\t\t\t\tonsuccessfulauthentication(request, response, remembermeauth);\n\n\t\t\t\t\tif (logger.isdebugenabled()) {\n\t\t\t\t\t\tlogger.debug("securitycontextholder populated with remember-me token: \'"\n\t\t\t\t\t\t\t\t+ securitycontextholder.getcontext().getauthentication()\n\t\t\t\t\t\t\t\t+ "\'");\n\t\t\t\t\t}\n\n\t\t\t\t\t// fire event\n\t\t\t\t\tif (this.eventpublisher != null) {\n\t\t\t\t\t\teventpublisher\n\t\t\t\t\t\t\t\t.publishevent(new interactiveauthenticationsuccessevent(\n\t\t\t\t\t\t\t\t\t\tsecuritycontextholder.getcontext()\n\t\t\t\t\t\t\t\t\t\t\t\t.getauthentication(), this.getclass()));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (successhandler != null) {\n\t\t\t\t\t\tsuccesshandler.onauthenticationsuccess(request, response,\n\t\t\t\t\t\t\t\tremembermeauth);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tcatch (authenticationexception authenticationexception) {\n\t\t\t\t\tif (logger.isdebugenabled()) {\n\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t"securitycontextholder not populated with remember-me token, as "\n\t\t\t\t\t\t\t\t\t\t+ "authenticationmanager rejected authentication returned by remembermeservices: \'"\n\t\t\t\t\t\t\t\t\t\t+ remembermeauth\n\t\t\t\t\t\t\t\t\t\t+ "\'; invalidating remember-me token",\n\t\t\t\t\t\t\t\tauthenticationexception);\n\t\t\t\t\t}\n\n\t\t\t\t\tremembermeservices.loginfail(request, response);\n\n\t\t\t\t\tonunsuccessfulauthentication(request, response,\n\t\t\t\t\t\t\tauthenticationexception);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchain.dofilter(request, response);\n\t\t}\n\t\telse {\n\t\t\tif (logger.isdebugenabled()) {\n\t\t\t\tlogger.debug("securitycontextholder not populated with remember-me token, as it already contained: \'"\n\t\t\t\t\t\t+ securitycontextholder.getcontext().getauthentication() + "\'");\n\t\t\t}\n\n\t\t\tchain.dofilter(request, response);\n\t\t}\n\t}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n2.remembermeservices.autologin(request,response)方法\n\npublic final authentication autologin(httpservletrequest request,\n\t\t\thttpservletresponse response) {\n\t\tstring remembermecookie = extractremembermecookie(request);\n\t\t//判断是否有cookie\n\t\tif (remembermecookie == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlogger.debug("remember-me cookie detected");\n\n\t\tif (remembermecookie.length() == 0) {\n\t\t\tlogger.debug("cookie was empty");\n\t\t\tcancelcookie(request, response);\n\t\t\treturn null;\n\t\t}\n\n\t\tuserdetails user = null;\n\n\t\ttry {\n\t\t\tstring[] cookietokens = decodecookie(remembermecookie);\n\t\t\tuser = processautologincookie(cookietokens, request, response);\n\t\t\tuserdetailschecker.check(user);\n\n\t\t\tlogger.debug("remember-me cookie accepted");\n\n\t\t\treturn createsuccessfulauthentication(request, user);\n\t\t}\n\n\t\tcancelcookie(request, response);\n\t\treturn null;\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n',charsets:{cjk:!0},lastUpdated:"2021/09/22, 16:16:17"},{title:"mybatis",frontmatter:{title:"mybatis",date:"2021-07-20T10:19:25.000Z",permalink:"/pages/e3c3e5/",categories:["后端","Spring全家桶","Mybatis"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/02.Mybatis/01.mybatis.html",relativePath:"01.后端/10.Spring全家桶/02.Mybatis/01.mybatis.md",key:"v-7ed2fa29",path:"/pages/e3c3e5/",headers:[{level:2,title:"一.搭建mybatis环境",slug:"一-搭建mybatis环境",normalizedTitle:"一.搭建mybatis环境",charIndex:14},{level:3,title:"1.1.引入maven依赖",slug:"_1-1-引入maven依赖",normalizedTitle:"1.1.引入maven依赖",charIndex:32},{level:3,title:"1.2.创建测试数据库",slug:"_1-2-创建测试数据库",normalizedTitle:"1.2.创建测试数据库",charIndex:1219},{level:3,title:"1.3.添加log4j日志 log4j.properties",slug:"_1-3-添加log4j日志-log4j-properties",normalizedTitle:"1.3.添加log4j日志 log4j.properties",charIndex:1433},{level:3,title:"1.4.创建MyUser类",slug:"_1-4-创建myuser类",normalizedTitle:"1.4.创建myuser类",charIndex:1813},{level:3,title:"1.5.创建userMapper 接口类，定义curd几个方法",slug:"_1-5-创建usermapper-接口类-定义curd几个方法",normalizedTitle:"1.5.创建usermapper 接口类，定义curd几个方法",charIndex:2958},{level:3,title:"1.6.创建usermapper.xml映射文件",slug:"_1-6-创建usermapper-xml映射文件",normalizedTitle:"1.6.创建usermapper.xml映射文件",charIndex:3278},{level:3,title:"1.7.创建Mybaitis-config.xml配置文件",slug:"_1-7-创建mybaitis-config-xml配置文件",normalizedTitle:"1.7.创建mybaitis-config.xml配置文件",charIndex:4219},{level:3,title:"1.8.编写测试用例",slug:"_1-8-编写测试用例",normalizedTitle:"1.8.编写测试用例",charIndex:5500},{level:2,title:"二.mybatis的配置",slug:"二-mybatis的配置",normalizedTitle:"二.mybatis的配置",charIndex:7741},{level:2,title:"三.mybatis映射标签",slug:"三-mybatis映射标签",normalizedTitle:"三.mybatis映射标签",charIndex:16030}],headersStr:"一.搭建mybatis环境 1.1.引入maven依赖 1.2.创建测试数据库 1.3.添加log4j日志 log4j.properties 1.4.创建MyUser类 1.5.创建userMapper 接口类，定义curd几个方法 1.6.创建usermapper.xml映射文件 1.7.创建Mybaitis-config.xml配置文件 1.8.编写测试用例 二.mybatis的配置 三.mybatis映射标签",content:'# mybatis\n\n\n# 一.搭建mybatis环境\n\n\n# 1.1.引入maven依赖\n\n> 注意： com.mysql.jdbc.Driver 是 mysql-connector-java 5版本， com.mysql.cj.jdbc.Driver 是 mysql-connector-java 6以上版本\n> \n> mysql-connector-java 6以上需要在配置文件中加入时区\n\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n      <scope>test</scope>\n    </dependency>\n\n    \x3c!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\x3e\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n      <version>3.5.7</version>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>5.1.25</version>\n    </dependency>\n\n    \x3c!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --\x3e\n    <dependency>\n      <groupId>org.apache.logging.log4j</groupId>\n      <artifactId>log4j-core</artifactId>\n      <version>2.14.1</version>\n    </dependency>\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <version>1.2.16</version>\n      <scope>compile</scope>\n    </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 1.2.创建测试数据库\n\nCREATE TABLE `user` (\n  `uid` tinyint(2) NOT NULL,\n  `uname` varchar(20) DEFAULT NULL,\n  `usex` varchar(10) DEFAULT NULL,\n  PRIMARY KEY (`uid`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 1.3.添加log4j日志 log4j.properties\n\n# Global logging configuration\nlog4j.rootLogger=ERROR,stdout\n# MyBatis logging configuration...\nlog4j.logger.com.mybatis=DEBUG\n# Console output...\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.4.创建MyUser类\n\npackage com.hand.dto;\n\npublic class User {\n    private Integer uid;\n    private String uName;\n    private String uSex;\n\n    public User(Integer uid, String uName, String uSex) {\n        this.uid = uid;\n        this.uName = uName;\n        this.uSex = uSex;\n    }\n\n    public User(String uName, String uSex) {\n        this.uName = uName;\n        this.uSex = uSex;\n    }\n\n    public Integer getUid() {\n        return uid;\n    }\n\n    public void setUid(Integer uid) {\n        this.uid = uid;\n    }\n\n    public String getuName() {\n        return uName;\n    }\n\n    public void setuName(String uName) {\n        this.uName = uName;\n    }\n\n    public String getuSex() {\n        return uSex;\n    }\n\n    public void setuSex(String uSex) {\n        this.uSex = uSex;\n    }\n\n    @Override\n    public String toString() {\n        return "User{" +\n                "uid=" + uid +\n                ", uName=\'" + uName + \'\\\'\' +\n                ", uSex=\'" + uSex + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 1.5.创建userMapper 接口类，定义curd几个方法\n\npackage com.hand.mapper;\n\nimport com.hand.dto.User;\n\npublic interface UserMapper {\n    public User selectUserById(Integer uid);\n\n    public int addUser(User user);\n\n    public int updateUser(User user);\n\n    public int deleteUserById(Integer uid);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 1.6.创建usermapper.xml映射文件\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\x3c!-- namespace:填写映射当前的Mapper接口，所有的增删改查的参数和返回值类型，\n\t\t就可以直接填写缩写，不区分大小写，直接通过方法名去找类型--\x3e\n<mapper namespace="com.hand.mapper.UserMapper">\n    <select id="selectUserById" parameterType="Integer" resultType="com.hand.dto.User">\n        select * from user where uid=#{uid}\n    </select>\n\n    <insert id="addUser" parameterType="com.hand.dto.User">\n        insert into user(uname,usex) value(#{uName},#{uSex})\n    </insert>\n\n    <update id="updateUser" parameterType="com.hand.dto.User">\n        update user set uname=#{uName},usex=#{uSex} where uid=#{uid}\n    </update>\n\n    <delete id="deleteUserById" parameterType="Integer">\n        delete from user where uid=#{uid}\n    </delete>\n</mapper>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 1.7.创建Mybaitis-config.xml配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    <settings>\n        <setting name="logImpl" value="log4j"/>\n    </settings>\n    \x3c!-- 配置mybatis运行环境 --\x3e\n    <environments default="development">\n        <environment id="development">\n            \x3c!-- 使用JDBC的事务管理 --\x3e\n            <transactionManager type="JDBC"/>\n            <dataSource type="POOLED">\n                \x3c!-- MySQL数据库驱动 --\x3e\n\x3c!--                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>--\x3e\n                <property name="driver" value="com.mysql.jdbc.Driver"/>\n                \x3c!-- 连接数据库的URL --\x3e\n                <property name="url"\n                          value="jdbc:mysql://192.168.188.128:3306/hand_ceshi?characterEncoding=utf8"/>\n                <property name="username" value="root"/>\n                <property name="password" value="2452952178"/>\n            </dataSource>\n        </environment>\n    </environments>\n    \x3c!-- 将mapper文件加入到配置文件中 --\x3e\n    <mappers>\n        <mapper resource="mapper/UserMapper.xml"/>\n    </mappers>\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 1.8.编写测试用例\n\npackage com.hand;\n\nimport com.hand.dto.User;\nimport com.hand.mapper.UserMapper;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.InputStream;\n\npublic class Test1 {\n    private SqlSessionFactory sqlSessionFactory = null;\n    @Before\n    public void init() throws Exception {\n        // 第一步：创建一个SQLSessionFactoryBuilder对象。\n        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n        // 第二步：加载配置文件。\n        InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");\n        // 第三步：创建SQLSessionFactory对象\n        sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);\n    }\n\n    @Test\n    public void select(){\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        User user = mapper.selectUserById(1);\n        System.out.println(user);\n    }\n\n    @Test\n    public void add(){\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int result = mapper.addUser(new User("李四", "34"));\n        sqlSession.commit();//提交事务\n        System.out.println("添加了"+result+"条数据");\n    }\n\n    @Test\n    public void update(){\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int result = mapper.updateUser(new User(1,"张三", "24"));\n        sqlSession.commit();//提交事务\n        System.out.println("更新了"+result+"条数据");\n    }\n\n    @Test\n    public void delete(){\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int result = mapper.deleteUserById(3);\n        sqlSession.commit();//提交事务\n        System.out.println("删除了"+result+"条数据");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 二.mybatis的配置\n\n# property 子元素\n\n<?xml version="1.0" encoding="utf-8"?>\n<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    <settings>\n        <setting name="logImpl" value="log4j"/>\n    </settings>\n    \x3c!-- 配置mybatis运行环境 --\x3e\n    <environments default="development">\n        <environment id="development">\n            \x3c!-- 使用JDBC的事务管理 --\x3e\n            <transactionManager type="JDBC"/>\n            <dataSource type="POOLED">\n                \x3c!-- MySQL数据库驱动 --\x3e\n                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>\n                \x3c!-- 连接数据库的URL --\x3e\n                <property name="url"\n                          value="jdbc:mysql://localhost:3306/spring?characterEncoding=utf8"/>\n                <property name="username" value="root"/>\n                <property name="password" value="root"/>\n            </dataSource>\n        </environment>\n    </environments>\n    \x3c!-- 将mapper文件加入到配置文件中 --\x3e\n    <mappers>\n        <mapper resource="mapper/UserMapper.xml"/>\n    </mappers>\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n案例中数据库链接的配置都是扣死的，可以用jdbc.properties 文件配置\n\ndatabase.driver=com.mysql.jdbc.Driver\ndatabase.url=jdbc:mysql://localhost:3306/spring\ndatabase.username=root\ndatabase.password=root\n\n\n1\n2\n3\n4\n\n\n修改配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    <properties resource="jdbc.properties"/>\n    <settings>\n        <setting name="logImpl" value="log4j"/>\n    </settings>\n    \x3c!-- 配置mybatis运行环境 --\x3e\n    <environments default="development">\n        <environment id="development">\n            \x3c!-- 使用JDBC的事务管理 --\x3e\n            <transactionManager type="JDBC"/>\n            <dataSource type="POOLED">\n                \x3c!-- MySQL数据库驱动 --\x3e\n                <property name="driver" value="${database.driver}"/>\n                \x3c!-- 连接数据库的URL --\x3e\n                <property name="url" value="jdbc:mysql://localhost:3306/spring?characterEncoding=utf8"/>\n                <property name="username" value="root"/>\n                <property name="password" value="root"/>\n            </dataSource>\n        </environment>\n    </environments>\n    \x3c!-- 将mapper文件加入到配置文件中 --\x3e\n    <mappers>\n        <mapper resource="mapper/UserMapper.xml"/>\n    </mappers>\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# Settings\n\n大部分情况下使用默认值便可以运行，所以在大部分情况下不需要大量配置它，只需要修改一些常用的规则即可，比如自动映射、驼峰命名映射、级联规则、是否启动缓存、执行器（Executor）类型等\n\n配置项                                 作用                                                             配置选项                                                  默认值\ncacheEnabled                        该配置影响所有映射器中配置缓存的全局开关                                           true|false                                            true\nlazyLoadingEnabled                  延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。在特定关联关系中可通过设置 fetchType            true|false                                            false\n                                    属性来覆盖该项的开关状态\naggressiveLazyLoading               当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载                 true|felse                                            版本3.4.1 （不包含） 之前 true，之后 false\nmultipleResultSetsEnabled           是否允许单一语句返回多结果集（需要兼容驱动）                                         true|false                                            true\nuseColumnLabel                      使用列标签代替列名。不同的驱动会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果      true|false                                            true\nuseGeneratedKeys                    允许JDBC 支持自动生成主键，需要驱动兼容。如果设置为                                   true|false                                            false\n                                    true，则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）\nautoMappingBehavior                 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射。 PARTIAL              NONE、PARTIAL、FULL                                     PARTIAL\n                                    表示只会自动映射，没有定义嵌套结果集和映射结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）\nautoMappingUnkno wnColumnBehavior   指定自动映射当中未知列（或未知属性类型）时的行为。 默认是不处理，只有当日志级别达到 WARN                NONE、WARNING、FAILING                                  NONE\n                                    级别或者以下，才会显示相关日志，如果处理失败会抛出 SqlSessionException 异常\ndefaultExecutorType                 配置默认的执行器。SIMPLE 是普通的执行器；REUSE 会重用预处理语句（prepared                SIMPLE、REUSE、BATCH                                    SIMPLE\n                                    statements）；BATCH 执行器将重用语句并执行批量更新\ndefaultStatementTimeout             设置超时时间，它决定驱动等待数据库响应的秒数                                         任何正整数                                                 Not Set (null)\ndefaultFetchSize                    设置数据库驱动程序默认返回的条数限制，此参数可以重新设置                                   任何正整数                                                 Not Set (null)\nsafeRowBoundsEnabled                允许在嵌套语句中使用分页（RowBounds）。如果允许，设置 false                          true|false                                            false\nsafeResultHandlerEnabled            允许在嵌套语句中使用分页（ResultHandler）。如果允许，设置false                       true|false                                            true\nmapUnderscoreToCamelCase            是否开启自动驼峰命名规则映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射   true|false                                            false\nlocalCacheScope                     MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular                   SESSION|STATEMENT                                     SESSION\n                                    references）和加速联复嵌套査询。 默认值为\n                                    SESSION，这种情况下会缓存一个会话中执行的所有查询。若设置值为\n                                    STATEMENT，本地会话仅用在语句执行上，对相同 SqlScssion 的不同调用将不会共享数据\njdbcTypeForNull                     当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。某些驱动需要指定列的 JDBC             NULL、VARCHAR、OTHER                                    OTHER\n                                    类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER\nlazyLoadTriggerMethods              指定哪个对象的方法触发一次延迟加载                                              —                                                     equals、clone、hashCode、toString\ndefaultScriptingLanguage            指定动态 SQL 生成的默认语言                                               —                                                     org.apache.ibatis .script.ing.xmltags\n                                                                                                                                                         .XMLDynamicLanguageDriver\ncallSettersOnNulls                  指定当结果集中值为 null 时，是否调用映射对象的 setter（map 对象时为 put）方法，这对于          true|false                                            false\n                                    Map.kcySet() 依赖或 null 值初始化时是有用的。注意，基本类型（int、boolean 等）不能设置成\n                                    null\nlogPrefix                           指定 MyBatis 增加到日志名称的前缀                                          任何字符串                                                 Not set\nloglmpl                             指定 MyBatis 所用日志的具体实现，未指定时将自动査找                                 SLF4J|LOG4J|LOG4J2|JDK_LOGGING |COMMONS_LOGGING |ST   Not set\n                                                                                                   DOUT_LOGGING|NO_LOGGING\nproxyFactory                        指定 MyBatis 创建具有延迟加栽能力的对象所用到的代理工具                               CGLIB|JAVASSIST                                       JAVASSIST （MyBatis 版本为 3.3 及以上的）\nvfsImpl                             指定 VFS 的实现类                                                    提供 VFS 类的全限定名，如果存在多个，可以使用逗号分隔                         Not set\nuseActualParamName                  允许用方法参数中声明的实际名称引用参数。要使用此功能，项目必须被编译为 Java 8 参数的选择。（从版本 3.4.1    true|false                                            true\n                                    开始可以使用）\n\nsettings 的配置项很多，但是真正用到的不会太多，我们把常用的配置项研究清楚就可以了，比如关于缓存的 cacheEnabled，关于级联的 lazyLoadingEnabled 和 aggressiveLazy Loading，关于自动映射的 autoMappingBehavior 和 mapUnderscoreToCamelCase，关于执行器类型的 defaultExecutorType 等。\n\n# typeAliases\n\n<typeAliases>\x3c!--别名--\x3e\n    <typeAlias alias="role" type="com.hand.dto.Role"/>\n    <typeAlias alias="user" type="com.hand.dto.User"/>\n</typeAliases>\n\n\n1\n2\n3\n4\n\n\n\n# 三.mybatis映射标签\n\n# select标签\n\n映射查询语句\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >\n<mapper namespace="com.hand.hap.system.mapper.CodeValueMapper">\n    <select id="selectUserById" \t\t\t     parameterType="Integer"resultType="com.mybatis.po.MyUser">\n        select * from user where uid = #{uid}\n    </select>\n</mapper>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nid 的值是唯一标识符，它接收一个 Integer 类型的参数，返回一个 MyUser 类型的对象，结果集自动映射到 MyUser 属性\n\n属性名称            描 述\nid              它和 Mapper 的命名空间组合起来使用，是唯一标识符，供 MyBatis 调用\nparameterType   表示传入 SQL 语句的参数类型的全限定名或别名。它是一个可选属性，MyBatis 能推断出具体传入语句的参数\nresultType      SQL 语句执行后返回的类型（全限定名或者别名）。如果是集合类型，返回的是集合元素的类型，返回时可以使用\n                resultType 或 resultMap 之一\nresultMap       它是映射集的引用，与 元素一起使用，返回时可以使用 resultType 或 resultMap 之一\nflushCache      用于设置在调用 SQL 语句后是否要求 MyBatis 清空之前查询的本地缓存和二级缓存，默认值为\n                false，如果设置为 true，则任何时候只要 SQL 语句被调用都将清空本地缓存和二级缓存\nuseCache        启动二级缓存的开关，默认值为 true，表示将査询结果存入二级缓存中\ntimeout         用于设置超时参数，单位是秒（s），超时将抛出异常\nfetchSize       获取记录的总条数设定\nstatementType   告诉 MyBatis 使用哪个 JDBC 的 Statement 工作，取值为\n                STATEMENT（Statement）、\n                PREPARED（PreparedStatement）、CALLABLE（CallableStatement）\nresultSetType   这是针对 JDBC 的 ResultSet 接口而言，其值可设置为\n                FORWARD_ONLY（只允许向前访问）、SCROLL_SENSITIVE（双向滚动，但不及时更新）、SCROLLJNSENSITIVE（双向滚动，及时更新）\n\n# insert标签\n\n插入语句\n\n自定义主键:oracle数据库不支持自增，使用序列作为主键，需要手动调用\n\n<insert id="insertUser" parameterType="com.po.MyUser ">\n    \x3c!--先使用selectKey元素定义主键,然后再定义sQL语句--\x3e\n    <selectKey keyProperty="uid" resultType="Integer" order="BEFORE">\n    \tselect aaa.nextval from dual\n    </selectKey>\n\tinsert into user(uid,uname,usex) values(#{uid},#{uname},#{usex})\n</insert>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# update / delete 标签\n\n更新/删除操作**(注意不要因为if造成全表更新或删除)**\n\n# sql 标签\n\n<sql id="comColumns">id,uname,usex</sql>\n<select id="selectUser" resultType="com.po.MyUser">\n    select <include refid="comColumns"> from user\n</select>\n\n\n1\n2\n3\n4\n\n\n# resultMap标签\n\n结果映射集\n\n<resultMap id="BaseResultMap" type="com.hand.hap.system.dto.CodeValue" extends="com.hand.hap.mapper.StdMapper.STD">\n        <result column="CODE_VALUE_ID" property="codeValueId" jdbcType="DECIMAL"/>\n        <result column="CODE_ID" property="codeId" jdbcType="DECIMAL"/>\n        <result column="VALUE" property="value" jdbcType="VARCHAR"/>\n        <result column="MEANING" property="meaning" jdbcType="VARCHAR"/>\n        <result column="ORDER_SEQ" property="orderSeq" jdbcType="DECIMAL"/>\n        <result column="DESCRIPTION" property="description" jdbcType="VARCHAR"/>\n        <result column="TAG" property="tag" jdbcType="VARCHAR" />\n        <result column="ENABLED_FLAG" property="enabledFlag" jdbcType="VARCHAR" />\n        <result column="PARENT_CODE_VALUE_ID" property="parentCodeValueId" jdbcType="DECIMAL" />\n        <result column="PARENT_VALUE" property="parentValue" jdbcType="VARCHAR" />\n</resultMap>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n元素的 type 属性表示需要的 DTO，id 属性是 resultMap 的唯一标识。\n\n用于表示DTO和数据表普通列的映射关系。\n\n# if 标签\n\n<select id="selectUserByIf" resultType="com.hand.dto.MyUser" parameterType="com.hand.dto.MyUser">\n    select * from user where 1=1\n    <if test="uname!=null and uname!=\'\'">\n        and uname like concat(\'%\',#{uname},\'%\')\n    </if >\n    <if test="usex !=null and usex !=\'\'">\n        and usex=#{usex}\n    </if >\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> if判断注意integer类型，由于mybatis中interger为空的时候默认为\' \'，所以判断integer类型应：\n> \n> usex =#{usex }\n\n# choose when otherwise标签\n\n<select id="selectUserByChoose" resultType="com.hand.dto.MyUser" parameterType="com.hand.dto.MyUser">\n        select * from user where 1=1\n        <choose>\n            <when test="uname==\'MIKE\'">\n                and uname like concat(\'%\',#{uname},\'%\')\n            </when>\n            <when test="usex!=null and usex!=\'\'">\n                and usex=#{usex}\n            </when>\n            <otherwise>\n                and uid > 10\n            </otherwise>\n        </choose>\n    </select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# trim / set / where 标签\n\ntrim 元素的主要功能是可以在自己包含的内容前加上某些前缀，也可以在其后加上某些后缀，与之对应的属性是 prefix 和 suffix 可以把包含内容的首部某些内容覆盖，即忽略，也可以把尾部的某些内容覆盖，对应的属性是 prefixOverrides 和 suffixOverrides。正因为 元素有这样的功能，所以也可以非常简单地利用 来代替 元素的功能。\n\n<select id="selectUserByTrim" resultType="com.hand.dto.MyUser" parameterType="com.hand.dto.MyUser">\n    select * from user\n    <trim prefix="where" prefixOverrides = "and | or">\n        <if test="uname!=null and uname!=\'\'">\n            and uname like concat(\'%\',#{uname},\'%\')\n        </if>\n        <if test="usex!=null and usex!=\'\'">\n            and usex=#{usex}\n        </if>\n    </trim>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nwhere\n\n输出后的第一个条件中带有and 或者or ，回自动省略\n\nset\n\n<update id="updateUserBySet" parameterType="com.hand.dto.MyUser">     \n    update user\n    <set>\n        <if test="uname!=null">uname=#{uname}</if>\n        <if test="usex!=null">usex=#{usex}</if>\n    </set>\n    where uid=#{uid}\n</update>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# foreach标签\n\nforeach 元素主要用在构建 in 条件中，它可以在 SQL 语句中迭代一个集合。\n\nitem 表示集合中每一个元素进行迭代时的别名。\n\nindex 指定一个名字，用于表示在迭代过程中每次迭代到的位置。\n\nopen 表示该语句以什么开始。\n\nseparator 表示在每次进行迭代之间以什么符号作为分隔符。\n\nclose 表示以什么结束。\n\n<select id="selectUserByForeach" resultType="com.hand.dto.MyUser" parameterType=\n"List">\n    select * from user where uid in\n    <foreach item="item" index="index" collection="list"\n    open="(" separator="," close=")">\n        # {item}\n    </foreach>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# bind标签\n\n\x3c!--使用bind元素进行模糊查询--\x3e\n<select id="selectUserByBind" resultType="com.hand.dto.MyUser" parameterType= "com.hand.dto.MyUser">\n        \x3c!-- bind 中的 uname 是 com.po.MyUser 的属性名--\x3e\n        <bind name="paran_uname" value="\'%\' + uname + \'%\'"/>\n            select * from user where uname like #{paran_uname}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'# mybatis\n\n\n# 一.搭建mybatis环境\n\n\n# 1.1.引入maven依赖\n\n> 注意： com.mysql.jdbc.driver 是 mysql-connector-java 5版本， com.mysql.cj.jdbc.driver 是 mysql-connector-java 6以上版本\n> \n> mysql-connector-java 6以上需要在配置文件中加入时区\n\n    <dependency>\n      <groupid>junit</groupid>\n      <artifactid>junit</artifactid>\n      <version>4.11</version>\n      <scope>test</scope>\n    </dependency>\n\n    \x3c!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\x3e\n    <dependency>\n      <groupid>org.mybatis</groupid>\n      <artifactid>mybatis</artifactid>\n      <version>3.5.7</version>\n    </dependency>\n    <dependency>\n      <groupid>mysql</groupid>\n      <artifactid>mysql-connector-java</artifactid>\n      <version>5.1.25</version>\n    </dependency>\n\n    \x3c!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --\x3e\n    <dependency>\n      <groupid>org.apache.logging.log4j</groupid>\n      <artifactid>log4j-core</artifactid>\n      <version>2.14.1</version>\n    </dependency>\n    <dependency>\n      <groupid>log4j</groupid>\n      <artifactid>log4j</artifactid>\n      <version>1.2.16</version>\n      <scope>compile</scope>\n    </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 1.2.创建测试数据库\n\ncreate table `user` (\n  `uid` tinyint(2) not null,\n  `uname` varchar(20) default null,\n  `usex` varchar(10) default null,\n  primary key (`uid`)\n) engine=innodb default charset=utf8;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 1.3.添加log4j日志 log4j.properties\n\n# global logging configuration\nlog4j.rootlogger=error,stdout\n# mybatis logging configuration...\nlog4j.logger.com.mybatis=debug\n# console output...\nlog4j.appender.stdout=org.apache.log4j.consoleappender\nlog4j.appender.stdout.layout=org.apache.log4j.patternlayout\nlog4j.appender.stdout.layout.conversionpattern=%5p [%t] - %m%n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.4.创建myuser类\n\npackage com.hand.dto;\n\npublic class user {\n    private integer uid;\n    private string uname;\n    private string usex;\n\n    public user(integer uid, string uname, string usex) {\n        this.uid = uid;\n        this.uname = uname;\n        this.usex = usex;\n    }\n\n    public user(string uname, string usex) {\n        this.uname = uname;\n        this.usex = usex;\n    }\n\n    public integer getuid() {\n        return uid;\n    }\n\n    public void setuid(integer uid) {\n        this.uid = uid;\n    }\n\n    public string getuname() {\n        return uname;\n    }\n\n    public void setuname(string uname) {\n        this.uname = uname;\n    }\n\n    public string getusex() {\n        return usex;\n    }\n\n    public void setusex(string usex) {\n        this.usex = usex;\n    }\n\n    @override\n    public string tostring() {\n        return "user{" +\n                "uid=" + uid +\n                ", uname=\'" + uname + \'\\\'\' +\n                ", usex=\'" + usex + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 1.5.创建usermapper 接口类，定义curd几个方法\n\npackage com.hand.mapper;\n\nimport com.hand.dto.user;\n\npublic interface usermapper {\n    public user selectuserbyid(integer uid);\n\n    public int adduser(user user);\n\n    public int updateuser(user user);\n\n    public int deleteuserbyid(integer uid);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 1.6.创建usermapper.xml映射文件\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper\n        public "-//mybatis.org//dtd mapper 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\x3c!-- namespace:填写映射当前的mapper接口，所有的增删改查的参数和返回值类型，\n\t\t就可以直接填写缩写，不区分大小写，直接通过方法名去找类型--\x3e\n<mapper namespace="com.hand.mapper.usermapper">\n    <select id="selectuserbyid" parametertype="integer" resulttype="com.hand.dto.user">\n        select * from user where uid=#{uid}\n    </select>\n\n    <insert id="adduser" parametertype="com.hand.dto.user">\n        insert into user(uname,usex) value(#{uname},#{usex})\n    </insert>\n\n    <update id="updateuser" parametertype="com.hand.dto.user">\n        update user set uname=#{uname},usex=#{usex} where uid=#{uid}\n    </update>\n\n    <delete id="deleteuserbyid" parametertype="integer">\n        delete from user where uid=#{uid}\n    </delete>\n</mapper>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 1.7.创建mybaitis-config.xml配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype configuration public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    <settings>\n        <setting name="logimpl" value="log4j"/>\n    </settings>\n    \x3c!-- 配置mybatis运行环境 --\x3e\n    <environments default="development">\n        <environment id="development">\n            \x3c!-- 使用jdbc的事务管理 --\x3e\n            <transactionmanager type="jdbc"/>\n            <datasource type="pooled">\n                \x3c!-- mysql数据库驱动 --\x3e\n\x3c!--                <property name="driver" value="com.mysql.cj.jdbc.driver"/>--\x3e\n                <property name="driver" value="com.mysql.jdbc.driver"/>\n                \x3c!-- 连接数据库的url --\x3e\n                <property name="url"\n                          value="jdbc:mysql://192.168.188.128:3306/hand_ceshi?characterencoding=utf8"/>\n                <property name="username" value="root"/>\n                <property name="password" value="2452952178"/>\n            </datasource>\n        </environment>\n    </environments>\n    \x3c!-- 将mapper文件加入到配置文件中 --\x3e\n    <mappers>\n        <mapper resource="mapper/usermapper.xml"/>\n    </mappers>\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 1.8.编写测试用例\n\npackage com.hand;\n\nimport com.hand.dto.user;\nimport com.hand.mapper.usermapper;\nimport org.apache.ibatis.io.resources;\nimport org.apache.ibatis.session.sqlsession;\nimport org.apache.ibatis.session.sqlsessionfactory;\nimport org.apache.ibatis.session.sqlsessionfactorybuilder;\nimport org.junit.before;\nimport org.junit.test;\n\nimport java.io.inputstream;\n\npublic class test1 {\n    private sqlsessionfactory sqlsessionfactory = null;\n    @before\n    public void init() throws exception {\n        // 第一步：创建一个sqlsessionfactorybuilder对象。\n        sqlsessionfactorybuilder sqlsessionfactorybuilder = new sqlsessionfactorybuilder();\n        // 第二步：加载配置文件。\n        inputstream inputstream = resources.getresourceasstream("mybatis-config.xml");\n        // 第三步：创建sqlsessionfactory对象\n        sqlsessionfactory = sqlsessionfactorybuilder.build(inputstream);\n    }\n\n    @test\n    public void select(){\n        sqlsession sqlsession = sqlsessionfactory.opensession();\n        usermapper mapper = sqlsession.getmapper(usermapper.class);\n        user user = mapper.selectuserbyid(1);\n        system.out.println(user);\n    }\n\n    @test\n    public void add(){\n        sqlsession sqlsession = sqlsessionfactory.opensession();\n        usermapper mapper = sqlsession.getmapper(usermapper.class);\n        int result = mapper.adduser(new user("李四", "34"));\n        sqlsession.commit();//提交事务\n        system.out.println("添加了"+result+"条数据");\n    }\n\n    @test\n    public void update(){\n        sqlsession sqlsession = sqlsessionfactory.opensession();\n        usermapper mapper = sqlsession.getmapper(usermapper.class);\n        int result = mapper.updateuser(new user(1,"张三", "24"));\n        sqlsession.commit();//提交事务\n        system.out.println("更新了"+result+"条数据");\n    }\n\n    @test\n    public void delete(){\n        sqlsession sqlsession = sqlsessionfactory.opensession();\n        usermapper mapper = sqlsession.getmapper(usermapper.class);\n        int result = mapper.deleteuserbyid(3);\n        sqlsession.commit();//提交事务\n        system.out.println("删除了"+result+"条数据");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 二.mybatis的配置\n\n# property 子元素\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype configuration public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    <settings>\n        <setting name="logimpl" value="log4j"/>\n    </settings>\n    \x3c!-- 配置mybatis运行环境 --\x3e\n    <environments default="development">\n        <environment id="development">\n            \x3c!-- 使用jdbc的事务管理 --\x3e\n            <transactionmanager type="jdbc"/>\n            <datasource type="pooled">\n                \x3c!-- mysql数据库驱动 --\x3e\n                <property name="driver" value="com.mysql.cj.jdbc.driver"/>\n                \x3c!-- 连接数据库的url --\x3e\n                <property name="url"\n                          value="jdbc:mysql://localhost:3306/spring?characterencoding=utf8"/>\n                <property name="username" value="root"/>\n                <property name="password" value="root"/>\n            </datasource>\n        </environment>\n    </environments>\n    \x3c!-- 将mapper文件加入到配置文件中 --\x3e\n    <mappers>\n        <mapper resource="mapper/usermapper.xml"/>\n    </mappers>\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n案例中数据库链接的配置都是扣死的，可以用jdbc.properties 文件配置\n\ndatabase.driver=com.mysql.jdbc.driver\ndatabase.url=jdbc:mysql://localhost:3306/spring\ndatabase.username=root\ndatabase.password=root\n\n\n1\n2\n3\n4\n\n\n修改配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype configuration public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    <properties resource="jdbc.properties"/>\n    <settings>\n        <setting name="logimpl" value="log4j"/>\n    </settings>\n    \x3c!-- 配置mybatis运行环境 --\x3e\n    <environments default="development">\n        <environment id="development">\n            \x3c!-- 使用jdbc的事务管理 --\x3e\n            <transactionmanager type="jdbc"/>\n            <datasource type="pooled">\n                \x3c!-- mysql数据库驱动 --\x3e\n                <property name="driver" value="${database.driver}"/>\n                \x3c!-- 连接数据库的url --\x3e\n                <property name="url" value="jdbc:mysql://localhost:3306/spring?characterencoding=utf8"/>\n                <property name="username" value="root"/>\n                <property name="password" value="root"/>\n            </datasource>\n        </environment>\n    </environments>\n    \x3c!-- 将mapper文件加入到配置文件中 --\x3e\n    <mappers>\n        <mapper resource="mapper/usermapper.xml"/>\n    </mappers>\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# settings\n\n大部分情况下使用默认值便可以运行，所以在大部分情况下不需要大量配置它，只需要修改一些常用的规则即可，比如自动映射、驼峰命名映射、级联规则、是否启动缓存、执行器（executor）类型等\n\n配置项                                 作用                                                             配置选项                                                  默认值\ncacheenabled                        该配置影响所有映射器中配置缓存的全局开关                                           true|false                                            true\nlazyloadingenabled                  延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。在特定关联关系中可通过设置 fetchtype            true|false                                            false\n                                    属性来覆盖该项的开关状态\naggressivelazyloading               当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载                 true|felse                                            版本3.4.1 （不包含） 之前 true，之后 false\nmultipleresultsetsenabled           是否允许单一语句返回多结果集（需要兼容驱动）                                         true|false                                            true\nusecolumnlabel                      使用列标签代替列名。不同的驱动会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果      true|false                                            true\nusegeneratedkeys                    允许jdbc 支持自动生成主键，需要驱动兼容。如果设置为                                   true|false                                            false\n                                    true，则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 derby）\nautomappingbehavior                 指定 mybatis 应如何自动映射列到字段或属性。 none 表示取消自动映射。 partial              none、partial、full                                     partial\n                                    表示只会自动映射，没有定义嵌套结果集和映射结果集。 full 会自动映射任意复杂的结果集（无论是否嵌套）\nautomappingunkno wncolumnbehavior   指定自动映射当中未知列（或未知属性类型）时的行为。 默认是不处理，只有当日志级别达到 warn                none、warning、failing                                  none\n                                    级别或者以下，才会显示相关日志，如果处理失败会抛出 sqlsessionexception 异常\ndefaultexecutortype                 配置默认的执行器。simple 是普通的执行器；reuse 会重用预处理语句（prepared                simple、reuse、batch                                    simple\n                                    statements）；batch 执行器将重用语句并执行批量更新\ndefaultstatementtimeout             设置超时时间，它决定驱动等待数据库响应的秒数                                         任何正整数                                                 not set (null)\ndefaultfetchsize                    设置数据库驱动程序默认返回的条数限制，此参数可以重新设置                                   任何正整数                                                 not set (null)\nsaferowboundsenabled                允许在嵌套语句中使用分页（rowbounds）。如果允许，设置 false                          true|false                                            false\nsaferesulthandlerenabled            允许在嵌套语句中使用分页（resulthandler）。如果允许，设置false                       true|false                                            true\nmapunderscoretocamelcase            是否开启自动驼峰命名规则映射，即从经典数据库列名 a_column 到经典 java 属性名 acolumn 的类似映射   true|false                                            false\nlocalcachescope                     mybatis 利用本地缓存机制（local cache）防止循环引用（circular                   session|statement                                     session\n                                    references）和加速联复嵌套査询。 默认值为\n                                    session，这种情况下会缓存一个会话中执行的所有查询。若设置值为\n                                    statement，本地会话仅用在语句执行上，对相同 sqlscssion 的不同调用将不会共享数据\njdbctypefornull                     当没有为参数提供特定的 jdbc 类型时，为空值指定 jdbc 类型。某些驱动需要指定列的 jdbc             null、varchar、other                                    other\n                                    类型，多数情况直接用一般类型即可，比如 null、varchar 或 other\nlazyloadtriggermethods              指定哪个对象的方法触发一次延迟加载                                              —                                                     equals、clone、hashcode、tostring\ndefaultscriptinglanguage            指定动态 sql 生成的默认语言                                               —                                                     org.apache.ibatis .script.ing.xmltags\n                                                                                                                                                         .xmldynamiclanguagedriver\ncallsettersonnulls                  指定当结果集中值为 null 时，是否调用映射对象的 setter（map 对象时为 put）方法，这对于          true|false                                            false\n                                    map.kcyset() 依赖或 null 值初始化时是有用的。注意，基本类型（int、boolean 等）不能设置成\n                                    null\nlogprefix                           指定 mybatis 增加到日志名称的前缀                                          任何字符串                                                 not set\nloglmpl                             指定 mybatis 所用日志的具体实现，未指定时将自动査找                                 slf4j|log4j|log4j2|jdk_logging |commons_logging |st   not set\n                                                                                                   dout_logging|no_logging\nproxyfactory                        指定 mybatis 创建具有延迟加栽能力的对象所用到的代理工具                               cglib|javassist                                       javassist （mybatis 版本为 3.3 及以上的）\nvfsimpl                             指定 vfs 的实现类                                                    提供 vfs 类的全限定名，如果存在多个，可以使用逗号分隔                         not set\nuseactualparamname                  允许用方法参数中声明的实际名称引用参数。要使用此功能，项目必须被编译为 java 8 参数的选择。（从版本 3.4.1    true|false                                            true\n                                    开始可以使用）\n\nsettings 的配置项很多，但是真正用到的不会太多，我们把常用的配置项研究清楚就可以了，比如关于缓存的 cacheenabled，关于级联的 lazyloadingenabled 和 aggressivelazy loading，关于自动映射的 automappingbehavior 和 mapunderscoretocamelcase，关于执行器类型的 defaultexecutortype 等。\n\n# typealiases\n\n<typealiases>\x3c!--别名--\x3e\n    <typealias alias="role" type="com.hand.dto.role"/>\n    <typealias alias="user" type="com.hand.dto.user"/>\n</typealiases>\n\n\n1\n2\n3\n4\n\n\n\n# 三.mybatis映射标签\n\n# select标签\n\n映射查询语句\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper public "-//mybatis.org//dtd mapper 3.0//en" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >\n<mapper namespace="com.hand.hap.system.mapper.codevaluemapper">\n    <select id="selectuserbyid" \t\t\t     parametertype="integer"resulttype="com.mybatis.po.myuser">\n        select * from user where uid = #{uid}\n    </select>\n</mapper>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nid 的值是唯一标识符，它接收一个 integer 类型的参数，返回一个 myuser 类型的对象，结果集自动映射到 myuser 属性\n\n属性名称            描 述\nid              它和 mapper 的命名空间组合起来使用，是唯一标识符，供 mybatis 调用\nparametertype   表示传入 sql 语句的参数类型的全限定名或别名。它是一个可选属性，mybatis 能推断出具体传入语句的参数\nresulttype      sql 语句执行后返回的类型（全限定名或者别名）。如果是集合类型，返回的是集合元素的类型，返回时可以使用\n                resulttype 或 resultmap 之一\nresultmap       它是映射集的引用，与 元素一起使用，返回时可以使用 resulttype 或 resultmap 之一\nflushcache      用于设置在调用 sql 语句后是否要求 mybatis 清空之前查询的本地缓存和二级缓存，默认值为\n                false，如果设置为 true，则任何时候只要 sql 语句被调用都将清空本地缓存和二级缓存\nusecache        启动二级缓存的开关，默认值为 true，表示将査询结果存入二级缓存中\ntimeout         用于设置超时参数，单位是秒（s），超时将抛出异常\nfetchsize       获取记录的总条数设定\nstatementtype   告诉 mybatis 使用哪个 jdbc 的 statement 工作，取值为\n                statement（statement）、\n                prepared（preparedstatement）、callable（callablestatement）\nresultsettype   这是针对 jdbc 的 resultset 接口而言，其值可设置为\n                forward_only（只允许向前访问）、scroll_sensitive（双向滚动，但不及时更新）、scrolljnsensitive（双向滚动，及时更新）\n\n# insert标签\n\n插入语句\n\n自定义主键:oracle数据库不支持自增，使用序列作为主键，需要手动调用\n\n<insert id="insertuser" parametertype="com.po.myuser ">\n    \x3c!--先使用selectkey元素定义主键,然后再定义sql语句--\x3e\n    <selectkey keyproperty="uid" resulttype="integer" order="before">\n    \tselect aaa.nextval from dual\n    </selectkey>\n\tinsert into user(uid,uname,usex) values(#{uid},#{uname},#{usex})\n</insert>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# update / delete 标签\n\n更新/删除操作**(注意不要因为if造成全表更新或删除)**\n\n# sql 标签\n\n<sql id="comcolumns">id,uname,usex</sql>\n<select id="selectuser" resulttype="com.po.myuser">\n    select <include refid="comcolumns"> from user\n</select>\n\n\n1\n2\n3\n4\n\n\n# resultmap标签\n\n结果映射集\n\n<resultmap id="baseresultmap" type="com.hand.hap.system.dto.codevalue" extends="com.hand.hap.mapper.stdmapper.std">\n        <result column="code_value_id" property="codevalueid" jdbctype="decimal"/>\n        <result column="code_id" property="codeid" jdbctype="decimal"/>\n        <result column="value" property="value" jdbctype="varchar"/>\n        <result column="meaning" property="meaning" jdbctype="varchar"/>\n        <result column="order_seq" property="orderseq" jdbctype="decimal"/>\n        <result column="description" property="description" jdbctype="varchar"/>\n        <result column="tag" property="tag" jdbctype="varchar" />\n        <result column="enabled_flag" property="enabledflag" jdbctype="varchar" />\n        <result column="parent_code_value_id" property="parentcodevalueid" jdbctype="decimal" />\n        <result column="parent_value" property="parentvalue" jdbctype="varchar" />\n</resultmap>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n元素的 type 属性表示需要的 dto，id 属性是 resultmap 的唯一标识。\n\n用于表示dto和数据表普通列的映射关系。\n\n# if 标签\n\n<select id="selectuserbyif" resulttype="com.hand.dto.myuser" parametertype="com.hand.dto.myuser">\n    select * from user where 1=1\n    <if test="uname!=null and uname!=\'\'">\n        and uname like concat(\'%\',#{uname},\'%\')\n    </if >\n    <if test="usex !=null and usex !=\'\'">\n        and usex=#{usex}\n    </if >\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> if判断注意integer类型，由于mybatis中interger为空的时候默认为\' \'，所以判断integer类型应：\n> \n> usex =#{usex }\n\n# choose when otherwise标签\n\n<select id="selectuserbychoose" resulttype="com.hand.dto.myuser" parametertype="com.hand.dto.myuser">\n        select * from user where 1=1\n        <choose>\n            <when test="uname==\'mike\'">\n                and uname like concat(\'%\',#{uname},\'%\')\n            </when>\n            <when test="usex!=null and usex!=\'\'">\n                and usex=#{usex}\n            </when>\n            <otherwise>\n                and uid > 10\n            </otherwise>\n        </choose>\n    </select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# trim / set / where 标签\n\ntrim 元素的主要功能是可以在自己包含的内容前加上某些前缀，也可以在其后加上某些后缀，与之对应的属性是 prefix 和 suffix 可以把包含内容的首部某些内容覆盖，即忽略，也可以把尾部的某些内容覆盖，对应的属性是 prefixoverrides 和 suffixoverrides。正因为 元素有这样的功能，所以也可以非常简单地利用 来代替 元素的功能。\n\n<select id="selectuserbytrim" resulttype="com.hand.dto.myuser" parametertype="com.hand.dto.myuser">\n    select * from user\n    <trim prefix="where" prefixoverrides = "and | or">\n        <if test="uname!=null and uname!=\'\'">\n            and uname like concat(\'%\',#{uname},\'%\')\n        </if>\n        <if test="usex!=null and usex!=\'\'">\n            and usex=#{usex}\n        </if>\n    </trim>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nwhere\n\n输出后的第一个条件中带有and 或者or ，回自动省略\n\nset\n\n<update id="updateuserbyset" parametertype="com.hand.dto.myuser">     \n    update user\n    <set>\n        <if test="uname!=null">uname=#{uname}</if>\n        <if test="usex!=null">usex=#{usex}</if>\n    </set>\n    where uid=#{uid}\n</update>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# foreach标签\n\nforeach 元素主要用在构建 in 条件中，它可以在 sql 语句中迭代一个集合。\n\nitem 表示集合中每一个元素进行迭代时的别名。\n\nindex 指定一个名字，用于表示在迭代过程中每次迭代到的位置。\n\nopen 表示该语句以什么开始。\n\nseparator 表示在每次进行迭代之间以什么符号作为分隔符。\n\nclose 表示以什么结束。\n\n<select id="selectuserbyforeach" resulttype="com.hand.dto.myuser" parametertype=\n"list">\n    select * from user where uid in\n    <foreach item="item" index="index" collection="list"\n    open="(" separator="," close=")">\n        # {item}\n    </foreach>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# bind标签\n\n\x3c!--使用bind元素进行模糊查询--\x3e\n<select id="selectuserbybind" resulttype="com.hand.dto.myuser" parametertype= "com.hand.dto.myuser">\n        \x3c!-- bind 中的 uname 是 com.po.myuser 的属性名--\x3e\n        <bind name="paran_uname" value="\'%\' + uname + \'%\'"/>\n            select * from user where uname like #{paran_uname}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"SpringBoot",frontmatter:{title:"SpringBoot",date:"2021-07-08T19:09:34.000Z",permalink:"/pages/9af6ea/",categories:["Spring全家桶","SpringBoot"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.SpringBoot/00.SpringBoot%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98.html",relativePath:"01.后端/10.Spring全家桶/01.SpringBoot/00.SpringBoot开发问题.md",key:"v-a6e5a316",path:"/pages/9af6ea/",headers:[{level:2,title:"1.SpringBoot自定义application-xxx文件",slug:"_1-springboot自定义application-xxx文件",normalizedTitle:"1.springboot自定义application-xxx文件",charIndex:19}],headersStr:"1.SpringBoot自定义application-xxx文件",content:"# 一.SpringBoot\n\n\n# 1.SpringBoot自定义application-xxx文件\n\n> springboot默认加载application-dev.yml、application-test.yml、application-prod .yml，如何加载自定义的比如：application-es .yml、application-druid .yml\n\napplication.yml中导入即可：\n\n方式一：该方式用于区分开发、测试、部署环境，不推荐\nspring:\n  profiles: \n    active: druid,es\n方式二:推荐，导入的方式\nspring:\n  profiles:\n    include: druid,es\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n",normalizedContent:"# 一.springboot\n\n\n# 1.springboot自定义application-xxx文件\n\n> springboot默认加载application-dev.yml、application-test.yml、application-prod .yml，如何加载自定义的比如：application-es .yml、application-druid .yml\n\napplication.yml中导入即可：\n\n方式一：该方式用于区分开发、测试、部署环境，不推荐\nspring:\n  profiles: \n    active: druid,es\n方式二:推荐，导入的方式\nspring:\n  profiles:\n    include: druid,es\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"SpingCloud导航",frontmatter:{title:"SpingCloud导航",date:"2021-08-17T09:31:44.000Z",permalink:"/pages/5ca4e4/",categories:["后端","Spring全家桶","SpringCloud"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/00.SpingCloud%E5%AF%BC%E8%88%AA.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/00.SpingCloud导航.md",key:"v-44f3f994",path:"/pages/5ca4e4/",headers:[{level:2,title:"1.笔记目录",slug:"_1-笔记目录",normalizedTitle:"1.笔记目录",charIndex:17},{level:2,title:"2.项目结构：",slug:"_2-项目结构",normalizedTitle:"2.项目结构：",charIndex:582}],headersStr:"1.笔记目录 2.项目结构：",content:"# SpingCloud\n\n\n# 1.笔记目录\n\n周阳老师视屏链接：\n\n零基础篇：\n\n 1. 什么是微服务？（小白必知）\n 2. 选择Boot和Cloud版本\n 3. 关于Cloud组件停更升级\n 4. 环境搭建\n\n初级篇：\n\n * 服务注册与发现\n\n 1. 05.Eureka基础篇\n 2. 06.Zookeeper\n 3. 07.consul\n 4. 08.三种服务注册的区别\n\n * 服务调用----负载均衡\n\n 1. 09.Ribbon+RestTemplet\n 2. 10.OpenFeign\n\n * 服务熔断、服务限流\n\n 1. 11.Hystrix豪猪哥\n\n * 服务网关\n\n 1. 12.Gateway网关\n\n * 全局配置+动态刷新\n\n 1. 13.config全局配置\n 2. 14.Bus消息总线\n\n * 整合MQ\n\n 1. 15.Stream\n\n * 链路追踪\n\n 1. 16.Sleuth链路追踪\n\n高级篇：\n\n * [17.SpringCloud alibaba入门介绍.md](./17.SpringCloud alibaba入门介绍.md)\n\n * [18.SpringCloud alibaba Nacos服务注册和配置中心.md](./18.SpringCloud alibaba Nacos服务注册和配置中心.md)\n\n\n# 2.项目结构：\n\n * cloud-api-commons：项目公共包 ，其他模块通过pom文件引入即可使用\n\n * Eureka的整合模块：\n   \n   1. cloud-consumer-order80：消费者\n   2. cloud-eureka-server7001、cloud-eureka-server7002：集群部署Eureka服务\n   3. cloud-provider-payment8001、cloud-provider-payment8002:生产者，提供服务，整合Eureka\n\n * Zookeeper的整合模块：\n   \n   1. cloud-provider-payment8004：生产者\n   2. cloud-consumerzk-order80：消费者\n\n * Consul的整合模块：\n   \n   1. cloud-providerconsul-payment8006：生产者\n   2. cloud-consumerconsul-order80：消费者\n\n * Ribbon的涉及模块：\n   \n   1. cloud-consumer-order80：消费者\n   2. cloud-eureka-server7001、cloud-eureka-server7002：集群部署Eureka服务\n   3. cloud-provider-payment8001、cloud-provider-payment8002:生产者，提供服务，整合Eureka\n\n * OpenFeign的涉及整合模块：\n   \n   1. cloud-consumer-feign-order80：消费者客户端\n   2. cloud-eureka-server7001、cloud-eureka-server7002：集群部署Eureka服务\n   3. cloud-provider-payment8001、cloud-provider-payment8002:生产者，提供服务，整合Eureka\n\n * Hystrix的涉及整合模块：\n   \n   1. cloud-provider-hystrix-payment8001：生产者\n   2. cloud-consumer-feign-hystrix-order80：消费者80\n   3. cloud-consumer-hystrix-dashboard9001：Hystrix的web监控模块\n\n * Gateway的涉及整合模块：\n   \n   1. cloud-eureka-server7001、cloud-eureka-server7002：集群部署Eureka服务\n   2. cloud-provider-payment8001、cloud-provider-payment8002：消费者\n   3. cloud-gateway-gateway9527：网关配置\n\n * config全局配置\n   \n   1. cloud-eureka-server7001、cloud-eureka-server7002：集群部署Eureka服务\n   2. cloud-provider-payment8001、cloud-provider-payment8002：消费者\n   3. cloud-config-center-3344：读取github上的配置信息\n   4. cloud-config-client-3355：读取3344上的配置信息\n\n * 动态刷新Bus\n   \n   1. cloud-eureka-server7001、cloud-eureka-server7002：集群部署Eureka服务\n   2. cloud-config-center-3344：读取github上的配置信息\n   3. cloud-config-client-3355、cloud-config-client-3366：读取3344上的配置信息\n\n * 整合消息中间件\n   \n   1. cloud-eureka-server7001、cloud-eureka-server7002：集群部署Eureka服务\n   2. cloud-stream-rabbitmq-provider8801：rabbitmq生产者\n   3. cloud-stream-rabbitmq-consumer8803、cloud-stream-rabbitmq-consumer8804：rabbitmq消费者\n\n * 链路追踪\n   \n   1. cloud-eureka-server7001、cloud-eureka-server7002：集群部署Eureka服务\n   2. cloud-provider-payment8001：服务端\n   3. cloud-consumer-order80：客户端\n\n * SpringCloud alibaba Nacos服务注册和配置中心\n   \n   1. cloudalibaba-provider-payment9001：后端注册进服务\n   2. cloudalibaba-consumer-nacos-order83：客户端注册进服务\n   3. cloudalibaba-config-nacos-client3377：配置中心",normalizedContent:"# spingcloud\n\n\n# 1.笔记目录\n\n周阳老师视屏链接：\n\n零基础篇：\n\n 1. 什么是微服务？（小白必知）\n 2. 选择boot和cloud版本\n 3. 关于cloud组件停更升级\n 4. 环境搭建\n\n初级篇：\n\n * 服务注册与发现\n\n 1. 05.eureka基础篇\n 2. 06.zookeeper\n 3. 07.consul\n 4. 08.三种服务注册的区别\n\n * 服务调用----负载均衡\n\n 1. 09.ribbon+resttemplet\n 2. 10.openfeign\n\n * 服务熔断、服务限流\n\n 1. 11.hystrix豪猪哥\n\n * 服务网关\n\n 1. 12.gateway网关\n\n * 全局配置+动态刷新\n\n 1. 13.config全局配置\n 2. 14.bus消息总线\n\n * 整合mq\n\n 1. 15.stream\n\n * 链路追踪\n\n 1. 16.sleuth链路追踪\n\n高级篇：\n\n * [17.springcloud alibaba入门介绍.md](./17.springcloud alibaba入门介绍.md)\n\n * [18.springcloud alibaba nacos服务注册和配置中心.md](./18.springcloud alibaba nacos服务注册和配置中心.md)\n\n\n# 2.项目结构：\n\n * cloud-api-commons：项目公共包 ，其他模块通过pom文件引入即可使用\n\n * eureka的整合模块：\n   \n   1. cloud-consumer-order80：消费者\n   2. cloud-eureka-server7001、cloud-eureka-server7002：集群部署eureka服务\n   3. cloud-provider-payment8001、cloud-provider-payment8002:生产者，提供服务，整合eureka\n\n * zookeeper的整合模块：\n   \n   1. cloud-provider-payment8004：生产者\n   2. cloud-consumerzk-order80：消费者\n\n * consul的整合模块：\n   \n   1. cloud-providerconsul-payment8006：生产者\n   2. cloud-consumerconsul-order80：消费者\n\n * ribbon的涉及模块：\n   \n   1. cloud-consumer-order80：消费者\n   2. cloud-eureka-server7001、cloud-eureka-server7002：集群部署eureka服务\n   3. cloud-provider-payment8001、cloud-provider-payment8002:生产者，提供服务，整合eureka\n\n * openfeign的涉及整合模块：\n   \n   1. cloud-consumer-feign-order80：消费者客户端\n   2. cloud-eureka-server7001、cloud-eureka-server7002：集群部署eureka服务\n   3. cloud-provider-payment8001、cloud-provider-payment8002:生产者，提供服务，整合eureka\n\n * hystrix的涉及整合模块：\n   \n   1. cloud-provider-hystrix-payment8001：生产者\n   2. cloud-consumer-feign-hystrix-order80：消费者80\n   3. cloud-consumer-hystrix-dashboard9001：hystrix的web监控模块\n\n * gateway的涉及整合模块：\n   \n   1. cloud-eureka-server7001、cloud-eureka-server7002：集群部署eureka服务\n   2. cloud-provider-payment8001、cloud-provider-payment8002：消费者\n   3. cloud-gateway-gateway9527：网关配置\n\n * config全局配置\n   \n   1. cloud-eureka-server7001、cloud-eureka-server7002：集群部署eureka服务\n   2. cloud-provider-payment8001、cloud-provider-payment8002：消费者\n   3. cloud-config-center-3344：读取github上的配置信息\n   4. cloud-config-client-3355：读取3344上的配置信息\n\n * 动态刷新bus\n   \n   1. cloud-eureka-server7001、cloud-eureka-server7002：集群部署eureka服务\n   2. cloud-config-center-3344：读取github上的配置信息\n   3. cloud-config-client-3355、cloud-config-client-3366：读取3344上的配置信息\n\n * 整合消息中间件\n   \n   1. cloud-eureka-server7001、cloud-eureka-server7002：集群部署eureka服务\n   2. cloud-stream-rabbitmq-provider8801：rabbitmq生产者\n   3. cloud-stream-rabbitmq-consumer8803、cloud-stream-rabbitmq-consumer8804：rabbitmq消费者\n\n * 链路追踪\n   \n   1. cloud-eureka-server7001、cloud-eureka-server7002：集群部署eureka服务\n   2. cloud-provider-payment8001：服务端\n   3. cloud-consumer-order80：客户端\n\n * springcloud alibaba nacos服务注册和配置中心\n   \n   1. cloudalibaba-provider-payment9001：后端注册进服务\n   2. cloudalibaba-consumer-nacos-order83：客户端注册进服务\n   3. cloudalibaba-config-nacos-client3377：配置中心",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"SpringMVC",frontmatter:{title:"SpringMVC",date:"2021-07-21T14:28:11.000Z",permalink:"/pages/1923fe/",categories:["后端","Spring全家桶","SpringMVC"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/03.SpringMVC/00.SpringMVC.html",relativePath:"01.后端/10.Spring全家桶/03.SpringMVC/00.SpringMVC.md",key:"v-6ffc7c26",path:"/pages/1923fe/",headers:[{level:2,title:"springMVC 样例",slug:"springmvc-样例",normalizedTitle:"springmvc 样例",charIndex:16},{level:2,title:"spring MVC的执行流程",slug:"spring-mvc的执行流程",normalizedTitle:"spring mvc的执行流程",charIndex:7423},{level:2,title:"注解",slug:"注解",normalizedTitle:"注解",charIndex:8586},{level:2,title:"参数传递",slug:"参数传递",normalizedTitle:"参数传递",charIndex:15076},{level:2,title:"转发、重定向",slug:"转发、重定向",normalizedTitle:"转发、重定向",charIndex:19125},{level:2,title:"表单标签",slug:"表单标签",normalizedTitle:"表单标签",charIndex:20337},{level:2,title:"JSON数据转换",slug:"json数据转换",normalizedTitle:"json数据转换",charIndex:23269},{level:2,title:"拦截器（Interceptor）",slug:"拦截器-interceptor",normalizedTitle:"拦截器（interceptor）",charIndex:24389}],headersStr:"springMVC 样例 spring MVC的执行流程 注解 参数传递 转发、重定向 表单标签 JSON数据转换 拦截器（Interceptor）",content:'# SpringMVC\n\n\n# springMVC 样例\n\n1.导入所需的maven依赖\n\n\x3c!--测试--\x3e\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.11</version>\n            <scope>test</scope>\n        </dependency>\n        \x3c!--日志--\x3e\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n            <version>1.7.21</version>\n        </dependency>\n        \x3c!--J2EE--\x3e\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>3.1.0</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet.jsp</groupId>\n            <artifactId>jsp-api</artifactId>\n            <version>2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>jstl</artifactId>\n            <version>1.2</version>\n        </dependency>\n        \x3c!--mysql驱动包--\x3e\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.35</version>\n        </dependency>\n        \x3c!--springframework--\x3e\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-web</artifactId>\n            <version>5.2.3.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>5.2.3.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.2.3.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>5.2.3.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>5.2.3.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>com.github.stefanbirkner</groupId>\n            <artifactId>system-rules</artifactId>\n            <version>1.16.1</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.9</version>\n        </dependency>\n        \x3c!--其他需要的包--\x3e\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-lang3</artifactId>\n            <version>3.4</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-fileupload</groupId>\n            <artifactId>commons-fileupload</artifactId>\n            <version>1.3.1</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n\n2.在 web.xml 中部署 DispatcherServlet\n\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"\n         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"\n         version="3.0">\n    <display-name>springMVC</display-name>\n    \x3c!-- 部署 DispatcherServlet --\x3e\n    <servlet>\n        <servlet-name>springmvc</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:springmvc-servlet.xml</param-value>\n        </init-param>\n        \x3c!-- 表示容器再启动时立即加载servlet --\x3e\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>springmvc</servlet-name>\n        \x3c!-- 处理所有URL --\x3e\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n3.创建 springmvc-servlet.xml 文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="\n                           http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd">\n    \n    \x3c!-- 对转向页面的路径解析。prefix：前缀， suffix：后缀 --\x3e\n    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">\n        <property name="prefix" value="/WEB-INF/jsp/" />\n        <property name="suffix" value=".jsp" />\n    </bean>\n    \n    \x3c!-- LoginController控制器类，映射到"/login" --\x3e\n    <bean name="/login"\n          class="com.hand.controller.LoginController"/>\n    \x3c!-- LoginController控制器类，映射到"/register" --\x3e\n    <bean name="/register"\n          class="com.hand.controller.RegisterController"/>\n    \n    \x3c!-- <context:component-scan base-package="com.hand.controller" /> --\x3e\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n4.创建Controller\n\n// @Controller\npublic class LoginController implements Controller {\n    public ModelAndView handleRequest(HttpServletRequest arg0,\n            HttpServletResponse arg1) throws Exception {\n        return new ModelAndView("/WEB-INF/jsp/register.jsp");\n    }\n}\n\n// @Controller\npublic class RegisterController implements Controller {\n    public ModelAndView handleRequest(HttpServletRequest arg0,\n            HttpServletResponse arg1) throws Exception {\n        return new ModelAndView("/WEB-INF/jsp/login.jsp");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n5.创建视图\n\nindex.jsp\n\n    <%@ page language="java" contentType="text/html; charset=UTF-8"\n        pageEncoding="UTF-8"%>\n    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">\n    <html>\n    <head>\n    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n    <title>Insert title here</title>\n    </head>\n    <body>\n        未注册的用户，请\n        <a href="${pageContext.request.contextPath }/register"> 注册</a>！\n        <br /> 已注册的用户，去\n        <a href="${pageContext.request.contextPath }/login"> 登录</a>！\n    </body>\n    </html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nlogin.jsp\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\n        pageEncoding="UTF-8"%>\n    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">\n    <html>\n    <head>\n    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n    <title>Insert title here</title>\n    </head>\n    <body>\n        登录页面！\n    </body>\n    </html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nregister.jsp\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\n             pageEncoding="UTF-8" %>\n    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">\n    <html>\n    <head>\n        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n        <title>Insert title here</title>\n    <body>\n        注册页面！\n    </body>\n    </html>\n    </head>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# spring MVC的执行流程\n\n\n\nSpringMVC 的执行流程如下。\n\n 1.  用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）；\n 2.  由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）。\n 3.  DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）；\n 4.  HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）；\n 5.  Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）；\n 6.  HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ；\n 7.  DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析；\n 8.  ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet；\n 9.  DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）；\n 10. 视图负责将结果显示到浏览器（客户端）。\n\nSpring MVC 涉及到的组件有 DispatcherServlet（前端控制器）、HandlerMapping（处理器映射器）、HandlerAdapter（处理器适配器）、Handler（处理器）、ViewResolver（视图解析器）和 View（视图）。下面对各个组件的功能说明如下。\n\n 1. DispatcherServlet\n\nDispatcherServlet 是前端控制器，从图 1 可以看出，Spring MVC 的所有请求都要经过 DispatcherServlet 来统一分发。DispatcherServlet 相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。\n\n 2. HandlerMapping\n\nHandlerMapping 是处理器映射器，其作用是根据请求的 URL 路径，通过注解或者 XML 配置，寻找匹配的处理器（Handler）信息。\n\n 3. HandlerAdapter\n\nHandlerAdapter 是处理器适配器，其作用是根据映射器找到的处理器（Handler）信息，按照特定规则执行相关的处理器（Handler）。\n\n 4. Handler\n\nHandler 是处理器，和 Java Servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至 ModelAndView 对象中。\n\n 5. View Resolver\n\nView Resolver 是视图解析器，其作用是进行解析操作，通过 ModelAndView 对象中的 View 信息将逻辑视图名解析成真正的视图 View（如通过一个 JSP 路径返回一个真正的 JSP 页面）。\n\nURLBasedViewResolver\n\nUrlBasedViewResolver 通过 prefix 属性指定前缀，suffix 属性指定后缀。当 ModelAndView 对象返回具体的 View 名称时，它会将前缀 prefix 和后缀 suffix 与具体的视图名称拼接，得到一个视图资源文件的具体加载路径，从而加载真正的视图文件并反馈给用户。 使用 UrlBasedViewResolver 除了要配置前缀和后缀属性之外，还需要配置“viewClass”，表示解析成哪种视图\n\n<bean id="viewResolver" class="org.springframework.web.servlet.view.UrlBasedViewResolver">            \n        <property name="viewClass" value="org.springframework.web.servlet.view.InternalResourceViewResolver"/> \x3c!--不能省略--\x3e\n        \x3c!--前缀--\x3e\n        <property name="prefix" value="/WEB-INF/jsp/"/>\n        \x3c!--后缀--\x3e\n        <property name="suffix" value=".jsp"/>  \n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nInternalResourceViewResolver\n\n<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">\n        \x3c!--前缀--\x3e\n        <property name="prefix" value="/WEB-INF/jsp/"/>\n        \x3c!--后缀--\x3e\n        <property name="suffix" value=".jsp"/>  \n</bean>\n\n\n1\n2\n3\n4\n5\n6\n\n\nFreeMarkerViewResolver\n\n<bean class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver">\n        <property name="prefix" value="fm_"/>\n        <property name="suffix" value=".ftl"/>\n     \x3c!-- FreeMarkerViewResolver需要设置一个 FreeMarkerConfig 的 bean 对象来定义 FreeMarker 的配置信息 --\x3e\n    \t<property name="templateLoaderPath" value="/WEB-INF/ftl" />\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n\n\n定义了 templateLoaderPath 属性后，Spring 可以通过该属性找到 FreeMarker 模板文件的具体位置\n\n@Controller\n@RequestMapping("viewtest")\npublic class ViewController {\n    @RequestMapping("freemarker")\n    public ModelAndView freemarker() {\n        ModelAndView mv = new ModelAndView();\n        mv.addObject("username", "hand");\n        mv.setViewName("freemarker");\n        return mv;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nfm_freemarker.ftl\n\n<html>\n<head>\n<title>FreeMarker</title>\n</head>\n<body>\n<b>Welcome!</b>\n<i>${username }</i>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 6. View\n\nView 是视图，其本身是一个接口，实现类支持不同的 View 类型（JSP、FreeMarker、Excel 等）。\n\n\n# 注解\n\n@controller:用于声明某类的实例是一个控制器\n\n一般与扫描机制配合使用（在 springmvc-servlet.xml 文件中）\n\n\x3c!-- 使用扫描机制扫描控制器类，控制器类都在net.biancheng.controller包及其子包下 --\x3e\n<context:component-scan base-package="com.hand.controller" />\n\n\n1\n2\n\n\n@RequestMapping：指定请求路径，将请求映射到对应的控制器方法上\n\n常用属性：\n\n1. value 属性：默认属性，只有value属性时，可忽略属性名\n\n@RequestMapping(value="123")\n@RequestMapping("123")\n\n\n1\n2\n\n\n 2. path属性\n    \n    与value属性相似，作为路径映射使用；\n    \n    path 属性支持通配符匹配，如 @RequestMapping(path="test/*")， localhost:8080/test/1 或 localhost:8080/test/hahaha都能够正常访问\n\n 3. name属性\n    \n    相当于方法的注释\n    \n    @RequestMapping(value = "getUser",name = "获取用户信息")\n\n 4. method属性\n    \n    用于表示该方法支持哪些 HTTP 请求。如果省略 method 属性，则说明该方法支持全部的 HTTP 请求\n    \n    @RequestMapping(value = "toUser",method = RequestMethod.GET)\n    \n    @RequestMapping(value = "toUser",method = {RequestMethod.GET,RequestMethod.POST}\n\n 5. params属性\n    \n    用于指定请求中规定的参数\n    \n    @RequestMapping(value = "toUser",params = "type")\n    public String toUser() {\n        \n        return "showUser";\n    }\n    \n    @RequestMapping(value = "toUser",params = "type=1")\n    public String toUser1() {\n        \n        return "showUser";\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n    \n    以上代码表示请求中必须包含 type 参数，且 type 参数为 1 时才能够执行该请求；\n    \n    localhost:8080/toUser?type=1 能够正常访问 toUser() 方法\n    \n    localhost:8080/toUser?type=2 则不能正常访问 toUser1() 方法\n\n 6. header属性\n    \n    表示请求中必须包含某些指定的 header 值\n    \n    如@RequestMapping(value = "toUser",headers = "Referer=http://www.xxx.com") 表示请求的 header 中必须包含了指定的“Referer”请求头，以及值为“http://www.xxx.com”时，才能执行该请求\n\n 7. consumers属性\n    \n    用于指定处理请求的提交内容类型（Content-Type），例如：application/json、text/html。如 @RequestMapping(value = "toUser",consumes = "application/json")\n\n 8. produces属性\n    \n    用于指定返回的内容类型，返回的内容类型必须是 request 请求头（Accept）中所包含的类型\n    \n    如 @RequestMapping(value = "toUser",produces = "application/json")； produces 属性还可以指定返回值的编码，\n    \n    如 @RequestMapping(value = "toUser",produces = "application/json,charset=utf-8")，表示返回 utf-8 编码； 使用 @RequestMapping 来完成映射，具体包括 4 个方面的信息项：请求 URL、请求参数、请求方法和请求头\n    \n    @Service：会将标注类自动注册到 Spring 容器中，与自动扫描搭配使用\n    \n    <context:component-scan base-package="com.hand.service"/>\n    \n    \n    1\n    \n    \n    @Autowired ：对类成员变量、方法及构造函数进行标注，完成自动装配的工作\n    \n    // 声明user实体类\n    public class User {\n        private String name;\n        private String pwd;\n        /*省略setter和getter方法*/\n    }\n    \n    //定义接口类\n    public interface IUserService {\n        boolean login(User user);\n        boolean register(User user);\n    }\n    \n    //实现类\n    @Service\n    public class UserServiceImpl implements IUserService {\n        @Override\n        public boolean login(User user) {\n            if ("bianchengbang".equals(user.getName()) && "123456".equals(user.getPwd())) {\n                return true;\n            }\n            return false;\n        }\n        @Override\n        public boolean register(User user) {\n            if ("bianchengbang".equals(user.getName()) && "123456".equals(user.getPwd())) {\n                return true;\n            }\n            return false;\n        }\n    }\n    \n    // 控制器类\n    @Controller\n    @RequestMapping("/user")\n    public class UserController {\n        @Autowired\n        private IUserService userService;\n        @RequestMapping("/login")\n        public String getLogin(Model model) {\n            User us = new User();\n            us.setName("bianchengbang");\n            userService.login(us);\n            model.addAttribute("user", us);\n            return "login";\n        }\n        @RequestMapping("/register")\n        public String getRegister(Model model) {\n            User us = new User();\n            us.setName("bianchengbang");\n            userService.login(us);\n            model.addAttribute("user", us);\n            return "register";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    \n\n\n# 参数传递\n\nSpring MVC Controller 接收请求参数的方式有很多种，有的适合 get 请求方式，有的适合 post 请求方式，有的两者都适合。主要有以下几种方式：\n\n * 通过实体 Bean 接收请求参数\n * 通过处理方法的形参接收请求参数\n * 通过 HttpServletRequest 接收请求参数\n * 通过 @PathVariable 接收 URL 中的请求参数\n * 通过 @RequestParam 接收请求参数\n * 通过 @ModelAttribute 接收请求参数\n\n 1. 通过实体Bean接收请求参数：适用于 get 和 post 提交请求方式。需要注意，Bean 的属性名称必须与请求参数名称相同\n    \n    @RequestMapping("/login")\n    public String login(User user, Model model) {\n    \tif ("hand".equals(user.getName()) && "123456".equals(user.getPwd())) {\n    \n    \t\tmodel.addAttribute("message", "登录成功");\n    \t\treturn "main"; // 登录成功，跳转到 main.jsp\n    \t} else {\n            model.addAttribute("message", "用户名或密码错误");\n            return "login";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 2. 通过处理方法的形参接收请求参数：直接把表单参数写在控制器类相应方法的形参中，即形参名称与请求参数名称完全相同。该接收参数方式适用于 get 和 post 提交请求方式\n    \n    @RequestMapping("/login")\n    public String login(String name, String pwd, Model model) {\n    \tif ("hand".equals(user.getName()) && "123456".equals(user.getPwd())) {\n    \n    \t\tmodel.addAttribute("message", "登录成功");\n    \t\treturn "main"; // 登录成功，跳转到 main.jsp\n    \t} else {\n    \t\tmodel.addAttribute("message", "用户名或密码错误");\n    \t\treturn "login";\n    \t}\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 3. 通过 HttpServletRequest 接收请求参数：适用于 get 和 post 提交请求方式\n    \n    @RequestMapping("/login")\n    public String login(HttpServletRequest request, Model model) {\n        String name = request.getParameter("name");\n        String pwd = request.getParameter("pwd");\n    \n        if ("hand".equals(name)  && "123456".equals(pwd)) {\n    \n            model.addAttribute("message", "登录成功");\n            return "main"; // 登录成功，跳转到 main.jsp\n        } else {\n            model.addAttribute("message", "用户名或密码错误");\n            return "login";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n 4. 通过 @PathVariable 接收 URL 中的请求参数\n    \n    @RequestMapping("/login/{name}/{pwd}")\n    public String login(@PathVariable String name, @PathVariable String pwd, Model model) {\n    \n        if ("hand".equals(name) && "123456".equals(pwd)) {\n            model.addAttribute("message", "登录成功");\n            return "main"; // 登录成功，跳转到 main.jsp\n        } else {\n            model.addAttribute("message", "用户名或密码错误");\n            return "login";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n    \n    在访问 localhost:8080/springMVCDemo02/user/login/hand/123456 路径时，上述代码会自动将URL 中的模板变量 {name} 和 {pwd} 绑定到通过 @PathVariable 注解的同名参数上，即 name=hand、pwd=123456\n\n 5. 通过 @RequestParam 接收请求参数：适用于 get 和 post 提交请求方式\n    \n    @RequestParam有以下三个参数：\n    \n    value：参数名\n    \n    required：是否必须，默认为 true，表示请求中必须包含对应的参数名，若不存在将抛出异常\n    \n    defaultValue：参数默认值\n    \n    @RequestMapping("/login")\n    public String login(@RequestParam String name, @RequestParam String pwd, Model model) {\n    \n        if ("hand".equals(name) && "123456".equals(pwd)) {\n    \n            model.addAttribute("message", "登录成功");\n            return "main"; // 登录成功，跳转到 main.jsp\n        } else {\n            model.addAttribute("message", "用户名或密码错误");\n            return "login";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n    \n    当请求参数与接收参数名不一致时，“通过处理方法的形参接收请求参数”不会报 404 错误，而“通过 @RequestParam 接收请求参数”会报 404 错误\n\n 6. 通过 @ModelAttribute 接收请求参数：适用于 get 和 post 提交请求方式\n    \n    @ModelAttribute 注解用于将多个请求参数封装到一个实体对象中，从而简化数据绑定流程，而且自动暴露为模型数据，在视图页面展示时使用\n    \n    @RequestMapping("/login")\n    public String login(@ModelAttribute("user") User user, Model model) {\n    \n        if ("hand".equals(name) && "123456".equals(pwd)) {\n    \n            model.addAttribute("message", "登录成功");\n            return "main"; // 登录成功，跳转到 main.jsp\n        } else {\n            model.addAttribute("message", "用户名或密码错误");\n            return "login";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n\n# 转发、重定向\n\n**转发 **是服务器行为，客户浏览器发送 http 请求，Web 服务器接受此请求，调用内部的一个方法在容器内部完成请求处理和转发动作，将目标资源发送给客户；在这里转发的路径必须是同一个 Web 容器下的 URL，不能转向到其他的 Web 路径上；\n\n重定向 是客户端行为，客户浏览器发送 http 请求，Web 服务器接受后发送 302 状态码响应及对应新的 location 给客户浏览器，客户浏览器发现是 302响应，则自动再发送一个新的 http 请求，请求 URL 是新的 location 地址，服务器根据此请求寻找资源并发送给客户\n\n@Controller\n@RequestMapping("/index")\npublic class IndexController {\n    \n    @RequestMapping("/login")\n    public String login() {\n        //转发到一个请求方法（同一个控制器类可以省略/index/）\n        return "forward:/index/isLogin";\n    }\n    \n    @RequestMapping("/isLogin")\n    public String isLogin() {\n        //重定向到一个请求方法\n        return "redirect:/index/isRegister";\n    }\n    \n    @RequestMapping("/isRegister")\n    public String isRegister() {\n        //转发到一个视图\n        return "register";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n在 Spring MVC 框架中，不管是重定向或转发，都需要符合视图解析器的配置，如果直接转发到一个不需要 DispatcherServlet 的资源，例如：\n\n return "forward:/html/test.html";\n\n\n1\n\n\n则需要使用 mvc:resources 配置：\n\n <mvc:resources location="/html/" mapping="/html/**" />\n <mvc:resources location="/img/" mapping="/img/**"/>   \n <mvc:resources location="/js/" mapping="/js/**"/>    \n <mvc:resources location="/css/" mapping="/css/**"/>  \n\n\n1\n2\n3\n4\n\n\n\n# 表单标签\n\n在进行 Spring MVC 项目开发时，一般会使用 EL 表达式和 JSTL 标签来完成页面视图的开发；\n\nSpring 也有自己的一套表单标签库，通过 Spring 表单标签，可以很容易地将模型数据中的命令对象绑定到 HTML 表单元素中\n\n和 JSTL 标签的使用方法相同，在使用 Spring 表单标签之前，必须在 JSP 页面开头处声明 taglib 指令\n\n<%@ taglib prefix="fm" uri="http://www.springframework.org/tags/form"%>\n\n\n1\n\n\n常用的 Spring 表单标签如下：\n\n名称             作用\nform           渲染表单元素\ninput          输入框组件标签，渲染 元素\npassword       密码框组件标签，渲染 元素\nhidden         隐藏框组件标签，渲染 元素\ntextarea       多行输入框组件标签，渲染 textarea 元素\ncheckbox       复选框组件标签，渲染一个 元素\ncheckboxes     渲染多个 元素\nradiobutton    单选框组件标签，渲染一个 元素\nradiobuttons   渲染多个 元素\nselect         下拉列表组件标签，渲染一个选择元素\noption         渲染一个选项元素\noptions        渲染多个选项元素\nerrors         显示表单数据校验所对应的错误信息\n\n以上标签基本都拥有以下属性。\n\n * path：属性路径，表示表单对象属性，如 userName、userCode 等。\n * cssClass：表单组件对应的 CSS 样式类名。\n * cssErrorClass：当提交表单后报错（服务端错误），采用的 CSS 样式类。\n * cssStyle：表单组件对应的 CSS 样式。\n * htmlEscape：绑定的表单属性值是否要对 HTML 特殊字符进行转换，默认为 true。\n\naddUser.jsp\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\n    pageEncoding="UTF-8"%>\n<%@ taglib prefix="fm" uri="http://www.springframework.org/tags/form"%>\n<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">\n<html>\n    <head>\n        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n        <title>添加用户</title>\n    </head>\n    <body>\n        <fm:form method="post" modelAttribute="user" action="${pageContext.request.contextPath }/showuser">\n            用户名：<fm:input path="name"/>\n            <br />\n            年龄：<fm:input path="age"/>\n            <br />\n            身高：<fm:input path="height"/>\n            <br />\n            <input type="submit" value="保存" />\n        </fm:form>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nshowUser.jsp\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\n    pageEncoding="UTF-8"%>\n<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">\n<html>\n    <head>\n        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n        <title>用户信息</title>\n    </head>\n    <body>\n        您创建的用户信息如下：\n        <br />\n        \x3c!-- 使用EL表达式取出model中的user信息 --\x3e\n        用户名：${user.name }\n        <br /> 年龄：${user.age }\n        <br /> 身高：${user.height }\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n// 创建控制器类\n@Controller\npublic class UserController {\n    @RequestMapping(value = "/addUser", method = RequestMethod.GET)\n    public String add(@ModelAttribute("user") User user) {\n        return "addUser";\n    }\n    @RequestMapping(value = "/showuser", method = RequestMethod.POST)\n    public String showuser(User user, HttpSession session, HttpServletRequest request) {\n        return "showUser";\n    }\n}\n\n// 创建实体类\npublic class User {\n    private String name;\n    private Integer age;\n    private Double height;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n启动项目后访问localhost:8080/addUser\n\n\n# JSON数据转换\n\nMVC 在数据绑定的过程中需要对传递数据的格式和类型进行转换，它既可以转换 String 等类型的数据，也可以转换 JSON 等其他类型的数据\n\nJSON（JavaScript Object Notation, JS 对象标记）是一种轻量级的数据交换格式。与 XML 一样，JSON 也是基于纯文本的数据格式。它有对象结构和数组结构两种数据结构\n\n1.对象结构：对象结构以{开始、以}结束，中间部分由 0 个或多个以英文,分隔的 key/value 对构成，key 和 value 之间以英文:分隔\n\nkey 必须为 String 类型，value 可以是 String、Number、Object、Array 等数据类型\n\n{\n    "pname":"张三",\n    "password":"123456",\n    "page":40\n}\n\n\n1\n2\n3\n4\n5\n\n\n2.数组结构：数组结构以[开始、以]结束，中间部分由 0 个或多个以英文,分隔的值的列表组成\n\n["篮球","足球","羽毛球"]\n\n\n1\n\n\n对象、数组两种数据结构也可以分别组合构成更加复杂的数据结构\n\n[{\n    "sno":"201802228888",\n    "sname":"张三",\n    "hobby":["篮球","足球"],\n    "college":{\n        "cname":"清华大学",\n        "city":"北京"\n    }\n},\n{\n    "sno":"201802228888",\n    "sname":"张三",\n    "hobby":["篮球","足球"],\n    "college":{\n        "cname":"清华大学",\n        "city":"北京"\n    }\n}]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n为实现浏览器与控制器类之间的 JSON 数据交互，Spring MVC 提供了 MappingJackson2HttpMessageConverter 实现类默认处理 JSON 格式请求响应。该实现类利用 Jackson 开源包读写 JSON 数据，将 Java 对象转换为 JSON 对象和 XML 文档，同时也可以将 JSON 对象和 XML 文档转换为 Java 对象。\n\n * @RequestBody：用于将请求体中的数据绑定到方法的形参中，该注解应用在方法的形参上。\n * @ResponseBody：用于直接返回 return 对象，该注解应用在方法上。\n\n\n# 拦截器（Interceptor）\n\n用于请求的预处理和后处理\n\n在 Spring MVC 框架中定义一个拦截器需要对拦截器进行定义和配置，主要有以下 2 种方式。\n\n 1. 通过实现 HandlerInterceptor 接口或继承 HandlerInterceptor 接口的实现类\n 2. 通过实现 WebRequestInterceptor 接口或继承 WebRequestInterceptor 接口\n\n测试样例：\n\n1.controller中添加测试api\n\n/**\n     * 登录页面初始化\n     */\n@RequestMapping("/toLogin")\npublic String initLogin() {\n    return "login";\n}\n/**\n     * 处理登录功能\n     */\n@RequestMapping("/login")\npublic String login(User user, Model model, HttpSession session) {\n    System.out.println(user.getName());\n    if ("hand".equals(user.getName()) && "123456".equals(user.getPwd())) {\n        // 登录成功，将用户信息保存到session对象中\n        session.setAttribute("user", user);\n        // 重定向到主页面的跳转方法\n        return "redirect:main";\n    }\n    model.addAttribute("msg", "用户名或密码错误，请重新登录！ ");\n    return "login";\n}\n/**\n     * 跳转到主页面\n     */\n@RequestMapping("/main")\npublic String toMain() {\n    return "main";\n}\n/**\n     * 退出登录\n     */\n@RequestMapping("/logout")\npublic String logout(HttpSession session) {\n    // 清除 session\n    session.invalidate();\n    return "login";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n2.继承HandlerInterceptor接口，实现拦截器\n\npublic class TestInterceptor implements HandlerInterceptor {\n    \n    // 请求之前\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n            throws Exception {\n        // 获取请求的URL\n        String url = request.getRequestURI();\n        // login.jsp或登录请求放行，不拦截\n        if (url.indexOf("/toLogin") >= 0 || url.indexOf("/login") >= 0) {\n            return true;\n        }\n        // 获取 session\n        HttpSession session = request.getSession();\n        Object obj = session.getAttribute("user");\n        if (obj != null)\n            return true;\n        // 没有登录且不是登录页面，转发到登录页面，并给出提示错误信息\n        request.setAttribute("msg", "还没登录，请先登录！");\n        request.getRequestDispatcher("/WEB-INF/jsp/login.jsp").forward(request, response);\n        return false;\n    }\n    \n    // 请求完全结束（包括视图加载完成）\n    @Override\n    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)\n            throws Exception {\n        // TODO Auto-generated method stub\n    }\n    \n    // 请求结束之后，视图加载之前\n    @Override\n    public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)\n            throws Exception {\n        // TODO Auto-generated method stub\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n3.在springMvc-servlet.xml文件中添加拦截器的配置信息\n\n\x3c!-- 配置拦截器 --\x3e\n<mvc:interceptors>\n    <mvc:interceptor>\n        \x3c!-- 配置拦截器作用的路径 --\x3e\n        <mvc:mapping path="/**" />\n        <bean class="com.hand.interceptor.TestInterceptor" />\n    </mvc:interceptor>\n</mvc:interceptors>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n4.创建视图\n\nlogin.jsp\n\n    <%@ page language="java" contentType="text/html; charset=UTF-8"\n        pageEncoding="UTF-8"%>\n    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">\n    <html>\n    <head>\n    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n    <title>用户登录</title>\n    </head>\n    <body>\n        ${msg }\n        <form action="${pageContext.request.contextPath }/login" method="post">\n            用户名：<input type="text" name="name" /><br>\n            密码：<input type="password" name="pwd" /><br>\n            <input type="submit" value="登录" />\n        </form>\n    </body>\n    </html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nmain.jsp\n\n    <%@ page language="java" contentType="text/html; charset=UTF-8"\n    pageEncoding="UTF-8"%>\n    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">\n    <html>\n    <head>\n    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n    <title>首页</title>\n    </head>\n    <body>\n        欢迎 ${user.name }，登录！<br />\n        <a href="${pageContext.request.contextPath }/logout">退出</a>\n    </body>\n    </html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',normalizedContent:'# springmvc\n\n\n# springmvc 样例\n\n1.导入所需的maven依赖\n\n\x3c!--测试--\x3e\n        <dependency>\n            <groupid>junit</groupid>\n            <artifactid>junit</artifactid>\n            <version>4.11</version>\n            <scope>test</scope>\n        </dependency>\n        \x3c!--日志--\x3e\n        <dependency>\n            <groupid>org.slf4j</groupid>\n            <artifactid>slf4j-log4j12</artifactid>\n            <version>1.7.21</version>\n        </dependency>\n        \x3c!--j2ee--\x3e\n        <dependency>\n            <groupid>javax.servlet</groupid>\n            <artifactid>javax.servlet-api</artifactid>\n            <version>3.1.0</version>\n        </dependency>\n        <dependency>\n            <groupid>javax.servlet.jsp</groupid>\n            <artifactid>jsp-api</artifactid>\n            <version>2.2</version>\n        </dependency>\n        <dependency>\n            <groupid>javax.servlet</groupid>\n            <artifactid>jstl</artifactid>\n            <version>1.2</version>\n        </dependency>\n        \x3c!--mysql驱动包--\x3e\n        <dependency>\n            <groupid>mysql</groupid>\n            <artifactid>mysql-connector-java</artifactid>\n            <version>5.1.35</version>\n        </dependency>\n        \x3c!--springframework--\x3e\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-web</artifactid>\n            <version>5.2.3.release</version>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-webmvc</artifactid>\n            <version>5.2.3.release</version>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-context</artifactid>\n            <version>5.2.3.release</version>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-test</artifactid>\n            <version>5.2.3.release</version>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-jdbc</artifactid>\n            <version>5.2.3.release</version>\n        </dependency>\n        <dependency>\n            <groupid>com.github.stefanbirkner</groupid>\n            <artifactid>system-rules</artifactid>\n            <version>1.16.1</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupid>org.aspectj</groupid>\n            <artifactid>aspectjweaver</artifactid>\n            <version>1.8.9</version>\n        </dependency>\n        \x3c!--其他需要的包--\x3e\n        <dependency>\n            <groupid>org.apache.commons</groupid>\n            <artifactid>commons-lang3</artifactid>\n            <version>3.4</version>\n        </dependency>\n        <dependency>\n            <groupid>commons-fileupload</groupid>\n            <artifactid>commons-fileupload</artifactid>\n            <version>1.3.1</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n\n2.在 web.xml 中部署 dispatcherservlet\n\n<?xml version="1.0" encoding="utf-8"?>\n<web-app xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"\n         xsi:schemalocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"\n         version="3.0">\n    <display-name>springmvc</display-name>\n    \x3c!-- 部署 dispatcherservlet --\x3e\n    <servlet>\n        <servlet-name>springmvc</servlet-name>\n        <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n        <init-param>\n            <param-name>contextconfiglocation</param-name>\n            <param-value>classpath:springmvc-servlet.xml</param-value>\n        </init-param>\n        \x3c!-- 表示容器再启动时立即加载servlet --\x3e\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>springmvc</servlet-name>\n        \x3c!-- 处理所有url --\x3e\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n3.创建 springmvc-servlet.xml 文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="\n                           http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd">\n    \n    \x3c!-- 对转向页面的路径解析。prefix：前缀， suffix：后缀 --\x3e\n    <bean class="org.springframework.web.servlet.view.internalresourceviewresolver">\n        <property name="prefix" value="/web-inf/jsp/" />\n        <property name="suffix" value=".jsp" />\n    </bean>\n    \n    \x3c!-- logincontroller控制器类，映射到"/login" --\x3e\n    <bean name="/login"\n          class="com.hand.controller.logincontroller"/>\n    \x3c!-- logincontroller控制器类，映射到"/register" --\x3e\n    <bean name="/register"\n          class="com.hand.controller.registercontroller"/>\n    \n    \x3c!-- <context:component-scan base-package="com.hand.controller" /> --\x3e\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n4.创建controller\n\n// @controller\npublic class logincontroller implements controller {\n    public modelandview handlerequest(httpservletrequest arg0,\n            httpservletresponse arg1) throws exception {\n        return new modelandview("/web-inf/jsp/register.jsp");\n    }\n}\n\n// @controller\npublic class registercontroller implements controller {\n    public modelandview handlerequest(httpservletrequest arg0,\n            httpservletresponse arg1) throws exception {\n        return new modelandview("/web-inf/jsp/login.jsp");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n5.创建视图\n\nindex.jsp\n\n    <%@ page language="java" contenttype="text/html; charset=utf-8"\n        pageencoding="utf-8"%>\n    <!doctype html public "-//w3c//dtd html 4.01 transitional//en" "http://www.w3.org/tr/html4/loose.dtd">\n    <html>\n    <head>\n    <meta http-equiv="content-type" content="text/html; charset=utf-8">\n    <title>insert title here</title>\n    </head>\n    <body>\n        未注册的用户，请\n        <a href="${pagecontext.request.contextpath }/register"> 注册</a>！\n        <br /> 已注册的用户，去\n        <a href="${pagecontext.request.contextpath }/login"> 登录</a>！\n    </body>\n    </html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nlogin.jsp\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\n        pageencoding="utf-8"%>\n    <!doctype html public "-//w3c//dtd html 4.01 transitional//en" "http://www.w3.org/tr/html4/loose.dtd">\n    <html>\n    <head>\n    <meta http-equiv="content-type" content="text/html; charset=utf-8">\n    <title>insert title here</title>\n    </head>\n    <body>\n        登录页面！\n    </body>\n    </html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nregister.jsp\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\n             pageencoding="utf-8" %>\n    <!doctype html public "-//w3c//dtd html 4.01 transitional//en" "http://www.w3.org/tr/html4/loose.dtd">\n    <html>\n    <head>\n        <meta http-equiv="content-type" content="text/html; charset=utf-8">\n        <title>insert title here</title>\n    <body>\n        注册页面！\n    </body>\n    </html>\n    </head>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# spring mvc的执行流程\n\n\n\nspringmvc 的执行流程如下。\n\n 1.  用户点击某个请求路径，发起一个 http request 请求，该请求会被提交到 dispatcherservlet（前端控制器）；\n 2.  由 dispatcherservlet 请求一个或多个 handlermapping（处理器映射器），并返回一个执行链（handlerexecutionchain）。\n 3.  dispatcherservlet 将执行链返回的 handler 信息发送给 handleradapter（处理器适配器）；\n 4.  handleradapter 根据 handler 信息找到并执行相应的 handler（常称为 controller）；\n 5.  handler 执行完毕后会返回给 handleradapter 一个 modelandview 对象（spring mvc的底层对象，包括 model 数据模型和 view 视图信息）；\n 6.  handleradapter 接收到 modelandview 对象后，将其返回给 dispatcherservlet ；\n 7.  dispatcherservlet 接收到 modelandview 对象后，会请求 viewresolver（视图解析器）对视图进行解析；\n 8.  viewresolver 根据 view 信息匹配到相应的视图结果，并返回给 dispatcherservlet；\n 9.  dispatcherservlet 接收到具体的 view 视图后，进行视图渲染，将 model 中的模型数据填充到 view 视图中的 request 域，生成最终的 view（视图）；\n 10. 视图负责将结果显示到浏览器（客户端）。\n\nspring mvc 涉及到的组件有 dispatcherservlet（前端控制器）、handlermapping（处理器映射器）、handleradapter（处理器适配器）、handler（处理器）、viewresolver（视图解析器）和 view（视图）。下面对各个组件的功能说明如下。\n\n 1. dispatcherservlet\n\ndispatcherservlet 是前端控制器，从图 1 可以看出，spring mvc 的所有请求都要经过 dispatcherservlet 来统一分发。dispatcherservlet 相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。\n\n 2. handlermapping\n\nhandlermapping 是处理器映射器，其作用是根据请求的 url 路径，通过注解或者 xml 配置，寻找匹配的处理器（handler）信息。\n\n 3. handleradapter\n\nhandleradapter 是处理器适配器，其作用是根据映射器找到的处理器（handler）信息，按照特定规则执行相关的处理器（handler）。\n\n 4. handler\n\nhandler 是处理器，和 java servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至 modelandview 对象中。\n\n 5. view resolver\n\nview resolver 是视图解析器，其作用是进行解析操作，通过 modelandview 对象中的 view 信息将逻辑视图名解析成真正的视图 view（如通过一个 jsp 路径返回一个真正的 jsp 页面）。\n\nurlbasedviewresolver\n\nurlbasedviewresolver 通过 prefix 属性指定前缀，suffix 属性指定后缀。当 modelandview 对象返回具体的 view 名称时，它会将前缀 prefix 和后缀 suffix 与具体的视图名称拼接，得到一个视图资源文件的具体加载路径，从而加载真正的视图文件并反馈给用户。 使用 urlbasedviewresolver 除了要配置前缀和后缀属性之外，还需要配置“viewclass”，表示解析成哪种视图\n\n<bean id="viewresolver" class="org.springframework.web.servlet.view.urlbasedviewresolver">            \n        <property name="viewclass" value="org.springframework.web.servlet.view.internalresourceviewresolver"/> \x3c!--不能省略--\x3e\n        \x3c!--前缀--\x3e\n        <property name="prefix" value="/web-inf/jsp/"/>\n        \x3c!--后缀--\x3e\n        <property name="suffix" value=".jsp"/>  \n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ninternalresourceviewresolver\n\n<bean id="viewresolver" class="org.springframework.web.servlet.view.internalresourceviewresolver">\n        \x3c!--前缀--\x3e\n        <property name="prefix" value="/web-inf/jsp/"/>\n        \x3c!--后缀--\x3e\n        <property name="suffix" value=".jsp"/>  \n</bean>\n\n\n1\n2\n3\n4\n5\n6\n\n\nfreemarkerviewresolver\n\n<bean class="org.springframework.web.servlet.view.freemarker.freemarkerviewresolver">\n        <property name="prefix" value="fm_"/>\n        <property name="suffix" value=".ftl"/>\n     \x3c!-- freemarkerviewresolver需要设置一个 freemarkerconfig 的 bean 对象来定义 freemarker 的配置信息 --\x3e\n    \t<property name="templateloaderpath" value="/web-inf/ftl" />\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n\n\n定义了 templateloaderpath 属性后，spring 可以通过该属性找到 freemarker 模板文件的具体位置\n\n@controller\n@requestmapping("viewtest")\npublic class viewcontroller {\n    @requestmapping("freemarker")\n    public modelandview freemarker() {\n        modelandview mv = new modelandview();\n        mv.addobject("username", "hand");\n        mv.setviewname("freemarker");\n        return mv;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nfm_freemarker.ftl\n\n<html>\n<head>\n<title>freemarker</title>\n</head>\n<body>\n<b>welcome!</b>\n<i>${username }</i>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 6. view\n\nview 是视图，其本身是一个接口，实现类支持不同的 view 类型（jsp、freemarker、excel 等）。\n\n\n# 注解\n\n@controller:用于声明某类的实例是一个控制器\n\n一般与扫描机制配合使用（在 springmvc-servlet.xml 文件中）\n\n\x3c!-- 使用扫描机制扫描控制器类，控制器类都在net.biancheng.controller包及其子包下 --\x3e\n<context:component-scan base-package="com.hand.controller" />\n\n\n1\n2\n\n\n@requestmapping：指定请求路径，将请求映射到对应的控制器方法上\n\n常用属性：\n\n1. value 属性：默认属性，只有value属性时，可忽略属性名\n\n@requestmapping(value="123")\n@requestmapping("123")\n\n\n1\n2\n\n\n 2. path属性\n    \n    与value属性相似，作为路径映射使用；\n    \n    path 属性支持通配符匹配，如 @requestmapping(path="test/*")， localhost:8080/test/1 或 localhost:8080/test/hahaha都能够正常访问\n\n 3. name属性\n    \n    相当于方法的注释\n    \n    @requestmapping(value = "getuser",name = "获取用户信息")\n\n 4. method属性\n    \n    用于表示该方法支持哪些 http 请求。如果省略 method 属性，则说明该方法支持全部的 http 请求\n    \n    @requestmapping(value = "touser",method = requestmethod.get)\n    \n    @requestmapping(value = "touser",method = {requestmethod.get,requestmethod.post}\n\n 5. params属性\n    \n    用于指定请求中规定的参数\n    \n    @requestmapping(value = "touser",params = "type")\n    public string touser() {\n        \n        return "showuser";\n    }\n    \n    @requestmapping(value = "touser",params = "type=1")\n    public string touser1() {\n        \n        return "showuser";\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n    \n    以上代码表示请求中必须包含 type 参数，且 type 参数为 1 时才能够执行该请求；\n    \n    localhost:8080/touser?type=1 能够正常访问 touser() 方法\n    \n    localhost:8080/touser?type=2 则不能正常访问 touser1() 方法\n\n 6. header属性\n    \n    表示请求中必须包含某些指定的 header 值\n    \n    如@requestmapping(value = "touser",headers = "referer=http://www.xxx.com") 表示请求的 header 中必须包含了指定的“referer”请求头，以及值为“http://www.xxx.com”时，才能执行该请求\n\n 7. consumers属性\n    \n    用于指定处理请求的提交内容类型（content-type），例如：application/json、text/html。如 @requestmapping(value = "touser",consumes = "application/json")\n\n 8. produces属性\n    \n    用于指定返回的内容类型，返回的内容类型必须是 request 请求头（accept）中所包含的类型\n    \n    如 @requestmapping(value = "touser",produces = "application/json")； produces 属性还可以指定返回值的编码，\n    \n    如 @requestmapping(value = "touser",produces = "application/json,charset=utf-8")，表示返回 utf-8 编码； 使用 @requestmapping 来完成映射，具体包括 4 个方面的信息项：请求 url、请求参数、请求方法和请求头\n    \n    @service：会将标注类自动注册到 spring 容器中，与自动扫描搭配使用\n    \n    <context:component-scan base-package="com.hand.service"/>\n    \n    \n    1\n    \n    \n    @autowired ：对类成员变量、方法及构造函数进行标注，完成自动装配的工作\n    \n    // 声明user实体类\n    public class user {\n        private string name;\n        private string pwd;\n        /*省略setter和getter方法*/\n    }\n    \n    //定义接口类\n    public interface iuserservice {\n        boolean login(user user);\n        boolean register(user user);\n    }\n    \n    //实现类\n    @service\n    public class userserviceimpl implements iuserservice {\n        @override\n        public boolean login(user user) {\n            if ("bianchengbang".equals(user.getname()) && "123456".equals(user.getpwd())) {\n                return true;\n            }\n            return false;\n        }\n        @override\n        public boolean register(user user) {\n            if ("bianchengbang".equals(user.getname()) && "123456".equals(user.getpwd())) {\n                return true;\n            }\n            return false;\n        }\n    }\n    \n    // 控制器类\n    @controller\n    @requestmapping("/user")\n    public class usercontroller {\n        @autowired\n        private iuserservice userservice;\n        @requestmapping("/login")\n        public string getlogin(model model) {\n            user us = new user();\n            us.setname("bianchengbang");\n            userservice.login(us);\n            model.addattribute("user", us);\n            return "login";\n        }\n        @requestmapping("/register")\n        public string getregister(model model) {\n            user us = new user();\n            us.setname("bianchengbang");\n            userservice.login(us);\n            model.addattribute("user", us);\n            return "register";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    \n\n\n# 参数传递\n\nspring mvc controller 接收请求参数的方式有很多种，有的适合 get 请求方式，有的适合 post 请求方式，有的两者都适合。主要有以下几种方式：\n\n * 通过实体 bean 接收请求参数\n * 通过处理方法的形参接收请求参数\n * 通过 httpservletrequest 接收请求参数\n * 通过 @pathvariable 接收 url 中的请求参数\n * 通过 @requestparam 接收请求参数\n * 通过 @modelattribute 接收请求参数\n\n 1. 通过实体bean接收请求参数：适用于 get 和 post 提交请求方式。需要注意，bean 的属性名称必须与请求参数名称相同\n    \n    @requestmapping("/login")\n    public string login(user user, model model) {\n    \tif ("hand".equals(user.getname()) && "123456".equals(user.getpwd())) {\n    \n    \t\tmodel.addattribute("message", "登录成功");\n    \t\treturn "main"; // 登录成功，跳转到 main.jsp\n    \t} else {\n            model.addattribute("message", "用户名或密码错误");\n            return "login";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 2. 通过处理方法的形参接收请求参数：直接把表单参数写在控制器类相应方法的形参中，即形参名称与请求参数名称完全相同。该接收参数方式适用于 get 和 post 提交请求方式\n    \n    @requestmapping("/login")\n    public string login(string name, string pwd, model model) {\n    \tif ("hand".equals(user.getname()) && "123456".equals(user.getpwd())) {\n    \n    \t\tmodel.addattribute("message", "登录成功");\n    \t\treturn "main"; // 登录成功，跳转到 main.jsp\n    \t} else {\n    \t\tmodel.addattribute("message", "用户名或密码错误");\n    \t\treturn "login";\n    \t}\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 3. 通过 httpservletrequest 接收请求参数：适用于 get 和 post 提交请求方式\n    \n    @requestmapping("/login")\n    public string login(httpservletrequest request, model model) {\n        string name = request.getparameter("name");\n        string pwd = request.getparameter("pwd");\n    \n        if ("hand".equals(name)  && "123456".equals(pwd)) {\n    \n            model.addattribute("message", "登录成功");\n            return "main"; // 登录成功，跳转到 main.jsp\n        } else {\n            model.addattribute("message", "用户名或密码错误");\n            return "login";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n 4. 通过 @pathvariable 接收 url 中的请求参数\n    \n    @requestmapping("/login/{name}/{pwd}")\n    public string login(@pathvariable string name, @pathvariable string pwd, model model) {\n    \n        if ("hand".equals(name) && "123456".equals(pwd)) {\n            model.addattribute("message", "登录成功");\n            return "main"; // 登录成功，跳转到 main.jsp\n        } else {\n            model.addattribute("message", "用户名或密码错误");\n            return "login";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n    \n    在访问 localhost:8080/springmvcdemo02/user/login/hand/123456 路径时，上述代码会自动将url 中的模板变量 {name} 和 {pwd} 绑定到通过 @pathvariable 注解的同名参数上，即 name=hand、pwd=123456\n\n 5. 通过 @requestparam 接收请求参数：适用于 get 和 post 提交请求方式\n    \n    @requestparam有以下三个参数：\n    \n    value：参数名\n    \n    required：是否必须，默认为 true，表示请求中必须包含对应的参数名，若不存在将抛出异常\n    \n    defaultvalue：参数默认值\n    \n    @requestmapping("/login")\n    public string login(@requestparam string name, @requestparam string pwd, model model) {\n    \n        if ("hand".equals(name) && "123456".equals(pwd)) {\n    \n            model.addattribute("message", "登录成功");\n            return "main"; // 登录成功，跳转到 main.jsp\n        } else {\n            model.addattribute("message", "用户名或密码错误");\n            return "login";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n    \n    当请求参数与接收参数名不一致时，“通过处理方法的形参接收请求参数”不会报 404 错误，而“通过 @requestparam 接收请求参数”会报 404 错误\n\n 6. 通过 @modelattribute 接收请求参数：适用于 get 和 post 提交请求方式\n    \n    @modelattribute 注解用于将多个请求参数封装到一个实体对象中，从而简化数据绑定流程，而且自动暴露为模型数据，在视图页面展示时使用\n    \n    @requestmapping("/login")\n    public string login(@modelattribute("user") user user, model model) {\n    \n        if ("hand".equals(name) && "123456".equals(pwd)) {\n    \n            model.addattribute("message", "登录成功");\n            return "main"; // 登录成功，跳转到 main.jsp\n        } else {\n            model.addattribute("message", "用户名或密码错误");\n            return "login";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n\n# 转发、重定向\n\n**转发 **是服务器行为，客户浏览器发送 http 请求，web 服务器接受此请求，调用内部的一个方法在容器内部完成请求处理和转发动作，将目标资源发送给客户；在这里转发的路径必须是同一个 web 容器下的 url，不能转向到其他的 web 路径上；\n\n重定向 是客户端行为，客户浏览器发送 http 请求，web 服务器接受后发送 302 状态码响应及对应新的 location 给客户浏览器，客户浏览器发现是 302响应，则自动再发送一个新的 http 请求，请求 url 是新的 location 地址，服务器根据此请求寻找资源并发送给客户\n\n@controller\n@requestmapping("/index")\npublic class indexcontroller {\n    \n    @requestmapping("/login")\n    public string login() {\n        //转发到一个请求方法（同一个控制器类可以省略/index/）\n        return "forward:/index/islogin";\n    }\n    \n    @requestmapping("/islogin")\n    public string islogin() {\n        //重定向到一个请求方法\n        return "redirect:/index/isregister";\n    }\n    \n    @requestmapping("/isregister")\n    public string isregister() {\n        //转发到一个视图\n        return "register";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n在 spring mvc 框架中，不管是重定向或转发，都需要符合视图解析器的配置，如果直接转发到一个不需要 dispatcherservlet 的资源，例如：\n\n return "forward:/html/test.html";\n\n\n1\n\n\n则需要使用 mvc:resources 配置：\n\n <mvc:resources location="/html/" mapping="/html/**" />\n <mvc:resources location="/img/" mapping="/img/**"/>   \n <mvc:resources location="/js/" mapping="/js/**"/>    \n <mvc:resources location="/css/" mapping="/css/**"/>  \n\n\n1\n2\n3\n4\n\n\n\n# 表单标签\n\n在进行 spring mvc 项目开发时，一般会使用 el 表达式和 jstl 标签来完成页面视图的开发；\n\nspring 也有自己的一套表单标签库，通过 spring 表单标签，可以很容易地将模型数据中的命令对象绑定到 html 表单元素中\n\n和 jstl 标签的使用方法相同，在使用 spring 表单标签之前，必须在 jsp 页面开头处声明 taglib 指令\n\n<%@ taglib prefix="fm" uri="http://www.springframework.org/tags/form"%>\n\n\n1\n\n\n常用的 spring 表单标签如下：\n\n名称             作用\nform           渲染表单元素\ninput          输入框组件标签，渲染 元素\npassword       密码框组件标签，渲染 元素\nhidden         隐藏框组件标签，渲染 元素\ntextarea       多行输入框组件标签，渲染 textarea 元素\ncheckbox       复选框组件标签，渲染一个 元素\ncheckboxes     渲染多个 元素\nradiobutton    单选框组件标签，渲染一个 元素\nradiobuttons   渲染多个 元素\nselect         下拉列表组件标签，渲染一个选择元素\noption         渲染一个选项元素\noptions        渲染多个选项元素\nerrors         显示表单数据校验所对应的错误信息\n\n以上标签基本都拥有以下属性。\n\n * path：属性路径，表示表单对象属性，如 username、usercode 等。\n * cssclass：表单组件对应的 css 样式类名。\n * csserrorclass：当提交表单后报错（服务端错误），采用的 css 样式类。\n * cssstyle：表单组件对应的 css 样式。\n * htmlescape：绑定的表单属性值是否要对 html 特殊字符进行转换，默认为 true。\n\nadduser.jsp\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\n    pageencoding="utf-8"%>\n<%@ taglib prefix="fm" uri="http://www.springframework.org/tags/form"%>\n<!doctype html public "-//w3c//dtd html 4.01 transitional//en" "http://www.w3.org/tr/html4/loose.dtd">\n<html>\n    <head>\n        <meta http-equiv="content-type" content="text/html; charset=utf-8">\n        <title>添加用户</title>\n    </head>\n    <body>\n        <fm:form method="post" modelattribute="user" action="${pagecontext.request.contextpath }/showuser">\n            用户名：<fm:input path="name"/>\n            <br />\n            年龄：<fm:input path="age"/>\n            <br />\n            身高：<fm:input path="height"/>\n            <br />\n            <input type="submit" value="保存" />\n        </fm:form>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nshowuser.jsp\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\n    pageencoding="utf-8"%>\n<!doctype html public "-//w3c//dtd html 4.01 transitional//en" "http://www.w3.org/tr/html4/loose.dtd">\n<html>\n    <head>\n        <meta http-equiv="content-type" content="text/html; charset=utf-8">\n        <title>用户信息</title>\n    </head>\n    <body>\n        您创建的用户信息如下：\n        <br />\n        \x3c!-- 使用el表达式取出model中的user信息 --\x3e\n        用户名：${user.name }\n        <br /> 年龄：${user.age }\n        <br /> 身高：${user.height }\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n// 创建控制器类\n@controller\npublic class usercontroller {\n    @requestmapping(value = "/adduser", method = requestmethod.get)\n    public string add(@modelattribute("user") user user) {\n        return "adduser";\n    }\n    @requestmapping(value = "/showuser", method = requestmethod.post)\n    public string showuser(user user, httpsession session, httpservletrequest request) {\n        return "showuser";\n    }\n}\n\n// 创建实体类\npublic class user {\n    private string name;\n    private integer age;\n    private double height;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n启动项目后访问localhost:8080/adduser\n\n\n# json数据转换\n\nmvc 在数据绑定的过程中需要对传递数据的格式和类型进行转换，它既可以转换 string 等类型的数据，也可以转换 json 等其他类型的数据\n\njson（javascript object notation, js 对象标记）是一种轻量级的数据交换格式。与 xml 一样，json 也是基于纯文本的数据格式。它有对象结构和数组结构两种数据结构\n\n1.对象结构：对象结构以{开始、以}结束，中间部分由 0 个或多个以英文,分隔的 key/value 对构成，key 和 value 之间以英文:分隔\n\nkey 必须为 string 类型，value 可以是 string、number、object、array 等数据类型\n\n{\n    "pname":"张三",\n    "password":"123456",\n    "page":40\n}\n\n\n1\n2\n3\n4\n5\n\n\n2.数组结构：数组结构以[开始、以]结束，中间部分由 0 个或多个以英文,分隔的值的列表组成\n\n["篮球","足球","羽毛球"]\n\n\n1\n\n\n对象、数组两种数据结构也可以分别组合构成更加复杂的数据结构\n\n[{\n    "sno":"201802228888",\n    "sname":"张三",\n    "hobby":["篮球","足球"],\n    "college":{\n        "cname":"清华大学",\n        "city":"北京"\n    }\n},\n{\n    "sno":"201802228888",\n    "sname":"张三",\n    "hobby":["篮球","足球"],\n    "college":{\n        "cname":"清华大学",\n        "city":"北京"\n    }\n}]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n为实现浏览器与控制器类之间的 json 数据交互，spring mvc 提供了 mappingjackson2httpmessageconverter 实现类默认处理 json 格式请求响应。该实现类利用 jackson 开源包读写 json 数据，将 java 对象转换为 json 对象和 xml 文档，同时也可以将 json 对象和 xml 文档转换为 java 对象。\n\n * @requestbody：用于将请求体中的数据绑定到方法的形参中，该注解应用在方法的形参上。\n * @responsebody：用于直接返回 return 对象，该注解应用在方法上。\n\n\n# 拦截器（interceptor）\n\n用于请求的预处理和后处理\n\n在 spring mvc 框架中定义一个拦截器需要对拦截器进行定义和配置，主要有以下 2 种方式。\n\n 1. 通过实现 handlerinterceptor 接口或继承 handlerinterceptor 接口的实现类\n 2. 通过实现 webrequestinterceptor 接口或继承 webrequestinterceptor 接口\n\n测试样例：\n\n1.controller中添加测试api\n\n/**\n     * 登录页面初始化\n     */\n@requestmapping("/tologin")\npublic string initlogin() {\n    return "login";\n}\n/**\n     * 处理登录功能\n     */\n@requestmapping("/login")\npublic string login(user user, model model, httpsession session) {\n    system.out.println(user.getname());\n    if ("hand".equals(user.getname()) && "123456".equals(user.getpwd())) {\n        // 登录成功，将用户信息保存到session对象中\n        session.setattribute("user", user);\n        // 重定向到主页面的跳转方法\n        return "redirect:main";\n    }\n    model.addattribute("msg", "用户名或密码错误，请重新登录！ ");\n    return "login";\n}\n/**\n     * 跳转到主页面\n     */\n@requestmapping("/main")\npublic string tomain() {\n    return "main";\n}\n/**\n     * 退出登录\n     */\n@requestmapping("/logout")\npublic string logout(httpsession session) {\n    // 清除 session\n    session.invalidate();\n    return "login";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n2.继承handlerinterceptor接口，实现拦截器\n\npublic class testinterceptor implements handlerinterceptor {\n    \n    // 请求之前\n    @override\n    public boolean prehandle(httpservletrequest request, httpservletresponse response, object handler)\n            throws exception {\n        // 获取请求的url\n        string url = request.getrequesturi();\n        // login.jsp或登录请求放行，不拦截\n        if (url.indexof("/tologin") >= 0 || url.indexof("/login") >= 0) {\n            return true;\n        }\n        // 获取 session\n        httpsession session = request.getsession();\n        object obj = session.getattribute("user");\n        if (obj != null)\n            return true;\n        // 没有登录且不是登录页面，转发到登录页面，并给出提示错误信息\n        request.setattribute("msg", "还没登录，请先登录！");\n        request.getrequestdispatcher("/web-inf/jsp/login.jsp").forward(request, response);\n        return false;\n    }\n    \n    // 请求完全结束（包括视图加载完成）\n    @override\n    public void aftercompletion(httpservletrequest arg0, httpservletresponse arg1, object arg2, exception arg3)\n            throws exception {\n        // todo auto-generated method stub\n    }\n    \n    // 请求结束之后，视图加载之前\n    @override\n    public void posthandle(httpservletrequest arg0, httpservletresponse arg1, object arg2, modelandview arg3)\n            throws exception {\n        // todo auto-generated method stub\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n3.在springmvc-servlet.xml文件中添加拦截器的配置信息\n\n\x3c!-- 配置拦截器 --\x3e\n<mvc:interceptors>\n    <mvc:interceptor>\n        \x3c!-- 配置拦截器作用的路径 --\x3e\n        <mvc:mapping path="/**" />\n        <bean class="com.hand.interceptor.testinterceptor" />\n    </mvc:interceptor>\n</mvc:interceptors>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n4.创建视图\n\nlogin.jsp\n\n    <%@ page language="java" contenttype="text/html; charset=utf-8"\n        pageencoding="utf-8"%>\n    <!doctype html public "-//w3c//dtd html 4.01 transitional//en" "http://www.w3.org/tr/html4/loose.dtd">\n    <html>\n    <head>\n    <meta http-equiv="content-type" content="text/html; charset=utf-8">\n    <title>用户登录</title>\n    </head>\n    <body>\n        ${msg }\n        <form action="${pagecontext.request.contextpath }/login" method="post">\n            用户名：<input type="text" name="name" /><br>\n            密码：<input type="password" name="pwd" /><br>\n            <input type="submit" value="登录" />\n        </form>\n    </body>\n    </html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nmain.jsp\n\n    <%@ page language="java" contenttype="text/html; charset=utf-8"\n    pageencoding="utf-8"%>\n    <!doctype html public "-//w3c//dtd html 4.01 transitional//en" "http://www.w3.org/tr/html4/loose.dtd">\n    <html>\n    <head>\n    <meta http-equiv="content-type" content="text/html; charset=utf-8">\n    <title>首页</title>\n    </head>\n    <body>\n        欢迎 ${user.name }，登录！<br />\n        <a href="${pagecontext.request.contextpath }/logout">退出</a>\n    </body>\n    </html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"什么是微服务",frontmatter:{title:"什么是微服务",date:"2021-08-17T09:31:44.000Z",permalink:"/pages/b5f6d0/",categories:["后端","Spring全家桶","SpringCloud","什么是微服务"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/01.%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/01.什么是微服务.md",key:"v-5ace857b",path:"/pages/b5f6d0/",headers:[{level:2,title:"1.微服务的提出者：",slug:"_1-微服务的提出者",normalizedTitle:"1.微服务的提出者：",charIndex:13},{level:2,title:"2.微服务维度（支持）",slug:"_2-微服务维度-支持",normalizedTitle:"2.微服务维度（支持）",charIndex:145},{level:2,title:"3.微服务技术",slug:"_3-微服务技术",normalizedTitle:"3.微服务技术",charIndex:163},{level:2,title:"4.掌握技术",slug:"_4-掌握技术",normalizedTitle:"4.掌握技术",charIndex:177}],headersStr:"1.微服务的提出者： 2.微服务维度（支持） 3.微服务技术 4.掌握技术",content:"# 什么是微服务\n\n\n# 1.微服务的提出者：\n\n 1. 微服务架构是一种新的架构模式，把以前单一程序化分为一个一个的小服务，\n 2. 一个服务就是一个进程，所以一个服务的宕机，不会影响其他的服务；\n 3. 服务与服务之前通过HTTP协议通信。（通常是RESTful API）\n\n\n\n\n# 2.微服务维度（支持）\n\n\n\n\n# 3.微服务技术\n\n\n\n\n# 4.掌握技术\n\n",normalizedContent:"# 什么是微服务\n\n\n# 1.微服务的提出者：\n\n 1. 微服务架构是一种新的架构模式，把以前单一程序化分为一个一个的小服务，\n 2. 一个服务就是一个进程，所以一个服务的宕机，不会影响其他的服务；\n 3. 服务与服务之前通过http协议通信。（通常是restful api）\n\n\n\n\n# 2.微服务维度（支持）\n\n\n\n\n# 3.微服务技术\n\n\n\n\n# 4.掌握技术\n\n",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"选择Boot和Cloud版本",frontmatter:{title:"选择Boot和Cloud版本",date:"2021-08-17T09:31:44.000Z",permalink:"/pages/f1a77d/",categories:["后端","Spring全家桶","SpringCloud","选择Boot和Cloud版本"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/02.%E9%80%89%E6%8B%A9Boot%E5%92%8CCloud%E7%89%88%E6%9C%AC.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/02.选择Boot和Cloud版本.md",key:"v-d5c1ca98",path:"/pages/f1a77d/",headers:[{level:2,title:"1.版本规则",slug:"_1-版本规则",normalizedTitle:"1.版本规则",charIndex:21},{level:2,title:"2.如何选择版本",slug:"_2-如何选择版本",normalizedTitle:"2.如何选择版本",charIndex:140},{level:2,title:"3查看选择具体版本",slug:"_3查看选择具体版本",normalizedTitle:"3查看选择具体版本",charIndex:273},{level:2,title:"4.本次视频版本",slug:"_4-本次视频版本",normalizedTitle:"4.本次视频版本",charIndex:349}],headersStr:"1.版本规则 2.如何选择版本 3查看选择具体版本 4.本次视频版本",content:"# 选择Boot和Cloud版本\n\n\n# 1.版本规则\n\nBoot使用数字版本，Cloud使用字母版本（采用伦敦地铁站ABCD---Z字母命名）；\n\n 1. 视屏前半场：Boot2.X版本，Cloud H版\n 2. 视频后半场：SpringCloud alibaba版本\n\n\n# 2.如何选择版本\n\n1.方法一：官网查看官网推荐\n\n\n\n2.方法二：官网地址查看：https://start.spring.io/actuator/info\n\n返回JSON字符串，通过https://tool.lu/json/ JSON在线工具解析查看\n\n\n\n\n# 3查看选择具体版本\n\n地址：https://spring.io/projects/spring-cloud#learn\n\n点击文档即可查看\n\n\n\n\n# 4.本次视频版本\n\n",normalizedContent:"# 选择boot和cloud版本\n\n\n# 1.版本规则\n\nboot使用数字版本，cloud使用字母版本（采用伦敦地铁站abcd---z字母命名）；\n\n 1. 视屏前半场：boot2.x版本，cloud h版\n 2. 视频后半场：springcloud alibaba版本\n\n\n# 2.如何选择版本\n\n1.方法一：官网查看官网推荐\n\n\n\n2.方法二：官网地址查看：https://start.spring.io/actuator/info\n\n返回json字符串，通过https://tool.lu/json/ json在线工具解析查看\n\n\n\n\n# 3查看选择具体版本\n\n地址：https://spring.io/projects/spring-cloud#learn\n\n点击文档即可查看\n\n\n\n\n# 4.本次视频版本\n\n",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"关于Cloud组件停更升级",frontmatter:{title:"关于Cloud组件停更升级",date:"2021-08-17T09:31:44.000Z",permalink:"/pages/8e2398/",categories:["后端","Spring全家桶","SpringCloud","关于Cloud组件停更升级"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/03.%E5%85%B3%E4%BA%8ECloud%E7%BB%84%E4%BB%B6%E5%81%9C%E6%9B%B4%E5%8D%87%E7%BA%A7.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/03.关于Cloud组件停更升级.md",key:"v-c934e8f6",path:"/pages/8e2398/",headers:[{level:2,title:"1.技术选型",slug:"_1-技术选型",normalizedTitle:"1.技术选型",charIndex:23},{level:2,title:"2.Cloud中文文档",slug:"_2-cloud中文文档",normalizedTitle:"2.cloud中文文档",charIndex:145}],headersStr:"1.技术选型 2.Cloud中文文档",content:"# 03.关于Cloud组件停更升级\n\n\n# 1.技术选型\n\n 1. 服务注册：Nacos\n 2. 服务调用：Ribbon、OpenFegin\n 3. 服务降级熔断：sentienl\n 4. 服务网关：gateway\n 5. 服务配置：Nacos\n 6. 服务总线：Nacos\n\n\n\n\n# 2.Cloud中文文档\n\nhttps://www.bookstack.cn/read/spring-cloud-docs/docs-index.md",normalizedContent:"# 03.关于cloud组件停更升级\n\n\n# 1.技术选型\n\n 1. 服务注册：nacos\n 2. 服务调用：ribbon、openfegin\n 3. 服务降级熔断：sentienl\n 4. 服务网关：gateway\n 5. 服务配置：nacos\n 6. 服务总线：nacos\n\n\n\n\n# 2.cloud中文文档\n\nhttps://www.bookstack.cn/read/spring-cloud-docs/docs-index.md",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"环境搭建",frontmatter:{title:"环境搭建",date:"2021-08-17T09:31:44.000Z",permalink:"/pages/ad4ca5/",categories:["后端","Spring全家桶","SpringCloud","环境搭建"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/04.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/04.环境搭建.md",key:"v-2fd5fa4e",path:"/pages/ad4ca5/",headers:[{level:2,title:"1.环境要求",slug:"_1-环境要求",normalizedTitle:"1.环境要求",charIndex:11},{level:2,title:"1.构建父工程Project空间",slug:"_1-构建父工程project空间",normalizedTitle:"1.构建父工程project空间",charIndex:163},{level:2,title:"2.构建父pom文件",slug:"_2-构建父pom文件",normalizedTitle:"2.构建父pom文件",charIndex:335},{level:2,title:"3.构建rest微服务项目（以订单支付为例）",slug:"_3-构建rest微服务项目-以订单支付为例",normalizedTitle:"3.构建rest微服务项目（以订单支付为例）",charIndex:4297},{level:2,title:"4.开启热部署",slug:"_4-开启热部署",normalizedTitle:"4.开启热部署",charIndex:7735},{level:2,title:"5.构建消费者下订单",slug:"_5-构建消费者下订单",normalizedTitle:"5.构建消费者下订单",charIndex:8477},{level:2,title:"6.使用Run Dashboard运行微服务",slug:"_6-使用run-dashboard运行微服务",normalizedTitle:"6.使用run dashboard运行微服务",charIndex:10781},{level:2,title:"7.代码重构（重复代码放入工具包模块）",slug:"_7-代码重构-重复代码放入工具包模块",normalizedTitle:"7.代码重构（重复代码放入工具包模块）",charIndex:11557}],headersStr:"1.环境要求 1.构建父工程Project空间 2.构建父pom文件 3.构建rest微服务项目（以订单支付为例） 4.开启热部署 5.构建消费者下订单 6.使用Run Dashboard运行微服务 7.代码重构（重复代码放入工具包模块）",content:'# 环境搭建\n\n\n# 1.环境要求\n\n 1. SpringCloud Hoxton.SR1\n 2. SpringBoot 2.2.2RELEASE\n 3. SpringCloud alibaba 2.1.0RELEASE\n 4. java jdk8\n 5. Maven 3.5及以上\n 6. Mysql 5.7及以上\n\n\n# 1.构建父工程Project空间\n\n1.选择创建Maven项目，注意勾选哪一个\n\n\n\n2.创建包名、项目名\n\n\n\n3.选择maven，注意选择自己本地maven，不要使用IDEA的maven\n\n\n\n4.设置字符编码\n\n\n\n5.开启注解\n\n\n\n6.指定java版本\n\n\n\n7.文件过滤（可选):可以把IDEA的一些不需要的文件过滤掉\n\n\n\n\n# 2.构建父pom文件\n\n1.只留下pom.xml文件，其他删除（注意：.idea,.iml是被隐藏了，不是被删了）\n\n2.对应的pom文件\n\ndependencyManagement和dependencies的区别：\n\n * dependencyManagement用于父pom文件，统一管理版本号\n * dependencyManagement只负责声明；子pom一定要引用，dependencies才能使用对应的jar包\n * dependencies只需声明 groupId、artifactId即可\n * 子pom中dependencies若声明版本号，则使用子pom的版本号\n\n<?xml version="1.0" encoding="UTF-8"?>\n\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.wcy.springcloud</groupId>\n  <artifactId>CloudStudy</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  \x3c!--父工程就是一个maven管理，打包方式为pom--\x3e\n  <packaging>pom</packaging>\n\n  \x3c!-- 统一管理jar包版本 --\x3e\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n    <junit.version>4.12</junit.version>\n    <log4j.version>1.2.17</log4j.version>\n    <lombok.version>1.16.18</lombok.version>\n    <mysql.version>5.1.47</mysql.version>\n    <druid.version>1.1.16</druid.version>\n    <mybatis.spring.boot.version>1.3.0</mybatis.spring.boot.version>\n  </properties>\n\n  \x3c!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version  --\x3e\n  <dependencyManagement>\n    <dependencies>\n      \x3c!--spring boot 2.2.2--\x3e\n      <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-dependencies</artifactId>\n        <version>2.2.2.RELEASE</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      \x3c!--spring cloud Hoxton.SR1--\x3e\n      <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-dependencies</artifactId>\n        <version>Hoxton.SR1</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      \x3c!--spring cloud alibaba 2.1.0.RELEASE--\x3e\n      <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n        <version>2.1.0.RELEASE</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>${mysql.version}</version>\n      </dependency>\n      <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid</artifactId>\n        <version>${druid.version}</version>\n      </dependency>\n      <dependency>\n        <groupId>org.mybatis.spring.boot</groupId>\n        <artifactId>mybatis-spring-boot-starter</artifactId>\n        <version>${mybatis.spring.boot.version}</version>\n      </dependency>\n      <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>${junit.version}</version>\n      </dependency>\n      <dependency>\n        <groupId>log4j</groupId>\n        <artifactId>log4j</artifactId>\n        <version>${log4j.version}</version>\n      </dependency>\n      <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>${lombok.version}</version>\n        <optional>true</optional>\n      </dependency>\n    </dependencies>\n  </dependencyManagement>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n        <configuration>\n          <fork>true</fork>\n          <addResources>true</addResources>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n\n\n3.maven跳过单元测试\n\n\n\n\n# 3.构建rest微服务项目（以订单支付为例）\n\n微服务搭建大体步骤：\n\n 1. 建module\n 2. 修改pom文件\n 3. 修改yml文件\n 4. 添加启动类\n 5. 添加业务类\n\n微服务搭建详细步骤：\n\n1.右键父工程，新建module：cloud-provider-payment8001\n\n2.pom文件内容：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloud-provider-payment8001</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid-spring-boot-starter</artifactId>\n            <version>1.1.10</version>\n        </dependency>\n        \x3c!--mysql-connector-java--\x3e\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n        \x3c!--jdbc--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-jdbc</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n3.修改yml\n\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-payment-service\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型\n    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包\n    url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&characterEncoding=utf-8&useSSL=false\n    username: root\n    password: 2452952178\n\nmybatis:\n  mapperLocations: classpath:mapper/*.xml\n  type-aliases-package: com.wcy.springcloud.entities    # 所有Entity别名类所在包\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n4.设置启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class PaymentMain8001 {\n    public static void main(String[] args) {\n        SpringApplication.run(PaymentMain8001.class, args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4.开启热部署\n\n1.导入maven（子项目)\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <scope>runtime</scope>\n    <optional>true</optional>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n2.父类工程增加build插件\n\n下段配置我们粘贴进聚合父类总工程的pom.xml里\n<build>\n    <finalName>你自己的工程名字</finalName>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <configuration>\n                <fork>true</fork>\n                <addResources>true</addResources>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n3.勾选开启热部署\n\n\n\n4.注册热部署\n\nctrl+shift+alt+/快捷键，选择第一个，勾选下面两个即可\n\n\n\n\n# 5.构建消费者下订单\n\n同理：\n\n 1. 建module\n 2. 修改pom文件\n 3. 修改yml文件\n 4. 添加启动类\n 5. 添加业务类\n\n2.对应的pom文件：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloud-consumer-order80</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n3.yml文件：\n\nserver:\n  port: 80\n\n\n1\n2\n\n\n4.消费者不应该有service、dao层，只有controller和返回结果集entities\n\n5.通过RestTemplate来调用消费者进行消费订单\n\npackage com.wcy.springcloud.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.client.RestTemplate;\n\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    //@LoadBalanced\n    public RestTemplate getRestTemplate()\n    {\n        return new RestTemplate();\n    }\n}\n//applicationContext.xml <bean id="" class="">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n6.对应的目录结构\n\n\n\n\n# 6.使用Run Dashboard运行微服务\n\n由于微服务会有多个项目，run界面有时候很难看出来，可以使用Run Dashboard查看运行的服务以及未运行服务等等\n\n2020.2之前的版本\n\n1.打开项目的工作空间，找到.idea/workspace.xml,打开文件\n\n2.搜索RunDashboard，添加即可\n\n  <component name="RunDashboard">\n    <option name="configurationTypes">\n      <set>\n        <option value="SpringBootApplicationConfigurationType" />\n      </set>\n    </option>\n    <option name="ruleStates">\n      <list>\n        <RuleState>\n          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />\n        </RuleState>\n        <RuleState>\n          <option name="name" value="StatusDashboardGroupingRule" />\n        </RuleState>\n      </list>\n    </option>\n  </component>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n3.重启idea\n\n2020.2之后直接打开：\n\nVIEW=>Tool Windouws=>Services(以前是RunDash)即可\n\n\n# 7.代码重构（重复代码放入工具包模块）\n\n1.新建模块cloud-api-commons,修改pom文件;\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloud-api-commons</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n            <version>5.1.0</version>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n2.把重复的代码放入到该模块;\n\n3.maven执行clean和install命令，把工具模块发布到本地，供其他模块使用；\n\n4.其他模块删除重复代码，并在pom中引入工具类模块；\n\n        \x3c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\x3e\n        <dependency>\n            <groupId>com.wcy.springcloud</groupId>\n            <artifactId>cloud-api-commons</artifactId>\n            <version>${project.version}</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'# 环境搭建\n\n\n# 1.环境要求\n\n 1. springcloud hoxton.sr1\n 2. springboot 2.2.2release\n 3. springcloud alibaba 2.1.0release\n 4. java jdk8\n 5. maven 3.5及以上\n 6. mysql 5.7及以上\n\n\n# 1.构建父工程project空间\n\n1.选择创建maven项目，注意勾选哪一个\n\n\n\n2.创建包名、项目名\n\n\n\n3.选择maven，注意选择自己本地maven，不要使用idea的maven\n\n\n\n4.设置字符编码\n\n\n\n5.开启注解\n\n\n\n6.指定java版本\n\n\n\n7.文件过滤（可选):可以把idea的一些不需要的文件过滤掉\n\n\n\n\n# 2.构建父pom文件\n\n1.只留下pom.xml文件，其他删除（注意：.idea,.iml是被隐藏了，不是被删了）\n\n2.对应的pom文件\n\ndependencymanagement和dependencies的区别：\n\n * dependencymanagement用于父pom文件，统一管理版本号\n * dependencymanagement只负责声明；子pom一定要引用，dependencies才能使用对应的jar包\n * dependencies只需声明 groupid、artifactid即可\n * 子pom中dependencies若声明版本号，则使用子pom的版本号\n\n<?xml version="1.0" encoding="utf-8"?>\n\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <groupid>com.wcy.springcloud</groupid>\n  <artifactid>cloudstudy</artifactid>\n  <version>1.0-snapshot</version>\n  \x3c!--父工程就是一个maven管理，打包方式为pom--\x3e\n  <packaging>pom</packaging>\n\n  \x3c!-- 统一管理jar包版本 --\x3e\n  <properties>\n    <project.build.sourceencoding>utf-8</project.build.sourceencoding>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n    <junit.version>4.12</junit.version>\n    <log4j.version>1.2.17</log4j.version>\n    <lombok.version>1.16.18</lombok.version>\n    <mysql.version>5.1.47</mysql.version>\n    <druid.version>1.1.16</druid.version>\n    <mybatis.spring.boot.version>1.3.0</mybatis.spring.boot.version>\n  </properties>\n\n  \x3c!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupid和version  --\x3e\n  <dependencymanagement>\n    <dependencies>\n      \x3c!--spring boot 2.2.2--\x3e\n      <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-dependencies</artifactid>\n        <version>2.2.2.release</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      \x3c!--spring cloud hoxton.sr1--\x3e\n      <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-dependencies</artifactid>\n        <version>hoxton.sr1</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      \x3c!--spring cloud alibaba 2.1.0.release--\x3e\n      <dependency>\n        <groupid>com.alibaba.cloud</groupid>\n        <artifactid>spring-cloud-alibaba-dependencies</artifactid>\n        <version>2.1.0.release</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      <dependency>\n        <groupid>mysql</groupid>\n        <artifactid>mysql-connector-java</artifactid>\n        <version>${mysql.version}</version>\n      </dependency>\n      <dependency>\n        <groupid>com.alibaba</groupid>\n        <artifactid>druid</artifactid>\n        <version>${druid.version}</version>\n      </dependency>\n      <dependency>\n        <groupid>org.mybatis.spring.boot</groupid>\n        <artifactid>mybatis-spring-boot-starter</artifactid>\n        <version>${mybatis.spring.boot.version}</version>\n      </dependency>\n      <dependency>\n        <groupid>junit</groupid>\n        <artifactid>junit</artifactid>\n        <version>${junit.version}</version>\n      </dependency>\n      <dependency>\n        <groupid>log4j</groupid>\n        <artifactid>log4j</artifactid>\n        <version>${log4j.version}</version>\n      </dependency>\n      <dependency>\n        <groupid>org.projectlombok</groupid>\n        <artifactid>lombok</artifactid>\n        <version>${lombok.version}</version>\n        <optional>true</optional>\n      </dependency>\n    </dependencies>\n  </dependencymanagement>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-maven-plugin</artifactid>\n        <configuration>\n          <fork>true</fork>\n          <addresources>true</addresources>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n\n\n3.maven跳过单元测试\n\n\n\n\n# 3.构建rest微服务项目（以订单支付为例）\n\n微服务搭建大体步骤：\n\n 1. 建module\n 2. 修改pom文件\n 3. 修改yml文件\n 4. 添加启动类\n 5. 添加业务类\n\n微服务搭建详细步骤：\n\n1.右键父工程，新建module：cloud-provider-payment8001\n\n2.pom文件内容：\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloud-provider-payment8001</artifactid>\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.mybatis.spring.boot</groupid>\n            <artifactid>mybatis-spring-boot-starter</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>com.alibaba</groupid>\n            <artifactid>druid-spring-boot-starter</artifactid>\n            <version>1.1.10</version>\n        </dependency>\n        \x3c!--mysql-connector-java--\x3e\n        <dependency>\n            <groupid>mysql</groupid>\n            <artifactid>mysql-connector-java</artifactid>\n        </dependency>\n        \x3c!--jdbc--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-jdbc</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n3.修改yml\n\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-payment-service\n  datasource:\n    type: com.alibaba.druid.pool.druiddatasource            # 当前数据源操作类型\n    driver-class-name: org.gjt.mm.mysql.driver              # mysql驱动包\n    url: jdbc:mysql://localhost:3306/db2019?useunicode=true&characterencoding=utf-8&usessl=false\n    username: root\n    password: 2452952178\n\nmybatis:\n  mapperlocations: classpath:mapper/*.xml\n  type-aliases-package: com.wcy.springcloud.entities    # 所有entity别名类所在包\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n4.设置启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\n\n@springbootapplication\npublic class paymentmain8001 {\n    public static void main(string[] args) {\n        springapplication.run(paymentmain8001.class, args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4.开启热部署\n\n1.导入maven（子项目)\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-devtools</artifactid>\n    <scope>runtime</scope>\n    <optional>true</optional>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n2.父类工程增加build插件\n\n下段配置我们粘贴进聚合父类总工程的pom.xml里\n<build>\n    <finalname>你自己的工程名字</finalname>\n    <plugins>\n        <plugin>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-maven-plugin</artifactid>\n            <configuration>\n                <fork>true</fork>\n                <addresources>true</addresources>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n3.勾选开启热部署\n\n\n\n4.注册热部署\n\nctrl+shift+alt+/快捷键，选择第一个，勾选下面两个即可\n\n\n\n\n# 5.构建消费者下订单\n\n同理：\n\n 1. 建module\n 2. 修改pom文件\n 3. 修改yml文件\n 4. 添加启动类\n 5. 添加业务类\n\n2.对应的pom文件：\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloud-consumer-order80</artifactid>\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n3.yml文件：\n\nserver:\n  port: 80\n\n\n1\n2\n\n\n4.消费者不应该有service、dao层，只有controller和返回结果集entities\n\n5.通过resttemplate来调用消费者进行消费订单\n\npackage com.wcy.springcloud.config;\n\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.web.client.resttemplate;\n\n@configuration\npublic class applicationcontextconfig\n{\n    @bean\n    //@loadbalanced\n    public resttemplate getresttemplate()\n    {\n        return new resttemplate();\n    }\n}\n//applicationcontext.xml <bean id="" class="">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n6.对应的目录结构\n\n\n\n\n# 6.使用run dashboard运行微服务\n\n由于微服务会有多个项目，run界面有时候很难看出来，可以使用run dashboard查看运行的服务以及未运行服务等等\n\n2020.2之前的版本\n\n1.打开项目的工作空间，找到.idea/workspace.xml,打开文件\n\n2.搜索rundashboard，添加即可\n\n  <component name="rundashboard">\n    <option name="configurationtypes">\n      <set>\n        <option value="springbootapplicationconfigurationtype" />\n      </set>\n    </option>\n    <option name="rulestates">\n      <list>\n        <rulestate>\n          <option name="name" value="configurationtypedashboardgroupingrule" />\n        </rulestate>\n        <rulestate>\n          <option name="name" value="statusdashboardgroupingrule" />\n        </rulestate>\n      </list>\n    </option>\n  </component>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n3.重启idea\n\n2020.2之后直接打开：\n\nview=>tool windouws=>services(以前是rundash)即可\n\n\n# 7.代码重构（重复代码放入工具包模块）\n\n1.新建模块cloud-api-commons,修改pom文件;\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloud-api-commons</artifactid>\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>cn.hutool</groupid>\n            <artifactid>hutool-all</artifactid>\n            <version>5.1.0</version>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n2.把重复的代码放入到该模块;\n\n3.maven执行clean和install命令，把工具模块发布到本地，供其他模块使用；\n\n4.其他模块删除重复代码，并在pom中引入工具类模块；\n\n        \x3c!-- 引入自己定义的api通用包，可以使用payment支付entity --\x3e\n        <dependency>\n            <groupid>com.wcy.springcloud</groupid>\n            <artifactid>cloud-api-commons</artifactid>\n            <version>${project.version}</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"Eureka基础篇",frontmatter:{title:"Eureka基础篇",date:"2021-08-17T09:31:44.000Z",permalink:"/pages/93e73f/",categories:["后端","Spring全家桶","SpringCloud","Eureka基础篇"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/05.Eureka%E5%9F%BA%E7%A1%80%E7%AF%87.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/05.Eureka基础篇.md",key:"v-8ee4cd26",path:"/pages/93e73f/",headers:[{level:2,title:"1.Eureka基础知识",slug:"_1-eureka基础知识",normalizedTitle:"1.eureka基础知识",charIndex:16},{level:2,title:"2.Eureka单机版使用",slug:"_2-eureka单机版使用",normalizedTitle:"2.eureka单机版使用",charIndex:1041},{level:3,title:"1.注册Eureka服务中心（单机版）",slug:"_1-注册eureka服务中心-单机版",normalizedTitle:"1.注册eureka服务中心（单机版）",charIndex:1059},{level:3,title:"2.把客户端（消费者、生产者）注册到Eureka中",slug:"_2-把客户端-消费者、生产者-注册到eureka中",normalizedTitle:"2.把客户端（消费者、生产者）注册到eureka中",charIndex:4355},{level:2,title:"2.Eureka集群配置",slug:"_2-eureka集群配置",normalizedTitle:"2.eureka集群配置",charIndex:5793},{level:3,title:"1.注册两个eureka服务",slug:"_1-注册两个eureka服务",normalizedTitle:"1.注册两个eureka服务",charIndex:5810},{level:3,title:"2.把客户端（消费者、生产者）注册到Eureka集群中",slug:"_2-把客户端-消费者、生产者-注册到eureka集群中",normalizedTitle:"2.把客户端（消费者、生产者）注册到eureka集群中",charIndex:7425},{level:2,title:"3.搭建订单（生产者）集群",slug:"_3-搭建订单-生产者-集群",normalizedTitle:"3.搭建订单（生产者）集群",charIndex:7850},{level:2,title:"4.actuator微服务信息提示完善",slug:"_4-actuator微服务信息提示完善",normalizedTitle:"4.actuator微服务信息提示完善",charIndex:8646},{level:3,title:"问题一：不要出现Euraka图形界面主机名",slug:"问题一-不要出现euraka图形界面主机名",normalizedTitle:"问题一：不要出现euraka图形界面主机名",charIndex:8704},{level:3,title:"问题二：点击超链接显示具体的IP地址",slug:"问题二-点击超链接显示具体的ip地址",normalizedTitle:"问题二：点击超链接显示具体的ip地址",charIndex:8732},{level:2,title:"5.discovery服务发现（对方暴露ip+端口号等信息）",slug:"_5-discovery服务发现-对方暴露ip-端口号等信息",normalizedTitle:"5.discovery服务发现（对方暴露ip+端口号等信息）",charIndex:9262},{level:2,title:"6.Eureka的自我保护机制（默认开启）",slug:"_6-eureka的自我保护机制-默认开启",normalizedTitle:"6.eureka的自我保护机制（默认开启）",charIndex:10166}],headersStr:"1.Eureka基础知识 2.Eureka单机版使用 1.注册Eureka服务中心（单机版） 2.把客户端（消费者、生产者）注册到Eureka中 2.Eureka集群配置 1.注册两个eureka服务 2.把客户端（消费者、生产者）注册到Eureka集群中 3.搭建订单（生产者）集群 4.actuator微服务信息提示完善 问题一：不要出现Euraka图形界面主机名 问题二：点击超链接显示具体的IP地址 5.discovery服务发现（对方暴露ip+端口号等信息） 6.Eureka的自我保护机制（默认开启）",content:'# Eureka基础篇\n\n\n# 1.Eureka基础知识\n\n类似于尚硅谷教学，需要给物业管理人员交物业费，交了物业费以后，同学们（消费者）就可以在物业管理中知道尚硅谷办理了教学服务；若在几个周期都没有交物业费，那么物业管理人员就默认认为尚硅谷不办教学了，同学们就看不到尚硅谷教学了。\n\n 1. 什么是服务治理：\n    \n    > 在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。\n\n 2. 服务注册与发现：\n    \n    > Eureka采用了CS的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。 在服务注册与发现中，有一个注册中心。当服务器启动的时候，**会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。**另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))\n    \n    \n\n 3. Eureka两大组件\n    \n    > 1.Eureka Server提供服务注册服务 各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。\n    > \n    > 2.EurekaClient通过注册中心进行访问 是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）\n\n\n# 2.Eureka单机版使用\n\n\n# 1.注册Eureka服务中心（单机版）\n\n核心部分依然是这五部：\n\n 1. 加moudle\n 2. 改pom\n 3. 加yml\n 4. 加主启动类（记得开启Eureka服务）\n 5. 添加业务类\n\n详细步骤：\n\n1.新建moudle：cloud-eureka-server7001\n\n2.改pom文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloud-eureka-server7001</artifactId>\n\n    <dependencies>\n        \x3c!--eureka-server--\x3e\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n        </dependency>\n        \x3c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\x3e\n        <dependency>\n            <groupId>com.wcy.springcloud</groupId>\n            <artifactId>cloud-api-commons</artifactId>\n            <version>${project.version}</version>\n        </dependency>\n        \x3c!--boot web actuator--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \x3c!--一般通用配置--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n3.添加yml文件\n\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: localhost #eureka服务端的实例名称\n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n4.添加启动类，并开启Eureka服务\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n\n@SpringBootApplication\n//开启Eureka服务端服务\n@EnableEurekaServer\npublic class EurekaMain7001 {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaMain7001.class,args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.把客户端（消费者、生产者）注册到Eureka中\n\n 1. 添加pom依赖\n    \n    \x3c!--eureka-client--\x3e\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n            </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 添加yml\n    \n    #spring.application.name必须要，后续Eureka注册名就是这个\n    spring:\n      application:\n        name: cloud-XXXX-service\n    \n    eureka:\n      client:\n        #表示是否将自己注册进EurekaServer默认为true。\n        register-with-eureka: true\n        #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n        fetchRegistry: true\n        service-url:\n          defaultZone: http://localhost:7001/eureka\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 3. 开启Eureka客户端\n    \n    在启动类上加上注解@EnableEurekaClient\n    \n    package com.wcy.springcloud;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.cloud.netflix.eureka.EnableEurekaClient;\n    \n    @SpringBootApplication\n    @EnableEurekaClient\n    public class PaymentMain8001 {\n        public static void main(String[] args) {\n            SpringApplication.run(PaymentMain8001.class, args);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n\n# 2.Eureka集群配置\n\n\n# 1.注册两个eureka服务\n\n与单机不同点：\n\n 1. 需要修改本地映射文件\n 2. 修改yml文件\n\n集群采用相互注册的方式，即若1、2、3，三个服务，那么1服务会注册2、3的服务，2服务会注册1、3的服务，3服务会注册1、2的服务\n\n 1. 注册两个eureka服务：cloud-eureka-server7001、cloud-eureka-server7002\n\n 2. 修改yml文件\n    \n    在修改yml之前，需要修改本地的hosts文件地址映射\n    \n    > 1.找到C:\\Windows\\System32\\drivers\\etc下面的hosts文件；\n    > \n    > 可能会出现权限无法编辑，给了权限还是无法修改，那么可以使用EditPlus文本编辑器来修改\n    > \n    > 2.添加内容：\n    > \n    > 127.0.0.1 eureka7001.com\n    > \n    > 127.0.0.1 eureka7002.com\n    \n    7001的配置文件内容：7001要注册到7002的服务中\n    \n    server:\n      port: 7001\n    \n    eureka:\n      instance:\n        hostname: eureka7001.com #eureka服务端的实例名称\n      client:\n        #false表示不向注册中心注册自己。\n        register-with-eureka: false\n        #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n        fetch-registry: false\n        service-url:\n          #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。\n          defaultZone: http://eureka7002.com:7002/eureka/\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n    \n    7002的配置文件内容：7002要注册到7001的服务中\n    \n    server:\n      port: 7002\n    \n    eureka:\n      instance:\n        hostname: eureka7002.com #eureka服务端的实例名称\n      client:\n        #false表示不向注册中心注册自己。\n        register-with-eureka: false\n        #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n        fetch-registry: false\n        service-url:\n          #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。\n          defaultZone: http://eureka7001.com:7001/eureka/\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n3.启动两个eureka服务，访问方式：127.0.0.1:7001或eureka7001.com:7001（上面配置的地址映射）来访问\n\n\n# 2.把客户端（消费者、生产者）注册到Eureka集群中\n\n只需要修改yml文件即可，其他和单机版一样\n\neureka:\n  client:\n    #表示是否将自己注册进EurekaServer默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n      #defaultZone: http://localhost:7001/eureka  #单机版\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.搭建订单（生产者）集群\n\n上面部分已经完成了eureka集群，还需要搭建生产者集群。\n\n\n\n搭建方式：\n\n1.新建模块cloud-provider-payment8002，复制之前的cloud-provider-payment8001，只需要修改端口即可\n\n2.修改controller层，输出端口号，方便知道消费者访问的哪个端口\n\n    @Value("${server.port}")\n    private String serverPort;//端口号\n\n\n1\n2\n\n\n3.修改消费者访问的地址，之前是写死的，访问的8001端口，现在后端有两个服务了\n\npublic class OrderController {\n    //private static final String PAMENT_URL="http://localhost:8001";\n    private static final String PAMENT_URL="http://CLOUD-PAYMENT-SERVICE";//访问服务器名\n\n\n1\n2\n3\n\n\n4.这样之后没法访问了，因为访问http://CLOUD-PAYMENT-SERVICE地址，服务器不知道访问8001和8002哪个端口，在之前注入RestTemplate的时候增加注解@LoadBalanced，实现负载均衡，\n\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate()\n    {\n        return new RestTemplate();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 4.actuator微服务信息提示完善\n\n比如Euraka图形界面不要出现主机名，点击超链接显示具体的地址\n\n\n# 问题一：不要出现Euraka图形界面主机名\n\n\n\n\n# 问题二：点击超链接显示具体的IP地址\n\n\n\n修改yml配置文件：\n\neureka:\n  client:\n    #表示是否将自己注册进EurekaServer默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n      #defaultZone: http://localhost:7001/eureka  #单机版\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n  instance:\n    instance-id: payment8001    #不显示主机名，显示别名payment8001\n    prefer-ip-address: true     #访问路径可以显示IP地址\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 5.discovery服务发现（对方暴露ip+端口号等信息）\n\n1.消费者主启动类开启@EnableDiscoveryClient\n\n 2. controller层加入get方法\n\n    @Autowired\n    private DiscoveryClient discoveryClient;\n    \n     /**\n     * 对外暴露该服务的信息\n     * @return\n     */\n    @GetMapping("/payment/discovery")\n    public Object discovery(){\n        List<String> services = discoveryClient.getServices();//获取在eureka的注册服务\n        for (String service:services){\n            log.info("服务:"+service);\n            List<ServiceInstance> instances = discoveryClient.getInstances(service);\n            for(ServiceInstance serviceInstance:instances){\n                log.info(serviceInstance.getServiceId()+"-"+serviceInstance.getHost()\n                +"-"+serviceInstance.getPort()+"-"+serviceInstance.getUri());\n            }\n        }\n        log.info(""+discoveryClient.getOrder());\n        return services;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 6.Eureka的自我保护机制（默认开启）\n\n 1. Eureka自我保护机制：Eureka客户端默认每30秒发送一次心跳，若90秒内未收到心跳会被剔除；\n 2. 属于CAP中的CA，需要高可用；\n\n> 保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式， Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。\n> \n> 如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式： EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY\'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE\n\n关闭自我保护机制：\n\n1.eureka服务端配置：\n\neureka:\n  instance:\n    hostname: eureka7001.com #eureka服务端的实例名称\n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://eureka7002.com:7002/eureka/\n  server:\n    #########################心跳检测与续约时间############################################\n    #关闭自我保护机制，保证不可用服务被及时踢除\n    enable-self-preservation: false\n    # 2秒内未接受到心跳则关闭微服务\n    eviction-interval-timer-in-ms: 2000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n2.eureka客户端配置：\n\neureka:\n  client:\n    #表示是否将自己注册进EurekaServer默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n      #defaultZone: http://localhost:7001/eureka  #单机版\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n  instance:\n    instance-id: payment8001  #不显示主机名，显示别名payment8001\n    prefer-ip-address: true     #访问路径可以显示IP地址\n    #########################心跳检测与续约时间############################################\n    #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\n    lease-renewal-interval-in-seconds: 1\n    #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\n    lease-expiration-duration-in-seconds: 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',normalizedContent:'# eureka基础篇\n\n\n# 1.eureka基础知识\n\n类似于尚硅谷教学，需要给物业管理人员交物业费，交了物业费以后，同学们（消费者）就可以在物业管理中知道尚硅谷办理了教学服务；若在几个周期都没有交物业费，那么物业管理人员就默认认为尚硅谷不办教学了，同学们就看不到尚硅谷教学了。\n\n 1. 什么是服务治理：\n    \n    > 在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。\n\n 2. 服务注册与发现：\n    \n    > eureka采用了cs的设计架构，eureka server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 eureka的客户端连接到 eureka server并维持心跳连接。这样系统的维护人员就可以通过 eureka server 来监控系统中各个微服务是否正常运行。 在服务注册与发现中，有一个注册中心。当服务器启动的时候，**会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。**另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地rpc调用rpc远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))\n    \n    \n\n 3. eureka两大组件\n    \n    > 1.eureka server提供服务注册服务 各个微服务节点通过配置启动后，会在eurekaserver中进行注册，这样eurekaserver中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。\n    > \n    > 2.eurekaclient通过注册中心进行访问 是一个java客户端，用于简化eureka server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向eureka server发送心跳(默认周期为30秒)。如果eureka server在多个心跳周期内没有接收到某个节点的心跳，eurekaserver将会从服务注册表中把这个服务节点移除（默认90秒）\n\n\n# 2.eureka单机版使用\n\n\n# 1.注册eureka服务中心（单机版）\n\n核心部分依然是这五部：\n\n 1. 加moudle\n 2. 改pom\n 3. 加yml\n 4. 加主启动类（记得开启eureka服务）\n 5. 添加业务类\n\n详细步骤：\n\n1.新建moudle：cloud-eureka-server7001\n\n2.改pom文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloud-eureka-server7001</artifactid>\n\n    <dependencies>\n        \x3c!--eureka-server--\x3e\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-netflix-eureka-server</artifactid>\n        </dependency>\n        \x3c!-- 引入自己定义的api通用包，可以使用payment支付entity --\x3e\n        <dependency>\n            <groupid>com.wcy.springcloud</groupid>\n            <artifactid>cloud-api-commons</artifactid>\n            <version>${project.version}</version>\n        </dependency>\n        \x3c!--boot web actuator--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n        \x3c!--一般通用配置--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupid>junit</groupid>\n            <artifactid>junit</artifactid>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n3.添加yml文件\n\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: localhost #eureka服务端的实例名称\n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultzone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n4.添加启动类，并开启eureka服务\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.cloud.netflix.eureka.server.enableeurekaserver;\n\n@springbootapplication\n//开启eureka服务端服务\n@enableeurekaserver\npublic class eurekamain7001 {\n    public static void main(string[] args) {\n        springapplication.run(eurekamain7001.class,args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.把客户端（消费者、生产者）注册到eureka中\n\n 1. 添加pom依赖\n    \n    \x3c!--eureka-client--\x3e\n            <dependency>\n                <groupid>org.springframework.cloud</groupid>\n                <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n            </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 添加yml\n    \n    #spring.application.name必须要，后续eureka注册名就是这个\n    spring:\n      application:\n        name: cloud-xxxx-service\n    \n    eureka:\n      client:\n        #表示是否将自己注册进eurekaserver默认为true。\n        register-with-eureka: true\n        #是否从eurekaserver抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n        fetchregistry: true\n        service-url:\n          defaultzone: http://localhost:7001/eureka\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 3. 开启eureka客户端\n    \n    在启动类上加上注解@enableeurekaclient\n    \n    package com.wcy.springcloud;\n    \n    import org.springframework.boot.springapplication;\n    import org.springframework.boot.autoconfigure.springbootapplication;\n    import org.springframework.cloud.netflix.eureka.enableeurekaclient;\n    \n    @springbootapplication\n    @enableeurekaclient\n    public class paymentmain8001 {\n        public static void main(string[] args) {\n            springapplication.run(paymentmain8001.class, args);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n\n# 2.eureka集群配置\n\n\n# 1.注册两个eureka服务\n\n与单机不同点：\n\n 1. 需要修改本地映射文件\n 2. 修改yml文件\n\n集群采用相互注册的方式，即若1、2、3，三个服务，那么1服务会注册2、3的服务，2服务会注册1、3的服务，3服务会注册1、2的服务\n\n 1. 注册两个eureka服务：cloud-eureka-server7001、cloud-eureka-server7002\n\n 2. 修改yml文件\n    \n    在修改yml之前，需要修改本地的hosts文件地址映射\n    \n    > 1.找到c:\\windows\\system32\\drivers\\etc下面的hosts文件；\n    > \n    > 可能会出现权限无法编辑，给了权限还是无法修改，那么可以使用editplus文本编辑器来修改\n    > \n    > 2.添加内容：\n    > \n    > 127.0.0.1 eureka7001.com\n    > \n    > 127.0.0.1 eureka7002.com\n    \n    7001的配置文件内容：7001要注册到7002的服务中\n    \n    server:\n      port: 7001\n    \n    eureka:\n      instance:\n        hostname: eureka7001.com #eureka服务端的实例名称\n      client:\n        #false表示不向注册中心注册自己。\n        register-with-eureka: false\n        #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n        fetch-registry: false\n        service-url:\n          #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n          defaultzone: http://eureka7002.com:7002/eureka/\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n    \n    7002的配置文件内容：7002要注册到7001的服务中\n    \n    server:\n      port: 7002\n    \n    eureka:\n      instance:\n        hostname: eureka7002.com #eureka服务端的实例名称\n      client:\n        #false表示不向注册中心注册自己。\n        register-with-eureka: false\n        #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n        fetch-registry: false\n        service-url:\n          #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n          defaultzone: http://eureka7001.com:7001/eureka/\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n3.启动两个eureka服务，访问方式：127.0.0.1:7001或eureka7001.com:7001（上面配置的地址映射）来访问\n\n\n# 2.把客户端（消费者、生产者）注册到eureka集群中\n\n只需要修改yml文件即可，其他和单机版一样\n\neureka:\n  client:\n    #表示是否将自己注册进eurekaserver默认为true。\n    register-with-eureka: true\n    #是否从eurekaserver抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchregistry: true\n    service-url:\n      #defaultzone: http://localhost:7001/eureka  #单机版\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.搭建订单（生产者）集群\n\n上面部分已经完成了eureka集群，还需要搭建生产者集群。\n\n\n\n搭建方式：\n\n1.新建模块cloud-provider-payment8002，复制之前的cloud-provider-payment8001，只需要修改端口即可\n\n2.修改controller层，输出端口号，方便知道消费者访问的哪个端口\n\n    @value("${server.port}")\n    private string serverport;//端口号\n\n\n1\n2\n\n\n3.修改消费者访问的地址，之前是写死的，访问的8001端口，现在后端有两个服务了\n\npublic class ordercontroller {\n    //private static final string pament_url="http://localhost:8001";\n    private static final string pament_url="http://cloud-payment-service";//访问服务器名\n\n\n1\n2\n3\n\n\n4.这样之后没法访问了，因为访问http://cloud-payment-service地址，服务器不知道访问8001和8002哪个端口，在之前注入resttemplate的时候增加注解@loadbalanced，实现负载均衡，\n\n@configuration\npublic class applicationcontextconfig\n{\n    @bean\n    @loadbalanced\n    public resttemplate getresttemplate()\n    {\n        return new resttemplate();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 4.actuator微服务信息提示完善\n\n比如euraka图形界面不要出现主机名，点击超链接显示具体的地址\n\n\n# 问题一：不要出现euraka图形界面主机名\n\n\n\n\n# 问题二：点击超链接显示具体的ip地址\n\n\n\n修改yml配置文件：\n\neureka:\n  client:\n    #表示是否将自己注册进eurekaserver默认为true。\n    register-with-eureka: true\n    #是否从eurekaserver抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchregistry: true\n    service-url:\n      #defaultzone: http://localhost:7001/eureka  #单机版\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n  instance:\n    instance-id: payment8001    #不显示主机名，显示别名payment8001\n    prefer-ip-address: true     #访问路径可以显示ip地址\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 5.discovery服务发现（对方暴露ip+端口号等信息）\n\n1.消费者主启动类开启@enablediscoveryclient\n\n 2. controller层加入get方法\n\n    @autowired\n    private discoveryclient discoveryclient;\n    \n     /**\n     * 对外暴露该服务的信息\n     * @return\n     */\n    @getmapping("/payment/discovery")\n    public object discovery(){\n        list<string> services = discoveryclient.getservices();//获取在eureka的注册服务\n        for (string service:services){\n            log.info("服务:"+service);\n            list<serviceinstance> instances = discoveryclient.getinstances(service);\n            for(serviceinstance serviceinstance:instances){\n                log.info(serviceinstance.getserviceid()+"-"+serviceinstance.gethost()\n                +"-"+serviceinstance.getport()+"-"+serviceinstance.geturi());\n            }\n        }\n        log.info(""+discoveryclient.getorder());\n        return services;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 6.eureka的自我保护机制（默认开启）\n\n 1. eureka自我保护机制：eureka客户端默认每30秒发送一次心跳，若90秒内未收到心跳会被剔除；\n 2. 属于cap中的ca，需要高可用；\n\n> 保护模式主要用于一组客户端和eureka server之间存在网络分区场景下的保护。一旦进入保护模式， eureka server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。\n> \n> 如果在eureka server的首页看到以下这段提示，则说明eureka进入了保护模式： emergency! eureka may be incorrectly claiming instances are up when they\'re not. renewals are lesser than threshold and hence the instances are not being expired just to be safe\n\n关闭自我保护机制：\n\n1.eureka服务端配置：\n\neureka:\n  instance:\n    hostname: eureka7001.com #eureka服务端的实例名称\n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultzone: http://eureka7002.com:7002/eureka/\n  server:\n    #########################心跳检测与续约时间############################################\n    #关闭自我保护机制，保证不可用服务被及时踢除\n    enable-self-preservation: false\n    # 2秒内未接受到心跳则关闭微服务\n    eviction-interval-timer-in-ms: 2000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n2.eureka客户端配置：\n\neureka:\n  client:\n    #表示是否将自己注册进eurekaserver默认为true。\n    register-with-eureka: true\n    #是否从eurekaserver抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchregistry: true\n    service-url:\n      #defaultzone: http://localhost:7001/eureka  #单机版\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n  instance:\n    instance-id: payment8001  #不显示主机名，显示别名payment8001\n    prefer-ip-address: true     #访问路径可以显示ip地址\n    #########################心跳检测与续约时间############################################\n    #eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\n    lease-renewal-interval-in-seconds: 1\n    #eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\n    lease-expiration-duration-in-seconds: 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"Zookeeper",frontmatter:{title:"Zookeeper",date:"2021-08-17T09:31:44.000Z",permalink:"/pages/1b8908/",categories:["后端","Spring全家桶","SpringCloud","Zookeeper"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/06.Zookeeper.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/06.Zookeeper.md",key:"v-f43959ca",path:"/pages/1b8908/",headers:[{level:2,title:"1.linux安装Zookeeper",slug:"_1-linux安装zookeeper",normalizedTitle:"1.linux安装zookeeper",charIndex:16},{level:2,title:"2.启动Zookeeper",slug:"_2-启动zookeeper",normalizedTitle:"2.启动zookeeper",charIndex:670},{level:2,title:"3.集群版安装",slug:"_3-集群版安装",normalizedTitle:"3.集群版安装",charIndex:2227},{level:3,title:"1.创建文件目录结构",slug:"_1-创建文件目录结构",normalizedTitle:"1.创建文件目录结构",charIndex:2268},{level:3,title:"2.创建数据存放和日志文件",slug:"_2-创建数据存放和日志文件",normalizedTitle:"2.创建数据存放和日志文件",charIndex:2413},{level:3,title:"3.创建zookeeper集群ID",slug:"_3-创建zookeeper集群id",normalizedTitle:"3.创建zookeeper集群id",charIndex:2714},{level:3,title:"4.下载zookeeper（参考单机版 下载、解压）",slug:"_4-下载zookeeper-参考单机版-下载、解压",normalizedTitle:"4.下载zookeeper（参考单机版 下载、解压）",charIndex:2899},{level:3,title:"4.修改配置文件",slug:"_4-修改配置文件",normalizedTitle:"4.修改配置文件",charIndex:2977},{level:3,title:"5.复制到server2、server3",slug:"_5-复制到server2、server3",normalizedTitle:"5.复制到server2、server3",charIndex:5235},{level:3,title:"6.启动",slug:"_6-启动",normalizedTitle:"6.启动",charIndex:5390},{level:3,title:"7.测试",slug:"_7-测试",normalizedTitle:"7.测试",charIndex:6433},{level:2,title:"4.Zookeeper使用",slug:"_4-zookeeper使用",normalizedTitle:"4.zookeeper使用",charIndex:6452},{level:3,title:"0.展示节点",slug:"_0-展示节点",normalizedTitle:"0.展示节点",charIndex:6514},{level:3,title:"1.创建节点",slug:"_1-创建节点",normalizedTitle:"1.创建节点",charIndex:6544},{level:3,title:"2.查看节点内容",slug:"_2-查看节点内容",normalizedTitle:"2.查看节点内容",charIndex:6923},{level:3,title:"3.查看子节点",slug:"_3-查看子节点",normalizedTitle:"3.查看子节点",charIndex:7271},{level:3,title:"4.更新节点内容",slug:"_4-更新节点内容",normalizedTitle:"4.更新节点内容",charIndex:7470},{level:3,title:"6.删除节点",slug:"_6-删除节点",normalizedTitle:"6.删除节点",charIndex:7900},{level:2,title:"******************",slug:"",normalizedTitle:"******************",charIndex:8469},{level:2,title:"4.SpringCloud整合Zookeeper",slug:"_4-springcloud整合zookeeper",normalizedTitle:"4.springcloud整合zookeeper",charIndex:8588},{level:3,title:"1.增加生产者模块：",slug:"_1-增加生产者模块",normalizedTitle:"1.增加生产者模块：",charIndex:8915},{level:3,title:"2.增加消费者模块：",slug:"_2-增加消费者模块",normalizedTitle:"2.增加消费者模块：",charIndex:16813}],headersStr:"1.linux安装Zookeeper 2.启动Zookeeper 3.集群版安装 1.创建文件目录结构 2.创建数据存放和日志文件 3.创建zookeeper集群ID 4.下载zookeeper（参考单机版 下载、解压） 4.修改配置文件 5.复制到server2、server3 6.启动 7.测试 4.Zookeeper使用 0.展示节点 1.创建节点 2.查看节点内容 3.查看子节点 4.更新节点内容 6.删除节点 ****************** 4.SpringCloud整合Zookeeper 1.增加生产者模块： 2.增加消费者模块：",content:'# ZooKeeper\n\n\n# 1.linux安装Zookeeper\n\n参考地址：https://www.cnblogs.com/expiator/p/9853378.html\n\n前提：已经安装了jdk\n\n1.https://archive.apache.org/dist/zookeeper/ 找到对应的版本下载\n\n安装命令操作：\n\n1.解压：\ntar -zxvf zookeeper-3.4.14.tar.gz 解压\n2.进入conf目录：\ncd zookeeper-3.4.14/conf\n3.将zoo_sample.cfg这个文件复制为zoo.cfg (必须是这个文件名)\ncp  zoo_sample.cfg  zoo.cfg\n4. 进入zoo.cfg文件进行编辑\nvi zoo.cfg\n    修改以下内容\n    dataDir=/tmp/zookeeper/data\n    dataLogDir=/tmp/zookeeper/log\n5.创建对应的文件夹\nmkdir /tmp/zookeeper\nmkdir /tmp/zookeeper/data\nmkdir /tmp/zookeeper/log\n6.配置环境变量\nexport ZOOKEEPER_INSTALL=/root/zookeeper/zookeeper-3.4.14/\nexport PATH=$PATH:$ZOOKEEPER_INSTALL/bin\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 2.启动Zookeeper\n\n1.进入bin目录，并启动zookeep。如果不是在bin目录下执行，启动zookeeper时会报错： bash: ./zkServer.sh: No such file or directory\n\n注意： ./zkServer.sh start前面的 . 不可忽略。\n\n[root@localhost local]# cd /root/zookeeper/zookeeper-3.4.14/bin\n[root@localhost bin]# ./zkServer.sh start\n\n\n1\n2\n\n\n2.启动成功效果\n\nZooKeeper JMX enabled by default\nUsing config: /usr/local/zookeeper-3.4.13/bin/../conf/zoo.cfg\nStarting zookeeper ... STARTED\n\n\n1\n2\n3\n\n\n3.zookeeper的服务端启动后，还需要启动zookeeper的客户端\n\n[root@localhost bin]# ./zkCli.sh\n\n\n1\n\n\n启动成功效果如下：\n\nConnecting to localhost:2181..............................Welcome to ZooKeeper!\n2018-10-25 21:04:54,407 [myid:] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@1029] - Opening socket connection to server localhost/0:0:0:0:0:0:0:1:2181. Will not attempt to authenticate using SASL (unknown error)\nJLine support is enabled\n2018-10-25 21:04:54,471 [myid:] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@879] - Socket connection established to localhost/0:0:0:0:0:0:0:1:2181, initiating session\n[zk: localhost:2181(CONNECTING) 0] 2018-10-25 21:04:54,501 [myid:] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@1303] - Session establishment complete on server localhost/0:0:0:0:0:0:0:1:2181, sessionid = 0x10000712e6f0000, negotiated timeout = 30000\n\nWATCHER::\n\nWatchedEvent state:SyncConnected type:None path:null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n4.查看状态：\n\n[root@localhost bin]# ./zkServer.sh status\nZooKeeper JMX enabled by default\nUsing config: /usr/local/zookeeper-3.4.13/bin/../conf/zoo.cfg\nMode: standalone\n\n\n1\n2\n3\n4\n\n\n\n# 3.集群版安装\n\n> 在同一个机子上面搭建三个zookeeper，伪集群\n\n\n# 1.创建文件目录结构\n\nmkdir -pv /opt/module/zookeeper/server1\nmkdir -pv /opt/module/zookeeper/server2\nmkdir -pv /opt/module/zookeeper/server3\n\n\n1\n2\n3\n\n\n\n# 2.创建数据存放和日志文件\n\nmkdir -pv /opt/module/zookeeper/server1/data\nmkdir -pv /opt/module/zookeeper/server1/log\nmkdir -pv /opt/module/zookeeper/server2/data\nmkdir -pv /opt/module/zookeeper/server2/log\nmkdir -pv /opt/module/zookeeper/server3/data\nmkdir -pv /opt/module/zookeeper/server3/log\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.创建zookeeper集群ID\n\necho "1" > /opt/module/zookeeper/server1/data/myid\necho "2" > /opt/module/zookeeper/server2/data/myid\necho "3" > /opt/module/zookeeper/server3/data/myid\n\n\n1\n2\n3\n\n\n\n# 4.下载zookeeper（参考单机版 下载、解压）\n\n解压到/opt/module/zookeeper/server1/目录\n\n目录结构图：\n\n\n\n\n# 4.修改配置文件\n\n> 注意：配置文件名字要改为zoo.cfg\n\ncd /opt/module/zookeeper/server1/zookeeper-3.4.14/conf\nvi zoo.cfg\n\n\n1\n2\n\n\n需要修改的地方：\n\n * clientPort=2181：端口号\n   * 2181、2182、2183\n * dataDir：数据文件\n   * /opt/module/zookeeper/server1/data\n   * /opt/module/zookeeper/server2/data\n   * /opt/module/zookeeper/server3/data\n * dataLogDir：日志文件\n   * /opt/module/zookeeper/server1/log\n   * /opt/module/zookeeper/server2/log\n   * /opt/module/zookeeper/server3/log\n * 集群配置，所有的配置文件都需要不用改动\n   * server.1=127.0.0.1:2888:3888 server.2=127.0.0.1:2889:3889 server.3=127.0.0.1:2890:3890\n\n# The number of milliseconds of each tick\ntickTime=2000\n# The number of ticks that the initial\n# synchronization phase can take\ninitLimit=10\n# The number of ticks that can pass between\n# sending a request and getting an acknowledgement\nsyncLimit=5\n# the directory where the snapshot is stored.\n# do not use /tmp for storage, /tmp here is just\n# example sakes.\ndataDir=/opt/module/zookeeper/server1/data\ndataLogDir=/opt/module/zookeeper/server1/log\n# the port at which the clients will connect\nclientPort=2181\n# the maximum number of client connections.\n# increase this if you need to handle more clients\n#maxClientCnxns=60\n#\n# Be sure to read the maintenance section of the\n# administrator guide before turning on autopurge.\n#\n# http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance\n#\n# The number of snapshots to retain in dataDir\n#autopurge.snapRetainCount=3\n# Purge task interval in hours\n# Set to "0" to disable auto purge feature\n#autopurge.purgeInterval=1\n\n\n##集群配置\n# The number of ticks that the initial, synchronization phase can take\n# follow服务器在启动的过程中会与leader服务器建立链接并完成对数据的同步，leader服务器允许follow在initLimit时间内完成，默认时10.集群量增大时\n#同步时间变长，有必要适当的调大这个参数, 当超过设置倍数的 tickTime 时间，则连接失败\ninitLimit=10\n#只有集群才需要一下配置\n#server.A=B：C：D：其中 A 数字，表示是第几号服务器. dataDir目录下必有一个myid文件，里面只存\n储A的值,ZK启动时读取此文件，与下面列表比较判断是哪个server\n# B 是服务器 ip ；C表示与 Leader 服务器交换信息的端口；D 表示的是进行选举时的通信端口。\nserver.1=127.0.0.1:2888:3888\nserver.2=127.0.0.1:2889:3889\nserver.3=127.0.0.1:2890:3890\n\n# 配置成observer模式\n#peerType=observer\n# 注意观察者角色的末尾，需要拼接上observer\n#server.4=10.2.143.38:2886:3886:observer\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 5.复制到server2、server3\n\ncp -r ./zookeeper-3.4.14 /opt/module/zookeeper/server2/\ncp -r ./zookeeper-3.4.14 /opt/module/zookeeper/server3/\n\n\n1\n2\n\n\n修改配置文件即可\n\n\n# 6.启动\n\n# 方式一：依次进入配置文件中启动服务\n\n./zkServer.sh start\n\n\n1\n\n\n# 方式二：通过sh文件来启动\n\n1.新增bat文件\n\n#!/bin/bash\n\nif [ "$1" = "" ];\nthen\n    echo -e "\\033[0;31m 未输入操作名 \\033[0m  \\033[0;34m {start|stop|status} \\033[0m"\n    exit 1\nfi\n\nfunction start()\n{\n\tserver1/zookeeper-3.4.14/bin/zkServer.sh start\n\tserver2/zookeeper-3.4.14/bin/zkServer.sh start\n\tserver3/zookeeper-3.4.14/bin/zkServer.sh start\n}\n\nfunction stop()\n{\n\tserver1/zookeeper-3.4.14/bin/zkServer.sh stop\n\tserver2/zookeeper-3.4.14/bin/zkServer.sh stop\n\tserver3/zookeeper-3.4.14/bin/zkServer.sh stop\n}\n\n\nfunction status()\n{\n\tserver1/zookeeper-3.4.14/bin/zkServer.sh status\n\tserver2/zookeeper-3.4.14/bin/zkServer.sh status\n\tserver3/zookeeper-3.4.14/bin/zkServer.sh status\n}\n\ncase $1 in\n    start)\n    start;;\n    stop)\n    stop;;\n    status)\n    status;;\n    *)\n\nesac\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n2.放到server1同一目录\n\n3.给权限\n\nchmod +x zkStart.sh\n\n\n1\n\n\n4.转化文件，通过wind10编辑后放入到linux，会出现文件格式不对\n\nsed -i "s/\\r//" zkStart.sh\n\n\n1\n\n\n\n# 7.测试\n\njps\n\n\n1\n\n\n\n# 4.Zookeeper使用\n\n通过 ./zkCli.sh 进入客户端后，就可以使用命令来操作zookeeper了。\n\n\n# 0.展示节点\n\n一定要有/\n\nls / \n\n\n1\n\n\n\n# 1.创建节点\n\n使用create命令，可以创建一个zookeeper节点。\n\ncreate [-s] [-e] path data acl\n\n其中-s表示顺序节点，-e表示临时节点。默认情况下，创建的是持久节点。\n\npath是节点路径，data是节点数据，acl是用来进行权限控制的。\n\n如下：\n\n创建一个叫做/zk-test的节点，内容是"123"\n\n[zk: localhost:2181(CONNECTED) 0] create /zk-test 123\nCreated /zk-test\n\n\n1\n2\n\n\n创建/zk-test的子节点book，内容是"233"\n\n[zk: localhost:2181(CONNECTED) 7] create  /zk-test/book  233\nCreated /zk-test/book\n\n\n1\n2\n\n\n\n# 2.查看节点内容\n\n使用get命令，可以获取zookeeper指定节点的内容和属性信息。\n\n如下：\n\n[zk: localhost:2181(CONNECTED) 1] get /zk-test\n123\ncZxid = 0x3a\nctime = Sun Nov 11 21:50:44 CST 2018\nmZxid = 0x3a\nmtime = Sun Nov 11 21:50:44 CST 2018\npZxid = 0x3a\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 3\nnumChildren = 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.查看子节点\n\n使用ls命令可以查看指定节点下的所有子节点\n\n以下查看根目录下的所有子节点：\n\n[zk: localhost:2181(CONNECTED) 2] ls /\n[zk-test, zookeeper]\n\n\n1\n2\n\n\n查看zk-test节点的子节点：\n\n[zk: localhost:2181(CONNECTED) 3] ls /zk-test\n[book]\n\n\n1\n2\n\n\n\n# 4.更新节点内容\n\n使用set命令，更新节点内容。格式为：\n\nset path data\n\n其中的data就是要更新的新内容。\n\n[zk: localhost:2181(CONNECTED) 4] set /zk-test 456\n\ncZxid = 0x3a\nctime = Sun Nov 11 21:50:44 CST 2018\nmZxid = 0x3b\nmtime = Sun Nov 11 22:05:20 CST 2018\npZxid = 0x3a\ncversion = 0\ndataVersion = 1\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 3\nnumChildren = 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在输出的信息中，可以发现，dataVersion的值由原来的0 变成了 1，这是因为刚才的更新操作导致该节点的数据版本也发生变更。\n\n\n# 6.删除节点\n\n使用delete命令来删除节点，如下：\n\n[zk: localhost:2181(CONNECTED) 11] delete /zk-test\nNode not empty: /zk-test\n\n\n1\n2\n\n\n可以发现，一个节点存在子节点时，无法删除该节点。\n\n删除子节点/zk-test/book，如下：\n\n[zk: localhost:2181(CONNECTED) 12] delete /zk-test/book\n\nWATCHER::\n\nWatchedEvent state:SyncConnected type:NodeDeleted path:/zk-test/book\n\n\n1\n2\n3\n4\n5\n\n\nzookeeper中的watcher会监控节点，当子节点发生变化时会发出通知。此时提示子节点 /zk-test/book删除成功。\n\n继续尝试删除节点 /zk-test，\n\n[zk: localhost:2181(CONNECTED) 13] ls /zk-test\n[]\n[zk: localhost:2181(CONNECTED) 14] delete /zk-test\n[zk: localhost:2181(CONNECTED) 15] ls /\n[]\n\n\n1\n2\n3\n4\n5\n\n\n删除成功。\n\n\n# ******************************************************************************************************************\n\n\n# 4.SpringCloud整合Zookeeper\n\n注意：\n\nzookeeper作为服务注册中心，微服务作为节点注册进来，那这个节点是临时还是持久？ 关于Eureka我们知道，偶尔有一时刻服务提供者出了点故障，Eureka会开启自我保护机制，微服务不会被删除，那现在关闭8004试一下zookeeper中的服务会有什么变化吗？\n\n可以看出，Zookeeper也是在一定时间内，不会剔除服务，超时才剔除，所以zookeeper具备的服务节点是临时的。当你再启动8004时，zookeeper还会自动监听服务状态，但是流水号是一个新的流水号。\n\n（临时节点:心跳未及时反馈及删除）\n\n记得关闭防火墙：systemctl stop firewalld\n\n\n# 1.增加生产者模块：\n\n 1. 新建模块：cloud-provider-payment8004\n\n 2. 修改pom文件\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <project xmlns="http://maven.apache.org/POM/4.0.0"\n             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n        <parent>\n            <artifactId>CloudStudy</artifactId>\n            <groupId>com.wcy.springcloud</groupId>\n            <version>1.0-SNAPSHOT</version>\n        </parent>\n        <modelVersion>4.0.0</modelVersion>\n    \n        <artifactId>cloud-provider-payment8004</artifactId>\n    \n        <dependencies>\n            \x3c!-- SpringBoot整合zookeeper客户端 --\x3e\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>\n            </dependency>\n    \n            \x3c!-- SpringBoot整合Web组件 --\x3e\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-web</artifactId>\n            </dependency>\n            <dependency>\x3c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\x3e\n                <groupId>com.wcy.springcloud</groupId>\n                <artifactId>cloud-api-commons</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-devtools</artifactId>\n                <scope>runtime</scope>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.projectlombok</groupId>\n                <artifactId>lombok</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-test</artifactId>\n                <scope>test</scope>\n            </dependency>\n        </dependencies>\n    </project>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    \n\n 3. 修改yml文件\n    \n    #8004表示注册到zookeeper服务器的支付服务提供者端口号\n    server:\n      port: 8004\n    #服务别名----注册zookeeper到注册中心名称\n    spring:\n      application:\n        name: cloud-provider-payment   #服务注册的别名\n      cloud:\n        zookeeper:\n          connect-string: 192.168.2.210:2181\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 4. 启动类\n    \n    package com.wcy.springcloud;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n    \n    @SpringBootApplication\n    @EnableDiscoveryClient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务\n    public class PaymentZookeeperMain8004 {\n        public static void main(String[] args) {\n            SpringApplication.run(PaymentZookeeperMain8004.class,args);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 5. 测试\n    \n    package com.wcy.springcloud.controller;\n    \n    import org.springframework.beans.factory.annotation.Value;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    import java.util.UUID;\n    \n    @RestController\n    public class PaymentController {\n        @Value("${server.port}")\n        private String serverPort;\n    \n        @GetMapping("/payment.zk")\n        public String getZk(){\n            return "springcloud with zookeeper: "+serverPort+"\\t"+ UUID.randomUUID().toString();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n\n 6. 启动服务报错：\n    \n    由于spring-cloud-starter-zookeeper-discovery自带的zookeeper版本是3.5.3，而我们下周的zookeeper版本是3.4.14\n    \n    org.apache.zookeeper.KeeperException$ConnectionLossException: KeeperErrorCode = ConnectionLoss\n    \tat org.apache.zookeeper.KeeperException.create(KeeperException.java:99) ~[zookeeper-3.5.3-beta.jar:3.5.3-beta-8ce24f9e675cbefffb8f21a47e06b42864475a60]\n    \tat org.apache.curator.framework.imps.CuratorFrameworkImpl.checkBackgroundRetry(CuratorFrameworkImpl.java:844) [curator-framework-4.0.1.jar:4.0.1]\n    \tat org.apache.curator.framework.imps.CuratorFrameworkImpl.performBackgroundOperation(CuratorFrameworkImpl.java:972) [curator-framework-4.0.1.jar:4.0.1]\n    \tat org.apache.curator.framework.imps.CuratorFrameworkImpl.backgroundOperationsLoop(CuratorFrameworkImpl.java:925) [curator-framework-4.0.1.jar:4.0.1]\n    \tat org.apache.curator.framework.imps.CuratorFrameworkImpl.access$300(CuratorFrameworkImpl.java:73) [curator-framework-4.0.1.jar:4.0.1]\n    \tat org.apache.curator.framework.imps.CuratorFrameworkImpl$4.call(CuratorFrameworkImpl.java:322) [curator-framework-4.0.1.jar:4.0.1]\n    \tat java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266) [na:1.8.0_40]\n    \tat java.util.concurrent.FutureTask.run(FutureTask.java) [na:1.8.0_40]\n    \tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) [na:1.8.0_40]\n    \tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) [na:1.8.0_40]\n    \tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_40]\n    \tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_40]\n    \tat java.lang.Thread.run(Thread.java:745) [na:1.8.0_40]\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n    \n    解决：排除自带的依赖，导入对应的版本\n    \n            \x3c!-- SpringBoot整合zookeeper客户端 --\x3e\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>\n                \x3c!--先排除自带的zookeeper3.5.3--\x3e\n                <exclusions>\n                    <exclusion>\n                        <groupId>org.apache.zookeeper</groupId>\n                        <artifactId>zookeeper</artifactId>\n                    </exclusion>\n                </exclusions>\n            </dependency>\n            \x3c!--添加zookeeper3.4.9版本--\x3e\n            <dependency>\n                <groupId>org.apache.zookeeper</groupId>\n                <artifactId>zookeeper</artifactId>\n                <version>3.4.14</version>\n            </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n    \n    PS： 新版本的zookeeper还会遇到slf4j和log4j包冲突的问题，此时在zookeeper去掉slf4j的依赖\n    \n    <dependency>\n    \t<groupId>org.apache.zookeeper</groupId>\n        \t<artifactId>zookeeper</artifactId>\n            <version>3.4.14</version>\n            <exclusions>\n            \t<exclusion>\n                \t<groupId>log4j</groupId>\n                    <artifactId>log4j</artifactId>\n                </exclusion>\n                <exclusion>\n                \t<groupId>org.slf4j</groupId>\n                    <artifactId>slf4j-log4j12</artifactId>\n                </exclusion>\n         </exclusions>\n    </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 7. 在linux中操作查看微服务是否注册成功\n    \n    进入zookeeper客户端\n    ./zkCli.sh\n    get /services/cloud-provider-payment/XXX字符串\n    得到一组数据，json在线转换工具查看即可\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 2.增加消费者模块：\n\n与上方增加生产者模块相同，通过RestTemplate调用生产者服务即可',normalizedContent:'# zookeeper\n\n\n# 1.linux安装zookeeper\n\n参考地址：https://www.cnblogs.com/expiator/p/9853378.html\n\n前提：已经安装了jdk\n\n1.https://archive.apache.org/dist/zookeeper/ 找到对应的版本下载\n\n安装命令操作：\n\n1.解压：\ntar -zxvf zookeeper-3.4.14.tar.gz 解压\n2.进入conf目录：\ncd zookeeper-3.4.14/conf\n3.将zoo_sample.cfg这个文件复制为zoo.cfg (必须是这个文件名)\ncp  zoo_sample.cfg  zoo.cfg\n4. 进入zoo.cfg文件进行编辑\nvi zoo.cfg\n    修改以下内容\n    datadir=/tmp/zookeeper/data\n    datalogdir=/tmp/zookeeper/log\n5.创建对应的文件夹\nmkdir /tmp/zookeeper\nmkdir /tmp/zookeeper/data\nmkdir /tmp/zookeeper/log\n6.配置环境变量\nexport zookeeper_install=/root/zookeeper/zookeeper-3.4.14/\nexport path=$path:$zookeeper_install/bin\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 2.启动zookeeper\n\n1.进入bin目录，并启动zookeep。如果不是在bin目录下执行，启动zookeeper时会报错： bash: ./zkserver.sh: no such file or directory\n\n注意： ./zkserver.sh start前面的 . 不可忽略。\n\n[root@localhost local]# cd /root/zookeeper/zookeeper-3.4.14/bin\n[root@localhost bin]# ./zkserver.sh start\n\n\n1\n2\n\n\n2.启动成功效果\n\nzookeeper jmx enabled by default\nusing config: /usr/local/zookeeper-3.4.13/bin/../conf/zoo.cfg\nstarting zookeeper ... started\n\n\n1\n2\n3\n\n\n3.zookeeper的服务端启动后，还需要启动zookeeper的客户端\n\n[root@localhost bin]# ./zkcli.sh\n\n\n1\n\n\n启动成功效果如下：\n\nconnecting to localhost:2181..............................welcome to zookeeper!\n2018-10-25 21:04:54,407 [myid:] - info  [main-sendthread(localhost:2181):clientcnxn$sendthread@1029] - opening socket connection to server localhost/0:0:0:0:0:0:0:1:2181. will not attempt to authenticate using sasl (unknown error)\njline support is enabled\n2018-10-25 21:04:54,471 [myid:] - info  [main-sendthread(localhost:2181):clientcnxn$sendthread@879] - socket connection established to localhost/0:0:0:0:0:0:0:1:2181, initiating session\n[zk: localhost:2181(connecting) 0] 2018-10-25 21:04:54,501 [myid:] - info  [main-sendthread(localhost:2181):clientcnxn$sendthread@1303] - session establishment complete on server localhost/0:0:0:0:0:0:0:1:2181, sessionid = 0x10000712e6f0000, negotiated timeout = 30000\n\nwatcher::\n\nwatchedevent state:syncconnected type:none path:null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n4.查看状态：\n\n[root@localhost bin]# ./zkserver.sh status\nzookeeper jmx enabled by default\nusing config: /usr/local/zookeeper-3.4.13/bin/../conf/zoo.cfg\nmode: standalone\n\n\n1\n2\n3\n4\n\n\n\n# 3.集群版安装\n\n> 在同一个机子上面搭建三个zookeeper，伪集群\n\n\n# 1.创建文件目录结构\n\nmkdir -pv /opt/module/zookeeper/server1\nmkdir -pv /opt/module/zookeeper/server2\nmkdir -pv /opt/module/zookeeper/server3\n\n\n1\n2\n3\n\n\n\n# 2.创建数据存放和日志文件\n\nmkdir -pv /opt/module/zookeeper/server1/data\nmkdir -pv /opt/module/zookeeper/server1/log\nmkdir -pv /opt/module/zookeeper/server2/data\nmkdir -pv /opt/module/zookeeper/server2/log\nmkdir -pv /opt/module/zookeeper/server3/data\nmkdir -pv /opt/module/zookeeper/server3/log\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.创建zookeeper集群id\n\necho "1" > /opt/module/zookeeper/server1/data/myid\necho "2" > /opt/module/zookeeper/server2/data/myid\necho "3" > /opt/module/zookeeper/server3/data/myid\n\n\n1\n2\n3\n\n\n\n# 4.下载zookeeper（参考单机版 下载、解压）\n\n解压到/opt/module/zookeeper/server1/目录\n\n目录结构图：\n\n\n\n\n# 4.修改配置文件\n\n> 注意：配置文件名字要改为zoo.cfg\n\ncd /opt/module/zookeeper/server1/zookeeper-3.4.14/conf\nvi zoo.cfg\n\n\n1\n2\n\n\n需要修改的地方：\n\n * clientport=2181：端口号\n   * 2181、2182、2183\n * datadir：数据文件\n   * /opt/module/zookeeper/server1/data\n   * /opt/module/zookeeper/server2/data\n   * /opt/module/zookeeper/server3/data\n * datalogdir：日志文件\n   * /opt/module/zookeeper/server1/log\n   * /opt/module/zookeeper/server2/log\n   * /opt/module/zookeeper/server3/log\n * 集群配置，所有的配置文件都需要不用改动\n   * server.1=127.0.0.1:2888:3888 server.2=127.0.0.1:2889:3889 server.3=127.0.0.1:2890:3890\n\n# the number of milliseconds of each tick\nticktime=2000\n# the number of ticks that the initial\n# synchronization phase can take\ninitlimit=10\n# the number of ticks that can pass between\n# sending a request and getting an acknowledgement\nsynclimit=5\n# the directory where the snapshot is stored.\n# do not use /tmp for storage, /tmp here is just\n# example sakes.\ndatadir=/opt/module/zookeeper/server1/data\ndatalogdir=/opt/module/zookeeper/server1/log\n# the port at which the clients will connect\nclientport=2181\n# the maximum number of client connections.\n# increase this if you need to handle more clients\n#maxclientcnxns=60\n#\n# be sure to read the maintenance section of the\n# administrator guide before turning on autopurge.\n#\n# http://zookeeper.apache.org/doc/current/zookeeperadmin.html#sc_maintenance\n#\n# the number of snapshots to retain in datadir\n#autopurge.snapretaincount=3\n# purge task interval in hours\n# set to "0" to disable auto purge feature\n#autopurge.purgeinterval=1\n\n\n##集群配置\n# the number of ticks that the initial, synchronization phase can take\n# follow服务器在启动的过程中会与leader服务器建立链接并完成对数据的同步，leader服务器允许follow在initlimit时间内完成，默认时10.集群量增大时\n#同步时间变长，有必要适当的调大这个参数, 当超过设置倍数的 ticktime 时间，则连接失败\ninitlimit=10\n#只有集群才需要一下配置\n#server.a=b：c：d：其中 a 数字，表示是第几号服务器. datadir目录下必有一个myid文件，里面只存\n储a的值,zk启动时读取此文件，与下面列表比较判断是哪个server\n# b 是服务器 ip ；c表示与 leader 服务器交换信息的端口；d 表示的是进行选举时的通信端口。\nserver.1=127.0.0.1:2888:3888\nserver.2=127.0.0.1:2889:3889\nserver.3=127.0.0.1:2890:3890\n\n# 配置成observer模式\n#peertype=observer\n# 注意观察者角色的末尾，需要拼接上observer\n#server.4=10.2.143.38:2886:3886:observer\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 5.复制到server2、server3\n\ncp -r ./zookeeper-3.4.14 /opt/module/zookeeper/server2/\ncp -r ./zookeeper-3.4.14 /opt/module/zookeeper/server3/\n\n\n1\n2\n\n\n修改配置文件即可\n\n\n# 6.启动\n\n# 方式一：依次进入配置文件中启动服务\n\n./zkserver.sh start\n\n\n1\n\n\n# 方式二：通过sh文件来启动\n\n1.新增bat文件\n\n#!/bin/bash\n\nif [ "$1" = "" ];\nthen\n    echo -e "\\033[0;31m 未输入操作名 \\033[0m  \\033[0;34m {start|stop|status} \\033[0m"\n    exit 1\nfi\n\nfunction start()\n{\n\tserver1/zookeeper-3.4.14/bin/zkserver.sh start\n\tserver2/zookeeper-3.4.14/bin/zkserver.sh start\n\tserver3/zookeeper-3.4.14/bin/zkserver.sh start\n}\n\nfunction stop()\n{\n\tserver1/zookeeper-3.4.14/bin/zkserver.sh stop\n\tserver2/zookeeper-3.4.14/bin/zkserver.sh stop\n\tserver3/zookeeper-3.4.14/bin/zkserver.sh stop\n}\n\n\nfunction status()\n{\n\tserver1/zookeeper-3.4.14/bin/zkserver.sh status\n\tserver2/zookeeper-3.4.14/bin/zkserver.sh status\n\tserver3/zookeeper-3.4.14/bin/zkserver.sh status\n}\n\ncase $1 in\n    start)\n    start;;\n    stop)\n    stop;;\n    status)\n    status;;\n    *)\n\nesac\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n2.放到server1同一目录\n\n3.给权限\n\nchmod +x zkstart.sh\n\n\n1\n\n\n4.转化文件，通过wind10编辑后放入到linux，会出现文件格式不对\n\nsed -i "s/\\r//" zkstart.sh\n\n\n1\n\n\n\n# 7.测试\n\njps\n\n\n1\n\n\n\n# 4.zookeeper使用\n\n通过 ./zkcli.sh 进入客户端后，就可以使用命令来操作zookeeper了。\n\n\n# 0.展示节点\n\n一定要有/\n\nls / \n\n\n1\n\n\n\n# 1.创建节点\n\n使用create命令，可以创建一个zookeeper节点。\n\ncreate [-s] [-e] path data acl\n\n其中-s表示顺序节点，-e表示临时节点。默认情况下，创建的是持久节点。\n\npath是节点路径，data是节点数据，acl是用来进行权限控制的。\n\n如下：\n\n创建一个叫做/zk-test的节点，内容是"123"\n\n[zk: localhost:2181(connected) 0] create /zk-test 123\ncreated /zk-test\n\n\n1\n2\n\n\n创建/zk-test的子节点book，内容是"233"\n\n[zk: localhost:2181(connected) 7] create  /zk-test/book  233\ncreated /zk-test/book\n\n\n1\n2\n\n\n\n# 2.查看节点内容\n\n使用get命令，可以获取zookeeper指定节点的内容和属性信息。\n\n如下：\n\n[zk: localhost:2181(connected) 1] get /zk-test\n123\nczxid = 0x3a\nctime = sun nov 11 21:50:44 cst 2018\nmzxid = 0x3a\nmtime = sun nov 11 21:50:44 cst 2018\npzxid = 0x3a\ncversion = 0\ndataversion = 0\naclversion = 0\nephemeralowner = 0x0\ndatalength = 3\nnumchildren = 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.查看子节点\n\n使用ls命令可以查看指定节点下的所有子节点\n\n以下查看根目录下的所有子节点：\n\n[zk: localhost:2181(connected) 2] ls /\n[zk-test, zookeeper]\n\n\n1\n2\n\n\n查看zk-test节点的子节点：\n\n[zk: localhost:2181(connected) 3] ls /zk-test\n[book]\n\n\n1\n2\n\n\n\n# 4.更新节点内容\n\n使用set命令，更新节点内容。格式为：\n\nset path data\n\n其中的data就是要更新的新内容。\n\n[zk: localhost:2181(connected) 4] set /zk-test 456\n\nczxid = 0x3a\nctime = sun nov 11 21:50:44 cst 2018\nmzxid = 0x3b\nmtime = sun nov 11 22:05:20 cst 2018\npzxid = 0x3a\ncversion = 0\ndataversion = 1\naclversion = 0\nephemeralowner = 0x0\ndatalength = 3\nnumchildren = 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在输出的信息中，可以发现，dataversion的值由原来的0 变成了 1，这是因为刚才的更新操作导致该节点的数据版本也发生变更。\n\n\n# 6.删除节点\n\n使用delete命令来删除节点，如下：\n\n[zk: localhost:2181(connected) 11] delete /zk-test\nnode not empty: /zk-test\n\n\n1\n2\n\n\n可以发现，一个节点存在子节点时，无法删除该节点。\n\n删除子节点/zk-test/book，如下：\n\n[zk: localhost:2181(connected) 12] delete /zk-test/book\n\nwatcher::\n\nwatchedevent state:syncconnected type:nodedeleted path:/zk-test/book\n\n\n1\n2\n3\n4\n5\n\n\nzookeeper中的watcher会监控节点，当子节点发生变化时会发出通知。此时提示子节点 /zk-test/book删除成功。\n\n继续尝试删除节点 /zk-test，\n\n[zk: localhost:2181(connected) 13] ls /zk-test\n[]\n[zk: localhost:2181(connected) 14] delete /zk-test\n[zk: localhost:2181(connected) 15] ls /\n[]\n\n\n1\n2\n3\n4\n5\n\n\n删除成功。\n\n\n# ******************************************************************************************************************\n\n\n# 4.springcloud整合zookeeper\n\n注意：\n\nzookeeper作为服务注册中心，微服务作为节点注册进来，那这个节点是临时还是持久？ 关于eureka我们知道，偶尔有一时刻服务提供者出了点故障，eureka会开启自我保护机制，微服务不会被删除，那现在关闭8004试一下zookeeper中的服务会有什么变化吗？\n\n可以看出，zookeeper也是在一定时间内，不会剔除服务，超时才剔除，所以zookeeper具备的服务节点是临时的。当你再启动8004时，zookeeper还会自动监听服务状态，但是流水号是一个新的流水号。\n\n（临时节点:心跳未及时反馈及删除）\n\n记得关闭防火墙：systemctl stop firewalld\n\n\n# 1.增加生产者模块：\n\n 1. 新建模块：cloud-provider-payment8004\n\n 2. 修改pom文件\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <project xmlns="http://maven.apache.org/pom/4.0.0"\n             xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n             xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n        <parent>\n            <artifactid>cloudstudy</artifactid>\n            <groupid>com.wcy.springcloud</groupid>\n            <version>1.0-snapshot</version>\n        </parent>\n        <modelversion>4.0.0</modelversion>\n    \n        <artifactid>cloud-provider-payment8004</artifactid>\n    \n        <dependencies>\n            \x3c!-- springboot整合zookeeper客户端 --\x3e\n            <dependency>\n                <groupid>org.springframework.cloud</groupid>\n                <artifactid>spring-cloud-starter-zookeeper-discovery</artifactid>\n            </dependency>\n    \n            \x3c!-- springboot整合web组件 --\x3e\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-web</artifactid>\n            </dependency>\n            <dependency>\x3c!-- 引入自己定义的api通用包，可以使用payment支付entity --\x3e\n                <groupid>com.wcy.springcloud</groupid>\n                <artifactid>cloud-api-commons</artifactid>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-devtools</artifactid>\n                <scope>runtime</scope>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupid>org.projectlombok</groupid>\n                <artifactid>lombok</artifactid>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-test</artifactid>\n                <scope>test</scope>\n            </dependency>\n        </dependencies>\n    </project>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    \n\n 3. 修改yml文件\n    \n    #8004表示注册到zookeeper服务器的支付服务提供者端口号\n    server:\n      port: 8004\n    #服务别名----注册zookeeper到注册中心名称\n    spring:\n      application:\n        name: cloud-provider-payment   #服务注册的别名\n      cloud:\n        zookeeper:\n          connect-string: 192.168.2.210:2181\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 4. 启动类\n    \n    package com.wcy.springcloud;\n    \n    import org.springframework.boot.springapplication;\n    import org.springframework.boot.autoconfigure.springbootapplication;\n    import org.springframework.cloud.client.discovery.enablediscoveryclient;\n    \n    @springbootapplication\n    @enablediscoveryclient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务\n    public class paymentzookeepermain8004 {\n        public static void main(string[] args) {\n            springapplication.run(paymentzookeepermain8004.class,args);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 5. 测试\n    \n    package com.wcy.springcloud.controller;\n    \n    import org.springframework.beans.factory.annotation.value;\n    import org.springframework.web.bind.annotation.getmapping;\n    import org.springframework.web.bind.annotation.restcontroller;\n    \n    import java.util.uuid;\n    \n    @restcontroller\n    public class paymentcontroller {\n        @value("${server.port}")\n        private string serverport;\n    \n        @getmapping("/payment.zk")\n        public string getzk(){\n            return "springcloud with zookeeper: "+serverport+"\\t"+ uuid.randomuuid().tostring();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n\n 6. 启动服务报错：\n    \n    由于spring-cloud-starter-zookeeper-discovery自带的zookeeper版本是3.5.3，而我们下周的zookeeper版本是3.4.14\n    \n    org.apache.zookeeper.keeperexception$connectionlossexception: keepererrorcode = connectionloss\n    \tat org.apache.zookeeper.keeperexception.create(keeperexception.java:99) ~[zookeeper-3.5.3-beta.jar:3.5.3-beta-8ce24f9e675cbefffb8f21a47e06b42864475a60]\n    \tat org.apache.curator.framework.imps.curatorframeworkimpl.checkbackgroundretry(curatorframeworkimpl.java:844) [curator-framework-4.0.1.jar:4.0.1]\n    \tat org.apache.curator.framework.imps.curatorframeworkimpl.performbackgroundoperation(curatorframeworkimpl.java:972) [curator-framework-4.0.1.jar:4.0.1]\n    \tat org.apache.curator.framework.imps.curatorframeworkimpl.backgroundoperationsloop(curatorframeworkimpl.java:925) [curator-framework-4.0.1.jar:4.0.1]\n    \tat org.apache.curator.framework.imps.curatorframeworkimpl.access$300(curatorframeworkimpl.java:73) [curator-framework-4.0.1.jar:4.0.1]\n    \tat org.apache.curator.framework.imps.curatorframeworkimpl$4.call(curatorframeworkimpl.java:322) [curator-framework-4.0.1.jar:4.0.1]\n    \tat java.util.concurrent.futuretask.run$$$capture(futuretask.java:266) [na:1.8.0_40]\n    \tat java.util.concurrent.futuretask.run(futuretask.java) [na:1.8.0_40]\n    \tat java.util.concurrent.scheduledthreadpoolexecutor$scheduledfuturetask.access$201(scheduledthreadpoolexecutor.java:180) [na:1.8.0_40]\n    \tat java.util.concurrent.scheduledthreadpoolexecutor$scheduledfuturetask.run(scheduledthreadpoolexecutor.java:293) [na:1.8.0_40]\n    \tat java.util.concurrent.threadpoolexecutor.runworker(threadpoolexecutor.java:1142) [na:1.8.0_40]\n    \tat java.util.concurrent.threadpoolexecutor$worker.run(threadpoolexecutor.java:617) [na:1.8.0_40]\n    \tat java.lang.thread.run(thread.java:745) [na:1.8.0_40]\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n    \n    解决：排除自带的依赖，导入对应的版本\n    \n            \x3c!-- springboot整合zookeeper客户端 --\x3e\n            <dependency>\n                <groupid>org.springframework.cloud</groupid>\n                <artifactid>spring-cloud-starter-zookeeper-discovery</artifactid>\n                \x3c!--先排除自带的zookeeper3.5.3--\x3e\n                <exclusions>\n                    <exclusion>\n                        <groupid>org.apache.zookeeper</groupid>\n                        <artifactid>zookeeper</artifactid>\n                    </exclusion>\n                </exclusions>\n            </dependency>\n            \x3c!--添加zookeeper3.4.9版本--\x3e\n            <dependency>\n                <groupid>org.apache.zookeeper</groupid>\n                <artifactid>zookeeper</artifactid>\n                <version>3.4.14</version>\n            </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n    \n    ps： 新版本的zookeeper还会遇到slf4j和log4j包冲突的问题，此时在zookeeper去掉slf4j的依赖\n    \n    <dependency>\n    \t<groupid>org.apache.zookeeper</groupid>\n        \t<artifactid>zookeeper</artifactid>\n            <version>3.4.14</version>\n            <exclusions>\n            \t<exclusion>\n                \t<groupid>log4j</groupid>\n                    <artifactid>log4j</artifactid>\n                </exclusion>\n                <exclusion>\n                \t<groupid>org.slf4j</groupid>\n                    <artifactid>slf4j-log4j12</artifactid>\n                </exclusion>\n         </exclusions>\n    </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 7. 在linux中操作查看微服务是否注册成功\n    \n    进入zookeeper客户端\n    ./zkcli.sh\n    get /services/cloud-provider-payment/xxx字符串\n    得到一组数据，json在线转换工具查看即可\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 2.增加消费者模块：\n\n与上方增加生产者模块相同，通过resttemplate调用生产者服务即可',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"consul",frontmatter:{title:"consul",date:"2021-08-17T09:31:44.000Z",permalink:"/pages/046d09/",categories:["后端","Spring全家桶","SpringCloud","consul"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/07.consul.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/07.consul.md",key:"v-470866cf",path:"/pages/046d09/",headers:[{level:2,title:"一.consul能干什么",slug:"一-consul能干什么",normalizedTitle:"一.consul能干什么",charIndex:142},{level:2,title:"二.linux安装consul",slug:"二-linux安装consul",normalizedTitle:"二.linux安装consul",charIndex:293},{level:2,title:"三.Spring整合consul",slug:"三-spring整合consul",normalizedTitle:"三.spring整合consul",charIndex:729},{level:3,title:"1.整合生产者payment",slug:"_1-整合生产者payment",normalizedTitle:"1.整合生产者payment",charIndex:750},{level:3,title:"2.整合消费者order",slug:"_2-整合消费者order",normalizedTitle:"2.整合消费者order",charIndex:4878}],headersStr:"一.consul能干什么 二.linux安装consul 三.Spring整合consul 1.整合生产者payment 2.整合消费者order",content:'# consul\n\n中文社区：https://www.springcloud.cc/spring-cloud-consul.html\n\n下载consul网址：https://blog.csdn.net/qq_38270106/article/details/83239921\n\n\n# 一.consul能干什么\n\n 1. 服务发现：提供Http、DNS两种方式发现\n 2. 健康监测：支持多种方式，HTTP、TCP、Docker、Shell脚本定制化监控\n 3. KV存储：key、value的存储方式\n 4. 多数据中心：consul支持多数据中心\n 5. 可视化的web界面\n\n\n# 二.linux安装consul\n\n1.下载consul1.6.1版本\n\nwget https://releases.hashicorp.com/consul/1.6.1/consul_1.6.1_linux_amd64.zip\n\n\n1\n\n\n2.解压consul_0.7.5_linux_amd64.zip\n\nunzip consul_0.7.5_linux_amd64.zip\n\n\n1\n\n\n解决办法-bash: unzip: 未找到命令如果解压出现该错误\n\nyum -y install unzip\n\n\n1\n\n\n3.关闭防火墙\n\nsystemctl stop firewalld \n\n\n1\n\n\n4.启动：192.168.128.149linux的IP地址\n\n./consul agent -dev -ui -node=consul-dev -client=192.168.128.149\n\n\n1\n\n\n5.访问\n\n192.168.128.149:8500\n\n\n1\n\n\n\n# 三.Spring整合consul\n\n\n# 1.整合生产者payment\n\n1.新建模块：cloud-providerconsul-payment8006\n\n2.pom文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloud-providerconsul-payment8006</artifactId>\n\n    <dependencies>\n        \x3c!--SpringCloud consul-server --\x3e\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n        </dependency>\n        \x3c!-- SpringBoot整合Web组件 --\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \x3c!--日常通用jar包配置--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n3.yml文件\n\n###consul服务端口号\nserver:\n  port: 8006\n\nspring:\n  application:\n    name: consul-provider-payment\n  ####consul注册中心地址\n  cloud:\n    consul:\n      host: 192.168.104.210\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n        #发送心跳协议\n        heartbeat:\n          enabled: true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class PaymentMain8006 {\n    public static void main(String[] args) {\n        SpringApplication.run(PaymentMain8006.class,args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n5.controller业务类\n\npackage com.wcy.springcloud.controller;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.cloud.client.ServiceInstance;\nimport org.springframework.cloud.client.discovery.DiscoveryClient;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.List;\nimport java.util.UUID;\n\n@RestController\n@Slf4j\npublic class PaymentController {\n    @Value("${server.port}")\n    private String serverPort;\n    @Autowired\n    private DiscoveryClient discoveryClient;\n\n    @GetMapping("/payment/consul")\n    public String getConsul(){\n        List<String> services = discoveryClient.getServices();\n        for(String service:services){\n            log.info(service);\n            List<ServiceInstance> instances = discoveryClient.getInstances(service);\n            for(ServiceInstance serviceInstance:instances){\n                log.info(serviceInstance.getUri()+"");\n            }\n        }\n        return "springcloud with consul: "+serverPort+"\\t\\t"+ UUID.randomUUID().toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 2.整合消费者order\n\n与上方类似，通过RestTemplate调用后端服务即可',normalizedContent:'# consul\n\n中文社区：https://www.springcloud.cc/spring-cloud-consul.html\n\n下载consul网址：https://blog.csdn.net/qq_38270106/article/details/83239921\n\n\n# 一.consul能干什么\n\n 1. 服务发现：提供http、dns两种方式发现\n 2. 健康监测：支持多种方式，http、tcp、docker、shell脚本定制化监控\n 3. kv存储：key、value的存储方式\n 4. 多数据中心：consul支持多数据中心\n 5. 可视化的web界面\n\n\n# 二.linux安装consul\n\n1.下载consul1.6.1版本\n\nwget https://releases.hashicorp.com/consul/1.6.1/consul_1.6.1_linux_amd64.zip\n\n\n1\n\n\n2.解压consul_0.7.5_linux_amd64.zip\n\nunzip consul_0.7.5_linux_amd64.zip\n\n\n1\n\n\n解决办法-bash: unzip: 未找到命令如果解压出现该错误\n\nyum -y install unzip\n\n\n1\n\n\n3.关闭防火墙\n\nsystemctl stop firewalld \n\n\n1\n\n\n4.启动：192.168.128.149linux的ip地址\n\n./consul agent -dev -ui -node=consul-dev -client=192.168.128.149\n\n\n1\n\n\n5.访问\n\n192.168.128.149:8500\n\n\n1\n\n\n\n# 三.spring整合consul\n\n\n# 1.整合生产者payment\n\n1.新建模块：cloud-providerconsul-payment8006\n\n2.pom文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloud-providerconsul-payment8006</artifactid>\n\n    <dependencies>\n        \x3c!--springcloud consul-server --\x3e\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-consul-discovery</artifactid>\n        </dependency>\n        \x3c!-- springboot整合web组件 --\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n        \x3c!--日常通用jar包配置--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n3.yml文件\n\n###consul服务端口号\nserver:\n  port: 8006\n\nspring:\n  application:\n    name: consul-provider-payment\n  ####consul注册中心地址\n  cloud:\n    consul:\n      host: 192.168.104.210\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n        #发送心跳协议\n        heartbeat:\n          enabled: true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.cloud.client.discovery.enablediscoveryclient;\n\n@springbootapplication\n@enablediscoveryclient\npublic class paymentmain8006 {\n    public static void main(string[] args) {\n        springapplication.run(paymentmain8006.class,args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n5.controller业务类\n\npackage com.wcy.springcloud.controller;\n\nimport lombok.extern.slf4j.slf4j;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.beans.factory.annotation.value;\nimport org.springframework.cloud.client.serviceinstance;\nimport org.springframework.cloud.client.discovery.discoveryclient;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\nimport java.util.list;\nimport java.util.uuid;\n\n@restcontroller\n@slf4j\npublic class paymentcontroller {\n    @value("${server.port}")\n    private string serverport;\n    @autowired\n    private discoveryclient discoveryclient;\n\n    @getmapping("/payment/consul")\n    public string getconsul(){\n        list<string> services = discoveryclient.getservices();\n        for(string service:services){\n            log.info(service);\n            list<serviceinstance> instances = discoveryclient.getinstances(service);\n            for(serviceinstance serviceinstance:instances){\n                log.info(serviceinstance.geturi()+"");\n            }\n        }\n        return "springcloud with consul: "+serverport+"\\t\\t"+ uuid.randomuuid().tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 2.整合消费者order\n\n与上方类似，通过resttemplate调用后端服务即可',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"三种服务注册的区别",frontmatter:{title:"三种服务注册的区别",date:"2021-08-17T09:31:44.000Z",permalink:"/pages/7dbd36/",categories:["后端","Spring全家桶","SpringCloud","三种服务注册的区别"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/08.%E4%B8%89%E7%A7%8D%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E7%9A%84%E5%8C%BA%E5%88%AB.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/08.三种服务注册的区别.md",key:"v-159e4156",path:"/pages/7dbd36/",headers:[{level:2,title:"1.CAP",slug:"_1-cap",normalizedTitle:"1.cap",charIndex:35}],headersStr:"1.CAP",content:"# Eureka、Zookeeper、Consul的区别\n\n\n\n\n# 1.CAP\n\nC：Consistency(强一致性)，数据必须保持一致\n\nA：Availability(可用性)，服务高可用\n\nP：Partition tolerance (分区容错性)：多个服务分区容错性\n\n比如：淘宝某个商品，双十一，肯定是满足AP高可用的，比如点赞量、访问量等数据可以不一致。\n\n任何一个服务都只会满足上方两种，不可能同时满足上方三种\n\n> 最多只能同时较好的满足两个。 CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求， 因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类： CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。 CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。 AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。\n\n分布式架构比满足P，所以存在CP和AP；\n\nEureka满足AP，高可用\n\nZookeeper、consul满足CP，数据一致性",normalizedContent:"# eureka、zookeeper、consul的区别\n\n\n\n\n# 1.cap\n\nc：consistency(强一致性)，数据必须保持一致\n\na：availability(可用性)，服务高可用\n\np：partition tolerance (分区容错性)：多个服务分区容错性\n\n比如：淘宝某个商品，双十一，肯定是满足ap高可用的，比如点赞量、访问量等数据可以不一致。\n\n任何一个服务都只会满足上方两种，不可能同时满足上方三种\n\n> 最多只能同时较好的满足两个。 cap理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求， 因此，根据 cap 原理将 nosql 数据库分成了满足 ca 原则、满足 cp 原则和满足 ap 原则三 大类： ca - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。 cp - 满足一致性，分区容忍必的系统，通常性能不是特别高。 ap - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。\n\n分布式架构比满足p，所以存在cp和ap；\n\neureka满足ap，高可用\n\nzookeeper、consul满足cp，数据一致性",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"Ribbon",frontmatter:{title:"Ribbon",date:"2021-08-17T09:31:44.000Z",permalink:"/pages/a5d650/",categories:["后端","Spring全家桶","SpringCloud","Ribbon"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/09.Ribbon.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/09.Ribbon.md",key:"v-46c1284f",path:"/pages/a5d650/",headers:[{level:2,title:"1.什么是负载均衡(Load Balance)",slug:"_1-什么是负载均衡-load-balance",normalizedTitle:"1.什么是负载均衡(load balance)",charIndex:17},{level:3,title:"1.1.集中式LB和进程内LB",slug:"_1-1-集中式lb和进程内lb",normalizedTitle:"1.1.集中式lb和进程内lb",charIndex:347},{level:2,title:"2.什么是Ribbon",slug:"_2-什么是ribbon",normalizedTitle:"2.什么是ribbon",charIndex:569},{level:2,title:"3.未来替换的产品",slug:"_3-未来替换的产品",normalizedTitle:"3.未来替换的产品",charIndex:835},{level:2,title:"4.SpringCloud使用Ribbon",slug:"_4-springcloud使用ribbon",normalizedTitle:"4.springcloud使用ribbon",charIndex:941},{level:2,title:"5.常见轮询算法",slug:"_5-常见轮询算法",normalizedTitle:"5.常见轮询算法",charIndex:3118},{level:2,title:"6.切换其他负载均衡算法",slug:"_6-切换其他负载均衡算法",normalizedTitle:"6.切换其他负载均衡算法",charIndex:3609},{level:2,title:"7.Ribbon负载均衡使用原理",slug:"_7-ribbon负载均衡使用原理",normalizedTitle:"7.ribbon负载均衡使用原理",charIndex:5056},{level:2,title:"8.Ribbon实现负载均衡的源码",slug:"_8-ribbon实现负载均衡的源码",normalizedTitle:"8.ribbon实现负载均衡的源码",charIndex:5669},{level:2,title:"9.手写自定义负载均衡算法",slug:"_9-手写自定义负载均衡算法",normalizedTitle:"9.手写自定义负载均衡算法",charIndex:8861}],headersStr:"1.什么是负载均衡(Load Balance) 1.1.集中式LB和进程内LB 2.什么是Ribbon 3.未来替换的产品 4.SpringCloud使用Ribbon 5.常见轮询算法 6.切换其他负载均衡算法 7.Ribbon负载均衡使用原理 8.Ribbon实现负载均衡的源码 9.手写自定义负载均衡算法",content:'# Ribbon负载均衡\n\n\n# 1.什么是负载均衡(Load Balance)\n\n简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）。 常见的负载均衡有软件Nginx，LVS，硬件 F5等。\n\nRibbon本地负载均衡客户端 VS Nginx服务端负载均衡区别： Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。\n\nRibbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。\n\n简单的说：比如一个医院病人看病，通过Nginx转发到某个科室，比如口腔科、骨科等等，然后再通过本地负载均衡派发到某个医生。\n\n\n# 1.1.集中式LB和进程内LB\n\n集中式LB：即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；\n\n进程内LB：将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。\n\nRibbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。\n\n\n# 2.什么是Ribbon\n\nSpring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。\n\n> 简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。\n\n\n# 3.未来替换的产品\n\n由于Ribbon已经停止更新，SpringCloud社区正在逐步使用Spring Cloud loadbalacer替换Ribbon，但是由于Ribbonn功能强大，暂时还未替换。\n\n\n# 4.SpringCloud使用Ribbon\n\n# 4.1.引入Pom文件\n\n由于引入了spring-cloud-starter-netflix-eureka-client，该组件已经帮我们引入了Ribbon，所以不需要引入多余的。\n\n\x3c!--eureka-client--\x3e\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\neureka-client已经引入了Ribbon，不需要引入\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n# 4.2.引入restTempelet\n\npackage com.wcy.springcloud.config;\n\nimport org.springframework.cloud.client.loadbalancer.LoadBalanced;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.client.RestTemplate;\n\n/**\n * @auther zzyy\n * @create 2020-02-18 17:27\n */\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力\n    public RestTemplate getRestTemplate()\n    {\n        return new RestTemplate();\n    }\n}\n//applicationContext.xml <bean id="" class="">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 4.3.Controller使用\n\n使用restTemplate的getForObject、getForEntity和postForObject、postForEntity方法\n\n# 4.3.1.getForObject、getForEntity的区别\n\ngetForObject：返回对象为响应体中数据转化成的对象，基本上可以理解为Json\n\ngetForEntity：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等\n\n    @GetMapping("/consumer/payment/{id:\\\\d*}")\n    //CommentResult<Payment> 前端消费者应该声明返回的类型\n    public CommentResult<Payment> create(@PathVariable("id") Long id){\n        return restTemplate.getForObject(PAMENT_URL+"/payment/"+id,CommentResult.class);\n    }\n\n    @GetMapping("/consumer/payment/Entity/{id:\\\\d*}")\n    //CommentResult<Payment> 前端消费者应该声明返回的类型\n    public CommentResult<Payment> create2(@PathVariable("id") Long id){\n        ResponseEntity<CommentResult> forEntity = restTemplate.getForEntity(PAMENT_URL + "/payment/" + id, CommentResult.class);\n        if(forEntity.getStatusCode().is2xxSuccessful()){\n            return forEntity.getBody();\n        }else{\n            return new CommentResult<>(400,"服务器错误");\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 5.常见轮询算法\n\n\n\nRibbon实现负载均衡算法的类接口关系如上图：\n\n常见的负载均衡算法：\n\n 1. com.netflix.loadbalancer.RoundRobinRule：轮询**（默认）**\n 2. com.netflix.loadbalancer.RandomRule：随机\n 3. com.netflix.loadbalancer.RetryRule：先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务\n 4. WeightedResponseTimeRule：对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择\n 5. BestAvailableRule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务\n 6. AvailabilityFilteringRule：先过滤掉故障实例，再选择并发较小的实例\n 7. ZoneAvoidanceRule：默认规则,复合判断server所在区域的性能和server的可用性选择服务器\n\n\n# 6.切换其他负载均衡算法\n\n修改cloud-consumer-order80客户端\n\n切换为其他负载均衡算法，注意自定义的配置类不要被@ComponentScan扫描，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了。\n\n新建包名com.wcy.myrule\n\n\n\n新建MySelfRule规则类\n\npackage com.wcy.myrule;\n\nimport com.netflix.loadbalancer.IRule;\nimport com.netflix.loadbalancer.RandomRule;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @auther zzyy\n * @create 2020-02-02 14:31\n */\n@Configuration\npublic class MySelfRule\n{\n    @Bean\n    public IRule myRule()\n    {\n        return new RandomRule();//定义为随机\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n主启动类添加@RibbonClient,注意name指的是后端多个服务的名字,这样客户端80访问后端消费者服务就会走我们定义的负载均衡方法。\n\n\n\npackage com.wcy.springcloud;\n\nimport com.atguigu.myrule.MySelfRule;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\nimport org.springframework.cloud.netflix.ribbon.RibbonClient;\n\n/**\n * @auther zzyy\n * @create 2020-01-28 16:18\n * 在启动该微服务的时候就能去加载我们的自定义Ribbon配置类，从而使配置生效，形如：\n */\n@SpringBootApplication\n@EnableEurekaClient\n@RibbonClient(name = "CLOUD-PAYMENT-SERVICE",configuration=MySelfRule.class)\npublic class OrderMain80\n{\n    public static void main(String[] args)\n    {\n        SpringApplication.run(OrderMain80.class,args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 7.Ribbon负载均衡使用原理\n\n轮询的原理：通过请求次数取余服务总数即可实现\n\n负载均衡算法：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标  ，每次服务重启动后rest接口计数从1开始。\n \nList<ServiceInstance> instances = discoveryClient.getInstances("CLOUD-PAYMENT-SERVICE");\n \n如：  List [0] instances = 127.0.0.1:8002\n　　　List [1] instances = 127.0.0.1:8001\n \n8001+ 8002 组合成为集群，它们共计2台机器，集群总数为2， 按照轮询算法原理：\n \n当总请求数为1时： 1 % 2 =1 对应下标位置为1 ，则获得服务地址为127.0.0.1:8001\n当总请求数位2时： 2 % 2 =0 对应下标位置为0 ，则获得服务地址为127.0.0.1:8002\n当总请求数位3时： 3 % 2 =1 对应下标位置为1 ，则获得服务地址为127.0.0.1:8001\n当总请求数位4时： 4 % 2 =0 对应下标位置为0 ，则获得服务地址为127.0.0.1:8002\n如此类推......\n\n若服务器重启，则重新从1开始\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 8.Ribbon实现负载均衡的源码\n\n轮询算法的源码解析\n\npackage com.netflix.loadbalancer;\n\nimport com.netflix.client.config.IClientConfig;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n*轮询的实现源码\n**/\npublic class RoundRobinRule extends AbstractLoadBalancerRule {\n    private AtomicInteger nextServerCyclicCounter; //核心，请求的次数，是个原子类\n    private static final boolean AVAILABLE_ONLY_SERVERS = true;\n    private static final boolean ALL_SERVERS = false;\n    private static Logger log = LoggerFactory.getLogger(RoundRobinRule.class);\n\n    public RoundRobinRule() {\n        this.nextServerCyclicCounter = new AtomicInteger(0);\n    }\n\n    public RoundRobinRule(ILoadBalancer lb) {\n        this();\n        this.setLoadBalancer(lb);\n    }\n\n    public Server choose(ILoadBalancer lb, Object key) {\n        if (lb == null) {\n            log.warn("no load balancer");\n            return null;\n        } else {\n            Server server = null;\n            int count = 0;\n\n            while(true) {\n                if (server == null && count++ < 10) {\n                    List<Server> reachableServers = lb.getReachableServers();//查询健康的总服务\n                    List<Server> allServers = lb.getAllServers();//获取所有的服务\n                    int upCount = reachableServers.size();\n                    int serverCount = allServers.size();\n                    if (upCount != 0 && serverCount != 0) {\n                        int nextServerIndex = this.incrementAndGetModulo(serverCount);//轮询的核心\n                        server = (Server)allServers.get(nextServerIndex);//得到下标以后返回服务\n                        if (server == null) {\n                            Thread.yield();\n                        } else {\n                            if (server.isAlive() && server.isReadyToServe()) {\n                                return server;\n                            }\n\n                            server = null;\n                        }\n                        continue;\n                    }\n\n                    log.warn("No up servers available from load balancer: " + lb);\n                    return null;\n                }\n\n                if (count >= 10) {\n                    log.warn("No available alive servers after 10 tries from load balancer: " + lb);\n                }\n\n                return server;\n            }\n        }\n    }\n\n\t//轮询的核心\n    private int incrementAndGetModulo(int modulo) {\n        int current;\n        int next;\n        do {\n            current = this.nextServerCyclicCounter.get();//获取当前请求的次数\n            next = (current + 1) % modulo; //取余获得当前下标\n        } while(!this.nextServerCyclicCounter.compareAndSet(current, next)); //CAS选择与替换，当前值与原来的值是否一致，不一致则自旋获取；\n\n        return next;\n    }\n\n    public Server choose(Object key) {\n        return this.choose(this.getLoadBalancer(), key);\n    }\n\n    public void initWithNiwsConfig(IClientConfig clientConfig) {\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 9.手写自定义负载均衡算法\n\n 1. 关闭@LoadBalanced注解，使用自定义的负载均衡算法\n    \n    @Configuration\n    public class ApplicationContextConfig\n    {\n        @Bean\n    //    @LoadBalanced//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力\n        public RestTemplate getRestTemplate()\n        {\n            return new RestTemplate();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 2. 自定义负载均衡接口\n    \n    package com.wcy.springcloud.lb;\n    \n    import org.springframework.cloud.client.ServiceInstance;\n    \n    import java.util.List;\n    \n    /**\n     * 自定义负载均衡接口，返回后端实例\n     */\n    public interface IMyLoadBalancer {\n        public ServiceInstance getInstace(List<ServiceInstance> serviceInstanceList);\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 3. 实现\n    \n    package com.wcy.springcloud.lb.impl;\n    \n    import com.wcy.springcloud.lb.IMyLoadBalancer;\n    import org.springframework.cloud.client.ServiceInstance;\n    import org.springframework.stereotype.Component;\n    \n    import java.util.List;\n    import java.util.concurrent.atomic.AtomicInteger;\n    \n    /**\n     * 负载均衡算法：\n     * 轮询参考 RoundRobinRule类\n     */\n    @Component\n    public class MyLoadBalancer implements IMyLoadBalancer {\n    \n        AtomicInteger atomicInteger=new AtomicInteger(0);//请求次数\n    \n        /**\n         * 获取下次的请求次数\n         * @return\n         */\n        public final int getCountAndIncr(){\n            int current,next;\n            do {\n                current=this.atomicInteger.get();//获取当前的请求次数\n                next=(current >= Integer.MAX_VALUE )?0:current+1; //注意这里不是current++\n            }while (!this.atomicInteger.compareAndSet(current,next));\n            System.out.println("当前请求次数："+next);\n            return next;\n        }\n    \n    \n        @Override\n        public ServiceInstance getInstace(List<ServiceInstance> serviceInstanceList) {\n            int count = this.getCountAndIncr();//得到请求次数\n            int index = count % serviceInstanceList.size();//取余获得后端服务小标 再get获取到服务\n            return serviceInstanceList.get(index);\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    \n\n 4. 客户端调用\n    \n        @GetMapping("/consumer/payment/port")\n        public String getPort(){\n        \t//通过后端服务名获取到所有服务器\n            List<ServiceInstance> instances = discoveryClient.getInstances("CLOUD-PAYMENT-SERVICE");\n            ServiceInstance instace = myLoadBalancer.getInstace(instances);//获取当前轮询服务\n            URI uri = instace.getUri();\n            return restTemplate.getForObject(uri + "/payment/port", String.class);\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    ',normalizedContent:'# ribbon负载均衡\n\n\n# 1.什么是负载均衡(load balance)\n\n简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的ha（高可用）。 常见的负载均衡有软件nginx，lvs，硬件 f5等。\n\nribbon本地负载均衡客户端 vs nginx服务端负载均衡区别： nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。\n\nribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到jvm本地，从而在本地实现rpc远程服务调用技术。\n\n简单的说：比如一个医院病人看病，通过nginx转发到某个科室，比如口腔科、骨科等等，然后再通过本地负载均衡派发到某个医生。\n\n\n# 1.1.集中式lb和进程内lb\n\n集中式lb：即在服务的消费方和提供方之间使用独立的lb设施(可以是硬件，如f5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；\n\n进程内lb：将lb逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。\n\nribbon就属于进程内lb，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。\n\n\n# 2.什么是ribbon\n\nspring cloud ribbon是基于netflix ribbon实现的一套客户端负载均衡的工具。\n\n> 简单的说，ribbon是netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出load balancer（简称lb）后面所有的机器，ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用ribbon实现自定义的负载均衡算法。\n\n\n# 3.未来替换的产品\n\n由于ribbon已经停止更新，springcloud社区正在逐步使用spring cloud loadbalacer替换ribbon，但是由于ribbonn功能强大，暂时还未替换。\n\n\n# 4.springcloud使用ribbon\n\n# 4.1.引入pom文件\n\n由于引入了spring-cloud-starter-netflix-eureka-client，该组件已经帮我们引入了ribbon，所以不需要引入多余的。\n\n\x3c!--eureka-client--\x3e\n<dependency>\n    <groupid>org.springframework.cloud</groupid>\n    <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n</dependency>\neureka-client已经引入了ribbon，不需要引入\n<dependency>\n    <groupid>org.springframework.cloud</groupid>\n    <artifactid>spring-cloud-starter-netflix-ribbon</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n# 4.2.引入resttempelet\n\npackage com.wcy.springcloud.config;\n\nimport org.springframework.cloud.client.loadbalancer.loadbalanced;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.web.client.resttemplate;\n\n/**\n * @auther zzyy\n * @create 2020-02-18 17:27\n */\n@configuration\npublic class applicationcontextconfig\n{\n    @bean\n    @loadbalanced//使用@loadbalanced注解赋予resttemplate负载均衡的能力\n    public resttemplate getresttemplate()\n    {\n        return new resttemplate();\n    }\n}\n//applicationcontext.xml <bean id="" class="">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 4.3.controller使用\n\n使用resttemplate的getforobject、getforentity和postforobject、postforentity方法\n\n# 4.3.1.getforobject、getforentity的区别\n\ngetforobject：返回对象为响应体中数据转化成的对象，基本上可以理解为json\n\ngetforentity：返回对象为responseentity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等\n\n    @getmapping("/consumer/payment/{id:\\\\d*}")\n    //commentresult<payment> 前端消费者应该声明返回的类型\n    public commentresult<payment> create(@pathvariable("id") long id){\n        return resttemplate.getforobject(pament_url+"/payment/"+id,commentresult.class);\n    }\n\n    @getmapping("/consumer/payment/entity/{id:\\\\d*}")\n    //commentresult<payment> 前端消费者应该声明返回的类型\n    public commentresult<payment> create2(@pathvariable("id") long id){\n        responseentity<commentresult> forentity = resttemplate.getforentity(pament_url + "/payment/" + id, commentresult.class);\n        if(forentity.getstatuscode().is2xxsuccessful()){\n            return forentity.getbody();\n        }else{\n            return new commentresult<>(400,"服务器错误");\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 5.常见轮询算法\n\n\n\nribbon实现负载均衡算法的类接口关系如上图：\n\n常见的负载均衡算法：\n\n 1. com.netflix.loadbalancer.roundrobinrule：轮询**（默认）**\n 2. com.netflix.loadbalancer.randomrule：随机\n 3. com.netflix.loadbalancer.retryrule：先按照roundrobinrule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务\n 4. weightedresponsetimerule：对roundrobinrule的扩展，响应速度越快的实例选择权重越大，越容易被选择\n 5. bestavailablerule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务\n 6. availabilityfilteringrule：先过滤掉故障实例，再选择并发较小的实例\n 7. zoneavoidancerule：默认规则,复合判断server所在区域的性能和server的可用性选择服务器\n\n\n# 6.切换其他负载均衡算法\n\n修改cloud-consumer-order80客户端\n\n切换为其他负载均衡算法，注意自定义的配置类不要被@componentscan扫描，否则我们自定义的这个配置类就会被所有的ribbon客户端所共享，达不到特殊化定制的目的了。\n\n新建包名com.wcy.myrule\n\n\n\n新建myselfrule规则类\n\npackage com.wcy.myrule;\n\nimport com.netflix.loadbalancer.irule;\nimport com.netflix.loadbalancer.randomrule;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\n/**\n * @auther zzyy\n * @create 2020-02-02 14:31\n */\n@configuration\npublic class myselfrule\n{\n    @bean\n    public irule myrule()\n    {\n        return new randomrule();//定义为随机\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n主启动类添加@ribbonclient,注意name指的是后端多个服务的名字,这样客户端80访问后端消费者服务就会走我们定义的负载均衡方法。\n\n\n\npackage com.wcy.springcloud;\n\nimport com.atguigu.myrule.myselfrule;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.cloud.netflix.eureka.enableeurekaclient;\nimport org.springframework.cloud.netflix.ribbon.ribbonclient;\n\n/**\n * @auther zzyy\n * @create 2020-01-28 16:18\n * 在启动该微服务的时候就能去加载我们的自定义ribbon配置类，从而使配置生效，形如：\n */\n@springbootapplication\n@enableeurekaclient\n@ribbonclient(name = "cloud-payment-service",configuration=myselfrule.class)\npublic class ordermain80\n{\n    public static void main(string[] args)\n    {\n        springapplication.run(ordermain80.class,args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 7.ribbon负载均衡使用原理\n\n轮询的原理：通过请求次数取余服务总数即可实现\n\n负载均衡算法：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标  ，每次服务重启动后rest接口计数从1开始。\n \nlist<serviceinstance> instances = discoveryclient.getinstances("cloud-payment-service");\n \n如：  list [0] instances = 127.0.0.1:8002\n　　　list [1] instances = 127.0.0.1:8001\n \n8001+ 8002 组合成为集群，它们共计2台机器，集群总数为2， 按照轮询算法原理：\n \n当总请求数为1时： 1 % 2 =1 对应下标位置为1 ，则获得服务地址为127.0.0.1:8001\n当总请求数位2时： 2 % 2 =0 对应下标位置为0 ，则获得服务地址为127.0.0.1:8002\n当总请求数位3时： 3 % 2 =1 对应下标位置为1 ，则获得服务地址为127.0.0.1:8001\n当总请求数位4时： 4 % 2 =0 对应下标位置为0 ，则获得服务地址为127.0.0.1:8002\n如此类推......\n\n若服务器重启，则重新从1开始\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 8.ribbon实现负载均衡的源码\n\n轮询算法的源码解析\n\npackage com.netflix.loadbalancer;\n\nimport com.netflix.client.config.iclientconfig;\nimport java.util.list;\nimport java.util.concurrent.atomic.atomicinteger;\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\n\n/**\n*轮询的实现源码\n**/\npublic class roundrobinrule extends abstractloadbalancerrule {\n    private atomicinteger nextservercycliccounter; //核心，请求的次数，是个原子类\n    private static final boolean available_only_servers = true;\n    private static final boolean all_servers = false;\n    private static logger log = loggerfactory.getlogger(roundrobinrule.class);\n\n    public roundrobinrule() {\n        this.nextservercycliccounter = new atomicinteger(0);\n    }\n\n    public roundrobinrule(iloadbalancer lb) {\n        this();\n        this.setloadbalancer(lb);\n    }\n\n    public server choose(iloadbalancer lb, object key) {\n        if (lb == null) {\n            log.warn("no load balancer");\n            return null;\n        } else {\n            server server = null;\n            int count = 0;\n\n            while(true) {\n                if (server == null && count++ < 10) {\n                    list<server> reachableservers = lb.getreachableservers();//查询健康的总服务\n                    list<server> allservers = lb.getallservers();//获取所有的服务\n                    int upcount = reachableservers.size();\n                    int servercount = allservers.size();\n                    if (upcount != 0 && servercount != 0) {\n                        int nextserverindex = this.incrementandgetmodulo(servercount);//轮询的核心\n                        server = (server)allservers.get(nextserverindex);//得到下标以后返回服务\n                        if (server == null) {\n                            thread.yield();\n                        } else {\n                            if (server.isalive() && server.isreadytoserve()) {\n                                return server;\n                            }\n\n                            server = null;\n                        }\n                        continue;\n                    }\n\n                    log.warn("no up servers available from load balancer: " + lb);\n                    return null;\n                }\n\n                if (count >= 10) {\n                    log.warn("no available alive servers after 10 tries from load balancer: " + lb);\n                }\n\n                return server;\n            }\n        }\n    }\n\n\t//轮询的核心\n    private int incrementandgetmodulo(int modulo) {\n        int current;\n        int next;\n        do {\n            current = this.nextservercycliccounter.get();//获取当前请求的次数\n            next = (current + 1) % modulo; //取余获得当前下标\n        } while(!this.nextservercycliccounter.compareandset(current, next)); //cas选择与替换，当前值与原来的值是否一致，不一致则自旋获取；\n\n        return next;\n    }\n\n    public server choose(object key) {\n        return this.choose(this.getloadbalancer(), key);\n    }\n\n    public void initwithniwsconfig(iclientconfig clientconfig) {\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 9.手写自定义负载均衡算法\n\n 1. 关闭@loadbalanced注解，使用自定义的负载均衡算法\n    \n    @configuration\n    public class applicationcontextconfig\n    {\n        @bean\n    //    @loadbalanced//使用@loadbalanced注解赋予resttemplate负载均衡的能力\n        public resttemplate getresttemplate()\n        {\n            return new resttemplate();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 2. 自定义负载均衡接口\n    \n    package com.wcy.springcloud.lb;\n    \n    import org.springframework.cloud.client.serviceinstance;\n    \n    import java.util.list;\n    \n    /**\n     * 自定义负载均衡接口，返回后端实例\n     */\n    public interface imyloadbalancer {\n        public serviceinstance getinstace(list<serviceinstance> serviceinstancelist);\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 3. 实现\n    \n    package com.wcy.springcloud.lb.impl;\n    \n    import com.wcy.springcloud.lb.imyloadbalancer;\n    import org.springframework.cloud.client.serviceinstance;\n    import org.springframework.stereotype.component;\n    \n    import java.util.list;\n    import java.util.concurrent.atomic.atomicinteger;\n    \n    /**\n     * 负载均衡算法：\n     * 轮询参考 roundrobinrule类\n     */\n    @component\n    public class myloadbalancer implements imyloadbalancer {\n    \n        atomicinteger atomicinteger=new atomicinteger(0);//请求次数\n    \n        /**\n         * 获取下次的请求次数\n         * @return\n         */\n        public final int getcountandincr(){\n            int current,next;\n            do {\n                current=this.atomicinteger.get();//获取当前的请求次数\n                next=(current >= integer.max_value )?0:current+1; //注意这里不是current++\n            }while (!this.atomicinteger.compareandset(current,next));\n            system.out.println("当前请求次数："+next);\n            return next;\n        }\n    \n    \n        @override\n        public serviceinstance getinstace(list<serviceinstance> serviceinstancelist) {\n            int count = this.getcountandincr();//得到请求次数\n            int index = count % serviceinstancelist.size();//取余获得后端服务小标 再get获取到服务\n            return serviceinstancelist.get(index);\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    \n\n 4. 客户端调用\n    \n        @getmapping("/consumer/payment/port")\n        public string getport(){\n        \t//通过后端服务名获取到所有服务器\n            list<serviceinstance> instances = discoveryclient.getinstances("cloud-payment-service");\n            serviceinstance instace = myloadbalancer.getinstace(instances);//获取当前轮询服务\n            uri uri = instace.geturi();\n            return resttemplate.getforobject(uri + "/payment/port", string.class);\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    ',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"OpenFeign",frontmatter:{title:"OpenFeign",date:"2021-08-17T09:31:44.000Z",permalink:"/pages/7348c0/",categories:["后端","Spring全家桶","SpringCloud","OpenFeign"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/10.OpenFeign.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/10.OpenFeign.md",key:"v-b641931a",path:"/pages/7348c0/",headers:[{level:2,title:"一.OpenFeign",slug:"一-openfeign",normalizedTitle:"一.openfeign",charIndex:16},{level:3,title:"1.1.什么是OpenFeign",slug:"_1-1-什么是openfeign",normalizedTitle:"1.1.什么是openfeign",charIndex:32},{level:3,title:"1.2.Feign能干什么",slug:"_1-2-feign能干什么",normalizedTitle:"1.2.feign能干什么",charIndex:381},{level:3,title:"1.3.Feign和OpenFeign两者区别",slug:"_1-3-feign和openfeign两者区别",normalizedTitle:"1.3.feign和openfeign两者区别",charIndex:873},{level:2,title:"二.Cloud集成OpenFeign（注意openFeign用于客户端及消费端）",slug:"二-cloud集成openfeign-注意openfeign用于客户端及消费端",normalizedTitle:"二.cloud集成openfeign（注意openfeign用于客户端及消费端）",charIndex:1493},{level:3,title:"2.1核心：",slug:"_2-1核心",normalizedTitle:"2.1核心：",charIndex:1538},{level:3,title:"2.2搭建详细步骤",slug:"_2-2搭建详细步骤",normalizedTitle:"2.2搭建详细步骤",charIndex:1624},{level:2,title:"三.OpenFeign的超时控制",slug:"三-openfeign的超时控制",normalizedTitle:"三.openfeign的超时控制",charIndex:8210},{level:3,title:"3.2.演示超时故障",slug:"_3-2-演示超时故障",normalizedTitle:"3.2.演示超时故障",charIndex:8329},{level:3,title:"3.3.解决办法：",slug:"_3-3-解决办法",normalizedTitle:"3.3.解决办法：",charIndex:9997},{level:2,title:"四.OpenFeign日志输出",slug:"四-openfeign日志输出",normalizedTitle:"四.openfeign日志输出",charIndex:10420},{level:3,title:"4.1.feign的日志级别",slug:"_4-1-feign的日志级别",normalizedTitle:"4.1.feign的日志级别",charIndex:10524},{level:3,title:"4.2.配置日志级别为FULL",slug:"_4-2-配置日志级别为full",normalizedTitle:"4.2.配置日志级别为full",charIndex:10688}],headersStr:"一.OpenFeign 1.1.什么是OpenFeign 1.2.Feign能干什么 1.3.Feign和OpenFeign两者区别 二.Cloud集成OpenFeign（注意openFeign用于客户端及消费端） 2.1核心： 2.2搭建详细步骤 三.OpenFeign的超时控制 3.2.演示超时故障 3.3.解决办法： 四.OpenFeign日志输出 4.1.feign的日志级别 4.2.配置日志级别为FULL",content:'# OpenFeign\n\n\n# 一.OpenFeign\n\n\n# 1.1.什么是OpenFeign\n\n官网解释： https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign\n\nFeign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。 它的使用方法是定义一个服务接口然后在上面添加注解(类似与Mapper接口操作数据库)。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。\n\n\n# 1.2.Feign能干什么\n\nFeign旨在使编写Java Http客户端变得更容易。 前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。**但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。**所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。\n\nFeign集成了Ribbon 利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用\n\n\n# 1.3.Feign和OpenFeign两者区别\n\n> Feign已经停止更新，所有推荐使用OpenFeign\n\nFEIGN                                                                                     OPENFEIGN\nFeign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端                                              OpenFeign是Spring Cloud\nFeign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务   在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。\nspring-cloud-starter-feign                                                                spring-cloud-starter-openfeign\n\n\n# 二.Cloud集成OpenFeign（注意openFeign用于客户端及消费端）\n\n\n# 2.1核心：\n\n 1. 启动类开启注解\n 2. 编写feign接口，开启注解，指定后端服务名\n 3. feign接口同后端服务接口controller方法一致即可\n\n\n# 2.2搭建详细步骤\n\n 1. 新建mondle：cloud-consumer-feign-order80\n\n 2. 引入pom文件\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <project xmlns="http://maven.apache.org/POM/4.0.0"\n             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n        <parent>\n            <artifactId>CloudStudy</artifactId>\n            <groupId>com.wcy.springcloud</groupId>\n            <version>1.0-SNAPSHOT</version>\n        </parent>\n        <modelVersion>4.0.0</modelVersion>\n    \n        <artifactId>cloud-consumer-feign-order80</artifactId>\n    \n        <dependencies>\n            \x3c!--openfeign--\x3e\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-openfeign</artifactId>\n            </dependency>\n            \x3c!--eureka client--\x3e\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n            </dependency>\n            \x3c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\x3e\n            <dependency>\n                <groupId>com.wcy.springcloud</groupId>\n                <artifactId>cloud-api-commons</artifactId>\n                <version>1.0-SNAPSHOT</version>\n            </dependency>\n            \x3c!--web--\x3e\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-web</artifactId>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-actuator</artifactId>\n            </dependency>\n            \x3c!--一般基础通用配置--\x3e\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-devtools</artifactId>\n                <scope>runtime</scope>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.projectlombok</groupId>\n                <artifactId>lombok</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-test</artifactId>\n                <scope>test</scope>\n            </dependency>\n        </dependencies>\n    </project>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    \n\n 3. 编写yml文件\n    \n    server:\n      port: 80\n    \n    eureka:\n      client:\n        register-with-eureka: false  # 客户端就不注册入服务注册中心了\n        service-url:\n          defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 4. 编写启动类，//开启openFeign接口\n    \n    package com.wcy.springcloud;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.cloud.openfeign.EnableFeignClients;\n    \n    @SpringBootApplication\n    @EnableFeignClients  //开启openFeign接口\n    public class OrderFeignMain80 {\n        public static void main(String[] args) {\n            SpringApplication.run(OrderFeignMain80.class,args);\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n 5. 查看后端服务8001、8002的查询接口\n    \n        /**\n         * 8001、8002查询订单接口\n         * @return\n         */\n        @GetMapping("/payment/{id:\\\\d*}")\n        public CommentResult create(@PathVariable("id") Long id){\n            Payment payment = paymentService.getPaymentById(id);\n            log.info("**************查询结果："+id+"O(∩_∩)O哈哈~");\n            if(payment !=null){\n                return new CommentResult(200,"查询成功：serverPort"+serverPort,payment);\n            }else{\n                return new CommentResult(404,"查询失败，不存在ID="+id+"的数据",null);\n            }\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n    \n    编写feign接口：通常服务端controller有哪些方法，那么feign就应该提供哪些方法，与mapper文件类似\n    \n    记住@Component和@FeignClient注解，指定后端服务的服务名，默认OpenFeign会使用轮询的负载均衡算法来调用具体的服务实例，\n    \n    package com.wcy.springcloud.service;\n    \n    import com.wcy.springcloud.entities.CommentResult;\n    import com.wcy.springcloud.entities.Payment;\n    import org.springframework.cloud.openfeign.FeignClient;\n    import org.springframework.stereotype.Component;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.PathVariable;\n    \n    //直接复制后端controller里面的方法，但是要注意{id:\\\\d*}的接口，因为Feign会报错，需要去掉\n    @Component \n    @FeignClient(value = "cloud-payment-service") //openFeign接口\n    public interface PaymentFeignService {\n        @GetMapping("/payment/{id}")  \n        public CommentResult<Payment> selectPayment(@PathVariable("id") Long id);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 6. 客户点controller层的调用\n    \n    package com.wcy.springcloud.controller;\n    \n    import com.wcy.springcloud.entities.CommentResult;\n    import com.wcy.springcloud.entities.Payment;\n    import com.wcy.springcloud.service.PaymentFeignService;\n    import lombok.extern.slf4j.Slf4j;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.PathVariable;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    @RestController\n    @Slf4j\n    public class OrderController {\n        @Autowired\n        private PaymentFeignService paymentFeignService;\n    \n        @GetMapping("/consumer/payment/{id:\\\\d*}")\n        public CommentResult<Payment> selectPayment(@PathVariable("id") Long id){\n            return paymentFeignService.selectPayment(id); //调用openFeign接口\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    \n    \n    总结：\n    \n    \n\n\n# 三.OpenFeign的超时控制\n\n默认Feign客户端只等待一秒钟，超过后报错 ，但是服务端处理需要超过1秒钟，导致Feign客户端不想等待了，直接返回报错。 为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。\n\n\n# 3.2.演示超时故障\n\n 1. 8001后端服务休眠三秒\n    \n        /**\n         * 后端服务模拟休眠3秒\n         * @return\n         */\n        @GetMapping("/payment/feign/timeout")\n        public String getfeignPort(){\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return serverPort;\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 2. 80客户端fegin加上调用8001的方法\n    \n    @Component\n    @FeignClient(value = "cloud-payment-service") //openFeign接口\n    public interface PaymentFeignService {\n        @GetMapping("/payment/{id}")\n        public CommentResult<Payment> selectPayment(@PathVariable("id") Long id);\n    \n        @GetMapping("/payment/feign/timeout")\n        public String getfeignPort();\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 3. 80客户端调用\n    \n    @RestController\n    @Slf4j\n    public class OrderController {\n        @Autowired\n        private PaymentFeignService paymentFeignService;\n    \n        @GetMapping("/consumer/payment/{id:\\\\d*}")\n        public CommentResult<Payment> selectPayment(@PathVariable("id") Long id){\n            return paymentFeignService.selectPayment(id); //调用openFeign接口\n        }\n    \n        @GetMapping("/consumer/payment/feign/timeout")\n        public String getfeignPort(){\n            return paymentFeignService.getfeignPort();\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 4. 访问http://localhost/consumer/payment/feign/timeout地址报错信息如下\n    \n    \n\n\n# 3.3.解决办法：\n\n80客户端yml加上ribbon的配置\n\nserver:\n  port: 80\n\neureka:\n  client:\n    register-with-eureka: false  # 客户端就不注册入服务注册中心了\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/\n#设置feign客户端超时时间(OpenFeign默认支持ribbon)\nribbon:\n  #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间\n  ReadTimeout: 5000\n  #指的是建立连接后从服务器读取到可用资源所用的时间\n  ConnectTimeout: 5000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 四.OpenFeign日志输出\n\nFeign 提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http 请求的细节。 说白了就是对Feign接口的调用情况进行监控和输出\n\n\n# 4.1.feign的日志级别\n\n 1. NONE：默认的，不显示任何日志；\n 2. BASIC：仅记录请求方法、URL、响应状态码及执行时间；\n 3. HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息；\n 4. FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。\n\n\n# 4.2.配置日志级别为FULL\n\n 1. 加入feign配置类\n    \n    package com.wcy.springcloud.config;\n    \n    import feign.Logger;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    /**\n     * 配置feign的日志打印级别\n     */\n    @Configuration\n    public class FeignConfig\n    {\n        @Bean\n        Logger.Level feignLoggerLevel()\n        {\n            return Logger.Level.FULL;\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    \n\n 2. yml文件中配置\n    \n    #feign打印日志\n    logging:\n      level:\n        # feign日志以什么级别监控哪个接口   --监控哪个接口就配置哪个接口的路径\n        com.wcy.springcloud.service.PaymentFeignService: debug\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. 输出信息\n    \n    ',normalizedContent:'# openfeign\n\n\n# 一.openfeign\n\n\n# 1.1.什么是openfeign\n\n官网解释： https://cloud.spring.io/spring-cloud-static/hoxton.sr1/reference/htmlsingle/#spring-cloud-openfeign\n\nfeign是一个声明式webservice客户端。使用feign能让编写web service客户端更加简单。 它的使用方法是定义一个服务接口然后在上面添加注解(类似与mapper接口操作数据库)。feign也支持可拔插式的编码器和解码器。spring cloud对feign进行了封装，使其支持了spring mvc标准注解和httpmessageconverters。feign可以与eureka和ribbon组合使用以支持负载均衡。\n\n\n# 1.2.feign能干什么\n\nfeign旨在使编写java http客户端变得更容易。 前面在使用ribbon+resttemplate时，利用resttemplate对http请求的封装处理，形成了一套模版化的调用方法。**但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。**所以，feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是dao接口上面标注mapper注解,现在是一个微服务接口上面标注一个feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用spring cloud ribbon时，自动封装服务调用客户端的开发量。\n\nfeign集成了ribbon 利用ribbon维护了payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用\n\n\n# 1.3.feign和openfeign两者区别\n\n> feign已经停止更新，所有推荐使用openfeign\n\nfeign                                                                                     openfeign\nfeign是spring cloud组件中的一个轻量级restful的http服务客户端                                              openfeign是spring cloud\nfeign内置了ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。feign的使用方式是：使用feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务   在feign的基础上支持了springmvc的注解，如@requesmapping等等。openfeign的@feignclient可以解析springmvc的@requestmapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。\nspring-cloud-starter-feign                                                                spring-cloud-starter-openfeign\n\n\n# 二.cloud集成openfeign（注意openfeign用于客户端及消费端）\n\n\n# 2.1核心：\n\n 1. 启动类开启注解\n 2. 编写feign接口，开启注解，指定后端服务名\n 3. feign接口同后端服务接口controller方法一致即可\n\n\n# 2.2搭建详细步骤\n\n 1. 新建mondle：cloud-consumer-feign-order80\n\n 2. 引入pom文件\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <project xmlns="http://maven.apache.org/pom/4.0.0"\n             xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n             xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n        <parent>\n            <artifactid>cloudstudy</artifactid>\n            <groupid>com.wcy.springcloud</groupid>\n            <version>1.0-snapshot</version>\n        </parent>\n        <modelversion>4.0.0</modelversion>\n    \n        <artifactid>cloud-consumer-feign-order80</artifactid>\n    \n        <dependencies>\n            \x3c!--openfeign--\x3e\n            <dependency>\n                <groupid>org.springframework.cloud</groupid>\n                <artifactid>spring-cloud-starter-openfeign</artifactid>\n            </dependency>\n            \x3c!--eureka client--\x3e\n            <dependency>\n                <groupid>org.springframework.cloud</groupid>\n                <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n            </dependency>\n            \x3c!-- 引入自己定义的api通用包，可以使用payment支付entity --\x3e\n            <dependency>\n                <groupid>com.wcy.springcloud</groupid>\n                <artifactid>cloud-api-commons</artifactid>\n                <version>1.0-snapshot</version>\n            </dependency>\n            \x3c!--web--\x3e\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-web</artifactid>\n            </dependency>\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-actuator</artifactid>\n            </dependency>\n            \x3c!--一般基础通用配置--\x3e\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-devtools</artifactid>\n                <scope>runtime</scope>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupid>org.projectlombok</groupid>\n                <artifactid>lombok</artifactid>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-test</artifactid>\n                <scope>test</scope>\n            </dependency>\n        </dependencies>\n    </project>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    \n\n 3. 编写yml文件\n    \n    server:\n      port: 80\n    \n    eureka:\n      client:\n        register-with-eureka: false  # 客户端就不注册入服务注册中心了\n        service-url:\n          defaultzone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 4. 编写启动类，//开启openfeign接口\n    \n    package com.wcy.springcloud;\n    \n    import org.springframework.boot.springapplication;\n    import org.springframework.boot.autoconfigure.springbootapplication;\n    import org.springframework.cloud.openfeign.enablefeignclients;\n    \n    @springbootapplication\n    @enablefeignclients  //开启openfeign接口\n    public class orderfeignmain80 {\n        public static void main(string[] args) {\n            springapplication.run(orderfeignmain80.class,args);\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n 5. 查看后端服务8001、8002的查询接口\n    \n        /**\n         * 8001、8002查询订单接口\n         * @return\n         */\n        @getmapping("/payment/{id:\\\\d*}")\n        public commentresult create(@pathvariable("id") long id){\n            payment payment = paymentservice.getpaymentbyid(id);\n            log.info("**************查询结果："+id+"o(∩_∩)o哈哈~");\n            if(payment !=null){\n                return new commentresult(200,"查询成功：serverport"+serverport,payment);\n            }else{\n                return new commentresult(404,"查询失败，不存在id="+id+"的数据",null);\n            }\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n    \n    编写feign接口：通常服务端controller有哪些方法，那么feign就应该提供哪些方法，与mapper文件类似\n    \n    记住@component和@feignclient注解，指定后端服务的服务名，默认openfeign会使用轮询的负载均衡算法来调用具体的服务实例，\n    \n    package com.wcy.springcloud.service;\n    \n    import com.wcy.springcloud.entities.commentresult;\n    import com.wcy.springcloud.entities.payment;\n    import org.springframework.cloud.openfeign.feignclient;\n    import org.springframework.stereotype.component;\n    import org.springframework.web.bind.annotation.getmapping;\n    import org.springframework.web.bind.annotation.pathvariable;\n    \n    //直接复制后端controller里面的方法，但是要注意{id:\\\\d*}的接口，因为feign会报错，需要去掉\n    @component \n    @feignclient(value = "cloud-payment-service") //openfeign接口\n    public interface paymentfeignservice {\n        @getmapping("/payment/{id}")  \n        public commentresult<payment> selectpayment(@pathvariable("id") long id);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 6. 客户点controller层的调用\n    \n    package com.wcy.springcloud.controller;\n    \n    import com.wcy.springcloud.entities.commentresult;\n    import com.wcy.springcloud.entities.payment;\n    import com.wcy.springcloud.service.paymentfeignservice;\n    import lombok.extern.slf4j.slf4j;\n    import org.springframework.beans.factory.annotation.autowired;\n    import org.springframework.web.bind.annotation.getmapping;\n    import org.springframework.web.bind.annotation.pathvariable;\n    import org.springframework.web.bind.annotation.restcontroller;\n    \n    @restcontroller\n    @slf4j\n    public class ordercontroller {\n        @autowired\n        private paymentfeignservice paymentfeignservice;\n    \n        @getmapping("/consumer/payment/{id:\\\\d*}")\n        public commentresult<payment> selectpayment(@pathvariable("id") long id){\n            return paymentfeignservice.selectpayment(id); //调用openfeign接口\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    \n    \n    总结：\n    \n    \n\n\n# 三.openfeign的超时控制\n\n默认feign客户端只等待一秒钟，超过后报错 ，但是服务端处理需要超过1秒钟，导致feign客户端不想等待了，直接返回报错。 为了避免这样的情况，有时候我们需要设置feign客户端的超时控制。\n\n\n# 3.2.演示超时故障\n\n 1. 8001后端服务休眠三秒\n    \n        /**\n         * 后端服务模拟休眠3秒\n         * @return\n         */\n        @getmapping("/payment/feign/timeout")\n        public string getfeignport(){\n            try {\n                thread.sleep(3000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            return serverport;\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 2. 80客户端fegin加上调用8001的方法\n    \n    @component\n    @feignclient(value = "cloud-payment-service") //openfeign接口\n    public interface paymentfeignservice {\n        @getmapping("/payment/{id}")\n        public commentresult<payment> selectpayment(@pathvariable("id") long id);\n    \n        @getmapping("/payment/feign/timeout")\n        public string getfeignport();\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 3. 80客户端调用\n    \n    @restcontroller\n    @slf4j\n    public class ordercontroller {\n        @autowired\n        private paymentfeignservice paymentfeignservice;\n    \n        @getmapping("/consumer/payment/{id:\\\\d*}")\n        public commentresult<payment> selectpayment(@pathvariable("id") long id){\n            return paymentfeignservice.selectpayment(id); //调用openfeign接口\n        }\n    \n        @getmapping("/consumer/payment/feign/timeout")\n        public string getfeignport(){\n            return paymentfeignservice.getfeignport();\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 4. 访问http://localhost/consumer/payment/feign/timeout地址报错信息如下\n    \n    \n\n\n# 3.3.解决办法：\n\n80客户端yml加上ribbon的配置\n\nserver:\n  port: 80\n\neureka:\n  client:\n    register-with-eureka: false  # 客户端就不注册入服务注册中心了\n    service-url:\n      defaultzone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/\n#设置feign客户端超时时间(openfeign默认支持ribbon)\nribbon:\n  #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间\n  readtimeout: 5000\n  #指的是建立连接后从服务器读取到可用资源所用的时间\n  connecttimeout: 5000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 四.openfeign日志输出\n\nfeign 提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 feign 中 http 请求的细节。 说白了就是对feign接口的调用情况进行监控和输出\n\n\n# 4.1.feign的日志级别\n\n 1. none：默认的，不显示任何日志；\n 2. basic：仅记录请求方法、url、响应状态码及执行时间；\n 3. headers：除了 basic 中定义的信息之外，还有请求和响应的头信息；\n 4. full：除了 headers 中定义的信息之外，还有请求和响应的正文及元数据。\n\n\n# 4.2.配置日志级别为full\n\n 1. 加入feign配置类\n    \n    package com.wcy.springcloud.config;\n    \n    import feign.logger;\n    import org.springframework.context.annotation.bean;\n    import org.springframework.context.annotation.configuration;\n    \n    /**\n     * 配置feign的日志打印级别\n     */\n    @configuration\n    public class feignconfig\n    {\n        @bean\n        logger.level feignloggerlevel()\n        {\n            return logger.level.full;\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    \n\n 2. yml文件中配置\n    \n    #feign打印日志\n    logging:\n      level:\n        # feign日志以什么级别监控哪个接口   --监控哪个接口就配置哪个接口的路径\n        com.wcy.springcloud.service.paymentfeignservice: debug\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. 输出信息\n    \n    ',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"config全局配置",frontmatter:{title:"config全局配置",date:"2021-08-20T16:05:33.000Z",permalink:"/pages/fa46ca/",categories:["后端","Spring全家桶","SpringCloud"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/13.config%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/13.config全局配置.md",key:"v-e39894f0",path:"/pages/fa46ca/",headers:[{level:2,title:"1.分布式配置存在的问题",slug:"_1-分布式配置存在的问题",normalizedTitle:"1.分布式配置存在的问题",charIndex:127},{level:2,title:"2.SpringCloud Config是什么",slug:"_2-springcloud-config是什么",normalizedTitle:"2.springcloud config是什么",charIndex:326},{level:2,title:"3.能干嘛",slug:"_3-能干嘛",normalizedTitle:"3.能干嘛",charIndex:434},{level:2,title:"4.config与github整合",slug:"_4-config与github整合",normalizedTitle:"4.config与github整合",charIndex:631},{level:2,title:"5.Config服务端配置与测试",slug:"_5-config服务端配置与测试",normalizedTitle:"5.config服务端配置与测试",charIndex:744},{level:3,title:"1.准备工作",slug:"_1-准备工作",normalizedTitle:"1.准备工作",charIndex:765},{level:3,title:"2.新建模块：cloud-config-center-3344",slug:"_2-新建模块-cloud-config-center-3344",normalizedTitle:"2.新建模块：cloud-config-center-3344",charIndex:919},{level:3,title:"3.导入依赖",slug:"_3-导入依赖",normalizedTitle:"3.导入依赖",charIndex:955},{level:3,title:"4.引入yml",slug:"_4-引入yml",normalizedTitle:"4.引入yml",charIndex:2940},{level:3,title:"5.主启动类",slug:"_5-主启动类",normalizedTitle:"5.主启动类",charIndex:3544},{level:3,title:"6.测试",slug:"_6-测试",normalizedTitle:"6.测试",charIndex:4007},{level:2,title:"6.config客户端配置与测试",slug:"_6-config客户端配置与测试",normalizedTitle:"6.config客户端配置与测试",charIndex:4409},{level:3,title:"1.新建模块cloud-config-client-3355",slug:"_1-新建模块cloud-config-client-3355",normalizedTitle:"1.新建模块cloud-config-client-3355",charIndex:4430},{level:3,title:"2.导入依赖",slug:"_2-导入依赖",normalizedTitle:"2.导入依赖",charIndex:4465},{level:3,title:"3.修改配置文件",slug:"_3-修改配置文件",normalizedTitle:"3.修改配置文件",charIndex:6542},{level:3,title:"4.主启动类",slug:"_4-主启动类",normalizedTitle:"4.主启动类",charIndex:7588},{level:3,title:"5.业务类",slug:"_5-业务类",normalizedTitle:"5.业务类",charIndex:8059},{level:3,title:"6.测试",slug:"_6-测试-2",normalizedTitle:"6.测试",charIndex:4007},{level:3,title:"问题：",slug:"问题",normalizedTitle:"问题：",charIndex:8716},{level:2,title:"7.Config客户端之动态刷新",slug:"_7-config客户端之动态刷新",normalizedTitle:"7.config客户端之动态刷新",charIndex:8790},{level:3,title:"1.pom中引入依赖",slug:"_1-pom中引入依赖",normalizedTitle:"1.pom中引入依赖",charIndex:8825},{level:3,title:"2.修改bootstrap.yml文件",slug:"_2-修改bootstrap-yml文件",normalizedTitle:"2.修改bootstrap.yml文件",charIndex:8989},{level:3,title:"3.业务层controller增加注解",slug:"_3-业务层controller增加注解",normalizedTitle:"3.业务层controller增加注解",charIndex:9614},{level:3,title:"4.关键一步",slug:"_4-关键一步",normalizedTitle:"4.关键一步",charIndex:10128}],headersStr:"1.分布式配置存在的问题 2.SpringCloud Config是什么 3.能干嘛 4.config与github整合 5.Config服务端配置与测试 1.准备工作 2.新建模块：cloud-config-center-3344 3.导入依赖 4.引入yml 5.主启动类 6.测试 6.config客户端配置与测试 1.新建模块cloud-config-client-3355 2.导入依赖 3.修改配置文件 4.主启动类 5.业务类 6.测试 问题： 7.Config客户端之动态刷新 1.pom中引入依赖 2.修改bootstrap.yml文件 3.业务层controller增加注解 4.关键一步",content:'# SpringCloud Config分布式配置中心\n\nhttps://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/\n\n\n# 1.分布式配置存在的问题\n\n微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。\n\nSpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理......\n\n\n# 2.SpringCloud Config是什么\n\n\n\nSpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。\n\n\n# 3.能干嘛\n\n 1. 集中管理配置文件\n 2. 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release\n 3. 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息\n 4. 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置\n 5. 将配置信息以REST接口的形式暴露\n\n\n# 4.config与github整合\n\n由于SpringCloud Config默认使用Git来存储配置文件(也有其它方式,比如支持SVN和本地文件)， 但最推荐的还是Git，而且使用的是http/https访问的形式\n\n\n# 5.Config服务端配置与测试\n\n\n# 1.准备工作\n\n1.用你自己的账号在GitHub上新建一个名为springcloud-config的新Repository\n\n2.clone到本地，创建三个配置文件，内容随意。\n\nconfig:\n    info: "springcloud config-dev，version=1"\n\n\n1\n2\n\n\n\n# 2.新建模块：cloud-config-center-3344\n\n\n# 3.导入依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloud-config-center-3344</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-config-server</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 4.引入yml\n\n * uri：github地址\n * search-paths：仓库名\n * label：主分支\n\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://gitee.com/wcy_dch/springcloud-config.git #GitHub上面的git仓库名字\n          ####搜索目录\n          search-paths:\n            - springcloud-config\n      ####读取分支\n      label: master\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 5.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.config.server.EnableConfigServer;\n\n@SpringBootApplication\n@EnableConfigServer\npublic class ConfigCenterMain3344 {\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigCenterMain3344.class,args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 6.测试\n\n1.启动eureka7001、eureka7002\n\n2.启动config3344\n\n访问url方式：\n\n 1. /{label}/{application}-{profile}.yml：\n 2. /{application}-{profile}.yml：\n 3. /{application}/{profile}[/{label}]：访问的json串\n\nlabel：分支(branch) name ：服务名 profiles：环境(dev/test/prod)\n\n3.访问地址：\n\n方式一：http://localhost:3344/master/config-dev.yml 指定分支\n\n方式二：http://localhost:3344/config-dev.yml 默认访问主分支\n\n方式三：http://localhost:3344/config/dev/master\n\n\n\n\n# 6.config客户端配置与测试\n\n\n# 1.新建模块cloud-config-client-3355\n\n\n# 2.导入依赖\n\n客户端的依赖是spring-cloud-starter-config，服务端是spring-cloud-starter-config-server\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloud-config-client-3355</artifactId>\n    \n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-config</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# 3.修改配置文件\n\n这次使用bootstrap.yml配置文件：\n\n> applicaiton.yml是用户级的资源配置项 bootstrap.yml是系统级的，优先级更加高\n> \n> Spring Cloud会创建一个“Bootstrap Context”，作为Spring应用的Application Context的父上下文。初始化的时候，Bootstrap Context负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment。\n> \n> Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。 Bootstrap context和Application Context有着不同的约定，所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离。\n> \n> 要将Client模块下的application.yml文件改为bootstrap.yml,这是很关键的， 因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml\n\nbootstrap.yml内容：\n\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\n\n@SpringBootApplication\n@EnableEurekaClient\npublic class ConfigClientMain3355 {\n    public static void main(String[] args)\n    {\n        SpringApplication.run(ConfigClientMain3355.class,args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 5.业务类\n\npackage com.wcy.springcloud.controller;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class CofigController {\n    @Value("${config.info}")\n    private String configInfo;\n\n    @GetMapping("/config/info")\n    public String config(){\n        return configInfo;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 6.测试\n\n1.启动Eureka7001、Eureka7001、3344、3355\n\n通过3355访问3344的中心配置：访问：http://localhost:3355/config/info\n\n\n# 问题：\n\n> 问题随时而来，分布式配置的动态刷新问题，修改github上面的配置文件信息，3344可以动态刷新，但是3355不能动态刷新。\n\n\n# 7.Config客户端之动态刷新\n\n修改微服务3355的配置\n\n\n# 1.pom中引入依赖\n\n \n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.修改bootstrap.yml文件\n\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n# 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: "*"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 3.业务层controller增加注解\n\npackage com.wcy.springcloud.controller;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RefreshScope\npublic class CofigController {\n    @Value("${config.info}")\n    private String configInfo;\n\n    @GetMapping("/config/info")\n    public String config(){\n        return configInfo;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 4.关键一步\n\n修改git仓库的内容后，3344可以正常更新，3355必须要运维人员发送一个post刷新请求即可。\n\n方式一：\n\n通过cmd命令的方式：curl -X POST http://localhost:3355/actuator/refresh\n\n方式二：\n\n使用post发起post请求：curl -X POST http://localhost:3355/actuator/refresh',normalizedContent:'# springcloud config分布式配置中心\n\nhttps://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.release/reference/html/\n\n\n# 1.分布式配置存在的问题\n\n微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。\n\nspringcloud提供了configserver来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理......\n\n\n# 2.springcloud config是什么\n\n\n\nspringcloud config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。\n\n\n# 3.能干嘛\n\n 1. 集中管理配置文件\n 2. 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release\n 3. 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息\n 4. 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置\n 5. 将配置信息以rest接口的形式暴露\n\n\n# 4.config与github整合\n\n由于springcloud config默认使用git来存储配置文件(也有其它方式,比如支持svn和本地文件)， 但最推荐的还是git，而且使用的是http/https访问的形式\n\n\n# 5.config服务端配置与测试\n\n\n# 1.准备工作\n\n1.用你自己的账号在github上新建一个名为springcloud-config的新repository\n\n2.clone到本地，创建三个配置文件，内容随意。\n\nconfig:\n    info: "springcloud config-dev，version=1"\n\n\n1\n2\n\n\n\n# 2.新建模块：cloud-config-center-3344\n\n\n# 3.导入依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloud-config-center-3344</artifactid>\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-config-server</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 4.引入yml\n\n * uri：github地址\n * search-paths：仓库名\n * label：主分支\n\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://gitee.com/wcy_dch/springcloud-config.git #github上面的git仓库名字\n          ####搜索目录\n          search-paths:\n            - springcloud-config\n      ####读取分支\n      label: master\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 5.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.cloud.config.server.enableconfigserver;\n\n@springbootapplication\n@enableconfigserver\npublic class configcentermain3344 {\n    public static void main(string[] args) {\n        springapplication.run(configcentermain3344.class,args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 6.测试\n\n1.启动eureka7001、eureka7002\n\n2.启动config3344\n\n访问url方式：\n\n 1. /{label}/{application}-{profile}.yml：\n 2. /{application}-{profile}.yml：\n 3. /{application}/{profile}[/{label}]：访问的json串\n\nlabel：分支(branch) name ：服务名 profiles：环境(dev/test/prod)\n\n3.访问地址：\n\n方式一：http://localhost:3344/master/config-dev.yml 指定分支\n\n方式二：http://localhost:3344/config-dev.yml 默认访问主分支\n\n方式三：http://localhost:3344/config/dev/master\n\n\n\n\n# 6.config客户端配置与测试\n\n\n# 1.新建模块cloud-config-client-3355\n\n\n# 2.导入依赖\n\n客户端的依赖是spring-cloud-starter-config，服务端是spring-cloud-starter-config-server\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloud-config-client-3355</artifactid>\n    \n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-config</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# 3.修改配置文件\n\n这次使用bootstrap.yml配置文件：\n\n> applicaiton.yml是用户级的资源配置项 bootstrap.yml是系统级的，优先级更加高\n> \n> spring cloud会创建一个“bootstrap context”，作为spring应用的application context的父上下文。初始化的时候，bootstrap context负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的environment。\n> \n> bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。 bootstrap context和application context有着不同的约定，所以新增了一个bootstrap.yml文件，保证bootstrap context和application context配置的分离。\n> \n> 要将client模块下的application.yml文件改为bootstrap.yml,这是很关键的， 因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml\n\nbootstrap.yml内容：\n\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultzone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.cloud.netflix.eureka.enableeurekaclient;\n\n@springbootapplication\n@enableeurekaclient\npublic class configclientmain3355 {\n    public static void main(string[] args)\n    {\n        springapplication.run(configclientmain3355.class,args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 5.业务类\n\npackage com.wcy.springcloud.controller;\n\nimport org.springframework.beans.factory.annotation.value;\nimport org.springframework.cloud.context.config.annotation.refreshscope;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\n@restcontroller\npublic class cofigcontroller {\n    @value("${config.info}")\n    private string configinfo;\n\n    @getmapping("/config/info")\n    public string config(){\n        return configinfo;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 6.测试\n\n1.启动eureka7001、eureka7001、3344、3355\n\n通过3355访问3344的中心配置：访问：http://localhost:3355/config/info\n\n\n# 问题：\n\n> 问题随时而来，分布式配置的动态刷新问题，修改github上面的配置文件信息，3344可以动态刷新，但是3355不能动态刷新。\n\n\n# 7.config客户端之动态刷新\n\n修改微服务3355的配置\n\n\n# 1.pom中引入依赖\n\n \n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-actuator</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.修改bootstrap.yml文件\n\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultzone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n# 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: "*"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 3.业务层controller增加注解\n\npackage com.wcy.springcloud.controller;\n\nimport org.springframework.beans.factory.annotation.value;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\n@restcontroller\n@refreshscope\npublic class cofigcontroller {\n    @value("${config.info}")\n    private string configinfo;\n\n    @getmapping("/config/info")\n    public string config(){\n        return configinfo;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 4.关键一步\n\n修改git仓库的内容后，3344可以正常更新，3355必须要运维人员发送一个post刷新请求即可。\n\n方式一：\n\n通过cmd命令的方式：curl -x post http://localhost:3355/actuator/refresh\n\n方式二：\n\n使用post发起post请求：curl -x post http://localhost:3355/actuator/refresh',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"Gateway网关",frontmatter:{title:"Gateway网关",date:"2021-08-18T18:52:09.000Z",permalink:"/pages/1beabf/",categories:["后端","Spring全家桶","SpringCloud"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/12.Gateway%E7%BD%91%E5%85%B3.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/12.Gateway网关.md",key:"v-23d7c457",path:"/pages/1beabf/",headers:[{level:2,title:"1.gateway网关介绍",slug:"_1-gateway网关介绍",normalizedTitle:"1.gateway网关介绍",charIndex:16},{level:2,title:"2.gateway能干嘛",slug:"_2-gateway能干嘛",normalizedTitle:"2.gateway能干嘛",charIndex:258},{level:2,title:"3.gateway的特性",slug:"_3-gateway的特性",normalizedTitle:"3.gateway的特性",charIndex:361},{level:2,title:"4.Spring Cloud Gateway 与 Zuul的区别",slug:"_4-spring-cloud-gateway-与-zuul的区别",normalizedTitle:"4.spring cloud gateway 与 zuul的区别",charIndex:587},{level:2,title:"5.gateway的三大核心",slug:"_5-gateway的三大核心",normalizedTitle:"5.gateway的三大核心",charIndex:1225},{level:2,title:"6.整合gateway网关",slug:"_6-整合gateway网关",normalizedTitle:"6.整合gateway网关",charIndex:1751},{level:3,title:"1.新建模块：cloud-gateway-gateway9527",slug:"_1-新建模块-cloud-gateway-gateway9527",normalizedTitle:"1.新建模块：cloud-gateway-gateway9527",charIndex:1769},{level:3,title:"2.导入依赖",slug:"_2-导入依赖",normalizedTitle:"2.导入依赖",charIndex:1806},{level:3,title:"3.添加yml",slug:"_3-添加yml",normalizedTitle:"3.添加yml",charIndex:3787},{level:3,title:"4.主启动类",slug:"_4-主启动类",normalizedTitle:"4.主启动类",charIndex:4756},{level:2,title:"7.配置路由规则",slug:"_7-配置路由规则",normalizedTitle:"7.配置路由规则",charIndex:5210},{level:3,title:"1.yml文件的方式",slug:"_1-yml文件的方式",normalizedTitle:"1.yml文件的方式",charIndex:5223},{level:3,title:"2.java的方式",slug:"_2-java的方式",normalizedTitle:"2.java的方式",charIndex:5783},{level:2,title:"8.gateway实现负载均衡",slug:"_8-gateway实现负载均衡",normalizedTitle:"8.gateway实现负载均衡",charIndex:7079},{level:2,title:"9.Predicate断言的使用",slug:"_9-predicate断言的使用",normalizedTitle:"9.predicate断言的使用",charIndex:8317},{level:2,title:"10.Filter的使用",slug:"_10-filter的使用",normalizedTitle:"10.filter的使用",charIndex:10478},{level:3,title:"1.Spring Cloud Gateway的Filter生命周期",slug:"_1-spring-cloud-gateway的filter生命周期",normalizedTitle:"1.spring cloud gateway的filter生命周期",charIndex:10495},{level:3,title:"2.Spring Cloud Gateway的Filter种类",slug:"_2-spring-cloud-gateway的filter种类",normalizedTitle:"2.spring cloud gateway的filter种类",charIndex:10545},{level:3,title:"3.常用的过滤器",slug:"_3-常用的过滤器",normalizedTitle:"3.常用的过滤器",charIndex:10770},{level:3,title:"4.自定义全局过滤器",slug:"_4-自定义全局过滤器",normalizedTitle:"4.自定义全局过滤器",charIndex:11409}],headersStr:"1.gateway网关介绍 2.gateway能干嘛 3.gateway的特性 4.Spring Cloud Gateway 与 Zuul的区别 5.gateway的三大核心 6.整合gateway网关 1.新建模块：cloud-gateway-gateway9527 2.导入依赖 3.添加yml 4.主启动类 7.配置路由规则 1.yml文件的方式 2.java的方式 8.gateway实现负载均衡 9.Predicate断言的使用 10.Filter的使用 1.Spring Cloud Gateway的Filter生命周期 2.Spring Cloud Gateway的Filter种类 3.常用的过滤器 4.自定义全局过滤器",content:'# Gateway网关\n\n\n# 1.gateway网关介绍\n\n官网\n\nCloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关； 但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul， 那就是SpringCloud Gateway一句话：gateway是原zuul1.x版的替代\n\n\n\nSpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架（异步非阻塞）。\n\n\n# 2.gateway能干嘛\n\n 1. 反向代理\n 2. 鉴权\n 3. 流量控制\n 4. 熔断\n 5. 日志监控\n 6. ....\n\n\n\n前端请求通过Ngnix负载均衡到网关，网关再调用对用的微服务。\n\n\n# 3.gateway的特性\n\n基于Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建；\n\n\n动态路由：能够匹配任何请求属性； 可以对路由指定 Predicate（断言）和 Filter（过滤器）； 集成Hystrix的断路器功能； 集成 Spring Cloud 服务发现功能； 易于编写的 Predicate（断言）和 Filter（过滤器）； 请求限流功能； 支持路径重写。\n\n\n# 4.Spring Cloud Gateway 与 Zuul的区别\n\n在SpringCloud Finchley 正式版之前，Spring Cloud 推荐的网关是 Netflix 提供的Zuul：\n\n1、Zuul 1.x，是一个基于阻塞 I/ O 的 API Gateway\n\n2、Zuul 1.x 基于Servlet 2. 5使用阻塞架构它不支持任何长连接(如 WebSocket) Zuul 的设计模式和Nginx较像，每次 I/ O 操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx 用C++ 实现，Zuul 用 Java 实现，而 JVM 本身会有第一次加载较慢的情况，使得Zuul 的性能相对较差。\n\n3、Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。 Zuul 2.x的性能较 Zuul 1.x 有较大提升。在性能方面，根据官方提供的基准测试， Spring Cloud Gateway 的 RPS（每秒请求数）是Zuul 的 1. 6 倍。\n\n4、Spring Cloud Gateway 建立 在 Spring Framework 5、 Project Reactor 和 Spring Boot 2 之上， 使用非阻塞 API。\n\n5、Spring Cloud Gateway 还 支持 WebSocket， 并且与Spring紧密集成拥有更好的开发体验\n\n\n# 5.gateway的三大核心\n\n 1. 路由（Route）：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由\n 2. 断言（Predicate）：开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由\n 3. 过滤（Filter）：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。\n\n客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。\n\nHandler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。 过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。\n\nFilter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等， 在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。\n\n\n# 6.整合gateway网关\n\n\n# 1.新建模块：cloud-gateway-gateway9527\n\n\n# 2.导入依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloud-gateway-gateway9527</artifactId>\n\n    <dependencies>\n        \x3c!--gateway--\x3e\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n        </dependency>\n        \x3c!--eureka-client--\x3e\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n        \x3c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\x3e\n        <dependency>\n            <groupId>com.wcy.springcloud</groupId>\n            <artifactId>cloud-api-commons</artifactId>\n            <version>1.0-SNAPSHOT</version>\n        </dependency>\n        \x3c!--一般基础配置类--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 3.添加yml\n\n访问:http://localhost:8001/payment/1可以通过网关http://localhost:9527/payment/1访问\n\n\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      routes:\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/**         # 断言，路径相匹配的进行路由\n\n        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8002          #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/**         # 断言，路径相匹配的进行路由\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\n\n@SpringBootApplication\n@EnableEurekaClient\npublic class GateWayMain9527 {\n    public static void main(String[] args) {\n        SpringApplication.run(GateWayMain9527.class,args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 7.配置路由规则\n\n\n# 1.yml文件的方式\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      routes:\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/**         # 断言，路径相匹配的进行路由\n\n        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8002          #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/**         # 断言，路径相匹配的进行路由\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.java的方式\n\n访问http://localhost:9527/guonei会访问http://news.baidu.com/guonei\n\npackage com.wcy.springcloud.config;\n\nimport org.springframework.cloud.gateway.route.Route;\nimport org.springframework.cloud.gateway.route.RouteLocator;\nimport org.springframework.cloud.gateway.route.builder.PredicateSpec;\nimport org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.function.Function;\n\n@Configuration\npublic class GateWayConfig {\n    /**\n     * 配置了一个id为route-name的路由规则，\n     * 当访问地址 http://localhost:9527/guonei时会自动转发到地址：http://news.baidu.com/guonei\n     * @return\n     */\n    @Bean\n    public RouteLocator customRouteLocator1(RouteLocatorBuilder builder){\n        RouteLocatorBuilder.Builder routes = builder.routes();\n        routes.route("path_route_wcy", new Function<PredicateSpec, Route.AsyncBuilder>() {\n            @Override\n            public Route.AsyncBuilder apply(PredicateSpec predicateSpec) {\n                return predicateSpec.path("/guonei").uri("http://news.baidu.com/guonei");\n            }\n        }).build();\n        return routes.build();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 8.gateway实现负载均衡\n\n以前80通过Feigin接口+Ribbon实现负载均衡；\n\n现在通过网关实现负载均衡；\n\n\n\n默认情况下Gateway会根据注册中心注册的服务列表， 以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能\n\n修改yml文件：\n\n\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n#          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/**         # 断言，路径相匹配的进行路由\n\n        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n#          uri: http://localhost:8002          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/feign/**         # 断言，路径相匹配的进行路由\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 9.Predicate断言的使用\n\n 1. After Route Predicate：多少时间之后才可以访问\n    \n    spring:\n      application:\n        name: cloud-gateway\n      cloud:\n        gateway:\n          discovery:\n            locator:\n              enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n          routes:\n            - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n    #          uri: http://localhost:8001          #匹配后提供服务的路由地址\n              uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n              predicates:\n                - Path=/payment/**         # 断言，路径相匹配的进行路由\n                - After=2021-08-20T15:00:03.685+08:00[Asia/Shanghai]         # 断言，路径相匹配的进行路由\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n    \n    时区可以通过jdk获取\n    \n        public static void main(String[] args)\n        {\n            ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区\n            System.out.println(zbj);\n    //        ZonedDateTime zny = ZonedDateTime.now(ZoneId.of("America/New_York")); // 用指定时区获取当前时间\n    //        System.out.println(zny);\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 2. Before Route Predicate：多少时间之前才能访问\n    \n    -Before=2020-02-05T15:10:03.685+08:00[Asia/Shanghai]         # 断言，路径相匹配的进行路由\n    \n    \n    1\n    \n\n 3. Between Route Predicate：时间之间\n    \n    - Between=2020-02-02T17:45:06.206+08:00[Asia/Shanghai],2020-03-25T18:59:06.206+08:00[Asia/Shanghai]\n    \n    \n    1\n    \n\n 4. Cookie Route Predicate：必须携带某个cookie，value支持正则表达式\n    \n    key，value的形式\n    \n    - Cookie=username,zzyy\n    \n    \n    1\n    \n\n 5. Header Route Predicate：头信息必须携带\n    \n    - Header=X-Request-Id, \\d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式\n    \n    \n    1\n    \n\n 6. Host Route Predicate：必须是某主机\n    \n    - Host=**.atguigu.com\n    \n    \n    1\n    \n\n 7. Method Route Predicate：允许get、post方式请求\n    \n    - Method=GET\n    \n    \n    1\n    \n\n 8. Path Route Predicate：有该路径匹配\n    \n    - Path=/payment/lb/**         # 断言，路径相匹配的进行路由\n    \n    \n    1\n    \n\n 9. Query Route Predicate：帶某参数才可以访问\n    \n    - Query=username, \\d+  # 要有参数名username并且值还要是整数才能路由\n    \n    \n    1\n    \n\n说白了，Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。\n\n\n# 10.Filter的使用\n\n\n# 1.Spring Cloud Gateway的Filter生命周期\n\n处理之前\n\n处理之后\n\n\n# 2.Spring Cloud Gateway的Filter种类\n\nGatewayFilter ：有31种，可以参考：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#the-addrequestparameter-gatewayfilter-factory\n\nGlobalFilter：全局过滤器\n\n\n\n\n# 3.常用的过滤器\n\nAddRequestParameter：可以对请求增加参数\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n#          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          filters:\n            - AddRequestParameter=X-Request-Id,1024 #过滤器工厂会在匹配的请求头加上一对请求头，名称为X-Request-Id值为1024\n          predicates:\n            - Path=/payment/**         # 断言，路径相匹配的进行路由\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 4.自定义全局过滤器\n\n自定义过滤器实现GlobalFilter, Ordered接口即可，记得注解@Component\n\n下面过滤器实现了只允许传入参数为wcy的才会放行，其他都被过滤掉。\n\npackage com.wcy.springcloud.filter;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.cloud.gateway.filter.GatewayFilterChain;\nimport org.springframework.cloud.gateway.filter.GlobalFilter;\nimport org.springframework.core.Ordered;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.server.ServerWebExchange;\nimport reactor.core.publisher.Mono;\n\nimport java.util.Date;\n\n/**\n * 自定义过滤器\n * 记录日志\n * 鉴权\n * 。。。。\n */\n@Component\npublic class MyLogGateWayFilter implements GlobalFilter, Ordered {\n    private static Logger logger = LoggerFactory.getLogger(MyLogGateWayFilter.class);\n\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        logger.info("time:"+new Date()+"\\t 执行了自定义的全局过滤器: "+"MyLogGateWayFilter"+"hello");\n        String uname = exchange.getRequest().getQueryParams().getFirst("uname");\n        if(!"wcy".equals(uname)){\n            //设置状态 并返回\n            logger.info("被拦截");\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\n            return exchange.getResponse().setComplete();\n        }\n        //放行\n        return chain.filter(exchange);\n    }\n\n    /**\n     * 返回值越小该过滤器优先级越高\n     * @return\n     */\n    @Override\n    public int getOrder() {\n        return 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n',normalizedContent:'# gateway网关\n\n\n# 1.gateway网关介绍\n\n官网\n\ncloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的zuul网关； 但在2.x版本中，zuul的升级一直跳票，springcloud最后自己研发了一个网关替代zuul， 那就是springcloud gateway一句话：gateway是原zuul1.x版的替代\n\n\n\nspringcloud gateway 使用的webflux中的reactor-netty响应式编程组件，底层使用了netty通讯框架（异步非阻塞）。\n\n\n# 2.gateway能干嘛\n\n 1. 反向代理\n 2. 鉴权\n 3. 流量控制\n 4. 熔断\n 5. 日志监控\n 6. ....\n\n\n\n前端请求通过ngnix负载均衡到网关，网关再调用对用的微服务。\n\n\n# 3.gateway的特性\n\n基于spring framework 5, project reactor 和 spring boot 2.0 进行构建；\n\n\n动态路由：能够匹配任何请求属性； 可以对路由指定 predicate（断言）和 filter（过滤器）； 集成hystrix的断路器功能； 集成 spring cloud 服务发现功能； 易于编写的 predicate（断言）和 filter（过滤器）； 请求限流功能； 支持路径重写。\n\n\n# 4.spring cloud gateway 与 zuul的区别\n\n在springcloud finchley 正式版之前，spring cloud 推荐的网关是 netflix 提供的zuul：\n\n1、zuul 1.x，是一个基于阻塞 i/ o 的 api gateway\n\n2、zuul 1.x 基于servlet 2. 5使用阻塞架构它不支持任何长连接(如 websocket) zuul 的设计模式和nginx较像，每次 i/ o 操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是nginx 用c++ 实现，zuul 用 java 实现，而 jvm 本身会有第一次加载较慢的情况，使得zuul 的性能相对较差。\n\n3、zuul 2.x理念更先进，想基于netty非阻塞和支持长连接，但springcloud目前还没有整合。 zuul 2.x的性能较 zuul 1.x 有较大提升。在性能方面，根据官方提供的基准测试， spring cloud gateway 的 rps（每秒请求数）是zuul 的 1. 6 倍。\n\n4、spring cloud gateway 建立 在 spring framework 5、 project reactor 和 spring boot 2 之上， 使用非阻塞 api。\n\n5、spring cloud gateway 还 支持 websocket， 并且与spring紧密集成拥有更好的开发体验\n\n\n# 5.gateway的三大核心\n\n 1. 路由（route）：路由是构建网关的基本模块，它由id，目标uri，一系列的断言和过滤器组成，如果断言为true则匹配该路由\n 2. 断言（predicate）：开发人员可以匹配http请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由\n 3. 过滤（filter）：指的是spring框架中gatewayfilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。\n\n客户端向 spring cloud gateway 发出请求。然后在 gateway handler mapping 中找到与请求相匹配的路由，将其发送到 gateway web handler。\n\nhandler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。 过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。\n\nfilter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等， 在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。\n\n\n# 6.整合gateway网关\n\n\n# 1.新建模块：cloud-gateway-gateway9527\n\n\n# 2.导入依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloud-gateway-gateway9527</artifactid>\n\n    <dependencies>\n        \x3c!--gateway--\x3e\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-gateway</artifactid>\n        </dependency>\n        \x3c!--eureka-client--\x3e\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n        </dependency>\n        \x3c!-- 引入自己定义的api通用包，可以使用payment支付entity --\x3e\n        <dependency>\n            <groupid>com.wcy.springcloud</groupid>\n            <artifactid>cloud-api-commons</artifactid>\n            <version>1.0-snapshot</version>\n        </dependency>\n        \x3c!--一般基础配置类--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 3.添加yml\n\n访问:http://localhost:8001/payment/1可以通过网关http://localhost:9527/payment/1访问\n\n\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      routes:\n        - id: payment_routh #payment_route    #路由的id，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          predicates:\n            - path=/payment/**         # 断言，路径相匹配的进行路由\n\n        - id: payment_routh2 #payment_route    #路由的id，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8002          #匹配后提供服务的路由地址\n          predicates:\n            - path=/payment/**         # 断言，路径相匹配的进行路由\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.cloud.netflix.eureka.enableeurekaclient;\n\n@springbootapplication\n@enableeurekaclient\npublic class gatewaymain9527 {\n    public static void main(string[] args) {\n        springapplication.run(gatewaymain9527.class,args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 7.配置路由规则\n\n\n# 1.yml文件的方式\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      routes:\n        - id: payment_routh #payment_route    #路由的id，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          predicates:\n            - path=/payment/**         # 断言，路径相匹配的进行路由\n\n        - id: payment_routh2 #payment_route    #路由的id，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8002          #匹配后提供服务的路由地址\n          predicates:\n            - path=/payment/**         # 断言，路径相匹配的进行路由\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.java的方式\n\n访问http://localhost:9527/guonei会访问http://news.baidu.com/guonei\n\npackage com.wcy.springcloud.config;\n\nimport org.springframework.cloud.gateway.route.route;\nimport org.springframework.cloud.gateway.route.routelocator;\nimport org.springframework.cloud.gateway.route.builder.predicatespec;\nimport org.springframework.cloud.gateway.route.builder.routelocatorbuilder;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\nimport java.util.function.function;\n\n@configuration\npublic class gatewayconfig {\n    /**\n     * 配置了一个id为route-name的路由规则，\n     * 当访问地址 http://localhost:9527/guonei时会自动转发到地址：http://news.baidu.com/guonei\n     * @return\n     */\n    @bean\n    public routelocator customroutelocator1(routelocatorbuilder builder){\n        routelocatorbuilder.builder routes = builder.routes();\n        routes.route("path_route_wcy", new function<predicatespec, route.asyncbuilder>() {\n            @override\n            public route.asyncbuilder apply(predicatespec predicatespec) {\n                return predicatespec.path("/guonei").uri("http://news.baidu.com/guonei");\n            }\n        }).build();\n        return routes.build();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 8.gateway实现负载均衡\n\n以前80通过feigin接口+ribbon实现负载均衡；\n\n现在通过网关实现负载均衡；\n\n\n\n默认情况下gateway会根据注册中心注册的服务列表， 以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能\n\n修改yml文件：\n\n\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n        - id: payment_routh #payment_route    #路由的id，没有固定规则但要求唯一，建议配合服务名\n#          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - path=/payment/**         # 断言，路径相匹配的进行路由\n\n        - id: payment_routh2 #payment_route    #路由的id，没有固定规则但要求唯一，建议配合服务名\n#          uri: http://localhost:8002          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - path=/payment/feign/**         # 断言，路径相匹配的进行路由\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 9.predicate断言的使用\n\n 1. after route predicate：多少时间之后才可以访问\n    \n    spring:\n      application:\n        name: cloud-gateway\n      cloud:\n        gateway:\n          discovery:\n            locator:\n              enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n          routes:\n            - id: payment_routh #payment_route    #路由的id，没有固定规则但要求唯一，建议配合服务名\n    #          uri: http://localhost:8001          #匹配后提供服务的路由地址\n              uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n              predicates:\n                - path=/payment/**         # 断言，路径相匹配的进行路由\n                - after=2021-08-20t15:00:03.685+08:00[asia/shanghai]         # 断言，路径相匹配的进行路由\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n    \n    时区可以通过jdk获取\n    \n        public static void main(string[] args)\n        {\n            zoneddatetime zbj = zoneddatetime.now(); // 默认时区\n            system.out.println(zbj);\n    //        zoneddatetime zny = zoneddatetime.now(zoneid.of("america/new_york")); // 用指定时区获取当前时间\n    //        system.out.println(zny);\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 2. before route predicate：多少时间之前才能访问\n    \n    -before=2020-02-05t15:10:03.685+08:00[asia/shanghai]         # 断言，路径相匹配的进行路由\n    \n    \n    1\n    \n\n 3. between route predicate：时间之间\n    \n    - between=2020-02-02t17:45:06.206+08:00[asia/shanghai],2020-03-25t18:59:06.206+08:00[asia/shanghai]\n    \n    \n    1\n    \n\n 4. cookie route predicate：必须携带某个cookie，value支持正则表达式\n    \n    key，value的形式\n    \n    - cookie=username,zzyy\n    \n    \n    1\n    \n\n 5. header route predicate：头信息必须携带\n    \n    - header=x-request-id, \\d+  # 请求头要有x-request-id属性并且值为整数的正则表达式\n    \n    \n    1\n    \n\n 6. host route predicate：必须是某主机\n    \n    - host=**.atguigu.com\n    \n    \n    1\n    \n\n 7. method route predicate：允许get、post方式请求\n    \n    - method=get\n    \n    \n    1\n    \n\n 8. path route predicate：有该路径匹配\n    \n    - path=/payment/lb/**         # 断言，路径相匹配的进行路由\n    \n    \n    1\n    \n\n 9. query route predicate：帶某参数才可以访问\n    \n    - query=username, \\d+  # 要有参数名username并且值还要是整数才能路由\n    \n    \n    1\n    \n\n说白了，predicate就是为了实现一组匹配规则，让请求过来找到对应的route进行处理。\n\n\n# 10.filter的使用\n\n\n# 1.spring cloud gateway的filter生命周期\n\n处理之前\n\n处理之后\n\n\n# 2.spring cloud gateway的filter种类\n\ngatewayfilter ：有31种，可以参考：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.release/reference/html/#the-addrequestparameter-gatewayfilter-factory\n\nglobalfilter：全局过滤器\n\n\n\n\n# 3.常用的过滤器\n\naddrequestparameter：可以对请求增加参数\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n        - id: payment_routh #payment_route    #路由的id，没有固定规则但要求唯一，建议配合服务名\n#          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          filters:\n            - addrequestparameter=x-request-id,1024 #过滤器工厂会在匹配的请求头加上一对请求头，名称为x-request-id值为1024\n          predicates:\n            - path=/payment/**         # 断言，路径相匹配的进行路由\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 4.自定义全局过滤器\n\n自定义过滤器实现globalfilter, ordered接口即可，记得注解@component\n\n下面过滤器实现了只允许传入参数为wcy的才会放行，其他都被过滤掉。\n\npackage com.wcy.springcloud.filter;\n\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.cloud.gateway.filter.gatewayfilterchain;\nimport org.springframework.cloud.gateway.filter.globalfilter;\nimport org.springframework.core.ordered;\nimport org.springframework.http.httpstatus;\nimport org.springframework.stereotype.component;\nimport org.springframework.web.server.serverwebexchange;\nimport reactor.core.publisher.mono;\n\nimport java.util.date;\n\n/**\n * 自定义过滤器\n * 记录日志\n * 鉴权\n * 。。。。\n */\n@component\npublic class myloggatewayfilter implements globalfilter, ordered {\n    private static logger logger = loggerfactory.getlogger(myloggatewayfilter.class);\n\n    @override\n    public mono<void> filter(serverwebexchange exchange, gatewayfilterchain chain) {\n        logger.info("time:"+new date()+"\\t 执行了自定义的全局过滤器: "+"myloggatewayfilter"+"hello");\n        string uname = exchange.getrequest().getqueryparams().getfirst("uname");\n        if(!"wcy".equals(uname)){\n            //设置状态 并返回\n            logger.info("被拦截");\n            exchange.getresponse().setstatuscode(httpstatus.not_acceptable);\n            return exchange.getresponse().setcomplete();\n        }\n        //放行\n        return chain.filter(exchange);\n    }\n\n    /**\n     * 返回值越小该过滤器优先级越高\n     * @return\n     */\n    @override\n    public int getorder() {\n        return 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"Hystrix豪猪哥",frontmatter:{title:"Hystrix豪猪哥",date:"2021-08-17T09:31:44.000Z",permalink:"/pages/e3e514/",categories:["后端","Spring全家桶","SpringCloud","Hystrix豪猪哥"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/11.Hystrix%E8%B1%AA%E7%8C%AA%E5%93%A5.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/11.Hystrix豪猪哥.md",key:"v-926d06f0",path:"/pages/e3e514/",headers:[{level:2,title:"一.分布式架构存在的问题",slug:"一-分布式架构存在的问题",normalizedTitle:"一.分布式架构存在的问题",charIndex:76},{level:2,title:"二.Hystrix是什么",slug:"二-hystrix是什么",normalizedTitle:"二.hystrix是什么",charIndex:524},{level:2,title:"三.Hystrix能干嘛",slug:"三-hystrix能干嘛",normalizedTitle:"三.hystrix能干嘛",charIndex:818},{level:2,title:"四.Hystrix停更维护",slug:"四-hystrix停更维护",normalizedTitle:"四.hystrix停更维护",charIndex:1231},{level:2,title:"五.Cloud搭建环境",slug:"五-cloud搭建环境",normalizedTitle:"五.cloud搭建环境",charIndex:1366},{level:2,title:"六.使用Jmeter测试",slug:"六-使用jmeter测试",normalizedTitle:"六.使用jmeter测试",charIndex:7536},{level:3,title:"6.1.Jmeter使用步骤：",slug:"_6-1-jmeter使用步骤",normalizedTitle:"6.1.jmeter使用步骤：",charIndex:7553},{level:3,title:"6.2.测试结果",slug:"_6-2-测试结果",normalizedTitle:"6.2.测试结果",charIndex:7654},{level:2,title:"七.引入消费者80端",slug:"七-引入消费者80端",normalizedTitle:"七.引入消费者80端",charIndex:7874},{level:2,title:"八.解决的问题",slug:"八-解决的问题",normalizedTitle:"八.解决的问题",charIndex:14132},{level:2,title:"九.解决方法",slug:"九-解决方法",normalizedTitle:"九.解决方法",charIndex:14362},{level:3,title:"9.1.服务器8001的兜底fallback实现",slug:"_9-1-服务器8001的兜底fallback实现",normalizedTitle:"9.1.服务器8001的兜底fallback实现",charIndex:14434},{level:3,title:"9.2.客户端80的兜底fallback实现",slug:"_9-2-客户端80的兜底fallback实现",normalizedTitle:"9.2.客户端80的兜底fallback实现",charIndex:16824},{level:2,title:"十.通用fallback(推荐十一)",slug:"十-通用fallback-推荐十一",normalizedTitle:"十.通用fallback(推荐十一)",charIndex:18692},{level:2,title:"十一.业务和回调解耦",slug:"十一-业务和回调解耦",normalizedTitle:"十一.业务和回调解耦",charIndex:21459},{level:3,title:"1.实现feign接口，实现方法的回调",slug:"_1-实现feign接口-实现方法的回调",normalizedTitle:"1.实现feign接口，实现方法的回调",charIndex:21585},{level:3,title:"2.yml文件",slug:"_2-yml文件",normalizedTitle:"2.yml文件",charIndex:22064},{level:3,title:"3.feign接口指定回调的类",slug:"_3-feign接口指定回调的类",normalizedTitle:"3.feign接口指定回调的类",charIndex:22512},{level:3,title:"4.测试",slug:"_4-测试",normalizedTitle:"4.测试",charIndex:22913},{level:2,title:"十二.服务熔断",slug:"十二-服务熔断",normalizedTitle:"十二.服务熔断",charIndex:22953},{level:3,title:"1.导入依赖",slug:"_1-导入依赖",normalizedTitle:"1.导入依赖",charIndex:23238},{level:3,title:"2.server层实现HystrixCommand",slug:"_2-server层实现hystrixcommand",normalizedTitle:"2.server层实现hystrixcommand",charIndex:23460},{level:3,title:"3.controller调用",slug:"_3-controller调用",normalizedTitle:"3.controller调用",charIndex:24800},{level:3,title:"4.测试",slug:"_4-测试-2",normalizedTitle:"4.测试",charIndex:22913},{level:2,title:"十三.服务熔断总结",slug:"十三-服务熔断总结",normalizedTitle:"十三.服务熔断总结",charIndex:25309},{level:3,title:"1.熔断类型",slug:"_1-熔断类型",normalizedTitle:"1.熔断类型",charIndex:25323},{level:3,title:"2.断路器生效条件",slug:"_2-断路器生效条件",normalizedTitle:"2.断路器生效条件",charIndex:25476},{level:3,title:"3.断路器打开后：",slug:"_3-断路器打开后",normalizedTitle:"3.断路器打开后：",charIndex:25800},{level:3,title:"4.熔断的配置",slug:"_4-熔断的配置",normalizedTitle:"4.熔断的配置",charIndex:26097},{level:2,title:"十四.hystrix工作流程",slug:"十四-hystrix工作流程",normalizedTitle:"十四.hystrix工作流程",charIndex:31289},{level:2,title:"十五.服务监控hystrixDashboard",slug:"十五-服务监控hystrixdashboard",normalizedTitle:"十五.服务监控hystrixdashboard",charIndex:32906},{level:3,title:"1.新建hystrixDashboard模块",slug:"_1-新建hystrixdashboard模块",normalizedTitle:"1.新建hystrixdashboard模块",charIndex:33165},{level:3,title:"2.测试",slug:"_2-测试",normalizedTitle:"2.测试",charIndex:7656},{level:3,title:"3.监控如何查看",slug:"_3-监控如何查看",normalizedTitle:"3.监控如何查看",charIndex:36436}],headersStr:"一.分布式架构存在的问题 二.Hystrix是什么 三.Hystrix能干嘛 四.Hystrix停更维护 五.Cloud搭建环境 六.使用Jmeter测试 6.1.Jmeter使用步骤： 6.2.测试结果 七.引入消费者80端 八.解决的问题 九.解决方法 9.1.服务器8001的兜底fallback实现 9.2.客户端80的兜底fallback实现 十.通用fallback(推荐十一) 十一.业务和回调解耦 1.实现feign接口，实现方法的回调 2.yml文件 3.feign接口指定回调的类 4.测试 十二.服务熔断 1.导入依赖 2.server层实现HystrixCommand 3.controller调用 4.测试 十三.服务熔断总结 1.熔断类型 2.断路器生效条件 3.断路器打开后： 4.熔断的配置 十四.hystrix工作流程 十五.服务监控hystrixDashboard 1.新建hystrixDashboard模块 2.测试 3.监控如何查看",content:'# Hystrix豪猪哥\n\n> https://github.com/Netflix/Hystrix/wiki/How-To-Use 官方文档\n\n\n# 一.分布式架构存在的问题\n\n> 复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。\n\n服务雪崩（服务于服务之间的调用）\n\n多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.\n\n对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。 所以： 通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。\n\n\n# 二.Hystrix是什么\n\nHystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。\n\n“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\n\n# 三.Hystrix能干嘛\n\n 1. 服务降级fallback：当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理fallback，从而释放服务器资源以保证核心交易正常运作或高效运作。\n    \n    哪些情况会出发降级？\n    \n    * 程序运行异常\n    * 超时\n    * 服务熔断触发服务降级\n    * 线程池/信号量打满也会导致服务降级\n\n 2. 服务熔断break：在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用，然后调用服务降级的方法并返回友好提示\n    \n    > 服务的降级->进而熔断->恢复调用链路\n\n 3. 接近实时的监控\n\n 4. 服务限流flowlimit：秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行\n\n 5. 服务隔离\n\n\n# 四.Hystrix停更维护\n\n> Hystrix已经停更维护，但是其设计思想值得学习，后面的alibab Sentinel也是借鉴了Hystrix\n\n官网资料：https://github.com/Netflix/Hystrix/wiki/How-To-Use\n\n\n# 五.Cloud搭建环境\n\n 1. 新建模块：cloud-provider-hystrix-payment8001\n\n 2. pom文件\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <project xmlns="http://maven.apache.org/POM/4.0.0"\n             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n        <parent>\n            <artifactId>CloudStudy</artifactId>\n            <groupId>com.wcy.springcloud</groupId>\n            <version>1.0-SNAPSHOT</version>\n        </parent>\n        <modelVersion>4.0.0</modelVersion>\n    \n        <artifactId>cloud-provider-hystrix-payment8001</artifactId>\n    \n        <dependencies>\n            \x3c!--hystrix--\x3e\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n            </dependency>\n            \x3c!--eureka client--\x3e\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n            </dependency>\n            \x3c!--web--\x3e\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-web</artifactId>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-actuator</artifactId>\n            </dependency>\n            <dependency>\x3c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\x3e\n                <groupId>com.wcy.springcloud</groupId>\n                <artifactId>cloud-api-commons</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-devtools</artifactId>\n                <scope>runtime</scope>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.projectlombok</groupId>\n                <artifactId>lombok</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-test</artifactId>\n                <scope>test</scope>\n            </dependency>\n        </dependencies>\n    \n    </project>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    \n\n 3. yml文件\n    \n    server:\n      port: 8001\n    \n    spring:\n      application:\n        name: cloud-provider-hystrix-payment\n    \n    eureka:\n      client:\n        register-with-eureka: true\n        fetch-registry: true\n        service-url:\n          defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n          #defaultZone: http://eureka7001.com:7001/eureka\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n 4. 主启动类\n    \n    package com.wcy.springcloud;\n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.cloud.netflix.eureka.EnableEurekaClient;\n    \n    @SpringBootApplication\n    @EnableEurekaClient //本服务启动后会自动注册进eureka服务中\n    public class PaymentHystrixMain8001\n    {\n        public static void main(String[] args)\n        {\n            SpringApplication.run(PaymentHystrixMain8001.class,args);\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 5. 业务类：\n    \n    service层：\n    \n    package com.wcy.springcloud.service;\n    \n    import org.springframework.stereotype.Service;\n    \n    @Service\n    public class PaymentService {\n        public String paymentInfo_OK(Integer id){\n            return "线程池："+Thread.currentThread().getName()+"paymentInfo_OK,id: "+id+"\\t"+"O(∩_∩)O";\n        }\n        public String paymentInfo_TimeOut(Integer id){\n            Integer timeOUt=3000;\n            try {\n                Thread.sleep(timeOUt);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return "线程池："+Thread.currentThread().getName()+"paymentInfo_TimeOut,id: "+id+"\\t"+"O(∩_∩)O 休眠（秒）："+timeOUt;\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n    \n    controller层：\n    \n    package com.wcy.springcloud.controller;\n    \n    import com.wcy.springcloud.service.PaymentService;\n    import lombok.extern.slf4j.Slf4j;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.PathVariable;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    @RestController\n    @Slf4j\n    public class PaymentController {\n        @Autowired\n        private PaymentService paymentService;\n    \n        @GetMapping("/payment/hystrix/ok/{id}")\n        public String paymentOK(@PathVariable("id") Integer id){\n            return paymentService.paymentInfo_OK(id);\n        }\n    \n        @GetMapping("/payment/hystrix/timeout/{id}")\n        public String paymentTimeOut(@PathVariable("id") Integer id){\n            return paymentService.paymentInfo_TimeOut(id);\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    \n\n 6. 测试：\n    \n    1. http://localhost:8001/payment/hystrix/ok/1 ：马上访问成功\n    2. http://localhost:8001/payment/hystrix/timeout/2 ：延迟三秒钟\n\n\n# 六.使用Jmeter测试\n\n\n# 6.1.Jmeter使用步骤：\n\n 1. 创建线程组\n    \n    \n\n 2. 设置20000的并发\n    \n    \n\n 3. 创建HTTP请求\n    \n    \n    \n    \n\n\n# 6.2.测试结果\n\n> Jmeter并发20000访问http://localhost:8001/payment/hystrix/timeout/2接口，我们去访问正常的http://localhost:8001/payment/hystrix/ok/1的接口，两个都在自己转圈圈，也会出现延迟？\n> \n> 那是因为Tomcat最小线程数是10,并发最高只支持200，而我们的并发是20000，所以导致后续正常的接口也会出现问题。\n\n\n# 七.引入消费者80端\n\n 1. 新建模块：cloud-consumer-feign-hystrix-order80\n\n 2. pom文件\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <project xmlns="http://maven.apache.org/POM/4.0.0"\n             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n        <parent>\n            <artifactId>CloudStudy</artifactId>\n            <groupId>com.wcy.springcloud</groupId>\n            <version>1.0-SNAPSHOT</version>\n        </parent>\n        <modelVersion>4.0.0</modelVersion>\n    \n        <artifactId>cloud-consumer-feign-hystrix-order80</artifactId>\n    \n        <dependencies>\n            \x3c!--openfeign--\x3e\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-openfeign</artifactId>\n            </dependency>\n            \x3c!--hystrix--\x3e\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n            </dependency>\n            \x3c!--eureka client--\x3e\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n            </dependency>\n            \x3c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\x3e\n            <dependency>\n                <groupId>com.wcy.springcloud</groupId>\n                <artifactId>cloud-api-commons</artifactId>\n                <version>1.0-SNAPSHOT</version>\n            </dependency>\n            \x3c!--web--\x3e\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-web</artifactId>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-actuator</artifactId>\n            </dependency>\n            \x3c!--一般基础通用配置--\x3e\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-devtools</artifactId>\n                <scope>runtime</scope>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.projectlombok</groupId>\n                <artifactId>lombok</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-test</artifactId>\n                <scope>test</scope>\n            </dependency>\n        </dependencies>\n    \n    \n    </project>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    \n\n 3. yml文件\n    \n    server:\n      port: 80\n    \n    eureka:\n      client:\n        register-with-eureka: false\n        service-url:\n          defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7001.com:7002/eureka/\n    \n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 4. 主启动类\n    \n    package com.wcy.springcloud;\n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.cloud.openfeign.EnableFeignClients;\n    \n    /**\n     * @auther zzyy\n     * @create 2020-02-04 16:32\n     */\n    @SpringBootApplication\n    @EnableFeignClients  //开启fegin接口\n    public class OrderHystrixMain80\n    {\n        public static void main(String[] args)\n        {\n            SpringApplication.run(OrderHystrixMain80.class,args);\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    \n\n 5. Feign接口，调用8001后端服务\n    \n    package com.wcy.springcloud.service;\n    \n    import org.springframework.cloud.openfeign.FeignClient;\n    import org.springframework.stereotype.Component;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.PathVariable;\n    \n    @Component\n    @FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT")\n    public interface PaymentFeign {\n        @GetMapping("/payment/hystrix/ok/{id}")\n        public String paymentOK(@PathVariable("id") Integer id);\n    \n        @GetMapping("/payment/hystrix/timeout/{id}")\n        public String paymentTimeOut(@PathVariable("id") Integer id);\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 6. 80消费者controller层\n    \n    package com.wcy.springcloud.controller;\n    \n    import com.wcy.springcloud.service.PaymentFeign;\n    import lombok.extern.slf4j.Slf4j;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.PathVariable;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    @RestController\n    @Slf4j\n    public class OrderController {\n        @Autowired\n        private PaymentFeign paymentFeign;\n    \n        @GetMapping("/consumer/payment/hystrix/ok/{id}")\n        public String paymentOK(@PathVariable("id") Integer id){\n            log.info("进入paymentOK方法:"+id);\n            return paymentFeign.paymentOK(id);\n        }\n    \n        @GetMapping("/consumer/payment/hystrix/timeout/{id}")\n        public String paymentTimeOut(@PathVariable("id") Integer id){\n            log.info("进入paymentTimeOut方法:"+id);\n            return paymentFeign.paymentTimeOut(id);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    \n\n\n# 八.解决的问题\n\n问题：\n\n>  1. 超时导致服务器变慢(转圈)，超时不再等待\n>  2. 出错(宕机或程序运行出错)，出错要有兜底\n\n解决：\n\n>  1. 对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级\n>  2. 对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级\n>  3. 对方服务(8001)OK，调用者(80)自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级\n\n\n# 九.解决方法\n\n> 我们自己配置过的热部署方式对java代码的改动明显， 但对@HystrixCommand内属性的修改建议重启微服务\n\n\n# 9.1.服务器8001的兜底fallback实现\n\n 1. 主启动类开启服务降级和熔断\n    \n    package com.wcy.springcloud;\n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n    import org.springframework.cloud.netflix.eureka.EnableEurekaClient;\n    \n    @SpringBootApplication\n    @EnableEurekaClient //本服务启动后会自动注册进eureka服务中\n    @EnableCircuitBreaker  //开启服务降级、熔断\n    public class PaymentHystrixMain8001\n    {\n        public static void main(String[] args)\n        {\n            SpringApplication.run(PaymentHystrixMain8001.class,args);\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 2. service实现兜底的方法\n    \n    paymentInfo_TimeOut：报错和时间超过三秒会直接走兜底的方法。\n    \n    package com.wcy.springcloud.service;\n    \n    import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\n    import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\n    import org.springframework.stereotype.Service;\n    \n    @Service\n    public class PaymentService {\n    \n        /**\n         * Hystrix服务降级：异常也会走兜底方法\n         * fallbackMethod ：服务出错的兜底方法\n         * commandProperties：设置出错规则，比如时间超过三秒则执行兜底方法\n         * @param id\n         * @return\n         */\n        @HystrixCommand(fallbackMethod = "paymentInfo_TimeOutHandler",commandProperties = {\n                @HystrixProperty(name="execution.isolation.thread.timeoutInMilliseconds",value="3000")\n        })\n        public String paymentInfo_TimeOut(Integer id){\n        //        int a=10/0;\n            Integer timeOUt=5000;\n            try {\n                Thread.sleep(timeOUt);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return "线程池："+Thread.currentThread().getName()+"paymentInfo_TimeOut,id: "+id+"\\t"+"O(∩_∩)O 休眠（秒）："+timeOUt;\n        }\n    \n        public String paymentInfo_TimeOutHandler(Integer id){\n            return "线程池："+Thread.currentThread().getName()+"请求失败，请重试";\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    \n\n\n# 9.2.客户端80的兜底fallback实现\n\n 1. 引入依赖\n    \n            \x3c!--hystrix--\x3e\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n            </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 修改pom\n    \n    server:\n      port: 80\n    \n    eureka:\n      client:\n        register-with-eureka: false\n        service-url:\n          defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7001.com:7002/eureka/\n    \n    #设置feign客户端超时时间(OpenFeign默认支持ribbon)\n    ribbon:\n      #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间\n      ReadTimeout: 6000\n      #指的是建立连接后从服务器读取到可用资源所用的时间\n      ConnectTimeout: 6000\n    \n    #开启Hystrix\n    feign:\n      hystrix:\n        enabled: true\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n 3. 主启动类开启Hystrix\n    \n    @EnableHystrix  //开启Hystrix\n    \n    \n    1\n    \n\n 4. controller实现兜底方法\n    \n        @GetMapping("/consumer/payment/hystrix/timeout/{id}")\n        @HystrixCommand(fallbackMethod="paymentTimeOutHandler",commandProperties = {\n                @HystrixProperty(name="execution.isolation.thread.timeoutInMilliseconds",value="1500")\n        })\n        public String paymentTimeOut(@PathVariable("id") Integer id){\n            int a=10/0;\n            log.info("进入paymentTimeOut方法:"+id);\n            return paymentFeign.paymentTimeOut(id);\n        }\n    \n        /**\n         * 兜底方法\n         * @param id\n         * @return\n         */\n        public String paymentTimeOutHandler(@PathVariable("id") Integer id){\n            return "我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o";\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n\n\n# 十.通用fallback(推荐十一)\n\n问题：上面每个业务方法对应一个兜底的方法，代码膨胀\n\n解决：统一和自定义的分开\n\n 1. controller设置全局处理fallback\n    \n    //该controller默认的丢底方法\n    @DefaultProperties(defaultFallback="payment_Global_FallbackMethod",commandProperties = {\n            @HystrixProperty(name="execution.isolation.thread.timeoutInMilliseconds",value="1500")\n    })\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. controller中兜底的方法\n    \n        /**\n         * 全局兜底方法\n         * @return\n         */\n        public String payment_Global_FallbackMethod()\n        {\n            return "Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~";\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. controller的使用方法\n    \n        // 开启Hystrix的兜底方法\n        @HystrixCommand\n        public String paymentTimeOut(@PathVariable("id") Integer id){\n    //        int a=10/0;\n            log.info("进入paymentTimeOut方法:"+id);\n            return paymentFeign.paymentTimeOut(id);\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n所有的配置：\n\n \npackage com.atguigu.springcloud.controller;\n\nimport com.atguigu.springcloud.service.PaymentHystrixService;\nimport com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.annotation.Resource;\n\n/**\n * @auther zzyy\n * @create 2020-02-04 16:35\n */\n@RestController\n@Slf4j\n@DefaultProperties(defaultFallback = "payment_Global_FallbackMethod")\npublic class PaymentHystirxController\n{\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping("/consumer/payment/hystrix/ok/{id}")\n    public String paymentInfo_OK(@PathVariable("id") Integer id)\n    {\n        String result = paymentHystrixService.paymentInfo_OK(id);\n        return result;\n    }\n\n    @GetMapping("/consumer/payment/hystrix/timeout/{id}")\n    @HystrixCommand //加了@DefaultProperties属性注解，并且没有写具体方法名字，就用统一全局的\n    public String paymentInfo_TimeOut(@PathVariable("id") Integer id)\n    {\n        String result = paymentHystrixService.paymentInfo_TimeOut(id);\n        return result;\n    }\n    public String paymentTimeOutFallbackMethod(@PathVariable("id") Integer id)\n    {\n        return "paymentTimeOutFallbackMethod,对方系统繁忙，请10秒钟后再次尝试/(ㄒoㄒ)/";\n    }\n\n    public String payment_Global_FallbackMethod()\n    {\n        return "Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~";\n    }\n}\n \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 十一.业务和回调解耦\n\n本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系。 只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦\n\n未来面对的异常：\n\n 1. 运行时异常\n 2. 超时\n 3. 宕机\n\n\n# 1.实现feign接口，实现方法的回调\n\npackage com.wcy.springcloud.service;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class PaymentFallbackFeign implements PaymentFeign{\n    @Override\n    public String paymentOK(Integer id) {\n        return "服务调用失败，提示来自：cloud-consumer-feign-order80";\n    }\n\n    @Override\n    public String paymentTimeOut(Integer id) {\n        return "服务调用失败，提示来自：cloud-consumer-feign-order80";\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2.yml文件\n\nserver:\n  port: 80\n\neureka:\n  client:\n    register-with-eureka: false\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7001.com:7002/eureka/\n\n#设置feign客户端超时时间(OpenFeign默认支持ribbon)\nribbon:\n  #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间\n  ReadTimeout: 6000\n  #指的是建立连接后从服务器读取到可用资源所用的时间\n  ConnectTimeout: 6000\n\n#开启Hystrix\nfeign:\n  hystrix:\n    enabled: true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 3.feign接口指定回调的类\n\n@Component\n@FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT",fallback = PaymentFallbackFeign.class)\npublic interface PaymentFeign {\n    @GetMapping("/payment/hystrix/ok/{id}")\n    public String paymentOK(@PathVariable("id") Integer id);\n\n    @GetMapping("/payment/hystrix/timeout/{id}")\n    public String paymentTimeOut(@PathVariable("id") Integer id);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4.测试\n\n关闭生产者8001、或8001出现错误等等都会调用兜底方法\n\n\n# 十二.服务熔断\n\n断路器：一句话就是家里的保险丝\n\n熔断机制概述： 熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时， 会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。 当检测到该节点微服务调用响应正常后，恢复调用链路。\n\n在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况， 当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。\n\n熔断机制的注解是@HystrixCommand。\n\n在生产者8001实现服务熔断：\n\n\n# 1.导入依赖\n\n        \x3c!--hystrix--\x3e\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.server层实现HystrixCommand\n\n//10秒窗口期10次请求中有百分之60出错，那么会触发断路器\n\n@HystrixProperty(name = "circuitBreaker.enabled",value = "true"),//开启服务熔断\n\n@HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"),//请求次数\n\n@HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"),//10秒\n\n@HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60"),//错误率百分之60\n\n    @HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback",commandProperties = {\n            //10秒窗口期10次请求中有百分之60出错，那么会触发断路器\n            @HystrixProperty(name = "circuitBreaker.enabled",value = "true"),//开启服务熔断\n            @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"),//请求次数\n            @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"),//10秒\n            @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60"),//错误率百分之60\n    })\n    public String paymentCircuitBreaker(Integer id){\n        if(id<0){\n            throw new RuntimeException("id不能小于0");\n        }\n        return "线程池："+Thread.currentThread().getName()+"id: "+ IdUtil.simpleUUID() +"\\t"+"O(∩_∩)O";\n    }\n    public String paymentCircuitBreaker_fallback(Integer id){\n        return "id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: " +id;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 3.controller调用\n\n    /**\n     * 测试服务熔断\n     * @param id\n     * @return\n     */\n    @GetMapping("/payment/circuit/{id}")\n    public String paymentCircuitBreaker(@PathVariable("id") Integer id){\n        String result = paymentService.paymentCircuitBreaker(id);\n        log.info(result);\n        return result;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4.测试\n\n先使用：http://localhost:8001/payment/circuit/-1，疯狂点会看到一直走的兜底方法，然后再访问http://localhost:8001/payment/circuit/1，发现也会走兜底方法，发现服务熔断生效，持续访问正确的地址，会发现断路器会慢慢关闭，就可以正常访问。\n\n\n# 十三.服务熔断总结\n\n\n# 1.熔断类型\n\n 1. 熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR（平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态\n 2. 熔断关闭：熔断关闭不会对服务进行熔断\n 3. 熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断\n\n\n# 2.断路器生效条件\n\n\n\n涉及到断路器的三个重要参数：快照时间窗、请求总数阀值、错误百分比阀值。\n\n 1. 快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。\n 2. 请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。\n 3. 错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。\n\n\n\n\n# 3.断路器打开后：\n\n1：再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。\n\n2：原来的主逻辑要如何恢复呢？ 对于这一问题，hystrix也为我们实现了自动恢复功能。 当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑， 当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合， 主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。\n\n\n# 4.熔断的配置\n\n//========================All\n@HystrixCommand(fallbackMethod = "str_fallbackMethod",\n        groupKey = "strGroupCommand",\n        commandKey = "strCommand",\n        threadPoolKey = "strThreadPool",\n\n        commandProperties = {\n                // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离\n                @HystrixProperty(name = "execution.isolation.strategy", value = "THREAD"),\n                // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）\n                @HystrixProperty(name = "execution.isolation.semaphore.maxConcurrentRequests", value = "10"),\n                // 配置命令执行的超时时间\n                @HystrixProperty(name = "execution.isolation.thread.timeoutinMilliseconds", value = "10"),\n                // 是否启用超时时间\n                @HystrixProperty(name = "execution.timeout.enabled", value = "true"),\n                // 执行超时的时候是否中断\n                @HystrixProperty(name = "execution.isolation.thread.interruptOnTimeout", value = "true"),\n                // 执行被取消的时候是否中断\n                @HystrixProperty(name = "execution.isolation.thread.interruptOnCancel", value = "true"),\n                // 允许回调方法执行的最大并发数\n                @HystrixProperty(name = "fallback.isolation.semaphore.maxConcurrentRequests", value = "10"),\n                // 服务降级是否启用，是否执行回调函数\n                @HystrixProperty(name = "fallback.enabled", value = "true"),\n                // 是否启用断路器\n                @HystrixProperty(name = "circuitBreaker.enabled", value = "true"),\n                // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，\n                // 如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。\n                @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "20"),\n                // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过\n                // circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50,\n                // 就把断路器设置为 "打开" 状态，否则就设置为 "关闭" 状态。\n                @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "50"),\n                // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，\n                // 会将断路器置为 "半开" 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 "打开" 状态，\n                // 如果成功就设置为 "关闭" 状态。\n                @HystrixProperty(name = "circuitBreaker.sleepWindowinMilliseconds", value = "5000"),\n                // 断路器强制打开\n                @HystrixProperty(name = "circuitBreaker.forceOpen", value = "false"),\n                // 断路器强制关闭\n                @HystrixProperty(name = "circuitBreaker.forceClosed", value = "false"),\n                // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间\n                @HystrixProperty(name = "metrics.rollingStats.timeinMilliseconds", value = "10000"),\n                // 该属性用来设置滚动时间窗统计指标信息时划分"桶"的数量，断路器在收集指标信息的时候会根据\n                // 设置的时间窗长度拆分成多个 "桶" 来累计各度量值，每个"桶"记录了一段时间内的采集指标。\n                // 比如 10 秒内拆分成 10 个"桶"收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常\n                @HystrixProperty(name = "metrics.rollingStats.numBuckets", value = "10"),\n                // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 -1。\n                @HystrixProperty(name = "metrics.rollingPercentile.enabled", value = "false"),\n                // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。\n                @HystrixProperty(name = "metrics.rollingPercentile.timeInMilliseconds", value = "60000"),\n                // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。\n                @HystrixProperty(name = "metrics.rollingPercentile.numBuckets", value = "60000"),\n                // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，\n                // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，\n                // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。\n                @HystrixProperty(name = "metrics.rollingPercentile.bucketSize", value = "100"),\n                // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。\n                @HystrixProperty(name = "metrics.healthSnapshot.intervalinMilliseconds", value = "500"),\n                // 是否开启请求缓存\n                @HystrixProperty(name = "requestCache.enabled", value = "true"),\n                // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中\n                @HystrixProperty(name = "requestLog.enabled", value = "true"),\n        },\n        threadPoolProperties = {\n                // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量\n                @HystrixProperty(name = "coreSize", value = "10"),\n                // 该参数用来设置线程池的最大队列大小。当设置为 -1 时，线程池将使用 SynchronousQueue 实现的队列，\n                // 否则将使用 LinkedBlockingQueue 实现的队列。\n                @HystrixProperty(name = "maxQueueSize", value = "-1"),\n                // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。\n                // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue\n                // 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。\n                @HystrixProperty(name = "queueSizeRejectionThreshold", value = "5"),\n        }\n)\npublic String strConsumer() {\n    return "hello 2020";\n}\npublic String str_fallbackMethod()\n{\n    return "*****fall back str_fallbackMethod";\n}\n \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n\n# 十四.hystrix工作流程\n\nhystrix官网\n\nhystrix的执行流程图：\n\n\n\nhystrix步骤说明：\n\n1 创建 HystrixCommand（用在依赖的服务返回单个操作结果的时候） 或 HystrixObserableCommand（用在依赖的服务返回多个操作结果的时候） 对象。 2 命令执行。其中 HystrixComand 实现了下面前两种执行方式；而 HystrixObservableCommand 实现了后两种执行方式：execute()：同步执行，从依赖的服务返回一个单一的结果对象， 或是在发生错误的时候抛出异常。queue()：异步执行， 直接返回 一个Future对象， 其中包含了服务执行结束时要返回的单一结果对象。observe()：返回 Observable 对象，它代表了操作的多个结果，它是一个 Hot Obserable（不论 "事件源" 是否有 "订阅者"，都会在创建后对事件进行发布，所以对于 Hot Observable 的每一个 "订阅者" 都有可能是从 "事件源" 的中途开始的，并可能只是看到了整个操作的局部过程）。toObservable()： 同样会返回 Observable 对象，也代表了操作的多个结果，但它返回的是一个Cold Observable（没有 "订阅者" 的时候并不会发布事件，而是进行等待，直到有 "订阅者" 之后才发布事件，所以对于 Cold Observable 的订阅者，它可以保证从一开始看到整个操作的全部过程）。 3 若当前命令的请求缓存功能是被启用的， 并且该命令缓存命中， 那么缓存的结果会立即以 Observable 对象的形式 返回。 4 检查断路器是否为打开状态。如果断路器是打开的，那么Hystrix不会执行命令，而是转接到 fallback 处理逻辑（第 8 步）；如果断路器是关闭的，检查是否有可用资源来执行命令（第 5 步）。 5 线程池/请求队列/信号量是否占满。如果命令依赖服务的专有线程池和请求队列，或者信号量（不使用线程池的时候）已经被占满， 那么 Hystrix 也不会执行命令， 而是转接到 fallback 处理逻辑（第8步）。 6 Hystrix 会根据我们编写的方法来决定采取什么样的方式去请求依赖服务。HystrixCommand.run() ：返回一个单一的结果，或者抛出异常。HystrixObservableCommand.construct()： 返回一个Observable 对象来发射多个结果，或通过 onError 发送错误通知。 7 Hystrix会将 "成功"、"失败"、"拒绝"、"超时" 等信息报告给断路器， 而断路器会维护一组计数器来统计这些数据。断路器会使用这些统计数据来决定是否要将断路器打开，来对某个依赖服务的请求进行 "熔断/短路"。 8 当命令执行失败的时候， Hystrix 会进入 fallback 尝试回退处理， 我们通常也称该操作为 "服务降级"。而能够引起服务降级处理的情况有下面几种：第4步： 当前命令处于"熔断/短路"状态，断路器是打开的时候。第5步： 当前命令的线程池、 请求队列或 者信号量被占满的时候。第6步：HystrixObservableCommand.construct() 或 HystrixCommand.run() 抛出异常的时候。 9 当Hystrix命令执行成功之后， 它会将处理结果直接返回或是以Observable 的形式返回。\n\n> tips：如果我们没有为命令实现降级逻辑或者在降级处理逻辑中抛出了异常， Hystrix 依然会返回一个 Observable 对象， 但是它不会发射任何结果数据， 而是通过 onError 方法通知命令立即中断请求，并通过onError()方法将引起命令失败的异常发送给调用者。\n\n\n# 十五.服务监控hystrixDashboard\n\n除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard），Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。\n\n\n# 1.新建hystrixDashboard模块\n\n1.新建cloud-consumer-hystrix-dashboard9001模块\n\n2.导入依赖\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n        </dependency>\n        \x3c!--重要--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n3.yml文件\n\nserver:\n  port: 9001\n\n\n1\n2\n\n\n4.主启动类\n\n@EnableHystrixDashboard//开启HystrixDashboard\n\n\n1\n\n\n5.哪些服务需要监控，就需要导入依赖，比如8001/8002/8003\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n\n1\n2\n3\n4\n\n\n注意:新版本Hystrix需要在主启动类MainAppHystrix8001中指定监控路径\n\n不然会报错：Unable to connect to Command Metric Stream.\n\n8001主启动类配置HystrixDashboard路径\n\npackage com.wcy.springcloud;\n\nimport com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\nimport org.springframework.context.annotation.Bean;\n\n@SpringBootApplication\n@EnableEurekaClient //本服务启动后会自动注册进eureka服务中\n@EnableCircuitBreaker  //开启服务降级、熔断\npublic class PaymentHystrixMain8001\n{\n    public static void main(String[] args)\n    {\n        SpringApplication.run(PaymentHystrixMain8001.class,args);\n    }\n\n    /**\n     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑\n     *ServletRegistrationBean因为springboot的默认路径不是"/hystrix.stream"，\n     *只要在自己的项目里配置上下面的servlet就可以了\n     */\n    @Bean\n    public ServletRegistrationBean getServlet() {\n        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();\n        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);\n        registrationBean.setLoadOnStartup(1);\n        registrationBean.addUrlMappings("/hystrix.stream");\n        registrationBean.setName("HystrixMetricsStreamServlet");\n        return registrationBean;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 2.测试\n\n输入地址：http://localhost:9001/hystrix\n\n先输入：http://localhost:8001/payment/circuit/31正确的地址，再输入错误的地址http://localhost:8001/payment/circuit/-31，最后通过http://localhost:9001/hystrix查看熔断情况；\n\n\n# 3.监控如何查看\n\n\n\n',normalizedContent:'# hystrix豪猪哥\n\n> https://github.com/netflix/hystrix/wiki/how-to-use 官方文档\n\n\n# 一.分布式架构存在的问题\n\n> 复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。\n\n服务雪崩（服务于服务之间的调用）\n\n多个微服务之间调用的时候，假设微服务a调用微服务b和微服务c，微服务b和微服务c又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务a的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.\n\n对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。 所以： 通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。\n\n\n# 二.hystrix是什么\n\nhystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。\n\n“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（fallback），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\n\n# 三.hystrix能干嘛\n\n 1. 服务降级fallback：当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理fallback，从而释放服务器资源以保证核心交易正常运作或高效运作。\n    \n    哪些情况会出发降级？\n    \n    * 程序运行异常\n    * 超时\n    * 服务熔断触发服务降级\n    * 线程池/信号量打满也会导致服务降级\n\n 2. 服务熔断break：在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用，然后调用服务降级的方法并返回友好提示\n    \n    > 服务的降级->进而熔断->恢复调用链路\n\n 3. 接近实时的监控\n\n 4. 服务限流flowlimit：秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟n个，有序进行\n\n 5. 服务隔离\n\n\n# 四.hystrix停更维护\n\n> hystrix已经停更维护，但是其设计思想值得学习，后面的alibab sentinel也是借鉴了hystrix\n\n官网资料：https://github.com/netflix/hystrix/wiki/how-to-use\n\n\n# 五.cloud搭建环境\n\n 1. 新建模块：cloud-provider-hystrix-payment8001\n\n 2. pom文件\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <project xmlns="http://maven.apache.org/pom/4.0.0"\n             xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n             xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n        <parent>\n            <artifactid>cloudstudy</artifactid>\n            <groupid>com.wcy.springcloud</groupid>\n            <version>1.0-snapshot</version>\n        </parent>\n        <modelversion>4.0.0</modelversion>\n    \n        <artifactid>cloud-provider-hystrix-payment8001</artifactid>\n    \n        <dependencies>\n            \x3c!--hystrix--\x3e\n            <dependency>\n                <groupid>org.springframework.cloud</groupid>\n                <artifactid>spring-cloud-starter-netflix-hystrix</artifactid>\n            </dependency>\n            \x3c!--eureka client--\x3e\n            <dependency>\n                <groupid>org.springframework.cloud</groupid>\n                <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n            </dependency>\n            \x3c!--web--\x3e\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-web</artifactid>\n            </dependency>\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-actuator</artifactid>\n            </dependency>\n            <dependency>\x3c!-- 引入自己定义的api通用包，可以使用payment支付entity --\x3e\n                <groupid>com.wcy.springcloud</groupid>\n                <artifactid>cloud-api-commons</artifactid>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-devtools</artifactid>\n                <scope>runtime</scope>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupid>org.projectlombok</groupid>\n                <artifactid>lombok</artifactid>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-test</artifactid>\n                <scope>test</scope>\n            </dependency>\n        </dependencies>\n    \n    </project>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    \n\n 3. yml文件\n    \n    server:\n      port: 8001\n    \n    spring:\n      application:\n        name: cloud-provider-hystrix-payment\n    \n    eureka:\n      client:\n        register-with-eureka: true\n        fetch-registry: true\n        service-url:\n          defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n          #defaultzone: http://eureka7001.com:7001/eureka\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n 4. 主启动类\n    \n    package com.wcy.springcloud;\n    import org.springframework.boot.springapplication;\n    import org.springframework.boot.autoconfigure.springbootapplication;\n    import org.springframework.cloud.netflix.eureka.enableeurekaclient;\n    \n    @springbootapplication\n    @enableeurekaclient //本服务启动后会自动注册进eureka服务中\n    public class paymenthystrixmain8001\n    {\n        public static void main(string[] args)\n        {\n            springapplication.run(paymenthystrixmain8001.class,args);\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 5. 业务类：\n    \n    service层：\n    \n    package com.wcy.springcloud.service;\n    \n    import org.springframework.stereotype.service;\n    \n    @service\n    public class paymentservice {\n        public string paymentinfo_ok(integer id){\n            return "线程池："+thread.currentthread().getname()+"paymentinfo_ok,id: "+id+"\\t"+"o(∩_∩)o";\n        }\n        public string paymentinfo_timeout(integer id){\n            integer timeout=3000;\n            try {\n                thread.sleep(timeout);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            return "线程池："+thread.currentthread().getname()+"paymentinfo_timeout,id: "+id+"\\t"+"o(∩_∩)o 休眠（秒）："+timeout;\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n    \n    controller层：\n    \n    package com.wcy.springcloud.controller;\n    \n    import com.wcy.springcloud.service.paymentservice;\n    import lombok.extern.slf4j.slf4j;\n    import org.springframework.beans.factory.annotation.autowired;\n    import org.springframework.web.bind.annotation.getmapping;\n    import org.springframework.web.bind.annotation.pathvariable;\n    import org.springframework.web.bind.annotation.restcontroller;\n    \n    @restcontroller\n    @slf4j\n    public class paymentcontroller {\n        @autowired\n        private paymentservice paymentservice;\n    \n        @getmapping("/payment/hystrix/ok/{id}")\n        public string paymentok(@pathvariable("id") integer id){\n            return paymentservice.paymentinfo_ok(id);\n        }\n    \n        @getmapping("/payment/hystrix/timeout/{id}")\n        public string paymenttimeout(@pathvariable("id") integer id){\n            return paymentservice.paymentinfo_timeout(id);\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    \n\n 6. 测试：\n    \n    1. http://localhost:8001/payment/hystrix/ok/1 ：马上访问成功\n    2. http://localhost:8001/payment/hystrix/timeout/2 ：延迟三秒钟\n\n\n# 六.使用jmeter测试\n\n\n# 6.1.jmeter使用步骤：\n\n 1. 创建线程组\n    \n    \n\n 2. 设置20000的并发\n    \n    \n\n 3. 创建http请求\n    \n    \n    \n    \n\n\n# 6.2.测试结果\n\n> jmeter并发20000访问http://localhost:8001/payment/hystrix/timeout/2接口，我们去访问正常的http://localhost:8001/payment/hystrix/ok/1的接口，两个都在自己转圈圈，也会出现延迟？\n> \n> 那是因为tomcat最小线程数是10,并发最高只支持200，而我们的并发是20000，所以导致后续正常的接口也会出现问题。\n\n\n# 七.引入消费者80端\n\n 1. 新建模块：cloud-consumer-feign-hystrix-order80\n\n 2. pom文件\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <project xmlns="http://maven.apache.org/pom/4.0.0"\n             xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n             xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n        <parent>\n            <artifactid>cloudstudy</artifactid>\n            <groupid>com.wcy.springcloud</groupid>\n            <version>1.0-snapshot</version>\n        </parent>\n        <modelversion>4.0.0</modelversion>\n    \n        <artifactid>cloud-consumer-feign-hystrix-order80</artifactid>\n    \n        <dependencies>\n            \x3c!--openfeign--\x3e\n            <dependency>\n                <groupid>org.springframework.cloud</groupid>\n                <artifactid>spring-cloud-starter-openfeign</artifactid>\n            </dependency>\n            \x3c!--hystrix--\x3e\n            <dependency>\n                <groupid>org.springframework.cloud</groupid>\n                <artifactid>spring-cloud-starter-netflix-hystrix</artifactid>\n            </dependency>\n            \x3c!--eureka client--\x3e\n            <dependency>\n                <groupid>org.springframework.cloud</groupid>\n                <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n            </dependency>\n            \x3c!-- 引入自己定义的api通用包，可以使用payment支付entity --\x3e\n            <dependency>\n                <groupid>com.wcy.springcloud</groupid>\n                <artifactid>cloud-api-commons</artifactid>\n                <version>1.0-snapshot</version>\n            </dependency>\n            \x3c!--web--\x3e\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-web</artifactid>\n            </dependency>\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-actuator</artifactid>\n            </dependency>\n            \x3c!--一般基础通用配置--\x3e\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-devtools</artifactid>\n                <scope>runtime</scope>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupid>org.projectlombok</groupid>\n                <artifactid>lombok</artifactid>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-test</artifactid>\n                <scope>test</scope>\n            </dependency>\n        </dependencies>\n    \n    \n    </project>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    \n\n 3. yml文件\n    \n    server:\n      port: 80\n    \n    eureka:\n      client:\n        register-with-eureka: false\n        service-url:\n          defaultzone: http://eureka7001.com:7001/eureka/,http://eureka7001.com:7002/eureka/\n    \n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 4. 主启动类\n    \n    package com.wcy.springcloud;\n    import org.springframework.boot.springapplication;\n    import org.springframework.boot.autoconfigure.springbootapplication;\n    import org.springframework.cloud.openfeign.enablefeignclients;\n    \n    /**\n     * @auther zzyy\n     * @create 2020-02-04 16:32\n     */\n    @springbootapplication\n    @enablefeignclients  //开启fegin接口\n    public class orderhystrixmain80\n    {\n        public static void main(string[] args)\n        {\n            springapplication.run(orderhystrixmain80.class,args);\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    \n\n 5. feign接口，调用8001后端服务\n    \n    package com.wcy.springcloud.service;\n    \n    import org.springframework.cloud.openfeign.feignclient;\n    import org.springframework.stereotype.component;\n    import org.springframework.web.bind.annotation.getmapping;\n    import org.springframework.web.bind.annotation.pathvariable;\n    \n    @component\n    @feignclient(value = "cloud-provider-hystrix-payment")\n    public interface paymentfeign {\n        @getmapping("/payment/hystrix/ok/{id}")\n        public string paymentok(@pathvariable("id") integer id);\n    \n        @getmapping("/payment/hystrix/timeout/{id}")\n        public string paymenttimeout(@pathvariable("id") integer id);\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 6. 80消费者controller层\n    \n    package com.wcy.springcloud.controller;\n    \n    import com.wcy.springcloud.service.paymentfeign;\n    import lombok.extern.slf4j.slf4j;\n    import org.springframework.beans.factory.annotation.autowired;\n    import org.springframework.web.bind.annotation.getmapping;\n    import org.springframework.web.bind.annotation.pathvariable;\n    import org.springframework.web.bind.annotation.restcontroller;\n    \n    @restcontroller\n    @slf4j\n    public class ordercontroller {\n        @autowired\n        private paymentfeign paymentfeign;\n    \n        @getmapping("/consumer/payment/hystrix/ok/{id}")\n        public string paymentok(@pathvariable("id") integer id){\n            log.info("进入paymentok方法:"+id);\n            return paymentfeign.paymentok(id);\n        }\n    \n        @getmapping("/consumer/payment/hystrix/timeout/{id}")\n        public string paymenttimeout(@pathvariable("id") integer id){\n            log.info("进入paymenttimeout方法:"+id);\n            return paymentfeign.paymenttimeout(id);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    \n\n\n# 八.解决的问题\n\n问题：\n\n>  1. 超时导致服务器变慢(转圈)，超时不再等待\n>  2. 出错(宕机或程序运行出错)，出错要有兜底\n\n解决：\n\n>  1. 对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级\n>  2. 对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级\n>  3. 对方服务(8001)ok，调用者(80)自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级\n\n\n# 九.解决方法\n\n> 我们自己配置过的热部署方式对java代码的改动明显， 但对@hystrixcommand内属性的修改建议重启微服务\n\n\n# 9.1.服务器8001的兜底fallback实现\n\n 1. 主启动类开启服务降级和熔断\n    \n    package com.wcy.springcloud;\n    import org.springframework.boot.springapplication;\n    import org.springframework.boot.autoconfigure.springbootapplication;\n    import org.springframework.cloud.client.circuitbreaker.enablecircuitbreaker;\n    import org.springframework.cloud.netflix.eureka.enableeurekaclient;\n    \n    @springbootapplication\n    @enableeurekaclient //本服务启动后会自动注册进eureka服务中\n    @enablecircuitbreaker  //开启服务降级、熔断\n    public class paymenthystrixmain8001\n    {\n        public static void main(string[] args)\n        {\n            springapplication.run(paymenthystrixmain8001.class,args);\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 2. service实现兜底的方法\n    \n    paymentinfo_timeout：报错和时间超过三秒会直接走兜底的方法。\n    \n    package com.wcy.springcloud.service;\n    \n    import com.netflix.hystrix.contrib.javanica.annotation.hystrixcommand;\n    import com.netflix.hystrix.contrib.javanica.annotation.hystrixproperty;\n    import org.springframework.stereotype.service;\n    \n    @service\n    public class paymentservice {\n    \n        /**\n         * hystrix服务降级：异常也会走兜底方法\n         * fallbackmethod ：服务出错的兜底方法\n         * commandproperties：设置出错规则，比如时间超过三秒则执行兜底方法\n         * @param id\n         * @return\n         */\n        @hystrixcommand(fallbackmethod = "paymentinfo_timeouthandler",commandproperties = {\n                @hystrixproperty(name="execution.isolation.thread.timeoutinmilliseconds",value="3000")\n        })\n        public string paymentinfo_timeout(integer id){\n        //        int a=10/0;\n            integer timeout=5000;\n            try {\n                thread.sleep(timeout);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            return "线程池："+thread.currentthread().getname()+"paymentinfo_timeout,id: "+id+"\\t"+"o(∩_∩)o 休眠（秒）："+timeout;\n        }\n    \n        public string paymentinfo_timeouthandler(integer id){\n            return "线程池："+thread.currentthread().getname()+"请求失败，请重试";\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    \n\n\n# 9.2.客户端80的兜底fallback实现\n\n 1. 引入依赖\n    \n            \x3c!--hystrix--\x3e\n            <dependency>\n                <groupid>org.springframework.cloud</groupid>\n                <artifactid>spring-cloud-starter-netflix-hystrix</artifactid>\n            </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 修改pom\n    \n    server:\n      port: 80\n    \n    eureka:\n      client:\n        register-with-eureka: false\n        service-url:\n          defaultzone: http://eureka7001.com:7001/eureka/,http://eureka7001.com:7002/eureka/\n    \n    #设置feign客户端超时时间(openfeign默认支持ribbon)\n    ribbon:\n      #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间\n      readtimeout: 6000\n      #指的是建立连接后从服务器读取到可用资源所用的时间\n      connecttimeout: 6000\n    \n    #开启hystrix\n    feign:\n      hystrix:\n        enabled: true\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n 3. 主启动类开启hystrix\n    \n    @enablehystrix  //开启hystrix\n    \n    \n    1\n    \n\n 4. controller实现兜底方法\n    \n        @getmapping("/consumer/payment/hystrix/timeout/{id}")\n        @hystrixcommand(fallbackmethod="paymenttimeouthandler",commandproperties = {\n                @hystrixproperty(name="execution.isolation.thread.timeoutinmilliseconds",value="1500")\n        })\n        public string paymenttimeout(@pathvariable("id") integer id){\n            int a=10/0;\n            log.info("进入paymenttimeout方法:"+id);\n            return paymentfeign.paymenttimeout(id);\n        }\n    \n        /**\n         * 兜底方法\n         * @param id\n         * @return\n         */\n        public string paymenttimeouthandler(@pathvariable("id") integer id){\n            return "我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o";\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n\n\n# 十.通用fallback(推荐十一)\n\n问题：上面每个业务方法对应一个兜底的方法，代码膨胀\n\n解决：统一和自定义的分开\n\n 1. controller设置全局处理fallback\n    \n    //该controller默认的丢底方法\n    @defaultproperties(defaultfallback="payment_global_fallbackmethod",commandproperties = {\n            @hystrixproperty(name="execution.isolation.thread.timeoutinmilliseconds",value="1500")\n    })\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. controller中兜底的方法\n    \n        /**\n         * 全局兜底方法\n         * @return\n         */\n        public string payment_global_fallbackmethod()\n        {\n            return "global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~";\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. controller的使用方法\n    \n        // 开启hystrix的兜底方法\n        @hystrixcommand\n        public string paymenttimeout(@pathvariable("id") integer id){\n    //        int a=10/0;\n            log.info("进入paymenttimeout方法:"+id);\n            return paymentfeign.paymenttimeout(id);\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n所有的配置：\n\n \npackage com.atguigu.springcloud.controller;\n\nimport com.atguigu.springcloud.service.paymenthystrixservice;\nimport com.netflix.hystrix.contrib.javanica.annotation.defaultproperties;\nimport com.netflix.hystrix.contrib.javanica.annotation.hystrixcommand;\nimport com.netflix.hystrix.contrib.javanica.annotation.hystrixproperty;\nimport lombok.extern.slf4j.slf4j;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.pathvariable;\nimport org.springframework.web.bind.annotation.restcontroller;\n\nimport javax.annotation.resource;\n\n/**\n * @auther zzyy\n * @create 2020-02-04 16:35\n */\n@restcontroller\n@slf4j\n@defaultproperties(defaultfallback = "payment_global_fallbackmethod")\npublic class paymenthystirxcontroller\n{\n    @resource\n    private paymenthystrixservice paymenthystrixservice;\n\n    @getmapping("/consumer/payment/hystrix/ok/{id}")\n    public string paymentinfo_ok(@pathvariable("id") integer id)\n    {\n        string result = paymenthystrixservice.paymentinfo_ok(id);\n        return result;\n    }\n\n    @getmapping("/consumer/payment/hystrix/timeout/{id}")\n    @hystrixcommand //加了@defaultproperties属性注解，并且没有写具体方法名字，就用统一全局的\n    public string paymentinfo_timeout(@pathvariable("id") integer id)\n    {\n        string result = paymenthystrixservice.paymentinfo_timeout(id);\n        return result;\n    }\n    public string paymenttimeoutfallbackmethod(@pathvariable("id") integer id)\n    {\n        return "paymenttimeoutfallbackmethod,对方系统繁忙，请10秒钟后再次尝试/(ㄒoㄒ)/";\n    }\n\n    public string payment_global_fallbackmethod()\n    {\n        return "global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~";\n    }\n}\n \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 十一.业务和回调解耦\n\n本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系。 只需要为feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦\n\n未来面对的异常：\n\n 1. 运行时异常\n 2. 超时\n 3. 宕机\n\n\n# 1.实现feign接口，实现方法的回调\n\npackage com.wcy.springcloud.service;\n\nimport org.springframework.stereotype.component;\n\n@component\npublic class paymentfallbackfeign implements paymentfeign{\n    @override\n    public string paymentok(integer id) {\n        return "服务调用失败，提示来自：cloud-consumer-feign-order80";\n    }\n\n    @override\n    public string paymenttimeout(integer id) {\n        return "服务调用失败，提示来自：cloud-consumer-feign-order80";\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2.yml文件\n\nserver:\n  port: 80\n\neureka:\n  client:\n    register-with-eureka: false\n    service-url:\n      defaultzone: http://eureka7001.com:7001/eureka/,http://eureka7001.com:7002/eureka/\n\n#设置feign客户端超时时间(openfeign默认支持ribbon)\nribbon:\n  #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间\n  readtimeout: 6000\n  #指的是建立连接后从服务器读取到可用资源所用的时间\n  connecttimeout: 6000\n\n#开启hystrix\nfeign:\n  hystrix:\n    enabled: true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 3.feign接口指定回调的类\n\n@component\n@feignclient(value = "cloud-provider-hystrix-payment",fallback = paymentfallbackfeign.class)\npublic interface paymentfeign {\n    @getmapping("/payment/hystrix/ok/{id}")\n    public string paymentok(@pathvariable("id") integer id);\n\n    @getmapping("/payment/hystrix/timeout/{id}")\n    public string paymenttimeout(@pathvariable("id") integer id);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4.测试\n\n关闭生产者8001、或8001出现错误等等都会调用兜底方法\n\n\n# 十二.服务熔断\n\n断路器：一句话就是家里的保险丝\n\n熔断机制概述： 熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时， 会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。 当检测到该节点微服务调用响应正常后，恢复调用链路。\n\n在spring cloud框架里，熔断机制通过hystrix实现。hystrix会监控微服务间调用的状况， 当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。\n\n熔断机制的注解是@hystrixcommand。\n\n在生产者8001实现服务熔断：\n\n\n# 1.导入依赖\n\n        \x3c!--hystrix--\x3e\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-netflix-hystrix</artifactid>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.server层实现hystrixcommand\n\n//10秒窗口期10次请求中有百分之60出错，那么会触发断路器\n\n@hystrixproperty(name = "circuitbreaker.enabled",value = "true"),//开启服务熔断\n\n@hystrixproperty(name = "circuitbreaker.requestvolumethreshold",value = "10"),//请求次数\n\n@hystrixproperty(name = "circuitbreaker.sleepwindowinmilliseconds",value = "10000"),//10秒\n\n@hystrixproperty(name = "circuitbreaker.errorthresholdpercentage",value = "60"),//错误率百分之60\n\n    @hystrixcommand(fallbackmethod = "paymentcircuitbreaker_fallback",commandproperties = {\n            //10秒窗口期10次请求中有百分之60出错，那么会触发断路器\n            @hystrixproperty(name = "circuitbreaker.enabled",value = "true"),//开启服务熔断\n            @hystrixproperty(name = "circuitbreaker.requestvolumethreshold",value = "10"),//请求次数\n            @hystrixproperty(name = "circuitbreaker.sleepwindowinmilliseconds",value = "10000"),//10秒\n            @hystrixproperty(name = "circuitbreaker.errorthresholdpercentage",value = "60"),//错误率百分之60\n    })\n    public string paymentcircuitbreaker(integer id){\n        if(id<0){\n            throw new runtimeexception("id不能小于0");\n        }\n        return "线程池："+thread.currentthread().getname()+"id: "+ idutil.simpleuuid() +"\\t"+"o(∩_∩)o";\n    }\n    public string paymentcircuitbreaker_fallback(integer id){\n        return "id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: " +id;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 3.controller调用\n\n    /**\n     * 测试服务熔断\n     * @param id\n     * @return\n     */\n    @getmapping("/payment/circuit/{id}")\n    public string paymentcircuitbreaker(@pathvariable("id") integer id){\n        string result = paymentservice.paymentcircuitbreaker(id);\n        log.info(result);\n        return result;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4.测试\n\n先使用：http://localhost:8001/payment/circuit/-1，疯狂点会看到一直走的兜底方法，然后再访问http://localhost:8001/payment/circuit/1，发现也会走兜底方法，发现服务熔断生效，持续访问正确的地址，会发现断路器会慢慢关闭，就可以正常访问。\n\n\n# 十三.服务熔断总结\n\n\n# 1.熔断类型\n\n 1. 熔断打开：请求不再进行调用当前服务，内部设置时钟一般为mttr（平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态\n 2. 熔断关闭：熔断关闭不会对服务进行熔断\n 3. 熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断\n\n\n# 2.断路器生效条件\n\n\n\n涉及到断路器的三个重要参数：快照时间窗、请求总数阀值、错误百分比阀值。\n\n 1. 快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。\n 2. 请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。\n 3. 错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。\n\n\n\n\n# 3.断路器打开后：\n\n1：再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。\n\n2：原来的主逻辑要如何恢复呢？ 对于这一问题，hystrix也为我们实现了自动恢复功能。 当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑， 当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合， 主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。\n\n\n# 4.熔断的配置\n\n//========================all\n@hystrixcommand(fallbackmethod = "str_fallbackmethod",\n        groupkey = "strgroupcommand",\n        commandkey = "strcommand",\n        threadpoolkey = "strthreadpool",\n\n        commandproperties = {\n                // 设置隔离策略，thread 表示线程池 semaphore：信号池隔离\n                @hystrixproperty(name = "execution.isolation.strategy", value = "thread"),\n                // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）\n                @hystrixproperty(name = "execution.isolation.semaphore.maxconcurrentrequests", value = "10"),\n                // 配置命令执行的超时时间\n                @hystrixproperty(name = "execution.isolation.thread.timeoutinmilliseconds", value = "10"),\n                // 是否启用超时时间\n                @hystrixproperty(name = "execution.timeout.enabled", value = "true"),\n                // 执行超时的时候是否中断\n                @hystrixproperty(name = "execution.isolation.thread.interruptontimeout", value = "true"),\n                // 执行被取消的时候是否中断\n                @hystrixproperty(name = "execution.isolation.thread.interruptoncancel", value = "true"),\n                // 允许回调方法执行的最大并发数\n                @hystrixproperty(name = "fallback.isolation.semaphore.maxconcurrentrequests", value = "10"),\n                // 服务降级是否启用，是否执行回调函数\n                @hystrixproperty(name = "fallback.enabled", value = "true"),\n                // 是否启用断路器\n                @hystrixproperty(name = "circuitbreaker.enabled", value = "true"),\n                // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，\n                // 如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。\n                @hystrixproperty(name = "circuitbreaker.requestvolumethreshold", value = "20"),\n                // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过\n                // circuitbreaker.requestvolumethreshold 的情况下，如果错误请求数的百分比超过50,\n                // 就把断路器设置为 "打开" 状态，否则就设置为 "关闭" 状态。\n                @hystrixproperty(name = "circuitbreaker.errorthresholdpercentage", value = "50"),\n                // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，\n                // 会将断路器置为 "半开" 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 "打开" 状态，\n                // 如果成功就设置为 "关闭" 状态。\n                @hystrixproperty(name = "circuitbreaker.sleepwindowinmilliseconds", value = "5000"),\n                // 断路器强制打开\n                @hystrixproperty(name = "circuitbreaker.forceopen", value = "false"),\n                // 断路器强制关闭\n                @hystrixproperty(name = "circuitbreaker.forceclosed", value = "false"),\n                // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间\n                @hystrixproperty(name = "metrics.rollingstats.timeinmilliseconds", value = "10000"),\n                // 该属性用来设置滚动时间窗统计指标信息时划分"桶"的数量，断路器在收集指标信息的时候会根据\n                // 设置的时间窗长度拆分成多个 "桶" 来累计各度量值，每个"桶"记录了一段时间内的采集指标。\n                // 比如 10 秒内拆分成 10 个"桶"收集这样，所以 timeinmilliseconds 必须能被 numbuckets 整除。否则会抛异常\n                @hystrixproperty(name = "metrics.rollingstats.numbuckets", value = "10"),\n                // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 -1。\n                @hystrixproperty(name = "metrics.rollingpercentile.enabled", value = "false"),\n                // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。\n                @hystrixproperty(name = "metrics.rollingpercentile.timeinmilliseconds", value = "60000"),\n                // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。\n                @hystrixproperty(name = "metrics.rollingpercentile.numbuckets", value = "60000"),\n                // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，\n                // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，\n                // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。\n                @hystrixproperty(name = "metrics.rollingpercentile.bucketsize", value = "100"),\n                // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。\n                @hystrixproperty(name = "metrics.healthsnapshot.intervalinmilliseconds", value = "500"),\n                // 是否开启请求缓存\n                @hystrixproperty(name = "requestcache.enabled", value = "true"),\n                // hystrixcommand的执行和事件是否打印日志到 hystrixrequestlog 中\n                @hystrixproperty(name = "requestlog.enabled", value = "true"),\n        },\n        threadpoolproperties = {\n                // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量\n                @hystrixproperty(name = "coresize", value = "10"),\n                // 该参数用来设置线程池的最大队列大小。当设置为 -1 时，线程池将使用 synchronousqueue 实现的队列，\n                // 否则将使用 linkedblockingqueue 实现的队列。\n                @hystrixproperty(name = "maxqueuesize", value = "-1"),\n                // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。\n                // 该参数主要是对 linkedblockingqueue 队列的补充,因为 linkedblockingqueue\n                // 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。\n                @hystrixproperty(name = "queuesizerejectionthreshold", value = "5"),\n        }\n)\npublic string strconsumer() {\n    return "hello 2020";\n}\npublic string str_fallbackmethod()\n{\n    return "*****fall back str_fallbackmethod";\n}\n \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n\n# 十四.hystrix工作流程\n\nhystrix官网\n\nhystrix的执行流程图：\n\n\n\nhystrix步骤说明：\n\n1 创建 hystrixcommand（用在依赖的服务返回单个操作结果的时候） 或 hystrixobserablecommand（用在依赖的服务返回多个操作结果的时候） 对象。 2 命令执行。其中 hystrixcomand 实现了下面前两种执行方式；而 hystrixobservablecommand 实现了后两种执行方式：execute()：同步执行，从依赖的服务返回一个单一的结果对象， 或是在发生错误的时候抛出异常。queue()：异步执行， 直接返回 一个future对象， 其中包含了服务执行结束时要返回的单一结果对象。observe()：返回 observable 对象，它代表了操作的多个结果，它是一个 hot obserable（不论 "事件源" 是否有 "订阅者"，都会在创建后对事件进行发布，所以对于 hot observable 的每一个 "订阅者" 都有可能是从 "事件源" 的中途开始的，并可能只是看到了整个操作的局部过程）。toobservable()： 同样会返回 observable 对象，也代表了操作的多个结果，但它返回的是一个cold observable（没有 "订阅者" 的时候并不会发布事件，而是进行等待，直到有 "订阅者" 之后才发布事件，所以对于 cold observable 的订阅者，它可以保证从一开始看到整个操作的全部过程）。 3 若当前命令的请求缓存功能是被启用的， 并且该命令缓存命中， 那么缓存的结果会立即以 observable 对象的形式 返回。 4 检查断路器是否为打开状态。如果断路器是打开的，那么hystrix不会执行命令，而是转接到 fallback 处理逻辑（第 8 步）；如果断路器是关闭的，检查是否有可用资源来执行命令（第 5 步）。 5 线程池/请求队列/信号量是否占满。如果命令依赖服务的专有线程池和请求队列，或者信号量（不使用线程池的时候）已经被占满， 那么 hystrix 也不会执行命令， 而是转接到 fallback 处理逻辑（第8步）。 6 hystrix 会根据我们编写的方法来决定采取什么样的方式去请求依赖服务。hystrixcommand.run() ：返回一个单一的结果，或者抛出异常。hystrixobservablecommand.construct()： 返回一个observable 对象来发射多个结果，或通过 onerror 发送错误通知。 7 hystrix会将 "成功"、"失败"、"拒绝"、"超时" 等信息报告给断路器， 而断路器会维护一组计数器来统计这些数据。断路器会使用这些统计数据来决定是否要将断路器打开，来对某个依赖服务的请求进行 "熔断/短路"。 8 当命令执行失败的时候， hystrix 会进入 fallback 尝试回退处理， 我们通常也称该操作为 "服务降级"。而能够引起服务降级处理的情况有下面几种：第4步： 当前命令处于"熔断/短路"状态，断路器是打开的时候。第5步： 当前命令的线程池、 请求队列或 者信号量被占满的时候。第6步：hystrixobservablecommand.construct() 或 hystrixcommand.run() 抛出异常的时候。 9 当hystrix命令执行成功之后， 它会将处理结果直接返回或是以observable 的形式返回。\n\n> tips：如果我们没有为命令实现降级逻辑或者在降级处理逻辑中抛出了异常， hystrix 依然会返回一个 observable 对象， 但是它不会发射任何结果数据， 而是通过 onerror 方法通知命令立即中断请求，并通过onerror()方法将引起命令失败的异常发送给调用者。\n\n\n# 十五.服务监控hystrixdashboard\n\n除了隔离依赖服务的调用以外，hystrix还提供了准实时的调用监控（hystrix dashboard），hystrix会持续地记录所有通过hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。spring cloud也提供了hystrix dashboard的整合，对监控内容转化成可视化界面。\n\n\n# 1.新建hystrixdashboard模块\n\n1.新建cloud-consumer-hystrix-dashboard9001模块\n\n2.导入依赖\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-netflix-hystrix-dashboard</artifactid>\n        </dependency>\n        \x3c!--重要--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n3.yml文件\n\nserver:\n  port: 9001\n\n\n1\n2\n\n\n4.主启动类\n\n@enablehystrixdashboard//开启hystrixdashboard\n\n\n1\n\n\n5.哪些服务需要监控，就需要导入依赖，比如8001/8002/8003\n\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n\n\n1\n2\n3\n4\n\n\n注意:新版本hystrix需要在主启动类mainapphystrix8001中指定监控路径\n\n不然会报错：unable to connect to command metric stream.\n\n8001主启动类配置hystrixdashboard路径\n\npackage com.wcy.springcloud;\n\nimport com.netflix.hystrix.contrib.metrics.eventstream.hystrixmetricsstreamservlet;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.boot.web.servlet.servletregistrationbean;\nimport org.springframework.cloud.client.circuitbreaker.enablecircuitbreaker;\nimport org.springframework.cloud.netflix.eureka.enableeurekaclient;\nimport org.springframework.context.annotation.bean;\n\n@springbootapplication\n@enableeurekaclient //本服务启动后会自动注册进eureka服务中\n@enablecircuitbreaker  //开启服务降级、熔断\npublic class paymenthystrixmain8001\n{\n    public static void main(string[] args)\n    {\n        springapplication.run(paymenthystrixmain8001.class,args);\n    }\n\n    /**\n     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑\n     *servletregistrationbean因为springboot的默认路径不是"/hystrix.stream"，\n     *只要在自己的项目里配置上下面的servlet就可以了\n     */\n    @bean\n    public servletregistrationbean getservlet() {\n        hystrixmetricsstreamservlet streamservlet = new hystrixmetricsstreamservlet();\n        servletregistrationbean registrationbean = new servletregistrationbean(streamservlet);\n        registrationbean.setloadonstartup(1);\n        registrationbean.addurlmappings("/hystrix.stream");\n        registrationbean.setname("hystrixmetricsstreamservlet");\n        return registrationbean;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 2.测试\n\n输入地址：http://localhost:9001/hystrix\n\n先输入：http://localhost:8001/payment/circuit/31正确的地址，再输入错误的地址http://localhost:8001/payment/circuit/-31，最后通过http://localhost:9001/hystrix查看熔断情况；\n\n\n# 3.监控如何查看\n\n\n\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"Bus消息总线",frontmatter:{title:"Bus消息总线",date:"2021-08-23T17:36:43.000Z",permalink:"/pages/c29287/",categories:["后端","Spring全家桶","SpringCloud"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/14.Bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/14.Bus消息总线.md",key:"v-01fcb9f0",path:"/pages/c29287/",headers:[{level:2,title:"1.BUS能干什么？",slug:"_1-bus能干什么",normalizedTitle:"1.bus能干什么？",charIndex:14},{level:2,title:"2.架构",slug:"_2-架构",normalizedTitle:"2.架构",charIndex:165},{level:2,title:"3.BUG能干嘛",slug:"_3-bug能干嘛",normalizedTitle:"3.bug能干嘛",charIndex:339},{level:2,title:"4.什么是总线",slug:"_4-什么是总线",normalizedTitle:"4.什么是总线",charIndex:430},{level:2,title:"5.docker安装rabbitmq",slug:"_5-docker安装rabbitmq",normalizedTitle:"5.docker安装rabbitmq",charIndex:780},{level:3,title:"1.选择版本，带web管理",slug:"_1-选择版本-带web管理",normalizedTitle:"1.选择版本，带web管理",charIndex:803},{level:3,title:"2.运行rabbitmq",slug:"_2-运行rabbitmq",normalizedTitle:"2.运行rabbitmq",charIndex:873},{level:3,title:"3.安装插件",slug:"_3-安装插件",normalizedTitle:"3.安装插件",charIndex:1012},{level:3,title:"4.访问地址",slug:"_4-访问地址",normalizedTitle:"4.访问地址",charIndex:1119},{level:2,title:"6.以3355为模板再创建一个模块3366",slug:"_6-以3355为模板再创建一个模块3366",normalizedTitle:"6.以3355为模板再创建一个模块3366",charIndex:1166},{level:3,title:"1.新建模块：cloud-config-client-3366",slug:"_1-新建模块-cloud-config-client-3366",normalizedTitle:"1.新建模块：cloud-config-client-3366",charIndex:1192},{level:3,title:"2.导入依赖",slug:"_2-导入依赖",normalizedTitle:"2.导入依赖",charIndex:1228},{level:3,title:"3.配置文件",slug:"_3-配置文件",normalizedTitle:"3.配置文件",charIndex:1239},{level:3,title:"4.主启动类",slug:"_4-主启动类",normalizedTitle:"4.主启动类",charIndex:1250},{level:3,title:"5.业务类",slug:"_5-业务类",normalizedTitle:"5.业务类",charIndex:1261},{level:2,title:"7.设计思想",slug:"_7-设计思想",normalizedTitle:"7.设计思想",charIndex:1271},{level:2,title:"8.一次修改，广播通知，处处生效",slug:"_8-一次修改-广播通知-处处生效",normalizedTitle:"8.一次修改，广播通知，处处生效",charIndex:1526},{level:3,title:"1.给cloud-config-center-3344配置中心服务端添加消息总线支持",slug:"_1-给cloud-config-center-3344配置中心服务端添加消息总线支持",normalizedTitle:"1.给cloud-config-center-3344配置中心服务端添加消息总线支持",charIndex:1547},{level:3,title:"2.给cloud-config-client-3355/cloud-config-client-3366客户端添加消息总线支持",slug:"_2-给cloud-config-client-3355-cloud-config-client-3366客户端添加消息总线支持",normalizedTitle:"2.给cloud-config-client-3355/cloud-config-client-3366客户端添加消息总线支持",charIndex:2802},{level:3,title:"3.测试",slug:"_3-测试",normalizedTitle:"3.测试",charIndex:3999},{level:2,title:"9.动态刷新定点通知",slug:"_9-动态刷新定点通知",normalizedTitle:"9.动态刷新定点通知",charIndex:4372}],headersStr:"1.BUS能干什么？ 2.架构 3.BUG能干嘛 4.什么是总线 5.docker安装rabbitmq 1.选择版本，带web管理 2.运行rabbitmq 3.安装插件 4.访问地址 6.以3355为模板再创建一个模块3366 1.新建模块：cloud-config-client-3366 2.导入依赖 3.配置文件 4.主启动类 5.业务类 7.设计思想 8.一次修改，广播通知，处处生效 1.给cloud-config-center-3344配置中心服务端添加消息总线支持 2.给cloud-config-client-3355/cloud-config-client-3366客户端添加消息总线支持 3.测试 9.动态刷新定点通知",content:'# Bus消息总线\n\n\n# 1.BUS能干什么？\n\n 1. 对config全局配置的补充，上一节config全局配置业务人员修改了git上面的配置，需要手动执行刷新的post请求，分布式自动刷新配置功能\n 2. Spring Cloud Bus 配合 Spring Cloud Config 使用可以实现配置的动态刷新。\n\n\n# 2.架构\n\nSpring Cloud Bus 配合 Spring Cloud Config 使用可以实现配置的动态刷新。\n\n\n\nSpring Cloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架， 它整合了Java的事件处理机制和消息中间件的功能。 Spring Clud Bus目前支持RabbitMQ和Kafka。\n\n\n# 3.BUG能干嘛\n\nSpring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。\n\n\n\n\n# 4.什么是总线\n\n在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。\n\n基本原理 ConfigClient实例都监听MQ中同一个topic(默认是springCloudBus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。\n\nRabbitMQ的学习://www.bilibili.com/video/av55976700?from=search&seid=15010075915728605208\n\n\n# 5.docker安装rabbitmq\n\n\n# 1.选择版本，带web管理\n\ndocker pull rabbitmq:3.7.14-management-alpine\n\n\n1\n\n\n\n# 2.运行rabbitmq\n\ndocker run -d --hostname my-rabbit --name my-rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.7.14-management-alpine\n\n\n1\n\n\n\n# 3.安装插件\n\ndocker ps \ndocker exec -it 镜像ID /bin/bash\nrabbitmq-plugins enable rabbitmq_management\n\n\n1\n2\n3\n\n\n\n# 4.访问地址\n\nhttp://ip:15672，这里的用户名和密码默认都是guest\n\n\n# 6.以3355为模板再创建一个模块3366\n\n\n# 1.新建模块：cloud-config-client-3366\n\n\n# 2.导入依赖\n\n\n# 3.配置文件\n\n\n# 4.主启动类\n\n\n# 5.业务类\n\n\n# 7.设计思想\n\n1）利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置（不推荐）\n\n\n\n2）利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置\n\n\n\n使用第二种的原因：\n\n 1. 打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。\n 2. 破坏了微服务各节点的对等性。\n 3. 有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改\n\n\n# 8.一次修改，广播通知，处处生效\n\n\n# 1.给cloud-config-center-3344配置中心服务端添加消息总线支持\n\n1.导入依赖\n\n\x3c!--添加消息总线RabbitMQ支持--\x3e\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n2.yml中配置\n\n 1. rabbitmq相关配置（注意rabbitmq是在spring下方）\n 2. 暴露bus刷新配置的端点\n\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://gitee.com/wcy_dch/springcloud-config.git #GitHub上面的git仓库名字\n          ####搜索目录\n          search-paths:\n            - springcloud-config\n      ####读取分支\n      label: master\n  #rabbitmq相关配置\n  rabbitmq:\n    host: 192.168.188.128\n    port: 5672\n    username: guest\n    password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n##rabbitmq相关配置,暴露bus刷新配置的端点\nmanagement:\n  endpoints: #暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: \'bus-refresh\'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 2.给cloud-config-client-3355/cloud-config-client-3366客户端添加消息总线支持\n\n1.导入依赖\n\n\x3c!--添加消息总线RabbitMQ支持--\x3e\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2.配置信息\n\n 1. rabbitmq相关配置（注意rabbitmq是在spring下方）\n 2. 暴露bus刷新配置的端点\n\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n  #rabbitmq相关配置\n  rabbitmq:\n    host: 192.168.188.128\n    port: 5672\n    username: guest\n    password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n# 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: "*"   # \'refresh\'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 3.测试\n\n 1. 启动eureka7001、eureka7002 地址：http://localhost:7001/\n 2. 启动ConfigCenterMain3344 地址：http://localhost:3344/master/config-dev.yml\n 3. 启动ConfigClientMain3355、ConfigClientMain3366 地址：http://localhost:3355/config/info\n\n运维人员先修改github上面的版本号，3344再执行actuator/bus-refresh的post请求\n\ncurl -X POST "http://localhost:3344/actuator/bus-refresh"\n\n\n1\n\n\n可以看到3344/3355/3366都同步刷新了版本号。\n\n\n# 9.动态刷新定点通知\n\n只想通过3355，不想通知3366\n\n> 公式：http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}\n> \n> {destination}：微服务名：端口号\n\n比如：\n\ncurl -X POST "http://localhost:3344/actuator/bus-refresh/config-client:3355"\n\n\n1\n',normalizedContent:'# bus消息总线\n\n\n# 1.bus能干什么？\n\n 1. 对config全局配置的补充，上一节config全局配置业务人员修改了git上面的配置，需要手动执行刷新的post请求，分布式自动刷新配置功能\n 2. spring cloud bus 配合 spring cloud config 使用可以实现配置的动态刷新。\n\n\n# 2.架构\n\nspring cloud bus 配合 spring cloud config 使用可以实现配置的动态刷新。\n\n\n\nspring cloud bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架， 它整合了java的事件处理机制和消息中间件的功能。 spring clud bus目前支持rabbitmq和kafka。\n\n\n# 3.bug能干嘛\n\nspring cloud bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。\n\n\n\n\n# 4.什么是总线\n\n在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。\n\n基本原理 configclient实例都监听mq中同一个topic(默认是springcloudbus)。当一个服务刷新数据的时候，它会把这个信息放入到topic中，这样其它监听同一topic的服务就能得到通知，然后去更新自身的配置。\n\nrabbitmq的学习://www.bilibili.com/video/av55976700?from=search&seid=15010075915728605208\n\n\n# 5.docker安装rabbitmq\n\n\n# 1.选择版本，带web管理\n\ndocker pull rabbitmq:3.7.14-management-alpine\n\n\n1\n\n\n\n# 2.运行rabbitmq\n\ndocker run -d --hostname my-rabbit --name my-rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.7.14-management-alpine\n\n\n1\n\n\n\n# 3.安装插件\n\ndocker ps \ndocker exec -it 镜像id /bin/bash\nrabbitmq-plugins enable rabbitmq_management\n\n\n1\n2\n3\n\n\n\n# 4.访问地址\n\nhttp://ip:15672，这里的用户名和密码默认都是guest\n\n\n# 6.以3355为模板再创建一个模块3366\n\n\n# 1.新建模块：cloud-config-client-3366\n\n\n# 2.导入依赖\n\n\n# 3.配置文件\n\n\n# 4.主启动类\n\n\n# 5.业务类\n\n\n# 7.设计思想\n\n1）利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置（不推荐）\n\n\n\n2）利用消息总线触发一个服务端configserver的/bus/refresh端点，而刷新所有客户端的配置\n\n\n\n使用第二种的原因：\n\n 1. 打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。\n 2. 破坏了微服务各节点的对等性。\n 3. 有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改\n\n\n# 8.一次修改，广播通知，处处生效\n\n\n# 1.给cloud-config-center-3344配置中心服务端添加消息总线支持\n\n1.导入依赖\n\n\x3c!--添加消息总线rabbitmq支持--\x3e\n<dependency>\n    <groupid>org.springframework.cloud</groupid>\n    <artifactid>spring-cloud-starter-bus-amqp</artifactid>\n</dependency>\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-actuator</artifactid>\n</dependency>\n \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n2.yml中配置\n\n 1. rabbitmq相关配置（注意rabbitmq是在spring下方）\n 2. 暴露bus刷新配置的端点\n\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://gitee.com/wcy_dch/springcloud-config.git #github上面的git仓库名字\n          ####搜索目录\n          search-paths:\n            - springcloud-config\n      ####读取分支\n      label: master\n  #rabbitmq相关配置\n  rabbitmq:\n    host: 192.168.188.128\n    port: 5672\n    username: guest\n    password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n##rabbitmq相关配置,暴露bus刷新配置的端点\nmanagement:\n  endpoints: #暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: \'bus-refresh\'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 2.给cloud-config-client-3355/cloud-config-client-3366客户端添加消息总线支持\n\n1.导入依赖\n\n\x3c!--添加消息总线rabbitmq支持--\x3e\n<dependency>\n    <groupid>org.springframework.cloud</groupid>\n    <artifactid>spring-cloud-starter-bus-amqp</artifactid>\n</dependency>\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-actuator</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2.配置信息\n\n 1. rabbitmq相关配置（注意rabbitmq是在spring下方）\n 2. 暴露bus刷新配置的端点\n\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n  #rabbitmq相关配置\n  rabbitmq:\n    host: 192.168.188.128\n    port: 5672\n    username: guest\n    password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultzone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n# 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: "*"   # \'refresh\'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 3.测试\n\n 1. 启动eureka7001、eureka7002 地址：http://localhost:7001/\n 2. 启动configcentermain3344 地址：http://localhost:3344/master/config-dev.yml\n 3. 启动configclientmain3355、configclientmain3366 地址：http://localhost:3355/config/info\n\n运维人员先修改github上面的版本号，3344再执行actuator/bus-refresh的post请求\n\ncurl -x post "http://localhost:3344/actuator/bus-refresh"\n\n\n1\n\n\n可以看到3344/3355/3366都同步刷新了版本号。\n\n\n# 9.动态刷新定点通知\n\n只想通过3355，不想通知3366\n\n> 公式：http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}\n> \n> {destination}：微服务名：端口号\n\n比如：\n\ncurl -x post "http://localhost:3344/actuator/bus-refresh/config-client:3355"\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"Sleuth链路追踪",frontmatter:{title:"Sleuth链路追踪",date:"2021-08-24T20:17:59.000Z",permalink:"/pages/080e29/",categories:["后端","Spring全家桶","SpringCloud"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/16.Sleuth%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/16.Sleuth链路追踪.md",key:"v-932e5b4a",path:"/pages/080e29/",headers:[{level:2,title:"1.为什么会出现这个技术？",slug:"_1-为什么会出现这个技术",normalizedTitle:"1.为什么会出现这个技术？",charIndex:22},{level:2,title:"2.Sleuth是什么",slug:"_2-sleuth是什么",normalizedTitle:"2.sleuth是什么",charIndex:173},{level:2,title:"3.下载zipkin",slug:"_3-下载zipkin",normalizedTitle:"3.下载zipkin",charIndex:264},{level:2,title:"4.Springcloud整合Sleuth",slug:"_4-springcloud整合sleuth",normalizedTitle:"4.springcloud整合sleuth",charIndex:446},{level:3,title:"1.导入依赖",slug:"_1-导入依赖",normalizedTitle:"1.导入依赖",charIndex:483},{level:3,title:"2.修改配置",slug:"_2-修改配置",normalizedTitle:"2.修改配置",charIndex:705},{level:3,title:"3.测试",slug:"_3-测试",normalizedTitle:"3.测试",charIndex:2208}],headersStr:"1.为什么会出现这个技术？ 2.Sleuth是什么 3.下载zipkin 4.Springcloud整合Sleuth 1.导入依赖 2.修改配置 3.测试",content:"# Sleuth链路追踪\n\n官网：\n\n\n# 1.为什么会出现这个技术？\n\n在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。\n\n比如：订单=》支付、库存、积分、物流等等\n\n\n# 2.Sleuth是什么\n\nSpring Cloud Sleuth提供了一套完整的服务跟踪的解决方案\n\n在分布式系统中提供追踪解决方案并且兼容支持了zipkin（可视化界面）\n\n\n# 3.下载zipkin\n\nSpringCloud从F版起已不需要自己构建Zipkin Server了，只需调用jar包即可\n\n方式一：\n\n手动下载地址\n\n方式二：cmd命令下载\n\ncurl -sSL https://zipkin.io/quickstart.sh | bash -s\n\n\n1\n\n\n运行：\n\njava -jar zipkin.jar\n\n\n1\n\n\n\n# 4.Springcloud整合Sleuth\n\n修改8001、80\n\n\n# 1.导入依赖\n\n        \x3c!--包含了sleuth+zipkin--\x3e\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zipkin</artifactId>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.修改配置\n\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-payment-service\n  #整合sleuth数据链路\n  zipkin:\n    base-url: http://localhost:9411\n  sleuth:\n    sampler:\n      #采样率值介于 0 到 1 之间，1 则表示全部采集\n      probability: 1\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型\n    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包\n    url: jdbc:mysql://121.40.132.169:3306/cloud2021?useUnicode=true&characterEncoding=utf-8&useSSL=false\n    username: root\n    password: wW2452952178\n\neureka:\n  client:\n    #表示是否将自己注册进EurekaServer默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n      #defaultZone: http://localhost:7001/eureka  #单机版\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n  instance:\n    instance-id: payment8001  #不显示主机名，显示别名payment8001\n    prefer-ip-address: true     #访问路径可以显示IP地址\n    #########################心跳检测与续约时间############################################\n    #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\n#    lease-renewal-interval-in-seconds: 1\n#    #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\n#    lease-expiration-duration-in-seconds: 2\n\nmybatis:\n  mapperLocations: classpath:mapper/*.xml\n  type-aliases-package: com.wcy.springcloud.entities    # 所有Entity别名类所在包\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 3.测试\n\n * 启动eureka7001/7002\n * 启动cloud-provider-payment8001、cloud-consumer-order80\n\n访问地址：http://localhost/consumer/payment/port",normalizedContent:"# sleuth链路追踪\n\n官网：\n\n\n# 1.为什么会出现这个技术？\n\n在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。\n\n比如：订单=》支付、库存、积分、物流等等\n\n\n# 2.sleuth是什么\n\nspring cloud sleuth提供了一套完整的服务跟踪的解决方案\n\n在分布式系统中提供追踪解决方案并且兼容支持了zipkin（可视化界面）\n\n\n# 3.下载zipkin\n\nspringcloud从f版起已不需要自己构建zipkin server了，只需调用jar包即可\n\n方式一：\n\n手动下载地址\n\n方式二：cmd命令下载\n\ncurl -ssl https://zipkin.io/quickstart.sh | bash -s\n\n\n1\n\n\n运行：\n\njava -jar zipkin.jar\n\n\n1\n\n\n\n# 4.springcloud整合sleuth\n\n修改8001、80\n\n\n# 1.导入依赖\n\n        \x3c!--包含了sleuth+zipkin--\x3e\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-zipkin</artifactid>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.修改配置\n\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-payment-service\n  #整合sleuth数据链路\n  zipkin:\n    base-url: http://localhost:9411\n  sleuth:\n    sampler:\n      #采样率值介于 0 到 1 之间，1 则表示全部采集\n      probability: 1\n  datasource:\n    type: com.alibaba.druid.pool.druiddatasource            # 当前数据源操作类型\n    driver-class-name: org.gjt.mm.mysql.driver              # mysql驱动包\n    url: jdbc:mysql://121.40.132.169:3306/cloud2021?useunicode=true&characterencoding=utf-8&usessl=false\n    username: root\n    password: ww2452952178\n\neureka:\n  client:\n    #表示是否将自己注册进eurekaserver默认为true。\n    register-with-eureka: true\n    #是否从eurekaserver抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchregistry: true\n    service-url:\n      #defaultzone: http://localhost:7001/eureka  #单机版\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n  instance:\n    instance-id: payment8001  #不显示主机名，显示别名payment8001\n    prefer-ip-address: true     #访问路径可以显示ip地址\n    #########################心跳检测与续约时间############################################\n    #eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\n#    lease-renewal-interval-in-seconds: 1\n#    #eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\n#    lease-expiration-duration-in-seconds: 2\n\nmybatis:\n  mapperlocations: classpath:mapper/*.xml\n  type-aliases-package: com.wcy.springcloud.entities    # 所有entity别名类所在包\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 3.测试\n\n * 启动eureka7001/7002\n * 启动cloud-provider-payment8001、cloud-consumer-order80\n\n访问地址：http://localhost/consumer/payment/port",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"Sentinel",frontmatter:{title:"Sentinel",date:"2021-08-26T14:50:01.000Z",permalink:"/pages/f97989/",categories:["后端","Spring全家桶","SpringCloud"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/19.Sentinel.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/19.Sentinel.md",key:"v-58fd5da2",path:"/pages/f97989/",headers:[{level:2,title:"1.hystrix和sentinel",slug:"_1-hystrix和sentinel",normalizedTitle:"1.hystrix和sentinel",charIndex:25},{level:2,title:"2.sentinel的特性",slug:"_2-sentinel的特性",normalizedTitle:"2.sentinel的特性",charIndex:50},{level:2,title:"3.sentinel下载",slug:"_3-sentinel下载",normalizedTitle:"3.sentinel下载",charIndex:497},{level:2,title:"4.sentinel能干嘛",slug:"_4-sentinel能干嘛",normalizedTitle:"4.sentinel能干嘛",charIndex:717},{level:2,title:"5.微服务注册进sentinel",slug:"_5-微服务注册进sentinel",normalizedTitle:"5.微服务注册进sentinel",charIndex:768},{level:3,title:"1.新建模块：cloudalibaba-sentinel-service8401",slug:"_1-新建模块-cloudalibaba-sentinel-service8401",normalizedTitle:"1.新建模块：cloudalibaba-sentinel-service8401",charIndex:789},{level:3,title:"2.导入依赖",slug:"_2-导入依赖",normalizedTitle:"2.导入依赖",charIndex:834},{level:3,title:"3.修改配置文件",slug:"_3-修改配置文件",normalizedTitle:"3.修改配置文件",charIndex:3773},{level:3,title:"4.主启动类",slug:"_4-主启动类",normalizedTitle:"4.主启动类",charIndex:4271},{level:3,title:"5.业务类",slug:"_5-业务类",normalizedTitle:"5.业务类",charIndex:4729},{level:3,title:"6.环境准备",slug:"_6-环境准备",normalizedTitle:"6.环境准备",charIndex:5246},{level:3,title:"7.测试",slug:"_7-测试",normalizedTitle:"7.测试",charIndex:5304},{level:2,title:"6.Sentinel流控规则",slug:"_6-sentinel流控规则",normalizedTitle:"6.sentinel流控规则",charIndex:5479},{level:3,title:"1.流控模式-QPS直接",slug:"_1-流控模式-qps直接",normalizedTitle:"1.流控模式-qps直接",charIndex:5514},{level:3,title:"2.流控模式-线程数",slug:"_2-流控模式-线程数",normalizedTitle:"2.流控模式-线程数",charIndex:5758},{level:3,title:"3.流控模式-关联",slug:"_3-流控模式-关联",normalizedTitle:"3.流控模式-关联",charIndex:6080},{level:3,title:"4.流控模式-链路",slug:"_4-流控模式-链路",normalizedTitle:"4.流控模式-链路",charIndex:6173},{level:3,title:"5.预热模式Warm Up",slug:"_5-预热模式warm-up",normalizedTitle:"5.预热模式warm up",charIndex:6260},{level:3,title:"6.排队等待",slug:"_6-排队等待",normalizedTitle:"6.排队等待",charIndex:6789},{level:2,title:"7.降级规则",slug:"_7-降级规则",normalizedTitle:"7.降级规则",charIndex:7076},{level:3,title:"1.RT平均响应时间",slug:"_1-rt平均响应时间",normalizedTitle:"1.rt平均响应时间",charIndex:7091},{level:3,title:"2.异常比列",slug:"_2-异常比列",normalizedTitle:"2.异常比列",charIndex:7743},{level:3,title:"3.异常数",slug:"_3-异常数",normalizedTitle:"3.异常数",charIndex:8350}],headersStr:"1.hystrix和sentinel 2.sentinel的特性 3.sentinel下载 4.sentinel能干嘛 5.微服务注册进sentinel 1.新建模块：cloudalibaba-sentinel-service8401 2.导入依赖 3.修改配置文件 4.主启动类 5.业务类 6.环境准备 7.测试 6.Sentinel流控规则 1.流控模式-QPS直接 2.流控模式-线程数 3.流控模式-关联 4.流控模式-链路 5.预热模式Warm Up 6.排队等待 7.降级规则 1.RT平均响应时间 2.异常比列 3.异常数",content:'# Sentinel\n\n官网\n\n使用手册\n\n\n# 1.hystrix和sentinel\n\n\n\n\n# 2.sentinel的特性\n\n * 丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。\n * 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。\n * 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。同时 Sentinel 提供 Java/Go/C++ 等多语言的原生实现。\n * 完善的 SPI 扩展机制：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。\n\n\n# 3.sentinel下载\n\n下载地址\n\n版本：1.7.0\n\n运行：\n\njava -jar sentinel-dashboard-1.7.0.jar\n\n//linux后台启动\nnohup java -jar sentinel-dashboard-1.7.2.jar --server.port=8718 &\n\n\n1\n2\n3\n4\n\n\n访问：\n\nhttp://localhost:8080/\n\n\n1\n\n\n登录账号密码均为sentinel\n\n\n# 4.sentinel能干嘛\n\n * 服务雪崩\n * 服务降级\n * 服务熔断\n * 服务限流\n\n\n# 5.微服务注册进sentinel\n\n\n# 1.新建模块：cloudalibaba-sentinel-service8401\n\n\n# 2.导入依赖\n\n * spring-cloud-starter-alibaba-nacos-discovery：nacos注册\n * spring-cloud-starter-alibaba-sentinel：sentinel服务\n * sentinel-datasource-nacos：持久化\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloudalibaba-sentinel-service8401</artifactId>\n\n    <dependencies>\n        \x3c!--SpringCloud ailibaba nacos --\x3e\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n        \x3c!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--\x3e\n        <dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-datasource-nacos</artifactId>\n        </dependency>\n        \x3c!--SpringCloud ailibaba sentinel --\x3e\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n        </dependency>\n        \x3c!--openfeign--\x3e\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\n        </dependency>\n        \x3c!-- SpringBoot整合Web组件+actuator --\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \x3c!--日常通用jar包配置--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n            <version>4.6.3</version>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n\n    </dependencies>\n\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 3.修改配置文件\n\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibaba-sentinel-service\n  cloud:\n    nacos:\n      discovery:\n        #Nacos服务注册中心地址\n        server-addr: localhost:8848\n    sentinel:\n      transport:\n        #配置Sentinel dashboard地址\n        dashboard: localhost:8080\n        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口\n        port: 8719\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \'*\'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class MainApp8401\n{\n    public static void main(String[] args) {\n        SpringApplication.run(MainApp8401.class, args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 5.业务类\n\npackage com.wcy.springcloud.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class FlowLimitController\n{\n\n    @GetMapping("/testA")\n    public String testA()\n    {\n        return "------testA";\n    }\n\n    @GetMapping("/testB")\n    public String testB()\n    {\n        return "------testB";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n----------------------------------------\n\n\n# 6.环境准备\n\n * 启动nacos8848\n * 启动sentinel8080\n * 启动微服务8401\n\n\n# 7.测试\n\n访问：http://localhost:8080/，发现并没有监控8401，是因为sentinel默认使用懒加载策略，只有8401访问了的url才会被注册进去。\n\n> 访问http://localhost:8401/testA和http://localhost:8401/testB\n\n可以看到8401已经被sentinel监控\n\n\n# 6.Sentinel流控规则\n\n可对某url进行流量控制\n\n\n\n\n# 1.流控模式-QPS直接\n\n对/testA该URL进行流量控制，一秒超过一次请求则直接抛出错误\n\n\n\n再次访问http://localhost:8401/testA，一秒进行一次请求是正常的，多点几次就会直接报错：\n\n> Blocked by Sentinel (flow limiting)\n\n直接->快速失败(默认的流控处理)的源码：com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController\n\n\n# 2.流控模式-线程数\n\n * QPS：每秒多少次请求\n * 线程数：该URL不能超过多少个线程数\n\n休眠一秒，模拟线程数，修改阈值为线程数，再访问http://localhost:8401/testA，不听的F5可以看到效果。\n\n    @GetMapping("/testA")\n    public String testA() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(1L);//休眠一秒\n        return "------testA"+ UUID.randomUUID().toString();\n    }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.流控模式-关联\n\n> 当配置/testA的url关联/testB的url，如果/testB该url访问流量过大，对应的/testA也会限流\n> \n> 别人惹事，自己限流\n\n\n\n\n# 4.流控模式-链路\n\n如果testA和testB都访问调用/testC,可以限制对testC设置限流，入门为testA，那么testA的QPS超过阈值则不允许访问。\n\n\n# 5.预热模式Warm Up\n\n开始流量很少，但是后续突增流量，若不加以控制，服务可能宕机，所以给某个请求设置预热模式，比如设置阈值为10，则开始的时候只能请求3QPS，后续慢慢的增加到10；\n\n> 如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来，慢慢的把阀值增长到设置的阀值。\n\n对/testB设置预热模式，阈值为10，访问/testB开始的时候只有10/3的QPS，五秒后慢慢的加到10的QPS\n\n\n\n说明：\n\n> 公式：阈值除以coldFactor(默认值为3),经过预热时长后才会达到阈值\n> \n> 默认coldFactor为3，即请求 QPS 从 threshold / 3 开始，经预热时长逐渐升至设定的 QPS 阈值。\n> \n> 官网：https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8\n> \n> 源码：com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController\n\n\n# 6.排队等待\n\n请求服务不被直接拒绝，而是排队等待\n\n> 匀速排队，阈值必须设置为QPS\n> \n> 官网：https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6\n> \n> 源码：com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController\n\n\n\n设置每秒10的QPS，超过10后等待2秒\n\n\n\n使用postman模拟并发测试：\n\n\n\n查看idea控制台，一秒只有10个请求\n\n\n\n\n# 7.降级规则\n\n官网\n\n\n# 1.RT平均响应时间\n\n> 平均响应时间(DEGRADE_GRADE_RT ):当1s内持续进入5个请求，对应时刻的平均响应时间(秒级）均超过阈值（ count，以 ms为单位)，那么在接下的时间窗口( DegradeRule中的timewindow，以s为单位)之内，对这个方法的调用都会自动地熔断(抛出DegradeException )。\n> \n> 注意Sentinel 默认统计的RT上限是4900 ms，超出此阈值的都会算作4900 ms，若需要变更此上限可以通过启动配置项-Dcsp.sentinel.statistic.max.rt=xxx来配置。\n\n\n\n# 1.controller中testA服务休眠一秒\n\n    @GetMapping("/testA")\n    public String testA() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(1L);//休眠一秒\n        return "------testA"+ UUID.randomUUID().toString();\n    }\n\n\n1\n2\n3\n4\n5\n\n\n# 2.对testA服务设置降级规则\n\n1秒内超过五次请求切平均响应时间>500毫秒在2秒内触发降级\n\n\n\n# 3.不停的F5访问http://localhost:8401/testA\n\n可以看到触发了降级，不允许访问，把RT设置为2000，就不会触发降级了。\n\n\n# 2.异常比列\n\n> 异常比例( DEGRADE_GRADE_EXCEPTION_RATIo ):当资源的每秒请求量>=5，并且每秒异常总数占通过量的比值超过阈值（ DegradeRule中的count ）之后，资源进入降级状态，即在接下的时间窗口( DegradeRule中的timeWindow，以s为单位)之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是[0.0，1.0]，代表0% - 100%。\n\n# 1.controller层模拟异常请求\n\n    @GetMapping("/testA")\n    public String testA() throws InterruptedException {\n        int a=10/0;\n        return "------testA"+ UUID.randomUUID().toString();\n    }\n\n\n1\n2\n3\n4\n5\n\n\n# 2.sentinel设置降级规则\n\n\n\n# 3.访问http://localhost:8401/testA\n\n注意：http://localhost:8401/testA由于该请求百分之百会报错误，如果一秒内没有超过五次请求，那么就不会被sentinel降级，会直接弹出runtimeException的页面错误；若不停的F5，则可以看到sentinel对其进行了降级。\n\n\n\n\n# 3.异常数\n\n> 异常数( DEGRADE_GRADE_EXCEPTION_COUNT ):当资源近1分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timewindow小于60s，则结束熔断状态后仍可能再进入熔断状态。\n\n# 1.controller层模拟异常请求\n\n    @GetMapping("/testA")\n    public String testA() throws InterruptedException {\n        int a=10/0;\n        return "------testA"+ UUID.randomUUID().toString();\n    }\n\n\n1\n2\n3\n4\n5\n\n\n# 2.sentinel设置降级规则\n\n\n\n# 3.访问http://localhost:8401/testA\n\n当70秒内异常数超过五次则触发降级规则',normalizedContent:'# sentinel\n\n官网\n\n使用手册\n\n\n# 1.hystrix和sentinel\n\n\n\n\n# 2.sentinel的特性\n\n * 丰富的应用场景：sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。\n * 完备的实时监控：sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。\n * 广泛的开源生态：sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 spring cloud、apache dubbo、grpc、quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 sentinel。同时 sentinel 提供 java/go/c++ 等多语言的原生实现。\n * 完善的 spi 扩展机制：sentinel 提供简单易用、完善的 spi 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。\n\n\n# 3.sentinel下载\n\n下载地址\n\n版本：1.7.0\n\n运行：\n\njava -jar sentinel-dashboard-1.7.0.jar\n\n//linux后台启动\nnohup java -jar sentinel-dashboard-1.7.2.jar --server.port=8718 &\n\n\n1\n2\n3\n4\n\n\n访问：\n\nhttp://localhost:8080/\n\n\n1\n\n\n登录账号密码均为sentinel\n\n\n# 4.sentinel能干嘛\n\n * 服务雪崩\n * 服务降级\n * 服务熔断\n * 服务限流\n\n\n# 5.微服务注册进sentinel\n\n\n# 1.新建模块：cloudalibaba-sentinel-service8401\n\n\n# 2.导入依赖\n\n * spring-cloud-starter-alibaba-nacos-discovery：nacos注册\n * spring-cloud-starter-alibaba-sentinel：sentinel服务\n * sentinel-datasource-nacos：持久化\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloudalibaba-sentinel-service8401</artifactid>\n\n    <dependencies>\n        \x3c!--springcloud ailibaba nacos --\x3e\n        <dependency>\n            <groupid>com.alibaba.cloud</groupid>\n            <artifactid>spring-cloud-starter-alibaba-nacos-discovery</artifactid>\n        </dependency>\n        \x3c!--springcloud ailibaba sentinel-datasource-nacos 后续做持久化用到--\x3e\n        <dependency>\n            <groupid>com.alibaba.csp</groupid>\n            <artifactid>sentinel-datasource-nacos</artifactid>\n        </dependency>\n        \x3c!--springcloud ailibaba sentinel --\x3e\n        <dependency>\n            <groupid>com.alibaba.cloud</groupid>\n            <artifactid>spring-cloud-starter-alibaba-sentinel</artifactid>\n        </dependency>\n        \x3c!--openfeign--\x3e\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-openfeign</artifactid>\n        </dependency>\n        \x3c!-- springboot整合web组件+actuator --\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n        \x3c!--日常通用jar包配置--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>cn.hutool</groupid>\n            <artifactid>hutool-all</artifactid>\n            <version>4.6.3</version>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n\n    </dependencies>\n\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 3.修改配置文件\n\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibaba-sentinel-service\n  cloud:\n    nacos:\n      discovery:\n        #nacos服务注册中心地址\n        server-addr: localhost:8848\n    sentinel:\n      transport:\n        #配置sentinel dashboard地址\n        dashboard: localhost:8080\n        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口\n        port: 8719\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \'*\'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.cloud.client.discovery.enablediscoveryclient;\n\n@enablediscoveryclient\n@springbootapplication\npublic class mainapp8401\n{\n    public static void main(string[] args) {\n        springapplication.run(mainapp8401.class, args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 5.业务类\n\npackage com.wcy.springcloud.controller;\n\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\n@restcontroller\npublic class flowlimitcontroller\n{\n\n    @getmapping("/testa")\n    public string testa()\n    {\n        return "------testa";\n    }\n\n    @getmapping("/testb")\n    public string testb()\n    {\n        return "------testb";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n----------------------------------------\n\n\n# 6.环境准备\n\n * 启动nacos8848\n * 启动sentinel8080\n * 启动微服务8401\n\n\n# 7.测试\n\n访问：http://localhost:8080/，发现并没有监控8401，是因为sentinel默认使用懒加载策略，只有8401访问了的url才会被注册进去。\n\n> 访问http://localhost:8401/testa和http://localhost:8401/testb\n\n可以看到8401已经被sentinel监控\n\n\n# 6.sentinel流控规则\n\n可对某url进行流量控制\n\n\n\n\n# 1.流控模式-qps直接\n\n对/testa该url进行流量控制，一秒超过一次请求则直接抛出错误\n\n\n\n再次访问http://localhost:8401/testa，一秒进行一次请求是正常的，多点几次就会直接报错：\n\n> blocked by sentinel (flow limiting)\n\n直接->快速失败(默认的流控处理)的源码：com.alibaba.csp.sentinel.slots.block.flow.controller.defaultcontroller\n\n\n# 2.流控模式-线程数\n\n * qps：每秒多少次请求\n * 线程数：该url不能超过多少个线程数\n\n休眠一秒，模拟线程数，修改阈值为线程数，再访问http://localhost:8401/testa，不听的f5可以看到效果。\n\n    @getmapping("/testa")\n    public string testa() throws interruptedexception {\n        timeunit.seconds.sleep(1l);//休眠一秒\n        return "------testa"+ uuid.randomuuid().tostring();\n    }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.流控模式-关联\n\n> 当配置/testa的url关联/testb的url，如果/testb该url访问流量过大，对应的/testa也会限流\n> \n> 别人惹事，自己限流\n\n\n\n\n# 4.流控模式-链路\n\n如果testa和testb都访问调用/testc,可以限制对testc设置限流，入门为testa，那么testa的qps超过阈值则不允许访问。\n\n\n# 5.预热模式warm up\n\n开始流量很少，但是后续突增流量，若不加以控制，服务可能宕机，所以给某个请求设置预热模式，比如设置阈值为10，则开始的时候只能请求3qps，后续慢慢的增加到10；\n\n> 如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来，慢慢的把阀值增长到设置的阀值。\n\n对/testb设置预热模式，阈值为10，访问/testb开始的时候只有10/3的qps，五秒后慢慢的加到10的qps\n\n\n\n说明：\n\n> 公式：阈值除以coldfactor(默认值为3),经过预热时长后才会达到阈值\n> \n> 默认coldfactor为3，即请求 qps 从 threshold / 3 开始，经预热时长逐渐升至设定的 qps 阈值。\n> \n> 官网：https://github.com/alibaba/sentinel/wiki/%e9%99%90%e6%b5%81---%e5%86%b7%e5%90%af%e5%8a%a8\n> \n> 源码：com.alibaba.csp.sentinel.slots.block.flow.controller.warmupcontroller\n\n\n# 6.排队等待\n\n请求服务不被直接拒绝，而是排队等待\n\n> 匀速排队，阈值必须设置为qps\n> \n> 官网：https://github.com/alibaba/sentinel/wiki/%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6\n> \n> 源码：com.alibaba.csp.sentinel.slots.block.flow.controller.ratelimitercontroller\n\n\n\n设置每秒10的qps，超过10后等待2秒\n\n\n\n使用postman模拟并发测试：\n\n\n\n查看idea控制台，一秒只有10个请求\n\n\n\n\n# 7.降级规则\n\n官网\n\n\n# 1.rt平均响应时间\n\n> 平均响应时间(degrade_grade_rt ):当1s内持续进入5个请求，对应时刻的平均响应时间(秒级）均超过阈值（ count，以 ms为单位)，那么在接下的时间窗口( degraderule中的timewindow，以s为单位)之内，对这个方法的调用都会自动地熔断(抛出degradeexception )。\n> \n> 注意sentinel 默认统计的rt上限是4900 ms，超出此阈值的都会算作4900 ms，若需要变更此上限可以通过启动配置项-dcsp.sentinel.statistic.max.rt=xxx来配置。\n\n\n\n# 1.controller中testa服务休眠一秒\n\n    @getmapping("/testa")\n    public string testa() throws interruptedexception {\n        timeunit.seconds.sleep(1l);//休眠一秒\n        return "------testa"+ uuid.randomuuid().tostring();\n    }\n\n\n1\n2\n3\n4\n5\n\n\n# 2.对testa服务设置降级规则\n\n1秒内超过五次请求切平均响应时间>500毫秒在2秒内触发降级\n\n\n\n# 3.不停的f5访问http://localhost:8401/testa\n\n可以看到触发了降级，不允许访问，把rt设置为2000，就不会触发降级了。\n\n\n# 2.异常比列\n\n> 异常比例( degrade_grade_exception_ratio ):当资源的每秒请求量>=5，并且每秒异常总数占通过量的比值超过阈值（ degraderule中的count ）之后，资源进入降级状态，即在接下的时间窗口( degraderule中的timewindow，以s为单位)之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是[0.0，1.0]，代表0% - 100%。\n\n# 1.controller层模拟异常请求\n\n    @getmapping("/testa")\n    public string testa() throws interruptedexception {\n        int a=10/0;\n        return "------testa"+ uuid.randomuuid().tostring();\n    }\n\n\n1\n2\n3\n4\n5\n\n\n# 2.sentinel设置降级规则\n\n\n\n# 3.访问http://localhost:8401/testa\n\n注意：http://localhost:8401/testa由于该请求百分之百会报错误，如果一秒内没有超过五次请求，那么就不会被sentinel降级，会直接弹出runtimeexception的页面错误；若不停的f5，则可以看到sentinel对其进行了降级。\n\n\n\n\n# 3.异常数\n\n> 异常数( degrade_grade_exception_count ):当资源近1分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timewindow小于60s，则结束熔断状态后仍可能再进入熔断状态。\n\n# 1.controller层模拟异常请求\n\n    @getmapping("/testa")\n    public string testa() throws interruptedexception {\n        int a=10/0;\n        return "------testa"+ uuid.randomuuid().tostring();\n    }\n\n\n1\n2\n3\n4\n5\n\n\n# 2.sentinel设置降级规则\n\n\n\n# 3.访问http://localhost:8401/testa\n\n当70秒内异常数超过五次则触发降级规则',charsets:{cjk:!0},lastUpdated:"2021/09/22, 16:16:17"},{title:"SpringCloud alibaba Nacos服务注册和配置中心",frontmatter:{title:"SpringCloud alibaba Nacos服务注册和配置中心",date:"2021-08-26T14:50:01.000Z",permalink:"/pages/2eb82f/",categories:["后端","Spring全家桶","SpringCloud"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/18.SpringCloud%20alibaba%20Nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%20-%20%E5%89%AF%E6%9C%AC.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/18.SpringCloud alibaba Nacos服务注册和配置中心 - 副本.md",key:"v-59998266",path:"/pages/2eb82f/",headers:[{level:2,title:"1.为什么叫Nacos",slug:"_1-为什么叫nacos",normalizedTitle:"1.为什么叫nacos",charIndex:59},{level:2,title:"2.Nacos是什么",slug:"_2-nacos是什么",normalizedTitle:"2.nacos是什么",charIndex:125},{level:2,title:"3.Nacos能干嘛",slug:"_3-nacos能干嘛",normalizedTitle:"3.nacos能干嘛",charIndex:288},{level:2,title:"4.Nacos下载",slug:"_4-nacos下载",normalizedTitle:"4.nacos下载",charIndex:344},{level:2,title:"5.Nacos作为服务注册中心演示",slug:"_5-nacos作为服务注册中心演示",normalizedTitle:"5.nacos作为服务注册中心演示",charIndex:458},{level:3,title:"1.基于Nacos的服务提供者",slug:"_1-基于nacos的服务提供者",normalizedTitle:"1.基于nacos的服务提供者",charIndex:480},{level:3,title:"2.演示负载均衡：复制9001端口映射：9011",slug:"_2-演示负载均衡-复制9001端口映射-9011",normalizedTitle:"2.演示负载均衡：复制9001端口映射：9011",charIndex:8921},{level:3,title:"3.基于Nacos的服务消费者",slug:"_3-基于nacos的服务消费者",normalizedTitle:"3.基于nacos的服务消费者",charIndex:8971},{level:2,title:"6.服务注册中心对比",slug:"_6-服务注册中心对比",normalizedTitle:"6.服务注册中心对比",charIndex:13010},{level:2,title:"7.Nacos作为配置中心-基础配置",slug:"_7-nacos作为配置中心-基础配置",normalizedTitle:"7.nacos作为配置中心-基础配置",charIndex:13491},{level:3,title:"1.新建模块：cloudalibaba-config-nacos-client3377",slug:"_1-新建模块-cloudalibaba-config-nacos-client3377",normalizedTitle:"1.新建模块：cloudalibaba-config-nacos-client3377",charIndex:13514},{level:3,title:"2.导入依赖",slug:"_2-导入依赖-2",normalizedTitle:"2.导入依赖",charIndex:9036},{level:3,title:"3.yml配置文件",slug:"_3-yml配置文件",normalizedTitle:"3.yml配置文件",charIndex:15683},{level:3,title:"4.主启动类",slug:"_4-主启动类-3",normalizedTitle:"4.主启动类",charIndex:7679},{level:3,title:"5.controller层",slug:"_5-controller层",normalizedTitle:"5.controller层",charIndex:16897},{level:3,title:"6.在Nacos中添加配置信息",slug:"_6-在nacos中添加配置信息",normalizedTitle:"6.在nacos中添加配置信息",charIndex:17582},{level:3,title:"7.测试",slug:"_7-测试",normalizedTitle:"7.测试",charIndex:17822},{level:2,title:"8.Nacos作为配置中心-分类配置",slug:"_8-nacos作为配置中心-分类配置",normalizedTitle:"8.nacos作为配置中心-分类配置",charIndex:17893},{level:3,title:"1.Namespace+Group+Data ID三者关系？",slug:"_1-namespace-group-data-id三者关系",normalizedTitle:"1.namespace+group+data id三者关系？",charIndex:18116},{level:3,title:"2.DataID配置方案",slug:"_2-dataid配置方案",normalizedTitle:"2.dataid配置方案",charIndex:18719},{level:3,title:"3.Group方案",slug:"_3-group方案",normalizedTitle:"3.group方案",charIndex:18848},{level:3,title:"4.Namespace方案",slug:"_4-namespace方案",normalizedTitle:"4.namespace方案",charIndex:18949},{level:2,title:"9.nacos持久化",slug:"_9-nacos持久化",normalizedTitle:"9.nacos持久化",charIndex:19072},{level:3,title:"1.准备mysql数据库",slug:"_1-准备mysql数据库",normalizedTitle:"1.准备mysql数据库",charIndex:19481},{level:3,title:"2.sql脚本导入mysql数据库",slug:"_2-sql脚本导入mysql数据库",normalizedTitle:"2.sql脚本导入mysql数据库",charIndex:19498},{level:3,title:"3.修改nacos配置文件",slug:"_3-修改nacos配置文件",normalizedTitle:"3.修改nacos配置文件",charIndex:19592},{level:2,title:"10.linux集群nacos",slug:"_10-linux集群nacos",normalizedTitle:"10.linux集群nacos",charIndex:19907},{level:3,title:"1.环境准备",slug:"_1-环境准备",normalizedTitle:"1.环境准备",charIndex:19927},{level:3,title:"2.linux下载nacos",slug:"_2-linux下载nacos",normalizedTitle:"2.linux下载nacos",charIndex:20015},{level:3,title:"3.解压",slug:"_3-解压",normalizedTitle:"3.解压",charIndex:20063},{level:3,title:"4.移动位置",slug:"_4-移动位置",normalizedTitle:"4.移动位置",charIndex:20114},{level:3,title:"5.Linux服务器上mysql数据库配置",slug:"_5-linux服务器上mysql数据库配置",normalizedTitle:"5.linux服务器上mysql数据库配置",charIndex:20161},{level:3,title:"6.application.properties 配置",slug:"_6-application-properties-配置",normalizedTitle:"6.application.properties 配置",charIndex:20202},{level:3,title:"7.Linux服务器上nacos的集群配置cluster.conf",slug:"_7-linux服务器上nacos的集群配置cluster-conf",normalizedTitle:"7.linux服务器上nacos的集群配置cluster.conf",charIndex:20648},{level:3,title:"8.编辑Nacos的启动脚本startup.sh，使它能够接受不同的启动端口",slug:"_8-编辑nacos的启动脚本startup-sh-使它能够接受不同的启动端口",normalizedTitle:"8.编辑nacos的启动脚本startup.sh，使它能够接受不同的启动端口",charIndex:20935},{level:3,title:"9.Nginx的配置，由它作为负载均衡器",slug:"_9-nginx的配置-由它作为负载均衡器",normalizedTitle:"9.nginx的配置，由它作为负载均衡器",charIndex:21555},{level:2,title:"11.微服务cloudalibaba-provider-payment9001启动注册进nacos集群",slug:"_11-微服务cloudalibaba-provider-payment9001启动注册进nacos集群",normalizedTitle:"11.微服务cloudalibaba-provider-payment9001启动注册进nacos集群",charIndex:22378}],headersStr:"1.为什么叫Nacos 2.Nacos是什么 3.Nacos能干嘛 4.Nacos下载 5.Nacos作为服务注册中心演示 1.基于Nacos的服务提供者 2.演示负载均衡：复制9001端口映射：9011 3.基于Nacos的服务消费者 6.服务注册中心对比 7.Nacos作为配置中心-基础配置 1.新建模块：cloudalibaba-config-nacos-client3377 2.导入依赖 3.yml配置文件 4.主启动类 5.controller层 6.在Nacos中添加配置信息 7.测试 8.Nacos作为配置中心-分类配置 1.Namespace+Group+Data ID三者关系？ 2.DataID配置方案 3.Group方案 4.Namespace方案 9.nacos持久化 1.准备mysql数据库 2.sql脚本导入mysql数据库 3.修改nacos配置文件 10.linux集群nacos 1.环境准备 2.linux下载nacos 3.解压 4.移动位置 5.Linux服务器上mysql数据库配置 6.application.properties 配置 7.Linux服务器上nacos的集群配置cluster.conf 8.编辑Nacos的启动脚本startup.sh，使它能够接受不同的启动端口 9.Nginx的配置，由它作为负载均衡器 11.微服务cloudalibaba-provider-payment9001启动注册进nacos集群",content:'# SpringCloud alibaba Nacos服务注册和配置中心\n\n官方文档\n\n官网源码\n\n开发文档\n\n\n# 1.为什么叫Nacos\n\n前四个字母分别为Naming和Configuration的前两个字母，最后的s为Service。\n\n\n# 2.Nacos是什么\n\n * 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n * Nacos: Dynamic Naming and Configuration Service\n * Nacos就是注册中心 + 配置中心的组合========》Nacos = Eureka+Config +Bus\n\n\n# 3.Nacos能干嘛\n\n * 替代Eureka做服务注册中心\n * 替代Config做服务配置中心\n\n\n\n\n# 4.Nacos下载\n\n下载地址\n\n启动startup.cmd即可\n\n访问地址：http://localhost:8848/nacos\n\nlinux启动\n./startup.sh -m standalone\n\n\n1\n2\n\n\n\n# 5.Nacos作为服务注册中心演示\n\n\n# 1.基于Nacos的服务提供者\n\n# 1.新建模块：cloudalibaba-provider-payment9001\n\n# 2.引入依赖\n\n父pom：\n\n<?xml version="1.0" encoding="UTF-8"?>\n\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.wcy.springcloud</groupId>\n  <artifactId>CloudStudy</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  \x3c!--父工程就是一个maven管理，打包方式为pom--\x3e\n  <packaging>pom</packaging>\n\n  <modules>\n      <module>cloud-provider-payment8001</module>\n      <module>cloud-consumer-order80</module>\n      <module>cloud-api-commons</module>\n      <module>cloud-eureka-server7001</module>\n      <module>cloud-eureka-server7002</module>\n      <module>cloud-provider-payment8002</module>\n      <module>cloud-provider-payment8004</module>\n      <module>cloud-consumerzk-order80</module>\n      <module>cloud-providerconsul-payment8006</module>\n      <module>cloud-consumerconsul-order80</module>\n      <module>cloud-consumer-feign-order80</module>\n      <module>cloud-provider-hystrix-payment8001</module>\n      <module>cloud-consumer-feign-hystrix-order80</module>\n      <module>cloud-consumer-hystrix-dashboard9001</module>\n      <module>cloud-gateway-gateway9527</module>\n      <module>cloud-config-center-3344</module>\n    <module>cloud-config-client-3355</module>\n      <module>cloud-config-client-3366</module>\n      <module>cloud-stream-rabbitmq-provider8801</module>\n      <module>cloud-stream-rabbitmq-consumer8802</module>\n      <module>cloud-stream-rabbitmq-consumer8803</module>\n    <module>cloudalibaba-provider-payment9001</module>\n  </modules>\n\n  \x3c!-- 统一管理jar包版本 --\x3e\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n    <junit.version>4.12</junit.version>\n    <log4j.version>1.2.17</log4j.version>\n    <lombok.version>1.16.18</lombok.version>\n    <mysql.version>5.1.47</mysql.version>\n    <druid.version>1.1.16</druid.version>\n    <mybatis.spring.boot.version>1.3.0</mybatis.spring.boot.version>\n  </properties>\n\n  \x3c!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version  --\x3e\n  <dependencyManagement>\n    <dependencies>\n      \x3c!--spring boot 2.2.2--\x3e\n      <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-dependencies</artifactId>\n        <version>2.2.2.RELEASE</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      \x3c!--spring cloud Hoxton.SR1--\x3e\n      <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-dependencies</artifactId>\n        <version>Hoxton.SR1</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      \x3c!--spring cloud alibaba 2.1.0.RELEASE--\x3e\n      <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n        <version>2.1.0.RELEASE</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>${mysql.version}</version>\n      </dependency>\n      <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid</artifactId>\n        <version>${druid.version}</version>\n      </dependency>\n      <dependency>\n        <groupId>org.mybatis.spring.boot</groupId>\n        <artifactId>mybatis-spring-boot-starter</artifactId>\n        <version>${mybatis.spring.boot.version}</version>\n      </dependency>\n      <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>${junit.version}</version>\n      </dependency>\n      <dependency>\n        <groupId>log4j</groupId>\n        <artifactId>log4j</artifactId>\n        <version>${log4j.version}</version>\n      </dependency>\n      <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>${lombok.version}</version>\n        <optional>true</optional>\n      </dependency>\n    </dependencies>\n  </dependencyManagement>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n        <configuration>\n          <fork>true</fork>\n          <addResources>true</addResources>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n\n\n子pom：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloudalibaba-provider-payment9001</artifactId>\n\n    <dependencies>\n        \x3c!--SpringCloud ailibaba nacos --\x3e\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n        \x3c!-- SpringBoot整合Web组件 --\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \x3c!--日常通用jar包配置--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n# 3.yml文件\n\nserver:\n  port: 9001\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #配置Nacos地址\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \'*\'\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class PaymentMain9001\n{\n    public static void main(String[] args) {\n        SpringApplication.run(PaymentMain9001.class, args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 5.controller类\n\npackage com.wcy.springcloud.controller;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class PaymentController\n{\n    @Value("${server.port}")\n    private String serverPort;\n\n    @GetMapping(value = "/payment/nacos/{id}")\n    public String getPayment(@PathVariable("id") Integer id)\n    {\n        return "nacos registry, serverPort: "+ serverPort+"\\t id"+id;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 6.测试\n\n * 启动Nacos\n * 启动9001\n\n访问地址：http://localhost:9001/payment/nacos/1\n\n查看nacos是否注册服务：http://localhost:8848/nacos\n\n\n# 2.演示负载均衡：复制9001端口映射：9011\n\n不想新建模块，直接拷贝虚拟端口映射\n\n\n\n\n# 3.基于Nacos的服务消费者\n\n# 1.新建模块：cloudalibaba-consumer-nacos-order83\n\n# 2.导入依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloudalibaba-consumer-nacos-order83</artifactId>\n\n\n    <dependencies>\n        \x3c!--SpringCloud ailibaba nacos --\x3e\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n        \x3c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\x3e\n        <dependency>\n            <groupId>com.wcy.springcloud</groupId>\n            <artifactId>cloud-api-commons</artifactId>\n            <version>${project.version}</version>\n        </dependency>\n        \x3c!-- SpringBoot整合Web组件 --\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \x3c!--日常通用jar包配置--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n# 3.配置文件\n\nserver:\n  port: 83\n\n\nspring:\n  application:\n    name: nacos-order-consumer\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 4.主启动类\n\npackage com.wcy.pringcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class OrderNacosMain83\n{\n    public static void main(String[] args)\n    {\n        SpringApplication.run(OrderNacosMain83.class,args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 5.业务类\n\n引入RestTemplate\n\n@Configuration\npublic class ApplicationContextBean\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate()\n    {\n        return new RestTemplate();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ncontroller类\n\npackage com.wcy.pringcloud.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.client.RestTemplate;\n\nimport javax.annotation.Resource;\n\n@RestController\npublic class OrderNacosController\n{\n    @Resource\n    private RestTemplate restTemplate;\n\n    private static final String serverURL="http://nacos-payment-provider";\n\n    @GetMapping("/consumer/payment/nacos/{id}")\n    public String paymentInfo(@PathVariable("id") Long id)\n    {\n        return restTemplate.getForObject(serverURL+"/payment/nacos/"+id,String.class);\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 6.测试\n\n * 启动Nacos\n * 启动9001、9011\n * 启动83\n\n访问地址：http://localhost:83/consumer/payment/nacos/1\n\n> 可以看到已经有自带负载均衡能力\n\n\n# 6.服务注册中心对比\n\n\n\nnacos与启动注册中心的特性对比\n\n\n\n\n\nC是所有节点在同一时间看到的数据是一致的；而A的定义是所有的请求都会收到响应。\n\n> 何时选择使用何种模式？ 一般来说： 如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如 Spring cloud 和 Dubbo 服务，都适用于AP模式，AP模式为了服务的可能性而减弱了一致性，因此AP模式下只支持注册临时实例。\n> \n> 如果需要在服务级别编辑或者存储配置信息，那么 CP 是必须，K8S服务和DNS服务则适用于CP模式。 CP模式下则支持注册持久化实例，此时则是以 Raft 协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。\n\n发送请求切换CP和AP：默认AP\n\ncurl -X PUT \'$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&value=CP\'\n\n\n1\n\n\n\n# 7.Nacos作为配置中心-基础配置\n\n\n# 1.新建模块：cloudalibaba-config-nacos-client3377\n\n\n# 2.导入依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloudalibaba-config-nacos-client3377</artifactId>\n\n    <dependencies>\n        \x3c!--nacos-config--\x3e\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n        </dependency>\n        \x3c!--nacos-discovery--\x3e\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n        \x3c!--web + actuator--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \x3c!--一般基础配置--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 3.yml配置文件\n\n> Nacos同springcloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取， 拉取配置之后，才能保证项目的正常启动。\n> \n> springboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application\n\nbootstrap.yml文件配置：\n\n * 指定nacos注册中心\n * 指定nacos配置中心\n\n# nacos配置\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacos-config-client\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n      config:\n        server-addr: localhost:8848 #Nacos作为配置中心地址\n        file-extension: yaml #指定yaml格式的配置  一定要写成yaml  nacos的bug\n\n\n# ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\napplication.yml配置：\n\n\nspring:\n  profiles:\n    active: dev # 表示开发环境\n \n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class NacosConfigClientMain3377\n{\n    public static void main(String[] args) {\n        SpringApplication.run(NacosConfigClientMain3377.class, args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 5.controller层\n\n * @RefreshScope：自动刷新功能，通过nacos实现动态刷新\n\npackage com.wcy.springcloud.controller;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RefreshScope //在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能。\npublic class ConfigClientController\n{\n    @Value("${config.info}")\n    private String configInfo;\n\n    @GetMapping("/config/info")\n    public String getConfigInfo() {\n        return configInfo;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 6.在Nacos中添加配置信息\n\nNacos中的匹配规则：\n\n\n\n> Data ID公式：${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}\n> \n> 微服务名-profiles.yaml：注意一定要写成yaml，nacos的BUG\n\n\n\n登录nacos新建配置：\n\n * 一定要注意Data ID最后文件格式必须为yaml\n\n\n\n\n# 7.测试\n\n * 启动nacos\n * 启动3377\n\n访问地址：http://localhost:3377/config/info\n\n\n# 8.Nacos作为配置中心-分类配置\n\n问题1：\n\n> 实际开发中，通常一个系统会准备 dev开发环境 test测试环境 prod生产环境。 如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢？\n\n问题2：\n\n> 一个大型分布式微服务系统会有很多微服务子项目， 每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境...... 那怎么对这些微服务配置进行管理呢？\n\nnacos的配置列表和命令空间：\n\n\n\n\n# 1.Namespace+Group+Data ID三者关系？\n\n# 1 Namespace+Group+Data ID是什么\n\n类似Java里面的package名和类名 最外层的namespace是可以用于区分部署环境的，Group和DataID逻辑上区分两个目标对象。\n\n# 2 三者情况\n\n默认情况：\n\n> Namespace=public，Group=DEFAULT_GROUP, 默认Cluster是DEFAULT\n\nNacos默认的命名空间是public，Namespace主要用来实现隔离。 比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。\n\nGroup默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去\n\nService就是微服务；一个Service可以包含多个Cluster（集群），Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。 比方说为了容灾，将Service微服务分别部署在了杭州机房和广州机房， 这时就可以给杭州机房的Service微服务起一个集群名称（HZ）， 给广州机房的Service微服务起一个集群名称（GZ），还可以尽量让同一个机房的微服务互相调用，以提升性能。\n\n最后是Instance，就是微服务的实例。\n\n\n# 2.DataID配置方案\n\n根据微服务名-${spring.profile.active}.yaml来实现\n\n\n\n修改配置文件的active即可实现开发环境的区分：\n\n\n\n测试访问：http://localhost:3377/config/info\n\n\n# 3.Group方案\n\nnacos新建相同Data ID不同的组：\n\n\n\n配置文件中指定使用哪个组的配置问题：\n\n\n\n测试访问：http://localhost:3377/config/info\n\n\n# 4.Namespace方案\n\nnacos新建两个Namespace：\n\n\n\nnacos在NameSpace为dev下创建三个配置文件：\n\n\n\n配置文件：\n\n\n\n测试访问：http://localhost:3377/config/info\n\n\n# 9.nacos持久化\n\nnacos架构：\n\n\n\n> Nacos默认自带的是嵌入式数据库derby；\n> \n> 默认Nacos使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的。\n> \n> 为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySQL的存储。\n\n在0.7版本之前，在单机模式时nacos使用嵌入式数据库实现数据的存储，不方便观察数据存储的基本情况。0.7版本增加了支持mysql数据源能力，具体的操作步骤：\n\n * 1.安装数据库，版本要求：5.6.5+\n * 2.初始化mysql数据库，数据库初始化文件：nacos-mysql.sql\n * 3.修改conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。\n\n\n# 1.准备mysql数据库\n\n\n# 2.sql脚本导入mysql数据库\n\n脚本路径：nacos-server-1.1.4\\nacos\\conf\\nacos-mysql.sql\n\n新建数据库：nacos_config\n\n\n# 3.修改nacos配置文件\n\n位置：nacos-server-1.1.4\\nacos\\conf\\application.properties\n\n添加内容：\n\nspring.datasource.platform=mysql\n \ndb.num=1\ndb.url.0=jdbc:mysql://192.168.188.128:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true\ndb.user=root\ndb.password=2452952178\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 10.linux集群nacos\n\n\n# 1.环境准备\n\n * linux环境\n * JDK1.8+\n * Maven3.2\n * 3个或3个以上nacos节点才能构成集群\n * mysql\n * nginx\n\n\n# 2.linux下载nacos\n\n地址\n\n对应版本：nacos-1.1.4.tar.gz\n\n\n# 3.解压\n\ntar -zxvf nacos-server-1.1.4.tar.gz\n\n\n1\n\n\n\n# 4.移动位置\n\ncp -r nacos /opt/module/nacos\n\n\n1\n\n\n\n# 5.Linux服务器上mysql数据库配置\n\n1.首先执行mysql脚本\n\n\n# 6.application.properties 配置\n\n1.进入路径/opt/module/nacos/conf/\n\ncd /opt/module/nacos/conf\n\n\n1\n\n\n2.备份配置文件，害怕可能修改错误\n\ncp application.properties application.properties.bf\n\n\n1\n\n\n3.修改配置文件\n\nvi application.properties\n\n\n1\n\n\n4.内容\n\nspring.datasource.platform=mysql\n\ndb.num=1\ndb.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true\ndb.user=root\ndb.password=2452952178\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 7.Linux服务器上nacos的集群配置cluster.conf\n\n1.同理：备份cluster.conf\n\ncp cluster.conf.example cluster.conf\n\n\n1\n\n\n2.修改cluster.conf\n\nvi cluster.conf\n\n\n1\n\n\n3.修改内容：\n\n> 这个IP不能写127.0.0.1，必须是 Linux命令hostname -I能够识别的IP\n> \n> 一定要配置正确\n\n192.168.188.128:3333\n192.168.188.128:4444\n192.168.188.128:5555\n\n\n1\n2\n3\n\n\n\n# 8.编辑Nacos的启动脚本startup.sh，使它能够接受不同的启动端口\n\n> 平时单机版的启动，都是./startup.sh即可。\n> \n> 但是：\n> \n> 集群启动，我们希望可以类似其它软件的shell命令，传递不同的端口号启动不同的nacos实例。 命令：./startup.sh -p 3333 表示启动端口号为3333的nacos服务器实例，和上一步的cluster.conf配置的一致。\n\n1.进入目录\n\ncd /opt/module/nacos/bin\n\n\n1\n\n\n2.备份\n\ncp startup.sh startup.sh.bf\n\n\n1\n\n\n3.修改startup.sh\n\nvi startup.sh\n\n\n1\n\n\n4.修改内容\n\n注意那里是p)\n\n修改前   修改后\n      \n      \n\n5.执行方式：\n\n./startup.sh -p 3333\n./startup.sh -p 4444\n./startup.sh -p 5555\n\n\n1\n2\n3\n\n\n查看是否启动\nps -ef|grep nacos|grep -v grep|wc -l\n\n\n1\n2\n\n\n6.测试访问地址\n\nhttp://192.168.188.128:3333/nacos\nhttp://192.168.188.128:4444/nacos\nhttp://192.168.188.128:5555/nacos\n\n\n1\n2\n3\n\n\n\n# 9.Nginx的配置，由它作为负载均衡器\n\n1.下载和安装参考文档nginx安装\n\n2.安装好后，查看nginx在哪\n\nwhereis nginx\n\n\n1\n\n\n3.进入目录\n\ncd /usr/local/nginx/conf\n\n\n1\n\n\n4.备份\n\ncp nginx.conf nginx.conf.bf\n\n\n1\n\n\n5.修改配置文件\n\nvi nginx.conf\n\n\n1\n\n\n6.内容：\n\n#增加映射端口\nupstream cluster{\n        server 127.0.0.1:3333;\n        server 127.0.0.1:4444;\n        server 127.0.0.1:5555;\n}\n#修改端口和location\nserver {\n        listen       1111;\n        server_name  localhost;\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;\n        location / {\n            #root   html;\n            #index  index.html index.htm;\n            proxy_pass http://cluster;\n        }\n.......省略\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n7.执行命令\n\ncd /usr/local/nginx/sbin\n#指定的配置文件启动\n./nginx -c /usr/local/nginx/conf/nginx.conf\n\n\n1\n2\n3\n\n\n8.测试\n\n访问地址：http://192.168.188.128:1111/nacos\n\n\n1\n\n\n\n# 11.微服务cloudalibaba-provider-payment9001启动注册进nacos集群\n\nserver-addr：配置ngnix的IP+端口进行转发\n\nserver:\n  port: 9001\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n      #server-addr: localhost:8848 #配置Nacos地址\n        #配置nginx转发地址\n        server-addr: 192.168.188.128:1111\n\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \'*\'\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',normalizedContent:'# springcloud alibaba nacos服务注册和配置中心\n\n官方文档\n\n官网源码\n\n开发文档\n\n\n# 1.为什么叫nacos\n\n前四个字母分别为naming和configuration的前两个字母，最后的s为service。\n\n\n# 2.nacos是什么\n\n * 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n * nacos: dynamic naming and configuration service\n * nacos就是注册中心 + 配置中心的组合========》nacos = eureka+config +bus\n\n\n# 3.nacos能干嘛\n\n * 替代eureka做服务注册中心\n * 替代config做服务配置中心\n\n\n\n\n# 4.nacos下载\n\n下载地址\n\n启动startup.cmd即可\n\n访问地址：http://localhost:8848/nacos\n\nlinux启动\n./startup.sh -m standalone\n\n\n1\n2\n\n\n\n# 5.nacos作为服务注册中心演示\n\n\n# 1.基于nacos的服务提供者\n\n# 1.新建模块：cloudalibaba-provider-payment9001\n\n# 2.引入依赖\n\n父pom：\n\n<?xml version="1.0" encoding="utf-8"?>\n\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <groupid>com.wcy.springcloud</groupid>\n  <artifactid>cloudstudy</artifactid>\n  <version>1.0-snapshot</version>\n  \x3c!--父工程就是一个maven管理，打包方式为pom--\x3e\n  <packaging>pom</packaging>\n\n  <modules>\n      <module>cloud-provider-payment8001</module>\n      <module>cloud-consumer-order80</module>\n      <module>cloud-api-commons</module>\n      <module>cloud-eureka-server7001</module>\n      <module>cloud-eureka-server7002</module>\n      <module>cloud-provider-payment8002</module>\n      <module>cloud-provider-payment8004</module>\n      <module>cloud-consumerzk-order80</module>\n      <module>cloud-providerconsul-payment8006</module>\n      <module>cloud-consumerconsul-order80</module>\n      <module>cloud-consumer-feign-order80</module>\n      <module>cloud-provider-hystrix-payment8001</module>\n      <module>cloud-consumer-feign-hystrix-order80</module>\n      <module>cloud-consumer-hystrix-dashboard9001</module>\n      <module>cloud-gateway-gateway9527</module>\n      <module>cloud-config-center-3344</module>\n    <module>cloud-config-client-3355</module>\n      <module>cloud-config-client-3366</module>\n      <module>cloud-stream-rabbitmq-provider8801</module>\n      <module>cloud-stream-rabbitmq-consumer8802</module>\n      <module>cloud-stream-rabbitmq-consumer8803</module>\n    <module>cloudalibaba-provider-payment9001</module>\n  </modules>\n\n  \x3c!-- 统一管理jar包版本 --\x3e\n  <properties>\n    <project.build.sourceencoding>utf-8</project.build.sourceencoding>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n    <junit.version>4.12</junit.version>\n    <log4j.version>1.2.17</log4j.version>\n    <lombok.version>1.16.18</lombok.version>\n    <mysql.version>5.1.47</mysql.version>\n    <druid.version>1.1.16</druid.version>\n    <mybatis.spring.boot.version>1.3.0</mybatis.spring.boot.version>\n  </properties>\n\n  \x3c!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupid和version  --\x3e\n  <dependencymanagement>\n    <dependencies>\n      \x3c!--spring boot 2.2.2--\x3e\n      <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-dependencies</artifactid>\n        <version>2.2.2.release</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      \x3c!--spring cloud hoxton.sr1--\x3e\n      <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-dependencies</artifactid>\n        <version>hoxton.sr1</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      \x3c!--spring cloud alibaba 2.1.0.release--\x3e\n      <dependency>\n        <groupid>com.alibaba.cloud</groupid>\n        <artifactid>spring-cloud-alibaba-dependencies</artifactid>\n        <version>2.1.0.release</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      <dependency>\n        <groupid>mysql</groupid>\n        <artifactid>mysql-connector-java</artifactid>\n        <version>${mysql.version}</version>\n      </dependency>\n      <dependency>\n        <groupid>com.alibaba</groupid>\n        <artifactid>druid</artifactid>\n        <version>${druid.version}</version>\n      </dependency>\n      <dependency>\n        <groupid>org.mybatis.spring.boot</groupid>\n        <artifactid>mybatis-spring-boot-starter</artifactid>\n        <version>${mybatis.spring.boot.version}</version>\n      </dependency>\n      <dependency>\n        <groupid>junit</groupid>\n        <artifactid>junit</artifactid>\n        <version>${junit.version}</version>\n      </dependency>\n      <dependency>\n        <groupid>log4j</groupid>\n        <artifactid>log4j</artifactid>\n        <version>${log4j.version}</version>\n      </dependency>\n      <dependency>\n        <groupid>org.projectlombok</groupid>\n        <artifactid>lombok</artifactid>\n        <version>${lombok.version}</version>\n        <optional>true</optional>\n      </dependency>\n    </dependencies>\n  </dependencymanagement>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-maven-plugin</artifactid>\n        <configuration>\n          <fork>true</fork>\n          <addresources>true</addresources>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n\n\n子pom：\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloudalibaba-provider-payment9001</artifactid>\n\n    <dependencies>\n        \x3c!--springcloud ailibaba nacos --\x3e\n        <dependency>\n            <groupid>com.alibaba.cloud</groupid>\n            <artifactid>spring-cloud-starter-alibaba-nacos-discovery</artifactid>\n        </dependency>\n        \x3c!-- springboot整合web组件 --\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n        \x3c!--日常通用jar包配置--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n# 3.yml文件\n\nserver:\n  port: 9001\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #配置nacos地址\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \'*\'\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.cloud.client.discovery.enablediscoveryclient;\n\n@enablediscoveryclient\n@springbootapplication\npublic class paymentmain9001\n{\n    public static void main(string[] args) {\n        springapplication.run(paymentmain9001.class, args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 5.controller类\n\npackage com.wcy.springcloud.controller;\n\nimport org.springframework.beans.factory.annotation.value;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.pathvariable;\nimport org.springframework.web.bind.annotation.restcontroller;\n\n@restcontroller\npublic class paymentcontroller\n{\n    @value("${server.port}")\n    private string serverport;\n\n    @getmapping(value = "/payment/nacos/{id}")\n    public string getpayment(@pathvariable("id") integer id)\n    {\n        return "nacos registry, serverport: "+ serverport+"\\t id"+id;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 6.测试\n\n * 启动nacos\n * 启动9001\n\n访问地址：http://localhost:9001/payment/nacos/1\n\n查看nacos是否注册服务：http://localhost:8848/nacos\n\n\n# 2.演示负载均衡：复制9001端口映射：9011\n\n不想新建模块，直接拷贝虚拟端口映射\n\n\n\n\n# 3.基于nacos的服务消费者\n\n# 1.新建模块：cloudalibaba-consumer-nacos-order83\n\n# 2.导入依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloudalibaba-consumer-nacos-order83</artifactid>\n\n\n    <dependencies>\n        \x3c!--springcloud ailibaba nacos --\x3e\n        <dependency>\n            <groupid>com.alibaba.cloud</groupid>\n            <artifactid>spring-cloud-starter-alibaba-nacos-discovery</artifactid>\n        </dependency>\n        \x3c!-- 引入自己定义的api通用包，可以使用payment支付entity --\x3e\n        <dependency>\n            <groupid>com.wcy.springcloud</groupid>\n            <artifactid>cloud-api-commons</artifactid>\n            <version>${project.version}</version>\n        </dependency>\n        \x3c!-- springboot整合web组件 --\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n        \x3c!--日常通用jar包配置--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n# 3.配置文件\n\nserver:\n  port: 83\n\n\nspring:\n  application:\n    name: nacos-order-consumer\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 4.主启动类\n\npackage com.wcy.pringcloud;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.cloud.client.discovery.enablediscoveryclient;\n\n@enablediscoveryclient\n@springbootapplication\npublic class ordernacosmain83\n{\n    public static void main(string[] args)\n    {\n        springapplication.run(ordernacosmain83.class,args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 5.业务类\n\n引入resttemplate\n\n@configuration\npublic class applicationcontextbean\n{\n    @bean\n    @loadbalanced\n    public resttemplate getresttemplate()\n    {\n        return new resttemplate();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ncontroller类\n\npackage com.wcy.pringcloud.controller;\n\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.pathvariable;\nimport org.springframework.web.bind.annotation.restcontroller;\nimport org.springframework.web.client.resttemplate;\n\nimport javax.annotation.resource;\n\n@restcontroller\npublic class ordernacoscontroller\n{\n    @resource\n    private resttemplate resttemplate;\n\n    private static final string serverurl="http://nacos-payment-provider";\n\n    @getmapping("/consumer/payment/nacos/{id}")\n    public string paymentinfo(@pathvariable("id") long id)\n    {\n        return resttemplate.getforobject(serverurl+"/payment/nacos/"+id,string.class);\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 6.测试\n\n * 启动nacos\n * 启动9001、9011\n * 启动83\n\n访问地址：http://localhost:83/consumer/payment/nacos/1\n\n> 可以看到已经有自带负载均衡能力\n\n\n# 6.服务注册中心对比\n\n\n\nnacos与启动注册中心的特性对比\n\n\n\n\n\nc是所有节点在同一时间看到的数据是一致的；而a的定义是所有的请求都会收到响应。\n\n> 何时选择使用何种模式？ 一般来说： 如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择ap模式。当前主流的服务如 spring cloud 和 dubbo 服务，都适用于ap模式，ap模式为了服务的可能性而减弱了一致性，因此ap模式下只支持注册临时实例。\n> \n> 如果需要在服务级别编辑或者存储配置信息，那么 cp 是必须，k8s服务和dns服务则适用于cp模式。 cp模式下则支持注册持久化实例，此时则是以 raft 协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。\n\n发送请求切换cp和ap：默认ap\n\ncurl -x put \'$nacos_server:8848/nacos/v1/ns/operator/switches?entry=servermode&value=cp\'\n\n\n1\n\n\n\n# 7.nacos作为配置中心-基础配置\n\n\n# 1.新建模块：cloudalibaba-config-nacos-client3377\n\n\n# 2.导入依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloudalibaba-config-nacos-client3377</artifactid>\n\n    <dependencies>\n        \x3c!--nacos-config--\x3e\n        <dependency>\n            <groupid>com.alibaba.cloud</groupid>\n            <artifactid>spring-cloud-starter-alibaba-nacos-config</artifactid>\n        </dependency>\n        \x3c!--nacos-discovery--\x3e\n        <dependency>\n            <groupid>com.alibaba.cloud</groupid>\n            <artifactid>spring-cloud-starter-alibaba-nacos-discovery</artifactid>\n        </dependency>\n        \x3c!--web + actuator--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n        \x3c!--一般基础配置--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 3.yml配置文件\n\n> nacos同springcloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取， 拉取配置之后，才能保证项目的正常启动。\n> \n> springboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application\n\nbootstrap.yml文件配置：\n\n * 指定nacos注册中心\n * 指定nacos配置中心\n\n# nacos配置\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacos-config-client\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #nacos服务注册中心地址\n      config:\n        server-addr: localhost:8848 #nacos作为配置中心地址\n        file-extension: yaml #指定yaml格式的配置  一定要写成yaml  nacos的bug\n\n\n# ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\napplication.yml配置：\n\n\nspring:\n  profiles:\n    active: dev # 表示开发环境\n \n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.cloud.client.discovery.enablediscoveryclient;\n\n@enablediscoveryclient\n@springbootapplication\npublic class nacosconfigclientmain3377\n{\n    public static void main(string[] args) {\n        springapplication.run(nacosconfigclientmain3377.class, args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 5.controller层\n\n * @refreshscope：自动刷新功能，通过nacos实现动态刷新\n\npackage com.wcy.springcloud.controller;\n\nimport org.springframework.beans.factory.annotation.value;\nimport org.springframework.cloud.context.config.annotation.refreshscope;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\n@restcontroller\n@refreshscope //在控制器类加入@refreshscope注解使当前类下的配置支持nacos的动态刷新功能。\npublic class configclientcontroller\n{\n    @value("${config.info}")\n    private string configinfo;\n\n    @getmapping("/config/info")\n    public string getconfiginfo() {\n        return configinfo;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 6.在nacos中添加配置信息\n\nnacos中的匹配规则：\n\n\n\n> data id公式：${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}\n> \n> 微服务名-profiles.yaml：注意一定要写成yaml，nacos的bug\n\n\n\n登录nacos新建配置：\n\n * 一定要注意data id最后文件格式必须为yaml\n\n\n\n\n# 7.测试\n\n * 启动nacos\n * 启动3377\n\n访问地址：http://localhost:3377/config/info\n\n\n# 8.nacos作为配置中心-分类配置\n\n问题1：\n\n> 实际开发中，通常一个系统会准备 dev开发环境 test测试环境 prod生产环境。 如何保证指定环境启动时服务能正确读取到nacos上相应环境的配置文件呢？\n\n问题2：\n\n> 一个大型分布式微服务系统会有很多微服务子项目， 每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境...... 那怎么对这些微服务配置进行管理呢？\n\nnacos的配置列表和命令空间：\n\n\n\n\n# 1.namespace+group+data id三者关系？\n\n# 1 namespace+group+data id是什么\n\n类似java里面的package名和类名 最外层的namespace是可以用于区分部署环境的，group和dataid逻辑上区分两个目标对象。\n\n# 2 三者情况\n\n默认情况：\n\n> namespace=public，group=default_group, 默认cluster是default\n\nnacos默认的命名空间是public，namespace主要用来实现隔离。 比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个namespace，不同的namespace之间是隔离的。\n\ngroup默认是default_group，group可以把不同的微服务划分到同一个分组里面去\n\nservice就是微服务；一个service可以包含多个cluster（集群），nacos默认cluster是default，cluster是对指定微服务的一个虚拟划分。 比方说为了容灾，将service微服务分别部署在了杭州机房和广州机房， 这时就可以给杭州机房的service微服务起一个集群名称（hz）， 给广州机房的service微服务起一个集群名称（gz），还可以尽量让同一个机房的微服务互相调用，以提升性能。\n\n最后是instance，就是微服务的实例。\n\n\n# 2.dataid配置方案\n\n根据微服务名-${spring.profile.active}.yaml来实现\n\n\n\n修改配置文件的active即可实现开发环境的区分：\n\n\n\n测试访问：http://localhost:3377/config/info\n\n\n# 3.group方案\n\nnacos新建相同data id不同的组：\n\n\n\n配置文件中指定使用哪个组的配置问题：\n\n\n\n测试访问：http://localhost:3377/config/info\n\n\n# 4.namespace方案\n\nnacos新建两个namespace：\n\n\n\nnacos在namespace为dev下创建三个配置文件：\n\n\n\n配置文件：\n\n\n\n测试访问：http://localhost:3377/config/info\n\n\n# 9.nacos持久化\n\nnacos架构：\n\n\n\n> nacos默认自带的是嵌入式数据库derby；\n> \n> 默认nacos使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的nacos节点，数据存储是存在一致性问题的。\n> \n> 为了解决这个问题，nacos采用了集中式存储的方式来支持集群化部署，目前只支持mysql的存储。\n\n在0.7版本之前，在单机模式时nacos使用嵌入式数据库实现数据的存储，不方便观察数据存储的基本情况。0.7版本增加了支持mysql数据源能力，具体的操作步骤：\n\n * 1.安装数据库，版本要求：5.6.5+\n * 2.初始化mysql数据库，数据库初始化文件：nacos-mysql.sql\n * 3.修改conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。\n\n\n# 1.准备mysql数据库\n\n\n# 2.sql脚本导入mysql数据库\n\n脚本路径：nacos-server-1.1.4\\nacos\\conf\\nacos-mysql.sql\n\n新建数据库：nacos_config\n\n\n# 3.修改nacos配置文件\n\n位置：nacos-server-1.1.4\\nacos\\conf\\application.properties\n\n添加内容：\n\nspring.datasource.platform=mysql\n \ndb.num=1\ndb.url.0=jdbc:mysql://192.168.188.128:3306/nacos_config?characterencoding=utf8&connecttimeout=1000&sockettimeout=3000&autoreconnect=true\ndb.user=root\ndb.password=2452952178\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 10.linux集群nacos\n\n\n# 1.环境准备\n\n * linux环境\n * jdk1.8+\n * maven3.2\n * 3个或3个以上nacos节点才能构成集群\n * mysql\n * nginx\n\n\n# 2.linux下载nacos\n\n地址\n\n对应版本：nacos-1.1.4.tar.gz\n\n\n# 3.解压\n\ntar -zxvf nacos-server-1.1.4.tar.gz\n\n\n1\n\n\n\n# 4.移动位置\n\ncp -r nacos /opt/module/nacos\n\n\n1\n\n\n\n# 5.linux服务器上mysql数据库配置\n\n1.首先执行mysql脚本\n\n\n# 6.application.properties 配置\n\n1.进入路径/opt/module/nacos/conf/\n\ncd /opt/module/nacos/conf\n\n\n1\n\n\n2.备份配置文件，害怕可能修改错误\n\ncp application.properties application.properties.bf\n\n\n1\n\n\n3.修改配置文件\n\nvi application.properties\n\n\n1\n\n\n4.内容\n\nspring.datasource.platform=mysql\n\ndb.num=1\ndb.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterencoding=utf8&connecttimeout=1000&sockettimeout=3000&autoreconnect=true\ndb.user=root\ndb.password=2452952178\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 7.linux服务器上nacos的集群配置cluster.conf\n\n1.同理：备份cluster.conf\n\ncp cluster.conf.example cluster.conf\n\n\n1\n\n\n2.修改cluster.conf\n\nvi cluster.conf\n\n\n1\n\n\n3.修改内容：\n\n> 这个ip不能写127.0.0.1，必须是 linux命令hostname -i能够识别的ip\n> \n> 一定要配置正确\n\n192.168.188.128:3333\n192.168.188.128:4444\n192.168.188.128:5555\n\n\n1\n2\n3\n\n\n\n# 8.编辑nacos的启动脚本startup.sh，使它能够接受不同的启动端口\n\n> 平时单机版的启动，都是./startup.sh即可。\n> \n> 但是：\n> \n> 集群启动，我们希望可以类似其它软件的shell命令，传递不同的端口号启动不同的nacos实例。 命令：./startup.sh -p 3333 表示启动端口号为3333的nacos服务器实例，和上一步的cluster.conf配置的一致。\n\n1.进入目录\n\ncd /opt/module/nacos/bin\n\n\n1\n\n\n2.备份\n\ncp startup.sh startup.sh.bf\n\n\n1\n\n\n3.修改startup.sh\n\nvi startup.sh\n\n\n1\n\n\n4.修改内容\n\n注意那里是p)\n\n修改前   修改后\n      \n      \n\n5.执行方式：\n\n./startup.sh -p 3333\n./startup.sh -p 4444\n./startup.sh -p 5555\n\n\n1\n2\n3\n\n\n查看是否启动\nps -ef|grep nacos|grep -v grep|wc -l\n\n\n1\n2\n\n\n6.测试访问地址\n\nhttp://192.168.188.128:3333/nacos\nhttp://192.168.188.128:4444/nacos\nhttp://192.168.188.128:5555/nacos\n\n\n1\n2\n3\n\n\n\n# 9.nginx的配置，由它作为负载均衡器\n\n1.下载和安装参考文档nginx安装\n\n2.安装好后，查看nginx在哪\n\nwhereis nginx\n\n\n1\n\n\n3.进入目录\n\ncd /usr/local/nginx/conf\n\n\n1\n\n\n4.备份\n\ncp nginx.conf nginx.conf.bf\n\n\n1\n\n\n5.修改配置文件\n\nvi nginx.conf\n\n\n1\n\n\n6.内容：\n\n#增加映射端口\nupstream cluster{\n        server 127.0.0.1:3333;\n        server 127.0.0.1:4444;\n        server 127.0.0.1:5555;\n}\n#修改端口和location\nserver {\n        listen       1111;\n        server_name  localhost;\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;\n        location / {\n            #root   html;\n            #index  index.html index.htm;\n            proxy_pass http://cluster;\n        }\n.......省略\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n7.执行命令\n\ncd /usr/local/nginx/sbin\n#指定的配置文件启动\n./nginx -c /usr/local/nginx/conf/nginx.conf\n\n\n1\n2\n3\n\n\n8.测试\n\n访问地址：http://192.168.188.128:1111/nacos\n\n\n1\n\n\n\n# 11.微服务cloudalibaba-provider-payment9001启动注册进nacos集群\n\nserver-addr：配置ngnix的ip+端口进行转发\n\nserver:\n  port: 9001\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n      #server-addr: localhost:8848 #配置nacos地址\n        #配置nginx转发地址\n        server-addr: 192.168.188.128:1111\n\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \'*\'\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',charsets:{cjk:!0},lastUpdated:"2021/09/22, 16:16:17"},{title:"Stream",frontmatter:{title:"Stream",date:"2021-08-24T14:38:22.000Z",permalink:"/pages/79277f/",categories:["后端","Spring全家桶","SpringCloud"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/15.Stream.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/15.Stream.md",key:"v-bc34ada2",path:"/pages/79277f/",headers:[{level:2,title:"1.引入stream的原因",slug:"_1-引入stream的原因",normalizedTitle:"1.引入stream的原因",charIndex:80},{level:2,title:"2.什么是stream",slug:"_2-什么是stream",normalizedTitle:"2.什么是stream",charIndex:248},{level:2,title:"3.设计思想",slug:"_3-设计思想",normalizedTitle:"3.设计思想",charIndex:626},{level:3,title:"1.标准的MQ的流程:",slug:"_1-标准的mq的流程",normalizedTitle:"1.标准的mq的流程:",charIndex:637},{level:3,title:"2.Binder",slug:"_2-binder",normalizedTitle:"2.binder",charIndex:721},{level:2,title:"4.编码API和常用注解",slug:"_4-编码api和常用注解",normalizedTitle:"4.编码api和常用注解",charIndex:1082},{level:2,title:"5.消息驱动之生产者8801",slug:"_5-消息驱动之生产者8801",normalizedTitle:"5.消息驱动之生产者8801",charIndex:1271},{level:3,title:"1.新建模块：cloud-stream-rabbitmq-provider8801",slug:"_1-新建模块-cloud-stream-rabbitmq-provider8801",normalizedTitle:"1.新建模块：cloud-stream-rabbitmq-provider8801",charIndex:1290},{level:3,title:"2.引入依赖",slug:"_2-引入依赖",normalizedTitle:"2.引入依赖",charIndex:1336},{level:3,title:"3.配置文件",slug:"_3-配置文件",normalizedTitle:"3.配置文件",charIndex:3362},{level:3,title:"4.主启动类",slug:"_4-主启动类",normalizedTitle:"4.主启动类",charIndex:4656},{level:3,title:"5.业务类",slug:"_5-业务类",normalizedTitle:"5.业务类",charIndex:5032},{level:3,title:"6.controller",slug:"_6-controller",normalizedTitle:"6.controller",charIndex:6204},{level:3,title:"7.测试",slug:"_7-测试",normalizedTitle:"7.测试",charIndex:6785},{level:2,title:"6.消息驱动之消费者",slug:"_6-消息驱动之消费者",normalizedTitle:"6.消息驱动之消费者",charIndex:6879},{level:3,title:"1.新建模块：cloud-stream-rabbitmq-consumer8802、cloud-stream-rabbitmq-consumer8803",slug:"_1-新建模块-cloud-stream-rabbitmq-consumer8802、cloud-stream-rabbitmq-consumer8803",normalizedTitle:"1.新建模块：cloud-stream-rabbitmq-consumer8802、cloud-stream-rabbitmq-consumer8803",charIndex:6905},{level:3,title:"2.引入依赖",slug:"_2-引入依赖-2",normalizedTitle:"2.引入依赖",charIndex:1336},{level:3,title:"3.修改配置文件",slug:"_3-修改配置文件",normalizedTitle:"3.修改配置文件",charIndex:9016},{level:3,title:"4.主启动类",slug:"_4-主启动类-2",normalizedTitle:"4.主启动类",charIndex:4656},{level:3,title:"5.业务类（接收消息）",slug:"_5-业务类-接收消息",normalizedTitle:"5.业务类（接收消息）",charIndex:10544},{level:3,title:"6.测试",slug:"_6-测试",normalizedTitle:"6.测试",charIndex:11427},{level:2,title:"7.重复消费问题、持久化",slug:"_7-重复消费问题、持久化",normalizedTitle:"7.重复消费问题、持久化",charIndex:11556}],headersStr:"1.引入stream的原因 2.什么是stream 3.设计思想 1.标准的MQ的流程: 2.Binder 4.编码API和常用注解 5.消息驱动之生产者8801 1.新建模块：cloud-stream-rabbitmq-provider8801 2.引入依赖 3.配置文件 4.主启动类 5.业务类 6.controller 7.测试 6.消息驱动之消费者 1.新建模块：cloud-stream-rabbitmq-consumer8802、cloud-stream-rabbitmq-consumer8803 2.引入依赖 3.修改配置文件 4.主启动类 5.业务类（接收消息） 6.测试 7.重复消费问题、持久化",content:'# Stream\n\nstream的中文文档：https://m.wang1314.com/doc/webapp/topic/20971999.html\n\n\n# 1.引入stream的原因\n\n屏蔽底层消息中间件的差异,降低切换成本，统一消息的编程模型\n\n\n\n由于市面上有很多MQ，这个微服务使用了RabbitMQ，那个微服务使用了kafka，每个MQ都有不同的操作，给开发者造成了困难，所以引入Stream整合市面上开源的MQ；\n\n类似于mybatis操作数据库、slf4j日志门面等等；\n\n\n# 2.什么是stream\n\n官方定义 Spring Cloud Stream 是一个构建消息驱动微服务的框架。\n\n应用程序通过 inputs 或者 outputs 来与 Spring Cloud Stream中binder对象交互。 通过我们配置来binding(绑定) ，而 Spring Cloud Stream 的 binder对象负责与消息中间件交互。 所以，我们只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。\n\n通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。 Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。\n\n> 目前仅支持RabbitMQ、Kafka。\n\n\n# 3.设计思想\n\n\n# 1.标准的MQ的流程:\n\n 1. 生产者/消费者之间靠消息媒介传递信息内容\n 2. 消息必须走特定的通道\n 3. 消息通道里的消息如何被消费呢，谁负责收发处理\n\n\n# 2.Binder\n\n在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性，通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。Stream对消息中间件的进一步封装，可以做到代码层面对中间件的无感知，甚至于动态的切换中间件(rabbitmq切换为kafka)，使得微服务开发的高度解耦，服务可以关注更多自己的业务流程\n\n\n\n通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。\n\nBinder可以生成Binding，Binding用来绑定消息容器的生产者和消费者，它有两种类型，INPUT和OUTPUT，INPUT对应于消费者，OUTPUT对应于生产者。\n\n\n# 4.编码API和常用注解\n\n\n\n 1. Binder：很方便的连接中间件，屏蔽差异\n 2. Channel：通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置\n 3. Source和Sink：简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入。\n\n\n# 5.消息驱动之生产者8801\n\n\n# 1.新建模块：cloud-stream-rabbitmq-provider8801\n\n\n# 2.引入依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloud-stream-rabbitmq-provider8801</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-stream-rabbit</artifactId>\n        </dependency>\n        \x3c!--基础配置--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 3.配置文件\n\n * defaultRabbit：\n   * type：消息类型，只支持rabbitmq和kafka\n   * environment：配置消息的IP等信息\n * bindings：\n   * output：生产者\n     * destination：消息的名字，类似于kafka的topic主题\n\nserver:\n  port: 8801\n\nspring:\n  application:\n    name: cloud-stream-provider\n  cloud:\n    stream:\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\n        defaultRabbit: # 表示定义的名称，用于于binding整合\n          type: rabbit # 消息组件类型\n          environment: # 设置rabbitmq的相关的环境配置\n            spring:\n              rabbitmq:\n                host: 192.168.188.128\n                port: 5672\n                username: guest\n                password: guest\n      bindings: # 服务的整合处理\n        output: # 这个名字是一个通道的名称\n          destination: WCYExchange # 表示要使用的Exchange名称定义\n          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”\n          binder: defaultRabbit # 设置要绑定的消息服务的具体设置\n\neureka:\n  client: # 客户端进行Eureka注册的配置\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: send-8801.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为IP地址\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class StreamMQMain8801\n{\n    public static void main(String[] args)\n    {\n        SpringApplication.run(StreamMQMain8801.class,args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 5.业务类\n\n# 1.发送消息接口\n\npackage com.wcy.springcloud.server;\n\npublic interface IMessageProvider {\n    public void send();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 2.消息实现类\n\n * @Service：别忘了该注解\n * @EnableBinding：绑定管道\n * MessageChannel：管道，发送消息\n * MessageBuilder：构建消息\n\npackage com.wcy.springcloud.server.impl;\n\nimport com.wcy.springcloud.server.IMessageProvider;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cloud.stream.annotation.EnableBinding;\nimport org.springframework.cloud.stream.messaging.Source;\nimport org.springframework.integration.support.MessageBuilder;\nimport org.springframework.messaging.MessageChannel;\nimport org.springframework.stereotype.Service;\n\nimport java.util.UUID;\n\n/**\n * 发送消息\n */\n@Service\n@EnableBinding(Source.class)// 可以理解为是一个消息的发送管道的定义\npublic class MessageProviderImpl implements IMessageProvider {\n    //获取发送管道\n    @Autowired\n    private MessageChannel output;\n    @Override\n    public void send() {\n        String message= UUID.randomUUID().toString();\n        //发送消息\n        output.send(MessageBuilder.withPayload(message).build());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 6.controller\n\npackage com.wcy.springcloud.server.controller;\n\nimport com.wcy.springcloud.server.IMessageProvider;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class SendMessageController {\n    @Autowired\n    private IMessageProvider messageProvider;\n\n    @GetMapping("/send")\n    public String send(){\n        messageProvider.send();\n        return "发送成功";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 7.测试\n\n * 启动eureka7001、eureka7002\n * 启动rabbitmq\n * 启动8801\n\n访问地址：http://localhost:8801/send\n\n\n# 6.消息驱动之消费者\n\n新建两个消费者模块\n\n\n# 1.新建模块：cloud-stream-rabbitmq-consumer8802、cloud-stream-rabbitmq-consumer8803\n\n\n# 2.引入依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>CloudStudy</artifactId>\n        <groupId>com.wcy.springcloud</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>cloud-stream-rabbitmq-consumer8802</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-stream-rabbit</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \x3c!--基础配置--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 3.修改配置文件\n\nserver:\n  port: 8802\n\nspring:\n  application:\n    name: cloud-stream-consumer\n  cloud:\n    stream:\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\n        defaultRabbit: # 表示定义的名称，用于于binding整合\n          type: rabbit # 消息组件类型\n          environment: # 设置rabbitmq的相关的环境配置\n            spring:\n              rabbitmq:\n                host: 192.168.188.128\n                port: 5672\n                username: guest\n                password: guest\n      bindings: # 服务的整合处理\n        input: # 这个名字是一个通道的名称\n          destination: WCYExchange # 表示要使用的Exchange名称定义\n          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”\n          binder: defaultRabbit # 设置要绑定的消息服务的具体设置\n\neureka:\n  client: # 客户端进行Eureka注册的配置\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: receive-8802.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为IP地址\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class StreamMQMain8802\n{\n    public static void main(String[] args)\n    {\n        SpringApplication.run(StreamMQMain8802.class,args);\n    }\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 5.业务类（接收消息）\n\n * Component：注入spring容器\n * EnableBinding：与消费者管道绑定\n * StreamListener：消费者监听器\n\npackage com.wcy.springcloud.listener;\n\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.cloud.stream.annotation.EnableBinding;\nimport org.springframework.cloud.stream.annotation.StreamListener;\nimport org.springframework.cloud.stream.messaging.Sink;\nimport org.springframework.messaging.Message;\nimport org.springframework.stereotype.Component;\n\n/**\n * 接受消息\n */\n@Component\n@EnableBinding(Sink.class)\npublic class ReceiveMessageListener {\n    @Value("${server.port}")\n    private String serverPort;\n\n    @StreamListener(Sink.INPUT)\n    public void input(Message<String> message){\n        System.out.println("消费者1号，-------\x3e接收到的消息：" + message.getPayload()+"\\t port: "+serverPort);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 6.测试\n\n * 启动eureka7001、eureka7002\n * 启动8801生产者\n * 启动8802消费者、启动8803消费者\n\n测试地址：http://localhost:8801/send 可以看到8802、8803控制台接收到的数据\n\n\n# 7.重复消费问题、持久化\n\n目前是8802/8803同时都收到了，存在重复消费问题\n\n比如：在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息， 那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。 这时我们就可以使用Stream中的消息分组来解决\n\n解决：分组属性group，类似于kafka同一个消费者组里的消费者不能消费同一个分区的消息\n\n持久化：\n\n> 配置group属性后，8802宕机后，消费者重启后收到生产者之前发送的消息\n\n8802/8803消费者yml中配置相同组名\n\nspring:\n  application:\n    name: cloud-stream-consumer\n  cloud:\n    stream:\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\n        defaultRabbit: # 表示定义的名称，用于于binding整合\n          type: rabbit # 消息组件类型\n          environment: # 设置rabbitmq的相关的环境配置\n            spring:\n              rabbitmq:\n                host: 192.168.188.128\n                port: 5672\n                username: guest\n                password: guest\n      bindings: # 服务的整合处理\n        input: # 这个名字是一个通道的名称\n          destination: WCYExchange # 表示要使用的Exchange名称定义\n          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”\n          binder: defaultRabbit # 设置要绑定的消息服务的具体设置\n          group: wcy #设置分组\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',normalizedContent:'# stream\n\nstream的中文文档：https://m.wang1314.com/doc/webapp/topic/20971999.html\n\n\n# 1.引入stream的原因\n\n屏蔽底层消息中间件的差异,降低切换成本，统一消息的编程模型\n\n\n\n由于市面上有很多mq，这个微服务使用了rabbitmq，那个微服务使用了kafka，每个mq都有不同的操作，给开发者造成了困难，所以引入stream整合市面上开源的mq；\n\n类似于mybatis操作数据库、slf4j日志门面等等；\n\n\n# 2.什么是stream\n\n官方定义 spring cloud stream 是一个构建消息驱动微服务的框架。\n\n应用程序通过 inputs 或者 outputs 来与 spring cloud stream中binder对象交互。 通过我们配置来binding(绑定) ，而 spring cloud stream 的 binder对象负责与消息中间件交互。 所以，我们只需要搞清楚如何与 spring cloud stream 交互就可以方便使用消息驱动的方式。\n\n通过使用spring integration来连接消息代理中间件以实现消息事件驱动。 spring cloud stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。\n\n> 目前仅支持rabbitmq、kafka。\n\n\n# 3.设计思想\n\n\n# 1.标准的mq的流程:\n\n 1. 生产者/消费者之间靠消息媒介传递信息内容\n 2. 消息必须走特定的通道\n 3. 消息通道里的消息如何被消费呢，谁负责收发处理\n\n\n# 2.binder\n\n在没有绑定器这个概念的情况下，我们的springboot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性，通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。stream对消息中间件的进一步封装，可以做到代码层面对中间件的无感知，甚至于动态的切换中间件(rabbitmq切换为kafka)，使得微服务开发的高度解耦，服务可以关注更多自己的业务流程\n\n\n\n通过定义绑定器binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。\n\nbinder可以生成binding，binding用来绑定消息容器的生产者和消费者，它有两种类型，input和output，input对应于消费者，output对应于生产者。\n\n\n# 4.编码api和常用注解\n\n\n\n 1. binder：很方便的连接中间件，屏蔽差异\n 2. channel：通道，是队列queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过channel对队列进行配置\n 3. source和sink：简单的可理解为参照对象是spring cloud stream自身，从stream发布消息就是输出，接受消息就是输入。\n\n\n# 5.消息驱动之生产者8801\n\n\n# 1.新建模块：cloud-stream-rabbitmq-provider8801\n\n\n# 2.引入依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloud-stream-rabbitmq-provider8801</artifactid>\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-stream-rabbit</artifactid>\n        </dependency>\n        \x3c!--基础配置--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 3.配置文件\n\n * defaultrabbit：\n   * type：消息类型，只支持rabbitmq和kafka\n   * environment：配置消息的ip等信息\n * bindings：\n   * output：生产者\n     * destination：消息的名字，类似于kafka的topic主题\n\nserver:\n  port: 8801\n\nspring:\n  application:\n    name: cloud-stream-provider\n  cloud:\n    stream:\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\n        defaultrabbit: # 表示定义的名称，用于于binding整合\n          type: rabbit # 消息组件类型\n          environment: # 设置rabbitmq的相关的环境配置\n            spring:\n              rabbitmq:\n                host: 192.168.188.128\n                port: 5672\n                username: guest\n                password: guest\n      bindings: # 服务的整合处理\n        output: # 这个名字是一个通道的名称\n          destination: wcyexchange # 表示要使用的exchange名称定义\n          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”\n          binder: defaultrabbit # 设置要绑定的消息服务的具体设置\n\neureka:\n  client: # 客户端进行eureka注册的配置\n    service-url:\n      defaultzone: http://localhost:7001/eureka,http://localhost:7002/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: send-8801.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为ip地址\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\n\n@springbootapplication\npublic class streammqmain8801\n{\n    public static void main(string[] args)\n    {\n        springapplication.run(streammqmain8801.class,args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 5.业务类\n\n# 1.发送消息接口\n\npackage com.wcy.springcloud.server;\n\npublic interface imessageprovider {\n    public void send();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 2.消息实现类\n\n * @service：别忘了该注解\n * @enablebinding：绑定管道\n * messagechannel：管道，发送消息\n * messagebuilder：构建消息\n\npackage com.wcy.springcloud.server.impl;\n\nimport com.wcy.springcloud.server.imessageprovider;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.cloud.stream.annotation.enablebinding;\nimport org.springframework.cloud.stream.messaging.source;\nimport org.springframework.integration.support.messagebuilder;\nimport org.springframework.messaging.messagechannel;\nimport org.springframework.stereotype.service;\n\nimport java.util.uuid;\n\n/**\n * 发送消息\n */\n@service\n@enablebinding(source.class)// 可以理解为是一个消息的发送管道的定义\npublic class messageproviderimpl implements imessageprovider {\n    //获取发送管道\n    @autowired\n    private messagechannel output;\n    @override\n    public void send() {\n        string message= uuid.randomuuid().tostring();\n        //发送消息\n        output.send(messagebuilder.withpayload(message).build());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 6.controller\n\npackage com.wcy.springcloud.server.controller;\n\nimport com.wcy.springcloud.server.imessageprovider;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\n@restcontroller\npublic class sendmessagecontroller {\n    @autowired\n    private imessageprovider messageprovider;\n\n    @getmapping("/send")\n    public string send(){\n        messageprovider.send();\n        return "发送成功";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 7.测试\n\n * 启动eureka7001、eureka7002\n * 启动rabbitmq\n * 启动8801\n\n访问地址：http://localhost:8801/send\n\n\n# 6.消息驱动之消费者\n\n新建两个消费者模块\n\n\n# 1.新建模块：cloud-stream-rabbitmq-consumer8802、cloud-stream-rabbitmq-consumer8803\n\n\n# 2.引入依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>cloudstudy</artifactid>\n        <groupid>com.wcy.springcloud</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>cloud-stream-rabbitmq-consumer8802</artifactid>\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-starter-stream-rabbit</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-actuator</artifactid>\n        </dependency>\n        \x3c!--基础配置--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-devtools</artifactid>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 3.修改配置文件\n\nserver:\n  port: 8802\n\nspring:\n  application:\n    name: cloud-stream-consumer\n  cloud:\n    stream:\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\n        defaultrabbit: # 表示定义的名称，用于于binding整合\n          type: rabbit # 消息组件类型\n          environment: # 设置rabbitmq的相关的环境配置\n            spring:\n              rabbitmq:\n                host: 192.168.188.128\n                port: 5672\n                username: guest\n                password: guest\n      bindings: # 服务的整合处理\n        input: # 这个名字是一个通道的名称\n          destination: wcyexchange # 表示要使用的exchange名称定义\n          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”\n          binder: defaultrabbit # 设置要绑定的消息服务的具体设置\n\neureka:\n  client: # 客户端进行eureka注册的配置\n    service-url:\n      defaultzone: http://localhost:7001/eureka,http://localhost:7002/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: receive-8802.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为ip地址\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 4.主启动类\n\npackage com.wcy.springcloud;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\n\n@springbootapplication\npublic class streammqmain8802\n{\n    public static void main(string[] args)\n    {\n        springapplication.run(streammqmain8802.class,args);\n    }\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 5.业务类（接收消息）\n\n * component：注入spring容器\n * enablebinding：与消费者管道绑定\n * streamlistener：消费者监听器\n\npackage com.wcy.springcloud.listener;\n\n\nimport org.springframework.beans.factory.annotation.value;\nimport org.springframework.cloud.stream.annotation.enablebinding;\nimport org.springframework.cloud.stream.annotation.streamlistener;\nimport org.springframework.cloud.stream.messaging.sink;\nimport org.springframework.messaging.message;\nimport org.springframework.stereotype.component;\n\n/**\n * 接受消息\n */\n@component\n@enablebinding(sink.class)\npublic class receivemessagelistener {\n    @value("${server.port}")\n    private string serverport;\n\n    @streamlistener(sink.input)\n    public void input(message<string> message){\n        system.out.println("消费者1号，-------\x3e接收到的消息：" + message.getpayload()+"\\t port: "+serverport);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 6.测试\n\n * 启动eureka7001、eureka7002\n * 启动8801生产者\n * 启动8802消费者、启动8803消费者\n\n测试地址：http://localhost:8801/send 可以看到8802、8803控制台接收到的数据\n\n\n# 7.重复消费问题、持久化\n\n目前是8802/8803同时都收到了，存在重复消费问题\n\n比如：在如下场景中，订单系统我们做集群部署，都会从rabbitmq中获取订单信息， 那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。 这时我们就可以使用stream中的消息分组来解决\n\n解决：分组属性group，类似于kafka同一个消费者组里的消费者不能消费同一个分区的消息\n\n持久化：\n\n> 配置group属性后，8802宕机后，消费者重启后收到生产者之前发送的消息\n\n8802/8803消费者yml中配置相同组名\n\nspring:\n  application:\n    name: cloud-stream-consumer\n  cloud:\n    stream:\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\n        defaultrabbit: # 表示定义的名称，用于于binding整合\n          type: rabbit # 消息组件类型\n          environment: # 设置rabbitmq的相关的环境配置\n            spring:\n              rabbitmq:\n                host: 192.168.188.128\n                port: 5672\n                username: guest\n                password: guest\n      bindings: # 服务的整合处理\n        input: # 这个名字是一个通道的名称\n          destination: wcyexchange # 表示要使用的exchange名称定义\n          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”\n          binder: defaultrabbit # 设置要绑定的消息服务的具体设置\n          group: wcy #设置分组\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"经典SQL语句",frontmatter:{title:"经典SQL语句",date:"2021-07-08T19:10:42.000Z",permalink:"/pages/31cb74/",categories:["数据库","Mysql"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/20.%E6%95%B0%E6%8D%AE%E5%BA%93/00.Mysql/00.%E7%BB%8F%E5%85%B8SQL%E8%AF%AD%E5%8F%A5.html",relativePath:"01.后端/20.数据库/00.Mysql/00.经典SQL语句.md",key:"v-32c6d179",path:"/pages/31cb74/",headers:[{level:2,title:"1.查询最近30天违规数据（没有违规，显示该时间，值为0就行)",slug:"_1-查询最近30天违规数据-没有违规-显示该时间-值为0就行",normalizedTitle:"1.查询最近30天违规数据（没有违规，显示该时间，值为0就行)",charIndex:14},{level:2,title:"2.当UNION和ORDER BY使用的问题",slug:"_2-当union和order-by使用的问题",normalizedTitle:"2.当union和order by使用的问题",charIndex:1231}],headersStr:"1.查询最近30天违规数据（没有违规，显示该时间，值为0就行) 2.当UNION和ORDER BY使用的问题",content:"# 经典SQL语句\n\n\n# 1.查询最近30天违规数据（没有违规，显示该时间，值为0就行)\n\n\x3c!--1.查询聊天室违规次数--\x3e\nselect '0' as type,lefttable.date,IFNULL(righttable.result,'0') as count\nfrom\n\x3c!--查询最近30天的日期--\x3e\n(select date_sub(CURDATE(),interval @i:=@i+1 day) as date\nfrom (select 1 union all  select 1 union all  select 1 union all select 1 union all select 1 union all select 1 union all  select 1 union all select 1\n union all select 1 union all select 1 union all  select 1 union all select 1 union all select 1 union all select 1 union all  select 1 union all select 1\nunion all select 1 union all select 1 union all  select 1 union all select 1 union all select 1 union all select 1 union all  select 1 union all select 1\nunion all select 1 union all select 1 union all  select 1 union all select 1 union all select 1 union all select 1) as tmp,\n (select @i:= -1) t)as lefttable\nLEFT JOIN\n\x3c!--统计30天内的违规数据--\x3e\n(SELECT\n    DATE_FORMAT( createTime, '%Y-%m-%d' ) AS gtdate,\n    COUNT( 1 ) AS result\nFROM\n    my_course_socket\nWHERE\n    DATE(createTime)>=DATE_SUB(CURDATE(), INTERVAL 29 DAY)\n    and isViolations =1\nGROUP BY\n    gtdate\nORDER BY\n    gtdate) as righttable\non lefttable.date=righttable.gtdate\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 2.当UNION和ORDER BY使用的问题\n\n①.需求分组排序完 再合并(重要)\n\n(   select * from (\n                select a from a1  order by a2\n     ) as table1\n) \nunion \n(   select * from ( \n                 select b from b1 order by b2 \n    ) as table2 \n) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n②.整体合并 再排序\n\nselect  *  from\n\n（...   union    ....）   as  a    【派生表别忘了加别名，否则 Every derived table must have its own alias】\n\norder  by..\n\norder by 别忘了在 select语句中查询出\n\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# 经典sql语句\n\n\n# 1.查询最近30天违规数据（没有违规，显示该时间，值为0就行)\n\n\x3c!--1.查询聊天室违规次数--\x3e\nselect '0' as type,lefttable.date,ifnull(righttable.result,'0') as count\nfrom\n\x3c!--查询最近30天的日期--\x3e\n(select date_sub(curdate(),interval @i:=@i+1 day) as date\nfrom (select 1 union all  select 1 union all  select 1 union all select 1 union all select 1 union all select 1 union all  select 1 union all select 1\n union all select 1 union all select 1 union all  select 1 union all select 1 union all select 1 union all select 1 union all  select 1 union all select 1\nunion all select 1 union all select 1 union all  select 1 union all select 1 union all select 1 union all select 1 union all  select 1 union all select 1\nunion all select 1 union all select 1 union all  select 1 union all select 1 union all select 1 union all select 1) as tmp,\n (select @i:= -1) t)as lefttable\nleft join\n\x3c!--统计30天内的违规数据--\x3e\n(select\n    date_format( createtime, '%y-%m-%d' ) as gtdate,\n    count( 1 ) as result\nfrom\n    my_course_socket\nwhere\n    date(createtime)>=date_sub(curdate(), interval 29 day)\n    and isviolations =1\ngroup by\n    gtdate\norder by\n    gtdate) as righttable\non lefttable.date=righttable.gtdate\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 2.当union和order by使用的问题\n\n①.需求分组排序完 再合并(重要)\n\n(   select * from (\n                select a from a1  order by a2\n     ) as table1\n) \nunion \n(   select * from ( \n                 select b from b1 order by b2 \n    ) as table2 \n) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n②.整体合并 再排序\n\nselect  *  from\n\n（...   union    ....）   as  a    【派生表别忘了加别名，否则 every derived table must have its own alias】\n\norder  by..\n\norder by 别忘了在 select语句中查询出\n\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"索引失效的十大杂症",frontmatter:{title:"索引失效的十大杂症",date:"2021-08-30T10:48:16.000Z",permalink:"/pages/ef2328/",categories:["后端","数据库","Mysql"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/20.%E6%95%B0%E6%8D%AE%E5%BA%93/00.Mysql/02.%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%8D%81%E5%A4%A7%E6%9D%82%E7%97%87.html",relativePath:"01.后端/20.数据库/00.Mysql/02.索引失效的十大杂症.md",key:"v-7a886be6",path:"/pages/ef2328/",headers:[{level:3,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:82},{level:3,title:"一、查询条件包含or，可能导致索引失效",slug:"一、查询条件包含or-可能导致索引失效",normalizedTitle:"一、查询条件包含or，可能导致索引失效",charIndex:150},{level:3,title:"二、如何字段类型是字符串，where时一定用引号括起来，否则索引失效",slug:"二、如何字段类型是字符串-where时一定用引号括起来-否则索引失效",normalizedTitle:"二、如何字段类型是字符串，where时一定用引号括起来，否则索引失效",charIndex:708},{level:3,title:"三、like通配符可能导致索引失效。",slug:"三、like通配符可能导致索引失效。",normalizedTitle:"三、like通配符可能导致索引失效。",charIndex:1186},{level:3,title:"四、联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。",slug:"四、联合索引-查询时的条件列不是联合索引中的第一个列-索引失效。",normalizedTitle:"四、联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。",charIndex:1693},{level:3,title:"五、在索引列上使用mysql的内置函数，索引失效。",slug:"五、在索引列上使用mysql的内置函数-索引失效。",normalizedTitle:"五、在索引列上使用mysql的内置函数，索引失效。",charIndex:2257},{level:3,title:"六、对索引列运算（如，+、-、*、/），索引失效。",slug:"六、对索引列运算-如-、-、-、-索引失效。",normalizedTitle:"六、对索引列运算（如，+、-、*、/），索引失效。",charIndex:2645},{level:3,title:"七、索引字段上使用（！= 或者 ，not in）时，可能会导致索引失效。",slug:"七、索引字段上使用-或者-not-in-时-可能会导致索引失效。",normalizedTitle:"七、索引字段上使用（！= 或者 ，not in）时，可能会导致索引失效。",charIndex:null},{level:3,title:"八、索引字段上使用is null， is not null，可能导致索引失效。",slug:"八、索引字段上使用is-null-is-not-null-可能导致索引失效。",normalizedTitle:"八、索引字段上使用is null， is not null，可能导致索引失效。",charIndex:3349},{level:3,title:"九、左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。",slug:"九、左连接查询或者右连接查询查询关联的字段编码格式不一样-可能导致索引失效。",normalizedTitle:"九、左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。",charIndex:3795},{level:3,title:"十、mysql估计使用全表扫描要比使用索引快,则不使用索引。",slug:"十、mysql估计使用全表扫描要比使用索引快-则不使用索引。",normalizedTitle:"十、mysql估计使用全表扫描要比使用索引快,则不使用索引。",charIndex:4499},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:120}],headersStr:"背景 一、查询条件包含or，可能导致索引失效 二、如何字段类型是字符串，where时一定用引号括起来，否则索引失效 三、like通配符可能导致索引失效。 四、联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。 五、在索引列上使用mysql的内置函数，索引失效。 六、对索引列运算（如，+、-、*、/），索引失效。 七、索引字段上使用（！= 或者 ，not in）时，可能会导致索引失效。 八、索引字段上使用is null， is not null，可能导致索引失效。 九、左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。 十、mysql估计使用全表扫描要比使用索引快,则不使用索引。 总结",content:"# 后端程序员必备：索引失效的十大杂症\n\n搬砖\n\n原创 捡田螺的小男孩 [捡田螺的小男孩](javascript:void(0)😉 2019-12-08\n\n\n# 背景\n\n最近生产爆出一条慢sql，原因是用了or和!=，导致索引失效。于是，总结了索引失效的十大杂症，希望对大家有帮助，加油。\n\n\n# 一、查询条件包含or，可能导致索引失效\n\n新建一个user表，它有一个普通索引userId，结构如下：\n\nCREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `userId` int(11) NOT NULL,  `age` int(11) NOT NULL,  `name` varchar(255) NOT NULL,  PRIMARY KEY (`id`),  KEY `idx_userId` (`userId`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n1\n\n 1. 执行一条查询sql，它是会走索引的，如下图所示：\n 2. 把or条件+没有索引的age加上，并不会走索引，如图：\n\n分析&结论：\n\n * 对于or+没有索引的age这种情况，假设它走了userId的索引，但是走到age查询条件时，它还得全表扫描，也就是需要三步过程：全表扫描+索引扫描+合并\n * 如果它一开始就走全表扫描，直接一遍扫描就完事。\n * mysql是有优化器的，处于效率与成本考虑，遇到or条件，让索引失效，看起来也合情合理嘛。\n\n注意: 如果or条件的列都加了索引，索引可能会走的，大家可以自己试一试。\n\n\n# 二、如何字段类型是字符串，where时一定用引号括起来，否则索引失效\n\n假设demo表结构如下：\n\nCREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `userId` varchar(32) NOT NULL,  `name` varchar(255) NOT NULL,  PRIMARY KEY (`id`),  KEY `idx_userId` (`userId`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\n\n\n1\n\n\nuserId为字符串类型，是B+树的普通索引，如果查询条件传了一个数字过去，它是不走索引的，如图所示：\n\n如果给数字加上'',也就是传一个字符串呢，当然是走索引，如下图：\n\n\n\n分析与结论：\n\n为什么第一条语句未加单引号就不走索引了呢？这是因为不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL会做隐式的类型转换，把它们转换为浮点数再做比较。\n\n\n# 三、like通配符可能导致索引失效。\n\n并不是用了like通配符，索引一定失效，而是like查询是以%开头，才会导致索引失效。\n\n表结构：\n\nCREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `userId` varchar(32) NOT NULL,  `name` varchar(255) NOT NULL,  PRIMARY KEY (`id`),  KEY `idx_userId` (`userId`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\n\n\n1\n\n\nlike查询以%开头，索引失效，如图：\n\n把%放后面，发现索引还是正常走的，如下：\n\n把%加回来，改为只查索引的字段（覆盖索引），发现还是走索引，惊不惊喜，意不意外\n\n结论：\n\nlike查询以%开头，会导致索引失效。可以有两种方式优化：\n\n * 使用覆盖索引\n * 把%放后面\n\n附: 索引包含所有满足查询需要的数据的索引，称为覆盖索引(Covering Index)。\n\n\n# 四、联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。\n\n表结构：（有一个联合索引 idx_userid_age， userId在前， age在后）\n\nCREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `userId` int(11) NOT NULL,  `age` int(11) DEFAULT NULL,  `name` varchar(255) NOT NULL,  PRIMARY KEY (`id`),  KEY `idx_userid_age` (`userId`,`age`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\n\n\n1\n\n\n在联合索引中，查询条件满足最左匹配原则时，索引是正常生效的。请看demo：\n\n\n\n\n\n如果条件列不是联合索引中的第一个列，索引失效，如下：\n\n\n\n分析与结论：\n\n * 当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。\n * 联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的。\n\n\n# 五、在索引列上使用mysql的内置函数，索引失效。\n\n表结构：\n\nCREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `userId` varchar(32) NOT NULL,  `loginTime` datetime NOT NULL,  PRIMARY KEY (`id`),  KEY `idx_userId` (`userId`) USING BTREE,  KEY `idx_login_time` (`loginTime`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\n\n\n1\n\n\n虽然loginTime加了索引，但是因为使用了mysql的内置函数Date_ADD()，索引直接GG，如图：\n\n\n# 六、对索引列运算（如，+、-、*、/），索引失效。\n\n表结构：\n\nCREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `userId` varchar(32) NOT NULL,  `age` int(11) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `idx_age` (`age`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\n\n\n1\n\n\n虽然age加了索引，但是因为它进行运算，索引直接迷路了。。。山重水复疑无路，算着算着脑瓜疼，索引就真的不认识路了。如图：\n\n\n\n\n# 七、索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。\n\n表结构：\n\nCREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `userId` int(11) NOT NULL,  `age` int(11) DEFAULT NULL,  `name` varchar(255) NOT NULL,  PRIMARY KEY (`id`),  KEY `idx_age` (`age`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\n\n\n1\n\n\n虽然age加了索引，但是使用了！= 或者 < >，not in这些时，索引如同虚设。如下：\n\n\n\n\n\n\n# 八、索引字段上使用is null， is not null，可能导致索引失效。\n\n表结构:\n\nCREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `card` varchar(255) DEFAULT NULL,  `name` varchar(255) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `idx_name` (`name`) USING BTREE,  KEY `idx_card` (`card`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\n\n\n1\n\n\n单个name字段加上索引，并查询name为非空的语句，其实会走索引的，如下:\n\n\n\n单个card字段加上索引，并查询name为非空的语句，其实也会走索引的，如下:\n\n但是它们用or连接起来，索引就失效了，如下：\n\n\n\n\n# 九、左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。\n\n新建两个表，一个user，一个user_job\n\nCREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(255) CHARACTER SET utf8mb4 DEFAULT NULL,  `age` int(11) NOT NULL,  PRIMARY KEY (`id`),  KEY `idx_name` (`name`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\nCREATE TABLE `user_job` (  `id` int(11) NOT NULL,  `userId` int(11) NOT NULL,  `job` varchar(255) DEFAULT NULL,  `name` varchar(255) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `idx_name` (`name`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n1\n2\n\n\nuser 表的name字段编码是utf8mb4，而user_job表的name字段编码为utf8。\n\n\n\n\n\n执行左外连接查询,user_job表还是走全表扫描，如下：\n\n\n\n如果把它们改为name字段编码一致，还是会一路高歌，雄赳赳，气昂昂，走向索引。\n\n\n\n\n# 十、mysql估计使用全表扫描要比使用索引快,则不使用索引。\n\n * 当表的索引被查询，会使用最好的索引，除非优化器使用全表扫描更有效。优化器优化成全表扫描取决与使用最好索引查出来的数据是否超过表的30%的数据。\n * 不要给'性别'等增加索引。如果某个数据列里包含了均是\"0/1\"或“Y/N”等值，即包含着许多重复的值，就算为它建立了索引，索引效果不会太好，还可能导致全表扫描。\n\nMysql出于效率与成本考虑，估算全表扫描与使用索引，哪个执行快。这跟它的优化器有关，来看一下它的逻辑架构图吧（图片来源网上）\n\n\n\n\n# 总结\n\n总结了索引失效的十大杂症，在这里来个首尾呼应吧，分析一下我们生产的那条慢sql。模拟的表结构与肇事sql如下：\n\nCREATE TABLE `user_session` (  \n`user_id` varchar(32) CHARACTER SET utf8mb4 NOT NULL,  \n`device_id` varchar(64) NOT NULL,  \n`status` varchar(2) NOT NULL,  \n`create_time` datetime NOT NULL,  \n`update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,  \nPRIMARY KEY (`user_id`,`device_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nexplain update user_session set status =1 where  (`user_id` = '1' and `device_id`!='2')or (`user_id` != '1' and `device_id`='2')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n分析：\n\n * 执行的sql，使用了 or条件，因为组合主键( user_id, device_id)，看起来像是每一列都加了索引，索引会生效。\n * 但是出现 !=,可能导致索引失效。也就是 or+ !=两大综合症，导致了慢更新sql。\n\n解决方案:\n\n那么，怎么解决呢？我们是把 or条件拆掉，分成两条执行。同时给 device_id加一个普通索引。\n\n最后，总结了索引失效的十大杂症，希望大家在工作学习中，参考这十大杂症，多点结合执行计划 expain和场景，具体分析，而不是按部就班，墨守成规，认定哪个情景一定索引失效等等。",normalizedContent:"# 后端程序员必备：索引失效的十大杂症\n\n搬砖\n\n原创 捡田螺的小男孩 [捡田螺的小男孩](javascript:void(0)😉 2019-12-08\n\n\n# 背景\n\n最近生产爆出一条慢sql，原因是用了or和!=，导致索引失效。于是，总结了索引失效的十大杂症，希望对大家有帮助，加油。\n\n\n# 一、查询条件包含or，可能导致索引失效\n\n新建一个user表，它有一个普通索引userid，结构如下：\n\ncreate table `user` (  `id` int(11) not null auto_increment,  `userid` int(11) not null,  `age` int(11) not null,  `name` varchar(255) not null,  primary key (`id`),  key `idx_userid` (`userid`)) engine=innodb default charset=utf8;\n\n\n1\n\n 1. 执行一条查询sql，它是会走索引的，如下图所示：\n 2. 把or条件+没有索引的age加上，并不会走索引，如图：\n\n分析&结论：\n\n * 对于or+没有索引的age这种情况，假设它走了userid的索引，但是走到age查询条件时，它还得全表扫描，也就是需要三步过程：全表扫描+索引扫描+合并\n * 如果它一开始就走全表扫描，直接一遍扫描就完事。\n * mysql是有优化器的，处于效率与成本考虑，遇到or条件，让索引失效，看起来也合情合理嘛。\n\n注意: 如果or条件的列都加了索引，索引可能会走的，大家可以自己试一试。\n\n\n# 二、如何字段类型是字符串，where时一定用引号括起来，否则索引失效\n\n假设demo表结构如下：\n\ncreate table `user` (  `id` int(11) not null auto_increment,  `userid` varchar(32) not null,  `name` varchar(255) not null,  primary key (`id`),  key `idx_userid` (`userid`) using btree) engine=innodb auto_increment=2 default charset=utf8;\n\n\n1\n\n\nuserid为字符串类型，是b+树的普通索引，如果查询条件传了一个数字过去，它是不走索引的，如图所示：\n\n如果给数字加上'',也就是传一个字符串呢，当然是走索引，如下图：\n\n\n\n分析与结论：\n\n为什么第一条语句未加单引号就不走索引了呢？这是因为不加单引号时，是字符串跟数字的比较，它们类型不匹配，mysql会做隐式的类型转换，把它们转换为浮点数再做比较。\n\n\n# 三、like通配符可能导致索引失效。\n\n并不是用了like通配符，索引一定失效，而是like查询是以%开头，才会导致索引失效。\n\n表结构：\n\ncreate table `user` (  `id` int(11) not null auto_increment,  `userid` varchar(32) not null,  `name` varchar(255) not null,  primary key (`id`),  key `idx_userid` (`userid`) using btree) engine=innodb auto_increment=2 default charset=utf8;\n\n\n1\n\n\nlike查询以%开头，索引失效，如图：\n\n把%放后面，发现索引还是正常走的，如下：\n\n把%加回来，改为只查索引的字段（覆盖索引），发现还是走索引，惊不惊喜，意不意外\n\n结论：\n\nlike查询以%开头，会导致索引失效。可以有两种方式优化：\n\n * 使用覆盖索引\n * 把%放后面\n\n附: 索引包含所有满足查询需要的数据的索引，称为覆盖索引(covering index)。\n\n\n# 四、联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。\n\n表结构：（有一个联合索引 idx_userid_age， userid在前， age在后）\n\ncreate table `user` (  `id` int(11) not null auto_increment,  `userid` int(11) not null,  `age` int(11) default null,  `name` varchar(255) not null,  primary key (`id`),  key `idx_userid_age` (`userid`,`age`) using btree) engine=innodb auto_increment=2 default charset=utf8;\n\n\n1\n\n\n在联合索引中，查询条件满足最左匹配原则时，索引是正常生效的。请看demo：\n\n\n\n\n\n如果条件列不是联合索引中的第一个列，索引失效，如下：\n\n\n\n分析与结论：\n\n * 当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。\n * 联合索引不满足最左原则，索引一般会失效，但是这个还跟mysql优化器有关的。\n\n\n# 五、在索引列上使用mysql的内置函数，索引失效。\n\n表结构：\n\ncreate table `user` (  `id` int(11) not null auto_increment,  `userid` varchar(32) not null,  `logintime` datetime not null,  primary key (`id`),  key `idx_userid` (`userid`) using btree,  key `idx_login_time` (`logintime`) using btree) engine=innodb auto_increment=2 default charset=utf8;\n\n\n1\n\n\n虽然logintime加了索引，但是因为使用了mysql的内置函数date_add()，索引直接gg，如图：\n\n\n# 六、对索引列运算（如，+、-、*、/），索引失效。\n\n表结构：\n\ncreate table `user` (  `id` int(11) not null auto_increment,  `userid` varchar(32) not null,  `age` int(11) default null,  primary key (`id`),  key `idx_age` (`age`) using btree) engine=innodb auto_increment=2 default charset=utf8;\n\n\n1\n\n\n虽然age加了索引，但是因为它进行运算，索引直接迷路了。。。山重水复疑无路，算着算着脑瓜疼，索引就真的不认识路了。如图：\n\n\n\n\n# 七、索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。\n\n表结构：\n\ncreate table `user` (  `id` int(11) not null auto_increment,  `userid` int(11) not null,  `age` int(11) default null,  `name` varchar(255) not null,  primary key (`id`),  key `idx_age` (`age`) using btree) engine=innodb auto_increment=2 default charset=utf8;\n\n\n1\n\n\n虽然age加了索引，但是使用了！= 或者 < >，not in这些时，索引如同虚设。如下：\n\n\n\n\n\n\n# 八、索引字段上使用is null， is not null，可能导致索引失效。\n\n表结构:\n\ncreate table `user` (  `id` int(11) not null auto_increment,  `card` varchar(255) default null,  `name` varchar(255) default null,  primary key (`id`),  key `idx_name` (`name`) using btree,  key `idx_card` (`card`) using btree) engine=innodb auto_increment=2 default charset=utf8;\n\n\n1\n\n\n单个name字段加上索引，并查询name为非空的语句，其实会走索引的，如下:\n\n\n\n单个card字段加上索引，并查询name为非空的语句，其实也会走索引的，如下:\n\n但是它们用or连接起来，索引就失效了，如下：\n\n\n\n\n# 九、左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。\n\n新建两个表，一个user，一个user_job\n\ncreate table `user` (  `id` int(11) not null auto_increment,  `name` varchar(255) character set utf8mb4 default null,  `age` int(11) not null,  primary key (`id`),  key `idx_name` (`name`) using btree) engine=innodb auto_increment=2 default charset=utf8;\ncreate table `user_job` (  `id` int(11) not null,  `userid` int(11) not null,  `job` varchar(255) default null,  `name` varchar(255) default null,  primary key (`id`),  key `idx_name` (`name`) using btree) engine=innodb default charset=utf8;\n\n\n1\n2\n\n\nuser 表的name字段编码是utf8mb4，而user_job表的name字段编码为utf8。\n\n\n\n\n\n执行左外连接查询,user_job表还是走全表扫描，如下：\n\n\n\n如果把它们改为name字段编码一致，还是会一路高歌，雄赳赳，气昂昂，走向索引。\n\n\n\n\n# 十、mysql估计使用全表扫描要比使用索引快,则不使用索引。\n\n * 当表的索引被查询，会使用最好的索引，除非优化器使用全表扫描更有效。优化器优化成全表扫描取决与使用最好索引查出来的数据是否超过表的30%的数据。\n * 不要给'性别'等增加索引。如果某个数据列里包含了均是\"0/1\"或“y/n”等值，即包含着许多重复的值，就算为它建立了索引，索引效果不会太好，还可能导致全表扫描。\n\nmysql出于效率与成本考虑，估算全表扫描与使用索引，哪个执行快。这跟它的优化器有关，来看一下它的逻辑架构图吧（图片来源网上）\n\n\n\n\n# 总结\n\n总结了索引失效的十大杂症，在这里来个首尾呼应吧，分析一下我们生产的那条慢sql。模拟的表结构与肇事sql如下：\n\ncreate table `user_session` (  \n`user_id` varchar(32) character set utf8mb4 not null,  \n`device_id` varchar(64) not null,  \n`status` varchar(2) not null,  \n`create_time` datetime not null,  \n`update_time` datetime default null on update current_timestamp,  \nprimary key (`user_id`,`device_id`) using btree) engine=innodb default charset=utf8;\n\nexplain update user_session set status =1 where  (`user_id` = '1' and `device_id`!='2')or (`user_id` != '1' and `device_id`='2')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n分析：\n\n * 执行的sql，使用了 or条件，因为组合主键( user_id, device_id)，看起来像是每一列都加了索引，索引会生效。\n * 但是出现 !=,可能导致索引失效。也就是 or+ !=两大综合症，导致了慢更新sql。\n\n解决方案:\n\n那么，怎么解决呢？我们是把 or条件拆掉，分成两条执行。同时给 device_id加一个普通索引。\n\n最后，总结了索引失效的十大杂症，希望大家在工作学习中，参考这十大杂症，多点结合执行计划 expain和场景，具体分析，而不是按部就班，墨守成规，认定哪个情景一定索引失效等等。",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"SpringCloud alibaba入门介绍",frontmatter:{title:"SpringCloud alibaba入门介绍",date:"2021-08-26T14:31:37.000Z",permalink:"/pages/91c605/",categories:["后端","Spring全家桶","SpringCloud"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/04.SpringCloud/17.SpringCloud%20alibaba%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D.html",relativePath:"01.后端/10.Spring全家桶/04.SpringCloud/17.SpringCloud alibaba入门介绍.md",key:"v-42d8b944",path:"/pages/91c605/",headers:[{level:2,title:"1.why会出现SpringCloud alibaba",slug:"_1-why会出现springcloud-alibaba",normalizedTitle:"1.why会出现springcloud alibaba",charIndex:36},{level:2,title:"2.SpringCloud alibaba带来了什么",slug:"_2-springcloud-alibaba带来了什么",normalizedTitle:"2.springcloud alibaba带来了什么",charIndex:292}],headersStr:"1.why会出现SpringCloud alibaba 2.SpringCloud alibaba带来了什么",content:"# SpringCloud Alibaba入门简介\n\n中文官网\n\n\n# 1.why会出现SpringCloud alibaba\n\nSpring Cloud Netflix项目进入维护模式\n\nSpring Cloud Netflix 将不再开发新的组件 我们都知道Spring Cloud 版本迭代算是比较快的，因而出现了很多重大ISSUE都还来不及Fix就又推另一个Release了。进入维护模式意思就是目前一直以后一段时间Spring Cloud Netflix提供的服务和功能就这么多了，不在开发新的组件和功能了。以后将以维护和Merge分支Full Request为主\n\n\n# 2.SpringCloud alibaba带来了什么\n\n 1. 服务限流降级：默认支持 Servlet、Feign、RestTemplate、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。\n 2. 服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。\n 3. 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。\n 4. 消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。\n 5. 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n 6. 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。\n\n开源组件：\n\nSentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n\nNacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n\nRocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。\n\nDubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。\n\nSeata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。\n\nAlibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n\nAlibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。\n\nAlibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。",normalizedContent:"# springcloud alibaba入门简介\n\n中文官网\n\n\n# 1.why会出现springcloud alibaba\n\nspring cloud netflix项目进入维护模式\n\nspring cloud netflix 将不再开发新的组件 我们都知道spring cloud 版本迭代算是比较快的，因而出现了很多重大issue都还来不及fix就又推另一个release了。进入维护模式意思就是目前一直以后一段时间spring cloud netflix提供的服务和功能就这么多了，不在开发新的组件和功能了。以后将以维护和merge分支full request为主\n\n\n# 2.springcloud alibaba带来了什么\n\n 1. 服务限流降级：默认支持 servlet、feign、resttemplate、dubbo 和 rocketmq 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 metrics 监控。\n 2. 服务注册与发现：适配 spring cloud 服务注册与发现标准，默认集成了 ribbon 的支持。\n 3. 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。\n 4. 消息驱动能力：基于 spring cloud stream 为微服务应用构建消息驱动能力。\n 5. 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n 6. 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 worker（schedulerx-client）上执行。\n\n开源组件：\n\nsentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n\nnacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n\nrocketmq：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。\n\ndubbo：apache dubbo™ 是一款高性能 java rpc 框架。\n\nseata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。\n\nalibaba cloud oss: 阿里云对象存储服务（object storage service，简称 oss），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n\nalibaba cloud schedulerx: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 cron 表达式）任务调度服务。\n\nalibaba cloud sms: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"100道经典MYSQL面试题",frontmatter:{title:"100道经典MYSQL面试题",date:"2021-08-30T10:48:16.000Z",permalink:"/pages/e581ae/",categories:["后端","数据库","Mysql"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/20.%E6%95%B0%E6%8D%AE%E5%BA%93/00.Mysql/03.100%E9%81%93%E7%BB%8F%E5%85%B8MYSQL%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"01.后端/20.数据库/00.Mysql/03.100道经典MYSQL面试题.md",key:"v-2191c822",path:"/pages/e581ae/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:100},{level:2,title:"数据库",slug:"数据库",normalizedTitle:"数据库",charIndex:11},{level:3,title:"1. MySQL索引使用有哪些注意事项呢？",slug:"_1-mysql索引使用有哪些注意事项呢",normalizedTitle:"1. mysql索引使用有哪些注意事项呢？",charIndex:270},{level:3,title:"2. MySQL遇到过死锁问题吗，你是如何解决的？",slug:"_2-mysql遇到过死锁问题吗-你是如何解决的",normalizedTitle:"2. mysql遇到过死锁问题吗，你是如何解决的？",charIndex:817},{level:3,title:"3. 日常工作中你是怎么优化SQL的？",slug:"_3-日常工作中你是怎么优化sql的",normalizedTitle:"3. 日常工作中你是怎么优化sql的？",charIndex:1034},{level:3,title:"4. 说说分库与分表的设计",slug:"_4-说说分库与分表的设计",normalizedTitle:"4. 说说分库与分表的设计",charIndex:1169},{level:3,title:"6. 数据库索引的原理，为什么要用B+树，为什么不用二叉树？",slug:"_6-数据库索引的原理-为什么要用b-树-为什么不用二叉树",normalizedTitle:"6. 数据库索引的原理，为什么要用b+树，为什么不用二叉树？",charIndex:2235},{level:3,title:"7. 聚集索引与非聚集索引的区别",slug:"_7-聚集索引与非聚集索引的区别",normalizedTitle:"7. 聚集索引与非聚集索引的区别",charIndex:2878},{level:3,title:"8. limit 1000000加载很慢的话，你是怎么解决的呢？",slug:"_8-limit-1000000加载很慢的话-你是怎么解决的呢",normalizedTitle:"8. limit 1000000加载很慢的话，你是怎么解决的呢？",charIndex:3137},{level:3,title:"9. 如何选择合适的分布式主键方案呢？",slug:"_9-如何选择合适的分布式主键方案呢",normalizedTitle:"9. 如何选择合适的分布式主键方案呢？",charIndex:3594},{level:3,title:"10. 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？",slug:"_10-事务的隔离级别有哪些-mysql的默认隔离级别是什么",normalizedTitle:"10. 事务的隔离级别有哪些？mysql的默认隔离级别是什么？",charIndex:3721},{level:3,title:"11. 什么是幻读，脏读，不可重复读呢？",slug:"_11-什么是幻读-脏读-不可重复读呢",normalizedTitle:"11. 什么是幻读，脏读，不可重复读呢？",charIndex:3924},{level:3,title:"12. 在高并发情况下，如何做到安全的修改同一行数据？",slug:"_12-在高并发情况下-如何做到安全的修改同一行数据",normalizedTitle:"12. 在高并发情况下，如何做到安全的修改同一行数据？",charIndex:4164},{level:3,title:"13. 数据库的乐观锁和悲观锁。",slug:"_13-数据库的乐观锁和悲观锁。",normalizedTitle:"13. 数据库的乐观锁和悲观锁。",charIndex:4578},{level:3,title:"15. select for update有什么含义，会锁表还是锁行还是其他。",slug:"_15-select-for-update有什么含义-会锁表还是锁行还是其他。",normalizedTitle:"15. select for update有什么含义，会锁表还是锁行还是其他。",charIndex:5018},{level:3,title:"16. MySQL事务得四大特性以及实现原理",slug:"_16-mysql事务得四大特性以及实现原理",normalizedTitle:"16. mysql事务得四大特性以及实现原理",charIndex:5704},{level:3,title:"17. 如果某个表有近千万数据，CRUD比较慢，如何优化。",slug:"_17-如果某个表有近千万数据-crud比较慢-如何优化。",normalizedTitle:"17. 如果某个表有近千万数据，crud比较慢，如何优化。",charIndex:6177},{level:3,title:"18. 如何写sql能够有效的使用到复合索引。",slug:"_18-如何写sql能够有效的使用到复合索引。",normalizedTitle:"18. 如何写sql能够有效的使用到复合索引。",charIndex:6468},{level:3,title:"19. mysql中in 和exists的区别。",slug:"_19-mysql中in-和exists的区别。",normalizedTitle:"19. mysql中in 和exists的区别。",charIndex:6716},{level:3,title:"20. 数据库自增主键可能遇到什么问题。",slug:"_20-数据库自增主键可能遇到什么问题。",normalizedTitle:"20. 数据库自增主键可能遇到什么问题。",charIndex:7951},{level:3,title:"21. MVCC熟悉吗，它的底层原理？",slug:"_21-mvcc熟悉吗-它的底层原理",normalizedTitle:"21. mvcc熟悉吗，它的底层原理？",charIndex:8070},{level:3,title:"22. 数据库中间件了解过吗，sharding jdbc，mycat？",slug:"_22-数据库中间件了解过吗-sharding-jdbc-mycat",normalizedTitle:"22. 数据库中间件了解过吗，sharding jdbc，mycat？",charIndex:8240},{level:3,title:"23. MYSQL的主从延迟，你怎么解决？",slug:"_23-mysql的主从延迟-你怎么解决",normalizedTitle:"23. mysql的主从延迟，你怎么解决？",charIndex:8456},{level:3,title:"24. 说一下大表查询的优化方案",slug:"_24-说一下大表查询的优化方案",normalizedTitle:"24. 说一下大表查询的优化方案",charIndex:9212},{level:3,title:"25. 什么是数据库连接池?为什么需要数据库连接池呢?",slug:"_25-什么是数据库连接池-为什么需要数据库连接池呢",normalizedTitle:"25. 什么是数据库连接池?为什么需要数据库连接池呢?",charIndex:9317},{level:3,title:"26. 一条SQL语句在MySQL中如何执行的？",slug:"_26-一条sql语句在mysql中如何执行的",normalizedTitle:"26. 一条sql语句在mysql中如何执行的？",charIndex:9646},{level:3,title:"27. InnoDB引擎中的索引策略，了解过吗？",slug:"_27-innodb引擎中的索引策略-了解过吗",normalizedTitle:"27. innodb引擎中的索引策略，了解过吗？",charIndex:9946},{level:3,title:"28. 数据库存储日期格式时，如何考虑时区转换问题？",slug:"_28-数据库存储日期格式时-如何考虑时区转换问题",normalizedTitle:"28. 数据库存储日期格式时，如何考虑时区转换问题？",charIndex:10113},{level:3,title:"29. 一条sql执行过长的时间，你如何优化，从哪些方面入手？",slug:"_29-一条sql执行过长的时间-你如何优化-从哪些方面入手",normalizedTitle:"29. 一条sql执行过长的时间，你如何优化，从哪些方面入手？",charIndex:10280},{level:3,title:"30. MYSQL数据库服务器性能分析的方法命令有哪些?",slug:"_30-mysql数据库服务器性能分析的方法命令有哪些",normalizedTitle:"30. mysql数据库服务器性能分析的方法命令有哪些?",charIndex:10482},{level:3,title:"31. Blob和text有什么区别？",slug:"_31-blob和text有什么区别",normalizedTitle:"31. blob和text有什么区别？",charIndex:10756},{level:3,title:"32. mysql里记录货币用什么字段类型比较好？",slug:"_32-mysql里记录货币用什么字段类型比较好",normalizedTitle:"32. mysql里记录货币用什么字段类型比较好？",charIndex:10923},{level:3,title:"33. Mysql中有哪几种锁，列举一下？",slug:"_33-mysql中有哪几种锁-列举一下",normalizedTitle:"33. mysql中有哪几种锁，列举一下？",charIndex:11199},{level:3,title:"34. Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？",slug:"_34-hash索引和b-树区别是什么-你在设计索引是怎么抉择的",normalizedTitle:"34. hash索引和b+树区别是什么？你在设计索引是怎么抉择的？",charIndex:11433},{level:3,title:"35. mysql 的内连接、左连接、右连接有什么区别？",slug:"_35-mysql-的内连接、左连接、右连接有什么区别",normalizedTitle:"35. mysql 的内连接、左连接、右连接有什么区别？",charIndex:11648},{level:3,title:"36. 说说MySQL 的基础架构图",slug:"_36-说说mysql-的基础架构图",normalizedTitle:"36. 说说mysql 的基础架构图",charIndex:11829},{level:3,title:"37. 什么是内连接、外连接、交叉连接、笛卡尔积呢？",slug:"_37-什么是内连接、外连接、交叉连接、笛卡尔积呢",normalizedTitle:"37. 什么是内连接、外连接、交叉连接、笛卡尔积呢？",charIndex:11924},{level:3,title:"38. 说一下数据库的三大范式",slug:"_38-说一下数据库的三大范式",normalizedTitle:"38. 说一下数据库的三大范式",charIndex:12115},{level:3,title:"39. mysql有关权限的表有哪几个呢？",slug:"_39-mysql有关权限的表有哪几个呢",normalizedTitle:"39. mysql有关权限的表有哪几个呢？",charIndex:12257},{level:3,title:"40. Mysql的binlog有几种录入格式？分别有什么区别？",slug:"_40-mysql的binlog有几种录入格式-分别有什么区别",normalizedTitle:"40. mysql的binlog有几种录入格式？分别有什么区别？",charIndex:12589},{level:3,title:"41. InnoDB引擎的4大特性，了解过吗",slug:"_41-innodb引擎的4大特性-了解过吗",normalizedTitle:"41. innodb引擎的4大特性，了解过吗",charIndex:12971},{level:3,title:"42. 索引有哪些优缺点？",slug:"_42-索引有哪些优缺点",normalizedTitle:"42. 索引有哪些优缺点？",charIndex:13077},{level:3,title:"43. 索引有哪几种类型？",slug:"_43-索引有哪几种类型",normalizedTitle:"43. 索引有哪几种类型？",charIndex:13250},{level:3,title:"44. 创建索引有什么原则呢？",slug:"_44-创建索引有什么原则呢",normalizedTitle:"44. 创建索引有什么原则呢？",charIndex:13490},{level:3,title:"45. 创建索引的三种方式",slug:"_45-创建索引的三种方式",normalizedTitle:"45. 创建索引的三种方式",charIndex:13745},{level:3,title:"46. 百万级别或以上的数据，你是如何删除的？",slug:"_46-百万级别或以上的数据-你是如何删除的",normalizedTitle:"46. 百万级别或以上的数据，你是如何删除的？",charIndex:14221},{level:3,title:"47. 什么是最左前缀原则？什么是最左匹配原则？",slug:"_47-什么是最左前缀原则-什么是最左匹配原则",normalizedTitle:"47. 什么是最左前缀原则？什么是最左匹配原则？",charIndex:14306},{level:3,title:"48. B树和B+树的区别，数据库为什么使用B+树而不是B树？",slug:"_48-b树和b-树的区别-数据库为什么使用b-树而不是b树",normalizedTitle:"48. b树和b+树的区别，数据库为什么使用b+树而不是b树？",charIndex:14473},{level:3,title:"49. 覆盖索引、回表等这些，了解过吗？",slug:"_49-覆盖索引、回表等这些-了解过吗",normalizedTitle:"49. 覆盖索引、回表等这些，了解过吗？",charIndex:14834},{level:3,title:"50. B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？",slug:"_50-b-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据",normalizedTitle:"50. b+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？",charIndex:14983},{level:3,title:"51. 何时使用聚簇索引与非聚簇索引",slug:"_51-何时使用聚簇索引与非聚簇索引",normalizedTitle:"51. 何时使用聚簇索引与非聚簇索引",charIndex:15205},{level:3,title:"52. 非聚簇索引一定会回表查询吗？",slug:"_52-非聚簇索引一定会回表查询吗",normalizedTitle:"52. 非聚簇索引一定会回表查询吗？",charIndex:15230},{level:3,title:"53. 组合索引是什么？为什么需要注意组合索引中的顺序？",slug:"_53-组合索引是什么-为什么需要注意组合索引中的顺序",normalizedTitle:"53. 组合索引是什么？为什么需要注意组合索引中的顺序？",charIndex:15412},{level:3,title:"54. 什么是数据库事务？",slug:"_54-什么是数据库事务",normalizedTitle:"54. 什么是数据库事务？",charIndex:15516},{level:3,title:"55. 隔离级别与锁的关系",slug:"_55-隔离级别与锁的关系",normalizedTitle:"55. 隔离级别与锁的关系",charIndex:15618},{level:3,title:"56. 按照锁的粒度分，数据库锁有哪些呢？锁机制与InnoDB锁算法",slug:"_56-按照锁的粒度分-数据库锁有哪些呢-锁机制与innodb锁算法",normalizedTitle:"56. 按照锁的粒度分，数据库锁有哪些呢？锁机制与innodb锁算法",charIndex:15718},{level:3,title:"57. 从锁的类别角度讲，MySQL都有哪些锁呢？",slug:"_57-从锁的类别角度讲-mysql都有哪些锁呢",normalizedTitle:"57. 从锁的类别角度讲，mysql都有哪些锁呢？",charIndex:15797},{level:3,title:"58. MySQL中InnoDB引擎的行锁是怎么实现的？",slug:"_58-mysql中innodb引擎的行锁是怎么实现的",normalizedTitle:"58. mysql中innodb引擎的行锁是怎么实现的？",charIndex:15969},{level:3,title:"59. 什么是死锁？怎么解决？",slug:"_59-什么是死锁-怎么解决",normalizedTitle:"59. 什么是死锁？怎么解决？",charIndex:16130},{level:3,title:"60. 为什么要使用视图？什么是视图？",slug:"_60-为什么要使用视图-什么是视图",normalizedTitle:"60. 为什么要使用视图？什么是视图？",charIndex:16514},{level:3,title:"61. 视图有哪些特点？哪些使用场景？",slug:"_61-视图有哪些特点-哪些使用场景",normalizedTitle:"61. 视图有哪些特点？哪些使用场景？",charIndex:16660},{level:3,title:"62. 视图的优点，缺点，讲一下？",slug:"_62-视图的优点-缺点-讲一下",normalizedTitle:"62. 视图的优点，缺点，讲一下？",charIndex:16961},{level:3,title:"63. count(1)、count(*) 与 count(列名) 的区别？",slug:"_63-count-1-、count-与-count-列名-的区别",normalizedTitle:"63. count(1)、count(*) 与 count(列名) 的区别？",charIndex:17078},{level:3,title:"64. 什么是游标？",slug:"_64-什么是游标",normalizedTitle:"64. 什么是游标？",charIndex:17301},{level:3,title:"65. 什么是存储过程？有哪些优缺点？",slug:"_65-什么是存储过程-有哪些优缺点",normalizedTitle:"65. 什么是存储过程？有哪些优缺点？",charIndex:17386},{level:3,title:"66. 什么是触发器？触发器的使用场景有哪些？",slug:"_66-什么是触发器-触发器的使用场景有哪些",normalizedTitle:"66. 什么是触发器？触发器的使用场景有哪些？",charIndex:17693},{level:3,title:"67. MySQL中都有哪些触发器？",slug:"_67-mysql中都有哪些触发器",normalizedTitle:"67. mysql中都有哪些触发器？",charIndex:17861},{level:3,title:"68. 超键、候选键、主键、外键分别是什么？",slug:"_68-超键、候选键、主键、外键分别是什么",normalizedTitle:"68. 超键、候选键、主键、外键分别是什么？",charIndex:18003},{level:3,title:"69. SQL 约束有哪几种呢？",slug:"_69-sql-约束有哪几种呢",normalizedTitle:"69. sql 约束有哪几种呢？",charIndex:18193},{level:3,title:"70. 谈谈六种关联查询，使用场景。",slug:"_70-谈谈六种关联查询-使用场景。",normalizedTitle:"70. 谈谈六种关联查询，使用场景。",charIndex:18392},{level:3,title:"71. varchar(50)中50的涵义",slug:"_71-varchar-50-中50的涵义",normalizedTitle:"71. varchar(50)中50的涵义",charIndex:18461},{level:3,title:"72. mysql中int(20)和char(20)以及varchar(20)的区别",slug:"_72-mysql中int-20-和char-20-以及varchar-20-的区别",normalizedTitle:"72. mysql中int(20)和char(20)以及varchar(20)的区别",charIndex:18572},{level:3,title:"73. drop、delete与truncate的区别",slug:"_73-drop、delete与truncate的区别",normalizedTitle:"73. drop、delete与truncate的区别",charIndex:18717},{level:3,title:"74. UNION与UNION ALL的区别？",slug:"_74-union与union-all的区别",normalizedTitle:"74. union与union all的区别？",charIndex:19038},{level:3,title:"75. SQL的生命周期？",slug:"_75-sql的生命周期",normalizedTitle:"75. sql的生命周期？",charIndex:19172},{level:3,title:"76. 一条Sql的执行顺序？",slug:"_76-一条sql的执行顺序",normalizedTitle:"76. 一条sql的执行顺序？",charIndex:19303},{level:3,title:"77. 列值为NULL时，查询是否会用到索引？",slug:"_77-列值为null时-查询是否会用到索引",normalizedTitle:"77. 列值为null时，查询是否会用到索引？",charIndex:19325},{level:3,title:"78. 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？",slug:"_78-关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过",normalizedTitle:"78. 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？",charIndex:19431},{level:3,title:"79. 主键使用自增ID还是UUID，为什么？",slug:"_79-主键使用自增id还是uuid-为什么",normalizedTitle:"79. 主键使用自增id还是uuid，为什么？",charIndex:19656},{level:3,title:"80. mysql自增主键用完了怎么办？",slug:"_80-mysql自增主键用完了怎么办",normalizedTitle:"80. mysql自增主键用完了怎么办？",charIndex:19848},{level:3,title:"81. 字段为什么要求定义为not null？",slug:"_81-字段为什么要求定义为not-null",normalizedTitle:"81. 字段为什么要求定义为not null？",charIndex:19909},{level:3,title:"82. 如果要存储用户的密码散列，应该使用什么字段进行存储？",slug:"_82-如果要存储用户的密码散列-应该使用什么字段进行存储",normalizedTitle:"82. 如果要存储用户的密码散列，应该使用什么字段进行存储？",charIndex:19965},{level:3,title:"83. Mysql驱动程序是什么？",slug:"_83-mysql驱动程序是什么",normalizedTitle:"83. mysql驱动程序是什么？",charIndex:20065},{level:3,title:"84. 如何优化长难的查询语句？有实战过吗？",slug:"_84-如何优化长难的查询语句-有实战过吗",normalizedTitle:"84. 如何优化长难的查询语句？有实战过吗？",charIndex:20174},{level:3,title:"85. 优化特定类型的查询语句",slug:"_85-优化特定类型的查询语句",normalizedTitle:"85. 优化特定类型的查询语句",charIndex:20280},{level:3,title:"86. MySQL数据库cpu飙升的话，要怎么处理呢？",slug:"_86-mysql数据库cpu飙升的话-要怎么处理呢",normalizedTitle:"86. mysql数据库cpu飙升的话，要怎么处理呢？",charIndex:20437},{level:3,title:"87. 读写分离常见方案？",slug:"_87-读写分离常见方案",normalizedTitle:"87. 读写分离常见方案？",charIndex:20804},{level:3,title:"88. MySQL的复制原理以及流程",slug:"_88-mysql的复制原理以及流程",normalizedTitle:"88. mysql的复制原理以及流程",charIndex:20929},{level:3,title:"89. MySQL中DATETIME和TIMESTAMP的区别",slug:"_89-mysql中datetime和timestamp的区别",normalizedTitle:"89. mysql中datetime和timestamp的区别",charIndex:21383},{level:3,title:"90. Innodb的事务实现原理？",slug:"_90-innodb的事务实现原理",normalizedTitle:"90. innodb的事务实现原理？",charIndex:21675},{level:3,title:"91. 谈谈MySQL的Explain",slug:"_91-谈谈mysql的explain",normalizedTitle:"91. 谈谈mysql的explain",charIndex:21902},{level:3,title:"92. Innodb的事务与日志的实现方式",slug:"_92-innodb的事务与日志的实现方式",normalizedTitle:"92. innodb的事务与日志的实现方式",charIndex:22236},{level:3,title:"93. MySQL中TEXT数据类型的最大长度",slug:"_93-mysql中text数据类型的最大长度",normalizedTitle:"93. mysql中text数据类型的最大长度",charIndex:22774},{level:3,title:"94. 500台db，在最快时间之内重启。",slug:"_94-500台db-在最快时间之内重启。",normalizedTitle:"94. 500台db，在最快时间之内重启。",charIndex:22926},{level:3,title:"95. 你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？",slug:"_95-你是如何监控你们的数据库的-你们的慢日志都是怎么查询的",normalizedTitle:"95. 你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？",charIndex:23071},{level:3,title:"96. 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？",slug:"_96-你是否做过主从一致性校验-如果有-怎么做的-如果没有-你打算怎么做",normalizedTitle:"96. 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？",charIndex:23145},{level:3,title:"97. 你们数据库是否支持emoji表情存储，如果不支持，如何操作？",slug:"_97-你们数据库是否支持emoji表情存储-如果不支持-如何操作",normalizedTitle:"97. 你们数据库是否支持emoji表情存储，如果不支持，如何操作？",charIndex:23242},{level:3,title:"98. MySQL如何获取当前日期？",slug:"_98-mysql如何获取当前日期",normalizedTitle:"98. mysql如何获取当前日期？",charIndex:23302},{level:3,title:"99. 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。",slug:"_99-一个6亿的表a-一个3亿的表b-通过外间tid关联-你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。",normalizedTitle:"99. 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。",charIndex:23349},{level:3,title:"100. Mysql一条SQL加锁分析",slug:"_100-mysql一条sql加锁分析",normalizedTitle:"100. mysql一条sql加锁分析",charIndex:23653}],headersStr:"前言 数据库 1. MySQL索引使用有哪些注意事项呢？ 2. MySQL遇到过死锁问题吗，你是如何解决的？ 3. 日常工作中你是怎么优化SQL的？ 4. 说说分库与分表的设计 6. 数据库索引的原理，为什么要用B+树，为什么不用二叉树？ 7. 聚集索引与非聚集索引的区别 8. limit 1000000加载很慢的话，你是怎么解决的呢？ 9. 如何选择合适的分布式主键方案呢？ 10. 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？ 11. 什么是幻读，脏读，不可重复读呢？ 12. 在高并发情况下，如何做到安全的修改同一行数据？ 13. 数据库的乐观锁和悲观锁。 15. select for update有什么含义，会锁表还是锁行还是其他。 16. MySQL事务得四大特性以及实现原理 17. 如果某个表有近千万数据，CRUD比较慢，如何优化。 18. 如何写sql能够有效的使用到复合索引。 19. mysql中in 和exists的区别。 20. 数据库自增主键可能遇到什么问题。 21. MVCC熟悉吗，它的底层原理？ 22. 数据库中间件了解过吗，sharding jdbc，mycat？ 23. MYSQL的主从延迟，你怎么解决？ 24. 说一下大表查询的优化方案 25. 什么是数据库连接池?为什么需要数据库连接池呢? 26. 一条SQL语句在MySQL中如何执行的？ 27. InnoDB引擎中的索引策略，了解过吗？ 28. 数据库存储日期格式时，如何考虑时区转换问题？ 29. 一条sql执行过长的时间，你如何优化，从哪些方面入手？ 30. MYSQL数据库服务器性能分析的方法命令有哪些? 31. Blob和text有什么区别？ 32. mysql里记录货币用什么字段类型比较好？ 33. Mysql中有哪几种锁，列举一下？ 34. Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？ 35. mysql 的内连接、左连接、右连接有什么区别？ 36. 说说MySQL 的基础架构图 37. 什么是内连接、外连接、交叉连接、笛卡尔积呢？ 38. 说一下数据库的三大范式 39. mysql有关权限的表有哪几个呢？ 40. Mysql的binlog有几种录入格式？分别有什么区别？ 41. InnoDB引擎的4大特性，了解过吗 42. 索引有哪些优缺点？ 43. 索引有哪几种类型？ 44. 创建索引有什么原则呢？ 45. 创建索引的三种方式 46. 百万级别或以上的数据，你是如何删除的？ 47. 什么是最左前缀原则？什么是最左匹配原则？ 48. B树和B+树的区别，数据库为什么使用B+树而不是B树？ 49. 覆盖索引、回表等这些，了解过吗？ 50. B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？ 51. 何时使用聚簇索引与非聚簇索引 52. 非聚簇索引一定会回表查询吗？ 53. 组合索引是什么？为什么需要注意组合索引中的顺序？ 54. 什么是数据库事务？ 55. 隔离级别与锁的关系 56. 按照锁的粒度分，数据库锁有哪些呢？锁机制与InnoDB锁算法 57. 从锁的类别角度讲，MySQL都有哪些锁呢？ 58. MySQL中InnoDB引擎的行锁是怎么实现的？ 59. 什么是死锁？怎么解决？ 60. 为什么要使用视图？什么是视图？ 61. 视图有哪些特点？哪些使用场景？ 62. 视图的优点，缺点，讲一下？ 63. count(1)、count(*) 与 count(列名) 的区别？ 64. 什么是游标？ 65. 什么是存储过程？有哪些优缺点？ 66. 什么是触发器？触发器的使用场景有哪些？ 67. MySQL中都有哪些触发器？ 68. 超键、候选键、主键、外键分别是什么？ 69. SQL 约束有哪几种呢？ 70. 谈谈六种关联查询，使用场景。 71. varchar(50)中50的涵义 72. mysql中int(20)和char(20)以及varchar(20)的区别 73. drop、delete与truncate的区别 74. UNION与UNION ALL的区别？ 75. SQL的生命周期？ 76. 一条Sql的执行顺序？ 77. 列值为NULL时，查询是否会用到索引？ 78. 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？ 79. 主键使用自增ID还是UUID，为什么？ 80. mysql自增主键用完了怎么办？ 81. 字段为什么要求定义为not null？ 82. 如果要存储用户的密码散列，应该使用什么字段进行存储？ 83. Mysql驱动程序是什么？ 84. 如何优化长难的查询语句？有实战过吗？ 85. 优化特定类型的查询语句 86. MySQL数据库cpu飙升的话，要怎么处理呢？ 87. 读写分离常见方案？ 88. MySQL的复制原理以及流程 89. MySQL中DATETIME和TIMESTAMP的区别 90. Innodb的事务实现原理？ 91. 谈谈MySQL的Explain 92. Innodb的事务与日志的实现方式 93. MySQL中TEXT数据类型的最大长度 94. 500台db，在最快时间之内重启。 95. 你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？ 96. 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？ 97. 你们数据库是否支持emoji表情存储，如果不支持，如何操作？ 98. MySQL如何获取当前日期？ 99. 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。 100. Mysql一条SQL加锁分析",content:'# 100道MySQL数据库经典面试题解析（收藏版）\n\n搬砖\n\n捡田螺的小男孩 [袁厨的算法小屋](javascript:void(0)😉 2020-11-21\n\n收录于话题#其他知识6个\n\n\n# 前言\n\n100道MySQL数据库经典面试题解析，已经上传github啦\n\n> https://github.com/whx123/JavaHome/tree/master/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%BB%93%E5%8F%B7\n\n公众号：捡田螺的小男孩\n\n\n# 数据库\n\n\n# 1. MySQL索引使用有哪些注意事项呢？\n\n可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则\n\n# 索引哪些情况会失效\n\n * 查询条件包含or，可能导致索引失效\n * 如何字段类型是字符串，where时一定用引号括起来，否则索引失效\n * like通配符可能导致索引失效。\n * 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。\n * 在索引列上使用mysql的内置函数，索引失效。\n * 对索引列运算（如，+、-、*、/），索引失效。\n * 索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。\n * 索引字段上使用is null， is not null，可能导致索引失效。\n * 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。\n * mysql估计使用全表扫描要比使用索引快,则不使用索引。\n\n后端程序员必备：索引失效的十大杂症\n\n# 索引不适合哪些场景\n\n * 数据量少的不适合加索引\n * 更新比较频繁的也不适合加索引\n * 区分度低的字段不适合加索引（如性别）\n\n# 索引的一些潜规则\n\n * 覆盖索引\n * 回表\n * 索引数据结构（B+树）\n * 最左前缀原则\n * 索引下推\n\n\n# 2. MySQL遇到过死锁问题吗，你是如何解决的？\n\n我排查死锁的一般步骤是酱紫的：\n\n * 查看死锁日志show engine innodb status;\n * 找出死锁Sql\n * 分析sql加锁情况\n * 模拟死锁案发\n * 分析死锁日志\n * 分析死锁结果\n\n可以看我这两篇文章哈：\n\n * 手把手教你分析Mysql死锁问题\n * Mysql死锁如何排查：insert on duplicate死锁一次排查分析过程\n\n\n# 3. 日常工作中你是怎么优化SQL的？\n\n可以从这几个维度回答这个问题：\n\n * 加索引\n * 避免返回不必要的数据\n * 适当分批量进行\n * 优化sql结构\n * 分库分表\n * 读写分离\n\n可以看我这篇文章哈：后端程序员必备：书写高质量SQL的30条建议\n\n\n# 4. 说说分库与分表的设计\n\n分库分表方案，分库分表中间件，分库分表可能遇到的问题\n\n分库分表方案:\n\n * 水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。\n * 水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。\n * 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。\n * 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。\n\n常用的分库分表中间件：\n\n * sharding-jdbc（当当）\n * Mycat\n * TDDL（淘宝）\n * Oceanus(58同城数据库中间件)\n * vitess（谷歌开发的数据库中间件）\n * Atlas(Qihoo 360)\n\n分库分表可能遇到的问题\n\n * 事务问题：需要用分布式事务啦\n * 跨节点Join的问题：解决这一问题可以分两次查询实现\n * 跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。\n * 数据迁移，容量规划，扩容等问题\n * ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID\n * 跨分片的排序分页问题（后台加大pagesize处理？）\n\n\\5. InnoDB与MyISAM的区别\n\n * InnoDB支持事务，MyISAM不支持事务\n * InnoDB支持外键，MyISAM不支持外键\n * InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持\n * select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。\n * Innodb不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引）\n * InnoDB支持表、行级锁，而MyISAM支持表级锁。\n * InnoDB表必须有主键，而MyISAM可以没有主键\n * Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。\n * Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。\n * InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引\n\n\n# 6. 数据库索引的原理，为什么要用B+树，为什么不用二叉树？\n\n可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？\n\n为什么不是一般二叉树？\n\n如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。\n\n为什么不是平衡二叉树呢？\n\n我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。\n\n那为什么不是B树而是B+树呢？\n\n1）B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。\n\n2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。\n\n可以看这篇文章哈：再有人问你为什么MySQL用B+树做索引，就把这篇文章发给她\n\n\n# 7. 聚集索引与非聚集索引的区别\n\n * 一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。\n * 聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。\n * 索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。\n * 聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；\n\n何时使用聚集索引或非聚集索引？\n\n\n# 8. limit 1000000加载很慢的话，你是怎么解决的呢？\n\n# 方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit\n\nselect id，name from employee where id>1000000 limit 10.\n\n\n1\n\n\n# 方案二：在业务允许的情况下限制页数：\n\n建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。\n\n# 方案三：order by + 索引（id为索引）\n\nselect id，name from employee order by id  limit 1000000，10\n\n\n1\n\n\n# 方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）\n\nSELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id=b.id\n\n\n1\n\n\n\n# 9. 如何选择合适的分布式主键方案呢？\n\n * 数据库自增长序列或字段。\n * UUID。\n * Redis生成ID\n * Twitter的snowflake算法\n * 利用zookeeper生成唯一ID\n * MongoDB的ObjectId\n\n\n# 10. 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？\n\n * 读未提交（Read Uncommitted）\n * 读已提交（Read Committed）\n * 可重复读（Repeatable Read）\n * 串行化（Serializable）\n\nMysql默认的事务隔离级别是可重复读(Repeatable Read)\n\n可以看我这篇文章哈：一文彻底读懂MySQL事务的四大隔离级别\n\n\n# 11. 什么是幻读，脏读，不可重复读呢？\n\n * 事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是脏读\n * 在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。\n * 事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。\n\n可以看我这篇文章哈：一文彻底读懂MySQL事务的四大隔离级别\n\n\n# 12. 在高并发情况下，如何做到安全的修改同一行数据？\n\n要安全的修改同一行数据，就要保证一个线程在修改时其它线程无法更新这行记录。一般有悲观锁和乐观锁两种方案~\n\n# 使用悲观锁\n\n悲观锁思想就是，当前线程要进来修改数据时，别的线程都得拒之门外~ 比如，可以使用select…for update ~\n\nselect * from User where name=‘jay’ for update\n\n\n1\n\n\n以上这条sql语句会锁定了User表中所有符合检索条件（name=‘jay’）的记录。本次事务提交之前，别的线程都无法修改这些记录。\n\n# 使用乐观锁\n\n乐观锁思想就是，有线程过来，先放过去修改，如果看到别的线程没修改过，就可以修改成功，如果别的线程修改过，就修改失败或者重试。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。\n\n可以看一下我这篇文章，主要是思路哈~CAS乐观锁解决并发问题的一次实践\n\n\n# 13. 数据库的乐观锁和悲观锁。\n\n# 悲观锁：\n\n悲观锁她专一且缺乏安全感了，她的心只属于当前事务，每时每刻都担心着它心爱的数据可能被别的事务修改，所以一个事务拥有（获得）悲观锁后，其他任何事务都不能对数据进行修改啦，只能等待锁被释放才可以执行。\n\n\n\n# 乐观锁：\n\n乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。\n\n\n\n之前转载了的这篇文章，觉得作者写得挺详细的~\n\n图文并茂的带你彻底理解悲观锁与乐观锁\n\n# 14. SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。\n\n * show status 命令了解各种 sql 的执行频率\n * 通过慢查询日志定位那些执行效率较低的 sql 语句\n * explain 分析低效 sql 的执行计划（这点非常重要，日常开发中用它分析Sql，会大大降低Sql导致的线上事故）\n\n\n# 15. select for update有什么含义，会锁表还是锁行还是其他。\n\n# select for update 含义\n\nselect查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加锁呢，而且它是悲观锁哦。至于加了是行锁还是表锁，这就要看是不是用了索引/主键啦。\n\n没用索引/主键的话就是表锁，否则就是是行锁。\n\n# select for update 加锁验证\n\n表结构：\n\n//id 为主键，name为唯一索引CREATE TABLE `account` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(255) DEFAULT NULL,  `balance` int(11) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `idx_name` (`name`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1570068 DEFAULT CHARSET=utf8\n\n\n1\n\n\nid为主键，select for update 1270070这条记录时，再开一个事务对该记录更新，发现更新阻塞啦，其实是加锁了。如下图：\n\n我们再开一个事务对另外一条记录1270071更新，发现更新成功，因此，如果查询条件用了索引/主键，会加行锁~\n\n我们继续一路向北吧，换普通字段balance吧，发现又阻塞了。因此，没用索引/主键的话，select for update加的就是表锁\n\n\n\n\n# 16. MySQL事务得四大特性以及实现原理\n\n\n\n * 原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\n * 一致性：指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。\n * 隔离性：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。\n * 持久性：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。\n\n事务ACID特性的实现思想\n\n * 原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。\n * 持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。\n * 隔离性：通过锁以及MVCC,使事务相互隔离开。\n * 一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。\n\n\n# 17. 如果某个表有近千万数据，CRUD比较慢，如何优化。\n\n# 分库分表\n\n某个表有近千万数据，可以考虑优化表结构，分表（水平分表，垂直分表），当然，你这样回答，需要准备好面试官问你的分库分表相关问题呀，如\n\n * 分表方案（水平分表，垂直分表，切分规则hash等）\n * 分库分表中间件（Mycat，sharding-jdbc等）\n * 分库分表一些问题（事务问题？跨节点Join的问题）\n * 解决方案（分布式事务等）\n\n# 索引优化\n\n除了分库分表，优化表结构，当然还有所以索引优化等方案~\n\n有兴趣可以看我这篇文章哈~后端程序员必备：书写高质量SQL的30条建议\n\n\n# 18. 如何写sql能够有效的使用到复合索引。\n\n复合索引，也叫组合索引，用户可以在多个列上建立索引,这种索引叫做复合索引。\n\n当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。\n\nselect * from table where k1=A AND k2=B AND k3=D\n\n\n1\n\n\n有关于复合索引，我们需要关注查询Sql条件的顺序，确保最左匹配原则有效，同时可以删除不必要的冗余索引。\n\n\n# 19. mysql中in 和exists的区别。\n\n这个，跟一下demo来看更刺激吧，啊哈哈\n\n假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下SQL:\n\nselect * from A where deptId in (select deptId from B);\n\n\n1\n\n\n这样写等价于：\n\n> 先查询部门表B\n> \n> select deptId from B\n> \n> 再由部门deptId，查询A的员工\n> \n> select * from A where A.deptId = B.deptId\n\n可以抽象成这样的一个循环：\n\n   List<> resultSet ;    for(int i=0;i<B.length;i++) {          for(int j=0;j<A.length;j++) {          if(A[i].id==B[j].id) {             resultSet.add(A[i]);             break;          }       }    }\n\n\n1\n\n\n显然，除了使用in，我们也可以用exists实现一样的查询功能，如下：\n\nselect * from A where exists (select 1 from B where A.deptId = B.deptId); \n\n\n1\n\n\n因为exists查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true或者false），来决定主查询的数据结果是否得意保留。\n\n那么，这样写就等价于：\n\n> select * from A,先从A表做循环\n> \n> select * from B where A.deptId = B.deptId,再从B表做循环.\n\n同理，可以抽象成这样一个循环：\n\n   List<> resultSet ;    for(int i=0;i<A.length;i++) {          for(int j=0;j<B.length;j++) {          if(A[i].deptId==B[j].deptId) {             resultSet.add(A[i]);             break;          }       }    }\n\n\n1\n\n\n数据库最费劲的就是跟程序链接释放。假设链接了两次，每次做上百万次的数据集查询，查完就走，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。即mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。\n\n因此，我们要选择最外层循环小的，也就是，如果B的数据量小于A，适合使用in，如果B的数据量大于A，即适合选择exists，这就是in和exists的区别。\n\n\n# 20. 数据库自增主键可能遇到什么问题。\n\n * 使用自增主键对数据库做分库分表，可能出现诸如主键重复等的问题。解决方案的话，简单点的话可以考虑使用UUID哈\n * 自增主键会产生表锁，从而引发问题\n * 自增主键可能用完问题。\n\n\n# 21. MVCC熟悉吗，它的底层原理？\n\nMVCC,多版本并发控制,它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。\n\nMVCC需要关注这几个知识点：\n\n * 事务版本号\n * 表的隐藏列\n * undo log\n * read view\n\n可以看我这篇文章哈：一文彻底读懂MySQL事务的四大隔离级别\n\n\n# 22. 数据库中间件了解过吗，sharding jdbc，mycat？\n\n * sharding-jdbc目前是基于jdbc驱动，无需额外的proxy，因此也无需关注proxy本身的高可用。\n * Mycat 是基于 Proxy，它复写了 MySQL 协议，将 Mycat Server 伪装成一个 MySQL 数据库，而 Sharding-JDBC 是基于 JDBC 接口的扩展，是以 jar 包的形式提供轻量级服务的。\n\n\n# 23. MYSQL的主从延迟，你怎么解决？\n\n嘻嘻，先复习一下主从复制原理吧，如图：主从复制分了五个步骤进行：\n\n * 步骤一：主库的更新事件(update、insert、delete)被写到binlog\n * 步骤二：从库发起连接，连接到主库。\n * 步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。\n * 步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log\n * 步骤五：还会创建一个SQL线程，从relay log里面读取内容，从ExecMasterLog_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db\n\n有兴趣的小伙伴也可以看看我这篇文章：后端程序员必备：mysql数据库相关流程图/原理图\n\n# 主从同步延迟的原因\n\n一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。\n\n# 主从同步延迟的解决办法\n\n * 主服务器要负责更新操作，对安全性的要求比从服务器要高，所以有些设置参数可以修改，比如syncbinlog=1，innodbflushlogattrxcommit = 1 之类的设置等。\n * 选择更好的硬件设备作为slave。\n * 把一台从服务器当度作为备份使用， 而不提供查询， 那边他的负载下来了， 执行relay log 里面的SQL效率自然就高了。\n * 增加从服务器喽，这个目的还是分散读的压力，从而降低服务器负载。\n\n\n# 24. 说一下大表查询的优化方案\n\n * 优化shema、sql语句+索引；\n * 可以考虑加缓存，memcached, redis，或者JVM本地缓存；\n * 主从复制，读写分离；\n * 分库分表；\n\n\n# 25. 什么是数据库连接池?为什么需要数据库连接池呢?\n\n**连接池基本原理：**数据库连接池原理：在内部对象池中，维护一定数量的数据库连接，并对外暴露数据库连接的获取和返回方法。\n\n应用程序和数据库建立连接的过程：\n\n * 通过TCP协议的三次握手和数据库服务器建立连接\n * 发送数据库用户账号密码，等待数据库验证用户身份\n * 完成身份验证后，系统可以提交SQL语句到数据库执行\n * 把连接关闭，TCP四次挥手告别。\n\n数据库连接池好处：\n\n * 资源重用 (连接复用)\n * 更快的系统响应速度\n * 新的资源分配手段\n * 统一的连接管理，避免数据库连接泄漏\n\n有兴趣的伙伴可以看看我这篇文章哈~数据库连接池内存泄漏问题的分析和解决方案\n\n\n# 26. 一条SQL语句在MySQL中如何执行的？\n\n先看一下Mysql的逻辑架构图吧~\n\n查询语句：\n\n * 先检查该语句是否有权限\n * 如果没有权限，直接返回错误信息\n * 如果有权限，在 MySQL8.0 版本以前，会先查询缓存。\n * 如果没有缓存，分析器进行词法分析，提取 sql 语句select等的关键元素。然后判断sql 语句是否有语法错误，比如关键词是否正确等等。\n * 优化器进行确定执行方案\n * 进行权限校验，如果没有权限就直接返回错误信息，如果有权限就会调用数据库引擎接口，返回执行结果。\n\n这篇文章非常不错，大家去看一下吧：一条SQL语句在MySQL中如何执行的\n\n\n# 27. InnoDB引擎中的索引策略，了解过吗？\n\n * 覆盖索引\n * 最左前缀原则\n * 索引下推\n\n索引下推优化是 MySQL 5.6 引入的， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\n\n这篇文章非常不错，大家去看一下吧：聊一聊 InnoDB 引擎中的这些索引策略\n\n\n# 28. 数据库存储日期格式时，如何考虑时区转换问题？\n\n * datetime类型适合用来记录数据的原始的创建时间，修改记录中其他字段的值，datetime字段的值不会改变，除非手动修改它。\n * timestamp类型适合用来记录数据的最后修改时间，只要修改了记录中其他字段的值，timestamp字段的值都会被自动更新。\n\n\n# 29. 一条sql执行过长的时间，你如何优化，从哪些方面入手？\n\n * 查看是否涉及多表和子查询，优化Sql结构，如去除冗余字段，是否可拆表等\n * 优化索引结构，看是否可以适当添加索引\n * 数量大的表，可以考虑进行分离/分表（如交易流水表）\n * 数据库主从分离，读写分离\n * explain分析sql语句，查看执行计划，优化sql\n * 查看mysql执行日志，分析是否有其他方面的问题\n\n\n# 30. MYSQL数据库服务器性能分析的方法命令有哪些?\n\n * Show status, 一些值得监控的变量值：\n\n>  * Bytesreceived和Bytessent 和服务器之间来往的流量。\n>  * Com_*服务器正在执行的命令。\n>  * Created_*在查询执行期限间创建的临时表和文件。\n>  * Handler_*存储引擎操作。\n>  * Select_*不同类型的联接执行计划。\n>  * Sort_*几种排序信息。\n\n * Show profiles 是MySql用来分析当前会话SQL语句执行的资源消耗情况\n\n\n# 31. Blob和text有什么区别？\n\n * Blob用于存储二进制数据，而Text用于存储大字符串。\n * Blob值被视为二进制字符串（字节字符串）,它们没有字符集，并且排序和比较基于列值中的字节的数值。\n * text值被视为非二进制字符串（字符字符串）。它们有一个字符集，并根据字符集的排序规则对值进行排序和比较。\n\n\n# 32. mysql里记录货币用什么字段类型比较好？\n\n * 货币在数据库中MySQL常用Decimal和Numric类型表示，这两种类型被MySQL实现为同样的类型。他们被用于保存与金钱有关的数据。\n * salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。存储在salary列中的值的范围是从-9999999.99到9999999.99。\n * DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。\n\n\n# 33. Mysql中有哪几种锁，列举一下？\n\n\n\n如果按锁粒度划分，有以下3种：\n\n * 表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。\n * 行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。\n * 页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般\n\n有兴趣的小伙伴可以看我这篇文章，有介绍到各种锁哈：\n\n后端程序员必备：mysql数据库相关流程图/原理图\n\n\n# 34. Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？\n\n * B+树可以进行范围查询，Hash索引不能。\n * B+树支持联合索引的最左侧原则，Hash索引不支持。\n * B+树支持order by排序，Hash索引不支持。\n * Hash索引在等值查询上比B+树效率更高。\n * B+树使用like 进行模糊查询的时候，like后面（比如%开头）的话可以起到优化的作用，Hash索引根本无法进行模糊查询。\n\n\n# 35. mysql 的内连接、左连接、右连接有什么区别？\n\n * Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集\n * left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。\n * right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。\n\n\n# 36. 说说MySQL 的基础架构图\n\nMysql逻辑架构图主要分三层：\n\n * 第一层负责连接处理，授权认证，安全等等\n * 第二层负责编译并优化SQL\n * 第三层是存储引擎。\n\n\n# 37. 什么是内连接、外连接、交叉连接、笛卡尔积呢？\n\n * 内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。\n * 外连接（outer join）：取得两张表中满足存在连接匹配关系的记录，以及某张表（或两张表）中不满足匹配关系的记录。\n * 交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，也被称为：笛卡尔积。\n\n\n# 38. 说一下数据库的三大范式\n\n * 第一范式：数据表中的每一列（每个字段）都不可以再拆分。\n * 第二范式：在第一范式的基础上，分主键列完全依赖于主键，而不能是依赖于主键的一部分。\n * 第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。\n\n\n# 39. mysql有关权限的表有哪几个呢？\n\nMySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysqlinstalldb脚本初始化。这些权限表分别user，db，tablepriv，columnspriv和host。\n\n * user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。\n * db权限表：记录各个帐号在各个数据库上的操作权限。\n * table_priv权限表：记录数据表级的操作权限。\n * columns_priv权限表：记录数据列级的操作权限。\n * host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。\n\n\n# 40. Mysql的binlog有几种录入格式？分别有什么区别？\n\n> 有三种格式哈，statement，row和mixed。\n> \n>  * statement，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。\n>  * row，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。\n>  * mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。\n\n\n# 41. InnoDB引擎的4大特性，了解过吗\n\n * 插入缓冲（insert buffer)\n * 二次写(double write)\n * 自适应哈希索引(ahi)\n * 预读(read ahead)\n\n\n# 42. 索引有哪些优缺点？\n\n优点：\n\n * 唯一索引可以保证数据库表中每一行的数据的唯一性\n * 索引可以加快数据查询速度，减少查询时间\n\n缺点：\n\n * 创建索引和维护索引要耗费时间\n * 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间\n * 以表中的数据进行增、删、改的时候，索引也要动态的维护。\n\n\n# 43. 索引有哪几种类型？\n\n * 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。\n * 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。\n * 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。\n * 全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。\n * 覆盖索引：查询列要被所建的索引覆盖，不必读取数据行\n * 组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并\n\n\n# 44. 创建索引有什么原则呢？\n\n * 最左前缀匹配原则\n * 频繁作为查询条件的字段才去创建索引\n * 频繁更新的字段不适合创建索引\n * 索引列不能参与计算，不能有函数操作\n * 优先考虑扩展索引，而不是新建索引，避免不必要的索引\n * 在order by或者group by子句中，创建索引需要注意顺序\n * 区分度低的数据列不适合做索引列(如性别）\n * 定义有外键的数据列一定要建立索引。\n * 对于定义为text、image数据类型的列不要建立索引。\n * 删除不再使用或者很少使用的索引\n\n\n# 45. 创建索引的三种方式\n\n * 在执行CREATE TABLE时创建索引\n\nCREATE TABLE `employee` (  `id` int(11) NOT NULL,  `name` varchar(255) DEFAULT NULL,  `age` int(11) DEFAULT NULL,  `date` datetime DEFAULT NULL,  `sex` int(1) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `idx_name` (`name`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n1\n\n * 使用ALTER TABLE命令添加索引\n\nALTER TABLE table_name ADD INDEX index_name (column);\n\n\n1\n\n * 使用CREATE INDEX命令创建\n\nCREATE INDEX index_name ON table_name (column);\n\n\n1\n\n\n\n# 46. 百万级别或以上的数据，你是如何删除的？\n\n * 我们想要删除百万数据的时候可以先删除索引\n * 然后批量删除其中无用数据\n * 删除完成后重新创建索引。\n\n\n# 47. 什么是最左前缀原则？什么是最左匹配原则？\n\n>  * 最左前缀原则，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。\n>  * 当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。。\n\n\n# 48. B树和B+树的区别，数据库为什么使用B+树而不是B树？\n\n * 在B树中，键和值即存放在内部节点又存放在叶子节点；在B+树中，内部节点只存键，叶子节点则同时存放键和值。\n * B+树的叶子节点有一条链相连，而B树的叶子节点各自独立的。\n\n>  * B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。.\n>  * B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快.\n\n\n# 49. 覆盖索引、回表等这些，了解过吗？\n\n * 覆盖索引：查询列要被所建的索引覆盖，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。\n * 回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。\n\n\n# 50. B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？\n\n>  * 在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。\n>  * 当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。\n\n\n# 51. 何时使用聚簇索引与非聚簇索引\n\n\n\n\n# 52. 非聚簇索引一定会回表查询吗？\n\n不一定，如果查询语句的字段全部命中了索引，那么就不必再进行回表查询（哈哈，覆盖索引就是这么回事）。\n\n> 举个简单的例子，假设我们在学生表的上建立了索引，那么当进行select age from student where age < 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。\n\n\n# 53. 组合索引是什么？为什么需要注意组合索引中的顺序？\n\n组合索引，用户可以在多个列上建立索引,这种索引叫做组合索引。\n\n因为InnoDB引擎中的索引策略的最左原则，所以需要注意组合索引中的顺序。\n\n\n# 54. 什么是数据库事务？\n\n数据库事务（简称：事务），是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。\n\n\n# 55. 隔离级别与锁的关系\n\n回答这个问题，可以先阐述四种隔离级别，再阐述它们的实现原理。隔离级别就是依赖锁和MVCC实现的。\n\n可以看我这篇文章哈：一文彻底读懂MySQL事务的四大隔离级别\n\n\n# 56. 按照锁的粒度分，数据库锁有哪些呢？锁机制与InnoDB锁算法\n\n\n\n * 按锁粒度分有：表锁，页锁，行锁\n * 按锁机制分有：乐观锁，悲观锁\n\n\n# 57. 从锁的类别角度讲，MySQL都有哪些锁呢？\n\n从锁的类别上来讲，有共享锁和排他锁。\n\n * 共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。\n * 排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。\n\n锁兼容性如下：\n\n\n# 58. MySQL中InnoDB引擎的行锁是怎么实现的？\n\n基于索引来完成行锁的。\n\nselect * from t where id = 666 for update;\n\n\n1\n\n\nfor update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将实行表锁。\n\n\n# 59. 什么是死锁？怎么解决？\n\n死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。看图形象一点，如下：死锁有四个必要条件：互斥条件，请求和保持条件，环路等待条件，不剥夺条件。\n\n解决死锁思路，一般就是切断环路，尽量避免并发形成环路。\n\n>  * 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。\n>  * 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；\n>  * 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；\n>  * 如果业务处理不好可以用分布式事务锁或者使用乐观锁\n>  * 死锁与索引密不可分，解决索引问题，需要合理优化你的索引，\n\n有兴趣的朋友，可以看我的这篇死锁分析：手把手教你分析Mysql死锁问题\n\n\n# 60. 为什么要使用视图？什么是视图？\n\n为什么要使用视图？\n\n为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。\n\n什么是视图？\n\n> 视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询select语句组成。\n\n\n# 61. 视图有哪些特点？哪些使用场景？\n\n视图特点：\n\n * 视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。\n * 视图是由基本表(实表)产生的表(虚表)。\n * 视图的建立和删除不影响基本表。\n * 对视图内容的更新(添加，删除和修改)直接影响基本表。\n * 当视图来自多个基本表时，不允许添加和删除数据。\n\n视图用途： 简化sql查询，提高开发效率，兼容老的表结构。\n\n视图的常见使用场景：\n\n * 重用SQL语句；\n * 简化复杂的SQL操作。\n * 使用表的组成部分而不是整个表；\n * 保护数据\n * 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。\n\n\n# 62. 视图的优点，缺点，讲一下？\n\n * 查询简单化。视图能简化用户的操作\n * 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护\n * 逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性\n\n\n# 63. count(1)、count(*) 与 count(列名) 的区别？\n\n * count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL\n * count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL\n * count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。\n\n\n# 64. 什么是游标？\n\n游标提供了一种对从表中检索出的数据进行操作的灵活手段，就本质而言，游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制。\n\n\n# 65. 什么是存储过程？有哪些优缺点？\n\n存储过程，就是一些编译好了的SQL语句，这些SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后给这些代码块取一个名字，在用到这个功能的时候调用即可。\n\n优点：\n\n * 存储过程是一个预编译的代码块，执行效率比较高\n * 存储过程在服务器端运行，减少客户端的压力\n * 允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用\n * 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率\n * 可以一定程度上确保数据安全\n\n缺点：\n\n * 调试麻烦\n * 可移植性不灵活\n * 重新编译问题\n\n\n# 66. 什么是触发器？触发器的使用场景有哪些？\n\n触发器，指一段代码，当触发某个事件时，自动执行这些代码。\n\n使用场景：\n\n * 可以通过数据库中的相关表实现级联更改。\n * 实时监控某张表中的某个字段的更改而需要做出相应的处理。\n * 例如可以生成某些业务的编号。\n * 注意不要滥用，否则会造成数据库及应用程序的维护困难。\n\n\n# 67. MySQL中都有哪些触发器？\n\nMySQL 数据库中有六种触发器：\n\n * Before Insert\n * After Insert\n * Before Update\n * After Update\n * Before Delete\n * After Delete\n\n\n# 68. 超键、候选键、主键、外键分别是什么？\n\n * 超键：在关系模式中，能唯一知标识元组的属性集称为超键。\n * 候选键：是最小超键，即没有冗余元素的超键。\n * 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。\n * 外键：在一个表中存在的另一个表的主键称此表的外键。。\n\n\n# 69. SQL 约束有哪几种呢？\n\n * NOT NULL: 约束字段的内容一定不能为NULL。\n * UNIQUE: 约束字段唯一性，一个表允许有多个 Unique 约束。\n * PRIMARY KEY: 约束字段唯一，不可重复，一个表只允许存在一个。\n * FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键。\n * CHECK: 用于控制字段的值范围。\n\n\n# 70. 谈谈六种关联查询，使用场景。\n\n * 交叉连接\n * 内连接\n * 外连接\n * 联合查询\n * 全连接\n * 交叉连接\n\n\n# 71. varchar(50)中50的涵义\n\n * 字段最多存放 50 个字符\n * 如 varchar(50) 和 varchar(200) 存储 "jay" 字符串所占空间是一样的，后者在排序时会消耗更多内存\n\n\n# 72. mysql中int(20)和char(20)以及varchar(20)的区别\n\n * int(20) 表示字段是int类型，显示长度是 20\n * char(20)表示字段是固定长度字符串，长度为 20\n * varchar(20) 表示字段是可变长度字符串，长度为 20\n\n\n# 73. drop、delete与truncate的区别\n\n       DELETE                 TRUNCATE          DROP\n类型     DML                    DDL               DDL\n回滚     可回滚                    不可回滚              不可回滚\n删除内容   表结构还在，删除表的全部或者一部分数据行   表结构还在，删除表中的所有数据   从数据库中删除表，所有的数据行，索引和权限也会被删除\n删除速度   删除速度慢，逐行删除             删除速度快             删除速度最快\n\n\n# 74. UNION与UNION ALL的区别？\n\n * Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；\n * Union All：对两个结果集进行并集操作，包括重复行，不进行排序；\n * UNION的效率高于 UNION ALL\n\n\n# 75. SQL的生命周期？\n\n>  * 服务器与数据库建立连接\n>  * 数据库进程拿到请求sql\n>  * 解析并生成执行计划，执行\n>  * 读取数据到内存，并进行逻辑处理\n>  * 通过步骤一的连接，发送结果到客户端\n>  * 关掉连接，释放资源\n\n\n# 76. 一条Sql的执行顺序？\n\n\n\n\n# 77. 列值为NULL时，查询是否会用到索引？\n\n列值为NULL也是可以走索引的\n\n计划对列进行索引，应尽量避免把它设置为可空，因为这会让 MySQL 难以优化引用了可空列的查询，同时增加了引擎的复杂度\n\n\n# 78. 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？\n\n * 我们平时写Sql时，都要养成用explain分析的习惯。\n * 慢查询的统计，运维会定期统计给我们\n\n优化慢查询：\n\n * 分析语句，是否加载了不必要的字段/数据。\n * 分析SQl执行句话，是否命中索引等。\n * 如果SQL很复杂，优化SQL结构\n * 如果表数据量太大，考虑分表\n\n可以看我这篇文章哈：后端程序员必备：书写高质量SQL的30条建议\n\n\n# 79. 主键使用自增ID还是UUID，为什么？\n\n如果是单机的话，选择自增ID；如果是分布式系统，优先考虑UUID吧，但还是最好自己公司有一套分布式唯一ID生产方案吧。\n\n * 自增ID：数据存储空间小，查询效率高。但是如果数据量过大,会超出自增长的值范围，多库合并，也有可能有问题。\n * uuid：适合大量数据的插入和更新操作，但是它无序的，插入数据效率慢，占用空间大。\n\n\n# 80. mysql自增主键用完了怎么办？\n\n自增主键一般用int类型，一般达不到最大值，可以考虑提前分库分表的。\n\n\n# 81. 字段为什么要求定义为not null？\n\nnull值会占用更多的字节，并且null有很多坑的。\n\n\n# 82. 如果要存储用户的密码散列，应该使用什么字段进行存储？\n\n> 密码散列，盐，用户身份证号等固定长度的字符串，应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。\n\n\n# 83. Mysql驱动程序是什么？\n\n这个jar包：mysql-connector-java-5.1.18.jar\n\nMysql驱动程序主要帮助编程语言与 MySQL服务端进行通信，如连接、传输数据、关闭等。\n\n\n# 84. 如何优化长难的查询语句？有实战过吗？\n\n * 将一个大的查询分为多个小的相同的查询\n * 减少冗余记录的查询。\n * 一个复杂查询可以考虑拆成多个简单查询\n * 分解关联查询，让缓存的效率更高。\n\n\n# 85. 优化特定类型的查询语句\n\n平时积累吧：\n\n * 比如使用select 具体字段代替 select *\n * 使用count(*) 而不是count(列名)\n * 在不影响业务的情况，使用缓存\n * explain 分析你的SQL\n\n可以看我这篇文章哈：后端程序员必备：书写高质量SQL的30条建议\n\n\n# 86. MySQL数据库cpu飙升的话，要怎么处理呢？\n\n排查过程：\n\n * 使用top 命令观察，确定是mysqld导致还是其他原因。\n * 如果是mysqld导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行。\n * 找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。\n\n处理：\n\n * kill 掉这些线程(同时观察 cpu 使用率是否下降)，\n * 进行相应的调整(比如说加索引、改 sql、改内存参数)\n * 重新跑这些 SQL。\n\n其他情况：\n\n也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等\n\n\n# 87. 读写分离常见方案？\n\n * 应用程序根据业务逻辑来判断，增删改等写操作命令发给主库，查询命令发给备库。\n * 利用中间件来做代理，负责对数据库的请求识别出读还是写，并分发到不同的数据库中。（如：amoeba，mysql-proxy）\n\n\n# 88. MySQL的复制原理以及流程\n\n主从复制原理，简言之，就三步曲，如下：\n\n * 主数据库有个bin-log二进制文件，纪录了所有增删改Sql语句。（binlog线程）\n * 从数据库把主数据库的bin-log文件的sql语句复制过来。（io线程）\n * 从数据库的relay-log重做日志文件中再执行一次这些sql语句。（Sql执行线程）\n\n如下图所示：\n\n\n\n上图主从复制分了五个步骤进行：\n\n步骤一：主库的更新事件(update、insert、delete)被写到binlog\n\n步骤二：从库发起连接，连接到主库。\n\n步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。\n\n步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log\n\n步骤五：还会创建一个SQL线程，从relay log里面读取内容，从ExecMasterLog_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db\n\n\n# 89. MySQL中DATETIME和TIMESTAMP的区别\n\n存储精度都为秒\n\n区别：\n\n * DATETIME 的日期范围是 1001——9999 年；TIMESTAMP 的时间范围是 1970——2038 年\n * DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区\n * DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节\n * DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)\n\n\n# 90. Innodb的事务实现原理？\n\n * 原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。\n * 持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。\n * 隔离性：通过锁以及MVCC,使事务相互隔离开。\n * 一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。\n\n\n# 91. 谈谈MySQL的Explain\n\nExplain 执行计划包含字段信息如下：分别是 id、selecttype、table、partitions、type、possiblekeys、key、key_len、ref、rows、filtered、Extra 等12个字段。\n\n我们重点关注的是type，它的属性排序如下：\n\nsystem  > const > eq_ref > ref  > ref_or_null >index_merge > unique_subquery > index_subquery > range > index > ALL\n\n\n1\n\n\n推荐大家看这篇文章哈：面试官：不会看 Explain执行计划，简历敢写 SQL 优化？\n\n\n# 92. Innodb的事务与日志的实现方式\n\n# 有多少种日志\n\ninnodb两种日志redo和undo。\n\n# 日志的存放形式\n\n * redo：在页修改的时候，先写到 redo log buffer 里面， 然后写到 redo log 的文件系统缓存里面(fwrite)，然后再同步到磁盘文件（ fsync）。\n * Undo：在 MySQL5.5 之前， undo 只能存放在 ibdata文件里面， 5.6 之后，可以通过设置 innodbundotablespaces 参数把 undo log 存放在 ibdata之外。\n\n# 事务是如何通过日志来实现的\n\n * 因为事务在修改页时，要先记 undo，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。Redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。\n * 当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的 状态，崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。\n * 如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。\n\n\n# 93. MySQL中TEXT数据类型的最大长度\n\n * TINYTEXT：256 bytes\n * TEXT：65,535 bytes(64kb)\n * MEDIUMTEXT：16,777,215 bytes(16MB)\n * LONGTEXT：4,294,967,295 bytes(4GB)\n\n\n# 94. 500台db，在最快时间之内重启。\n\n * 可以使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。\n * 也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务\n\n\n# 95. 你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？\n\n监控的工具有很多，例如zabbix，lepus，我这里用的是lepus\n\n\n# 96. 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？\n\n主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等\n\n\n# 97. 你们数据库是否支持emoji表情存储，如果不支持，如何操作？\n\n更换字符集utf8--\x3eutf8mb4\n\n\n# 98. MySQL如何获取当前日期？\n\nSELECT CURRENT_DATE();\n\n\n# 99. 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。\n\n1、如果A表TID是自增长,并且是连续的,B表的ID为索引 select * from a,b where a.tid = b.id and a.tid>500000 limit 200;\n\n2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;\n\n\n# 100. Mysql一条SQL加锁分析\n\n一条SQL加锁，可以分9种情况进行哈：\n\n * 组合一：id列是主键，RC隔离级别\n * 组合二：id列是二级唯一索引，RC隔离级别\n * 组合三：id列是二级非唯一索引，RC隔离级别\n * 组合四：id列上没有索引，RC隔离级别\n * 组合五：id列是主键，RR隔离级别\n * 组合六：id列是二级唯一索引，RR隔离级别\n * 组合七：id列是二级非唯一索引，RR隔离级别\n * 组合八：id列上没有索引，RR隔离级别\n * 组合九：Serializable隔离级别\n\n往期精彩推荐：\n\n * 一文带你夯实双指针基础\n * 一道非常经典的队列面试题\n * 看看这篇文章能不能把那个著名的接雨水问题讲明白\n * 什么锅配什么盖（一个老生常谈的匹配问题）\n * 栈和队列的那些事，你读完这个文章就懂了\n * 链表的一二三四五六七全都在这了',normalizedContent:'# 100道mysql数据库经典面试题解析（收藏版）\n\n搬砖\n\n捡田螺的小男孩 [袁厨的算法小屋](javascript:void(0)😉 2020-11-21\n\n收录于话题#其他知识6个\n\n\n# 前言\n\n100道mysql数据库经典面试题解析，已经上传github啦\n\n> https://github.com/whx123/javahome/tree/master/java%e9%9d%a2%e8%af%95%e9%a2%98%e9%9b%86%e7%bb%93%e5%8f%b7\n\n公众号：捡田螺的小男孩\n\n\n# 数据库\n\n\n# 1. mysql索引使用有哪些注意事项呢？\n\n可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则\n\n# 索引哪些情况会失效\n\n * 查询条件包含or，可能导致索引失效\n * 如何字段类型是字符串，where时一定用引号括起来，否则索引失效\n * like通配符可能导致索引失效。\n * 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。\n * 在索引列上使用mysql的内置函数，索引失效。\n * 对索引列运算（如，+、-、*、/），索引失效。\n * 索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。\n * 索引字段上使用is null， is not null，可能导致索引失效。\n * 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。\n * mysql估计使用全表扫描要比使用索引快,则不使用索引。\n\n后端程序员必备：索引失效的十大杂症\n\n# 索引不适合哪些场景\n\n * 数据量少的不适合加索引\n * 更新比较频繁的也不适合加索引\n * 区分度低的字段不适合加索引（如性别）\n\n# 索引的一些潜规则\n\n * 覆盖索引\n * 回表\n * 索引数据结构（b+树）\n * 最左前缀原则\n * 索引下推\n\n\n# 2. mysql遇到过死锁问题吗，你是如何解决的？\n\n我排查死锁的一般步骤是酱紫的：\n\n * 查看死锁日志show engine innodb status;\n * 找出死锁sql\n * 分析sql加锁情况\n * 模拟死锁案发\n * 分析死锁日志\n * 分析死锁结果\n\n可以看我这两篇文章哈：\n\n * 手把手教你分析mysql死锁问题\n * mysql死锁如何排查：insert on duplicate死锁一次排查分析过程\n\n\n# 3. 日常工作中你是怎么优化sql的？\n\n可以从这几个维度回答这个问题：\n\n * 加索引\n * 避免返回不必要的数据\n * 适当分批量进行\n * 优化sql结构\n * 分库分表\n * 读写分离\n\n可以看我这篇文章哈：后端程序员必备：书写高质量sql的30条建议\n\n\n# 4. 说说分库与分表的设计\n\n分库分表方案，分库分表中间件，分库分表可能遇到的问题\n\n分库分表方案:\n\n * 水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。\n * 水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。\n * 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。\n * 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。\n\n常用的分库分表中间件：\n\n * sharding-jdbc（当当）\n * mycat\n * tddl（淘宝）\n * oceanus(58同城数据库中间件)\n * vitess（谷歌开发的数据库中间件）\n * atlas(qihoo 360)\n\n分库分表可能遇到的问题\n\n * 事务问题：需要用分布式事务啦\n * 跨节点join的问题：解决这一问题可以分两次查询实现\n * 跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。\n * 数据迁移，容量规划，扩容等问题\n * id问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑uuid\n * 跨分片的排序分页问题（后台加大pagesize处理？）\n\n\\5. innodb与myisam的区别\n\n * innodb支持事务，myisam不支持事务\n * innodb支持外键，myisam不支持外键\n * innodb 支持 mvcc(多版本并发控制)，myisam 不支持\n * select count(*) from table时，myisam更快，因为它有一个变量保存了整个表的总行数，可以直接读取，innodb就需要全表扫描。\n * innodb不支持全文索引，而myisam支持全文索引（5.7以后的innodb也支持全文索引）\n * innodb支持表、行级锁，而myisam支持表级锁。\n * innodb表必须有主键，而myisam可以没有主键\n * innodb表需要更多的内存和存储，而myisam可被压缩，存储空间较小，。\n * innodb按主键大小有序插入，myisam记录插入顺序是，按记录插入顺序保存。\n * innodb 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 myisam 比 innodb 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引\n\n\n# 6. 数据库索引的原理，为什么要用b+树，为什么不用二叉树？\n\n可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是b树，而偏偏是b+树呢？\n\n为什么不是一般二叉树？\n\n如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。\n\n为什么不是平衡二叉树呢？\n\n我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是b树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。\n\n那为什么不是b树而是b+树呢？\n\n1）b+树非叶子节点上是不存储数据的，仅存储键值，而b树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16kb，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的io次数有会再次减少，数据查询的效率也会更快。\n\n2）b+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么b+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。\n\n可以看这篇文章哈：再有人问你为什么mysql用b+树做索引，就把这篇文章发给她\n\n\n# 7. 聚集索引与非聚集索引的区别\n\n * 一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。\n * 聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。\n * 索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。\n * 聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；\n\n何时使用聚集索引或非聚集索引？\n\n\n# 8. limit 1000000加载很慢的话，你是怎么解决的呢？\n\n# 方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit\n\nselect id，name from employee where id>1000000 limit 10.\n\n\n1\n\n\n# 方案二：在业务允许的情况下限制页数：\n\n建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。\n\n# 方案三：order by + 索引（id为索引）\n\nselect id，name from employee order by id  limit 1000000，10\n\n\n1\n\n\n# 方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）\n\nselect a.* from employee a, (select id from employee where 条件 limit 1000000,10 ) b where a.id=b.id\n\n\n1\n\n\n\n# 9. 如何选择合适的分布式主键方案呢？\n\n * 数据库自增长序列或字段。\n * uuid。\n * redis生成id\n * twitter的snowflake算法\n * 利用zookeeper生成唯一id\n * mongodb的objectid\n\n\n# 10. 事务的隔离级别有哪些？mysql的默认隔离级别是什么？\n\n * 读未提交（read uncommitted）\n * 读已提交（read committed）\n * 可重复读（repeatable read）\n * 串行化（serializable）\n\nmysql默认的事务隔离级别是可重复读(repeatable read)\n\n可以看我这篇文章哈：一文彻底读懂mysql事务的四大隔离级别\n\n\n# 11. 什么是幻读，脏读，不可重复读呢？\n\n * 事务a、b交替执行，事务a被事务b干扰到了，因为事务a读取到事务b未提交的数据,这就是脏读\n * 在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。\n * 事务a查询一个范围的结果集，另一个并发事务b往这个范围中插入/删除了数据，并静悄悄地提交，然后事务a再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。\n\n可以看我这篇文章哈：一文彻底读懂mysql事务的四大隔离级别\n\n\n# 12. 在高并发情况下，如何做到安全的修改同一行数据？\n\n要安全的修改同一行数据，就要保证一个线程在修改时其它线程无法更新这行记录。一般有悲观锁和乐观锁两种方案~\n\n# 使用悲观锁\n\n悲观锁思想就是，当前线程要进来修改数据时，别的线程都得拒之门外~ 比如，可以使用select…for update ~\n\nselect * from user where name=‘jay’ for update\n\n\n1\n\n\n以上这条sql语句会锁定了user表中所有符合检索条件（name=‘jay’）的记录。本次事务提交之前，别的线程都无法修改这些记录。\n\n# 使用乐观锁\n\n乐观锁思想就是，有线程过来，先放过去修改，如果看到别的线程没修改过，就可以修改成功，如果别的线程修改过，就修改失败或者重试。实现方式：乐观锁一般会使用版本号机制或cas算法实现。\n\n可以看一下我这篇文章，主要是思路哈~cas乐观锁解决并发问题的一次实践\n\n\n# 13. 数据库的乐观锁和悲观锁。\n\n# 悲观锁：\n\n悲观锁她专一且缺乏安全感了，她的心只属于当前事务，每时每刻都担心着它心爱的数据可能被别的事务修改，所以一个事务拥有（获得）悲观锁后，其他任何事务都不能对数据进行修改啦，只能等待锁被释放才可以执行。\n\n\n\n# 乐观锁：\n\n乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。实现方式：乐观锁一般会使用版本号机制或cas算法实现。\n\n\n\n之前转载了的这篇文章，觉得作者写得挺详细的~\n\n图文并茂的带你彻底理解悲观锁与乐观锁\n\n# 14. sql优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。\n\n * show status 命令了解各种 sql 的执行频率\n * 通过慢查询日志定位那些执行效率较低的 sql 语句\n * explain 分析低效 sql 的执行计划（这点非常重要，日常开发中用它分析sql，会大大降低sql导致的线上事故）\n\n\n# 15. select for update有什么含义，会锁表还是锁行还是其他。\n\n# select for update 含义\n\nselect查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加锁呢，而且它是悲观锁哦。至于加了是行锁还是表锁，这就要看是不是用了索引/主键啦。\n\n没用索引/主键的话就是表锁，否则就是是行锁。\n\n# select for update 加锁验证\n\n表结构：\n\n//id 为主键，name为唯一索引create table `account` (  `id` int(11) not null auto_increment,  `name` varchar(255) default null,  `balance` int(11) default null,  primary key (`id`),  key `idx_name` (`name`) using btree) engine=innodb auto_increment=1570068 default charset=utf8\n\n\n1\n\n\nid为主键，select for update 1270070这条记录时，再开一个事务对该记录更新，发现更新阻塞啦，其实是加锁了。如下图：\n\n我们再开一个事务对另外一条记录1270071更新，发现更新成功，因此，如果查询条件用了索引/主键，会加行锁~\n\n我们继续一路向北吧，换普通字段balance吧，发现又阻塞了。因此，没用索引/主键的话，select for update加的就是表锁\n\n\n\n\n# 16. mysql事务得四大特性以及实现原理\n\n\n\n * 原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\n * 一致性：指在事务开始之前和事务结束以后，数据不会被破坏，假如a账户给b账户转10块钱，不管成功与否，a和b的总金额是不变的。\n * 隔离性：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。\n * 持久性：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。\n\n事务acid特性的实现思想\n\n * 原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。\n * 持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。\n * 隔离性：通过锁以及mvcc,使事务相互隔离开。\n * 一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。\n\n\n# 17. 如果某个表有近千万数据，crud比较慢，如何优化。\n\n# 分库分表\n\n某个表有近千万数据，可以考虑优化表结构，分表（水平分表，垂直分表），当然，你这样回答，需要准备好面试官问你的分库分表相关问题呀，如\n\n * 分表方案（水平分表，垂直分表，切分规则hash等）\n * 分库分表中间件（mycat，sharding-jdbc等）\n * 分库分表一些问题（事务问题？跨节点join的问题）\n * 解决方案（分布式事务等）\n\n# 索引优化\n\n除了分库分表，优化表结构，当然还有所以索引优化等方案~\n\n有兴趣可以看我这篇文章哈~后端程序员必备：书写高质量sql的30条建议\n\n\n# 18. 如何写sql能够有效的使用到复合索引。\n\n复合索引，也叫组合索引，用户可以在多个列上建立索引,这种索引叫做复合索引。\n\n当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。\n\nselect * from table where k1=a and k2=b and k3=d\n\n\n1\n\n\n有关于复合索引，我们需要关注查询sql条件的顺序，确保最左匹配原则有效，同时可以删除不必要的冗余索引。\n\n\n# 19. mysql中in 和exists的区别。\n\n这个，跟一下demo来看更刺激吧，啊哈哈\n\n假设表a表示某企业的员工表，表b表示部门表，查询所有部门的所有员工，很容易有以下sql:\n\nselect * from a where deptid in (select deptid from b);\n\n\n1\n\n\n这样写等价于：\n\n> 先查询部门表b\n> \n> select deptid from b\n> \n> 再由部门deptid，查询a的员工\n> \n> select * from a where a.deptid = b.deptid\n\n可以抽象成这样的一个循环：\n\n   list<> resultset ;    for(int i=0;i<b.length;i++) {          for(int j=0;j<a.length;j++) {          if(a[i].id==b[j].id) {             resultset.add(a[i]);             break;          }       }    }\n\n\n1\n\n\n显然，除了使用in，我们也可以用exists实现一样的查询功能，如下：\n\nselect * from a where exists (select 1 from b where a.deptid = b.deptid); \n\n\n1\n\n\n因为exists查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true或者false），来决定主查询的数据结果是否得意保留。\n\n那么，这样写就等价于：\n\n> select * from a,先从a表做循环\n> \n> select * from b where a.deptid = b.deptid,再从b表做循环.\n\n同理，可以抽象成这样一个循环：\n\n   list<> resultset ;    for(int i=0;i<a.length;i++) {          for(int j=0;j<b.length;j++) {          if(a[i].deptid==b[j].deptid) {             resultset.add(a[i]);             break;          }       }    }\n\n\n1\n\n\n数据库最费劲的就是跟程序链接释放。假设链接了两次，每次做上百万次的数据集查询，查完就走，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。即mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。\n\n因此，我们要选择最外层循环小的，也就是，如果b的数据量小于a，适合使用in，如果b的数据量大于a，即适合选择exists，这就是in和exists的区别。\n\n\n# 20. 数据库自增主键可能遇到什么问题。\n\n * 使用自增主键对数据库做分库分表，可能出现诸如主键重复等的问题。解决方案的话，简单点的话可以考虑使用uuid哈\n * 自增主键会产生表锁，从而引发问题\n * 自增主键可能用完问题。\n\n\n# 21. mvcc熟悉吗，它的底层原理？\n\nmvcc,多版本并发控制,它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。\n\nmvcc需要关注这几个知识点：\n\n * 事务版本号\n * 表的隐藏列\n * undo log\n * read view\n\n可以看我这篇文章哈：一文彻底读懂mysql事务的四大隔离级别\n\n\n# 22. 数据库中间件了解过吗，sharding jdbc，mycat？\n\n * sharding-jdbc目前是基于jdbc驱动，无需额外的proxy，因此也无需关注proxy本身的高可用。\n * mycat 是基于 proxy，它复写了 mysql 协议，将 mycat server 伪装成一个 mysql 数据库，而 sharding-jdbc 是基于 jdbc 接口的扩展，是以 jar 包的形式提供轻量级服务的。\n\n\n# 23. mysql的主从延迟，你怎么解决？\n\n嘻嘻，先复习一下主从复制原理吧，如图：主从复制分了五个步骤进行：\n\n * 步骤一：主库的更新事件(update、insert、delete)被写到binlog\n * 步骤二：从库发起连接，连接到主库。\n * 步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。\n * 步骤四：从库启动之后，创建一个i/o线程，读取主库传过来的binlog内容并写入到relay log\n * 步骤五：还会创建一个sql线程，从relay log里面读取内容，从execmasterlog_pos位置开始执行读取到的更新事件，将更新内容写入到slave的db\n\n有兴趣的小伙伴也可以看看我这篇文章：后端程序员必备：mysql数据库相关流程图/原理图\n\n# 主从同步延迟的原因\n\n一个服务器开放ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取binlog的线程仅有一个，当某个sql在从服务器上执行的时间稍长 或者由于某个sql要进行锁表就会导致，主服务器的sql大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。\n\n# 主从同步延迟的解决办法\n\n * 主服务器要负责更新操作，对安全性的要求比从服务器要高，所以有些设置参数可以修改，比如syncbinlog=1，innodbflushlogattrxcommit = 1 之类的设置等。\n * 选择更好的硬件设备作为slave。\n * 把一台从服务器当度作为备份使用， 而不提供查询， 那边他的负载下来了， 执行relay log 里面的sql效率自然就高了。\n * 增加从服务器喽，这个目的还是分散读的压力，从而降低服务器负载。\n\n\n# 24. 说一下大表查询的优化方案\n\n * 优化shema、sql语句+索引；\n * 可以考虑加缓存，memcached, redis，或者jvm本地缓存；\n * 主从复制，读写分离；\n * 分库分表；\n\n\n# 25. 什么是数据库连接池?为什么需要数据库连接池呢?\n\n**连接池基本原理：**数据库连接池原理：在内部对象池中，维护一定数量的数据库连接，并对外暴露数据库连接的获取和返回方法。\n\n应用程序和数据库建立连接的过程：\n\n * 通过tcp协议的三次握手和数据库服务器建立连接\n * 发送数据库用户账号密码，等待数据库验证用户身份\n * 完成身份验证后，系统可以提交sql语句到数据库执行\n * 把连接关闭，tcp四次挥手告别。\n\n数据库连接池好处：\n\n * 资源重用 (连接复用)\n * 更快的系统响应速度\n * 新的资源分配手段\n * 统一的连接管理，避免数据库连接泄漏\n\n有兴趣的伙伴可以看看我这篇文章哈~数据库连接池内存泄漏问题的分析和解决方案\n\n\n# 26. 一条sql语句在mysql中如何执行的？\n\n先看一下mysql的逻辑架构图吧~\n\n查询语句：\n\n * 先检查该语句是否有权限\n * 如果没有权限，直接返回错误信息\n * 如果有权限，在 mysql8.0 版本以前，会先查询缓存。\n * 如果没有缓存，分析器进行词法分析，提取 sql 语句select等的关键元素。然后判断sql 语句是否有语法错误，比如关键词是否正确等等。\n * 优化器进行确定执行方案\n * 进行权限校验，如果没有权限就直接返回错误信息，如果有权限就会调用数据库引擎接口，返回执行结果。\n\n这篇文章非常不错，大家去看一下吧：一条sql语句在mysql中如何执行的\n\n\n# 27. innodb引擎中的索引策略，了解过吗？\n\n * 覆盖索引\n * 最左前缀原则\n * 索引下推\n\n索引下推优化是 mysql 5.6 引入的， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\n\n这篇文章非常不错，大家去看一下吧：聊一聊 innodb 引擎中的这些索引策略\n\n\n# 28. 数据库存储日期格式时，如何考虑时区转换问题？\n\n * datetime类型适合用来记录数据的原始的创建时间，修改记录中其他字段的值，datetime字段的值不会改变，除非手动修改它。\n * timestamp类型适合用来记录数据的最后修改时间，只要修改了记录中其他字段的值，timestamp字段的值都会被自动更新。\n\n\n# 29. 一条sql执行过长的时间，你如何优化，从哪些方面入手？\n\n * 查看是否涉及多表和子查询，优化sql结构，如去除冗余字段，是否可拆表等\n * 优化索引结构，看是否可以适当添加索引\n * 数量大的表，可以考虑进行分离/分表（如交易流水表）\n * 数据库主从分离，读写分离\n * explain分析sql语句，查看执行计划，优化sql\n * 查看mysql执行日志，分析是否有其他方面的问题\n\n\n# 30. mysql数据库服务器性能分析的方法命令有哪些?\n\n * show status, 一些值得监控的变量值：\n\n>  * bytesreceived和bytessent 和服务器之间来往的流量。\n>  * com_*服务器正在执行的命令。\n>  * created_*在查询执行期限间创建的临时表和文件。\n>  * handler_*存储引擎操作。\n>  * select_*不同类型的联接执行计划。\n>  * sort_*几种排序信息。\n\n * show profiles 是mysql用来分析当前会话sql语句执行的资源消耗情况\n\n\n# 31. blob和text有什么区别？\n\n * blob用于存储二进制数据，而text用于存储大字符串。\n * blob值被视为二进制字符串（字节字符串）,它们没有字符集，并且排序和比较基于列值中的字节的数值。\n * text值被视为非二进制字符串（字符字符串）。它们有一个字符集，并根据字符集的排序规则对值进行排序和比较。\n\n\n# 32. mysql里记录货币用什么字段类型比较好？\n\n * 货币在数据库中mysql常用decimal和numric类型表示，这两种类型被mysql实现为同样的类型。他们被用于保存与金钱有关的数据。\n * salary decimal(9,2)，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。存储在salary列中的值的范围是从-9999999.99到9999999.99。\n * decimal和numeric值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。\n\n\n# 33. mysql中有哪几种锁，列举一下？\n\n\n\n如果按锁粒度划分，有以下3种：\n\n * 表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。\n * 行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。\n * 页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般\n\n有兴趣的小伙伴可以看我这篇文章，有介绍到各种锁哈：\n\n后端程序员必备：mysql数据库相关流程图/原理图\n\n\n# 34. hash索引和b+树区别是什么？你在设计索引是怎么抉择的？\n\n * b+树可以进行范围查询，hash索引不能。\n * b+树支持联合索引的最左侧原则，hash索引不支持。\n * b+树支持order by排序，hash索引不支持。\n * hash索引在等值查询上比b+树效率更高。\n * b+树使用like 进行模糊查询的时候，like后面（比如%开头）的话可以起到优化的作用，hash索引根本无法进行模糊查询。\n\n\n# 35. mysql 的内连接、左连接、右连接有什么区别？\n\n * inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集\n * left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。\n * right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。\n\n\n# 36. 说说mysql 的基础架构图\n\nmysql逻辑架构图主要分三层：\n\n * 第一层负责连接处理，授权认证，安全等等\n * 第二层负责编译并优化sql\n * 第三层是存储引擎。\n\n\n# 37. 什么是内连接、外连接、交叉连接、笛卡尔积呢？\n\n * 内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。\n * 外连接（outer join）：取得两张表中满足存在连接匹配关系的记录，以及某张表（或两张表）中不满足匹配关系的记录。\n * 交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，也被称为：笛卡尔积。\n\n\n# 38. 说一下数据库的三大范式\n\n * 第一范式：数据表中的每一列（每个字段）都不可以再拆分。\n * 第二范式：在第一范式的基础上，分主键列完全依赖于主键，而不能是依赖于主键的一部分。\n * 第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。\n\n\n# 39. mysql有关权限的表有哪几个呢？\n\nmysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysqlinstalldb脚本初始化。这些权限表分别user，db，tablepriv，columnspriv和host。\n\n * user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。\n * db权限表：记录各个帐号在各个数据库上的操作权限。\n * table_priv权限表：记录数据表级的操作权限。\n * columns_priv权限表：记录数据列级的操作权限。\n * host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受grant和revoke语句的影响。\n\n\n# 40. mysql的binlog有几种录入格式？分别有什么区别？\n\n> 有三种格式哈，statement，row和mixed。\n> \n>  * statement，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了io，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。\n>  * row，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。\n>  * mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。\n\n\n# 41. innodb引擎的4大特性，了解过吗\n\n * 插入缓冲（insert buffer)\n * 二次写(double write)\n * 自适应哈希索引(ahi)\n * 预读(read ahead)\n\n\n# 42. 索引有哪些优缺点？\n\n优点：\n\n * 唯一索引可以保证数据库表中每一行的数据的唯一性\n * 索引可以加快数据查询速度，减少查询时间\n\n缺点：\n\n * 创建索引和维护索引要耗费时间\n * 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间\n * 以表中的数据进行增、删、改的时候，索引也要动态的维护。\n\n\n# 43. 索引有哪几种类型？\n\n * 主键索引: 数据列不允许重复，不允许为null，一个表只能有一个主键。\n * 唯一索引: 数据列不允许重复，允许为null值，一个表允许多个列创建唯一索引。\n * 普通索引: 基本的索引类型，没有唯一性的限制，允许为null值。\n * 全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。\n * 覆盖索引：查询列要被所建的索引覆盖，不必读取数据行\n * 组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并\n\n\n# 44. 创建索引有什么原则呢？\n\n * 最左前缀匹配原则\n * 频繁作为查询条件的字段才去创建索引\n * 频繁更新的字段不适合创建索引\n * 索引列不能参与计算，不能有函数操作\n * 优先考虑扩展索引，而不是新建索引，避免不必要的索引\n * 在order by或者group by子句中，创建索引需要注意顺序\n * 区分度低的数据列不适合做索引列(如性别）\n * 定义有外键的数据列一定要建立索引。\n * 对于定义为text、image数据类型的列不要建立索引。\n * 删除不再使用或者很少使用的索引\n\n\n# 45. 创建索引的三种方式\n\n * 在执行create table时创建索引\n\ncreate table `employee` (  `id` int(11) not null,  `name` varchar(255) default null,  `age` int(11) default null,  `date` datetime default null,  `sex` int(1) default null,  primary key (`id`),  key `idx_name` (`name`) using btree) engine=innodb default charset=utf8;\n\n\n1\n\n * 使用alter table命令添加索引\n\nalter table table_name add index index_name (column);\n\n\n1\n\n * 使用create index命令创建\n\ncreate index index_name on table_name (column);\n\n\n1\n\n\n\n# 46. 百万级别或以上的数据，你是如何删除的？\n\n * 我们想要删除百万数据的时候可以先删除索引\n * 然后批量删除其中无用数据\n * 删除完成后重新创建索引。\n\n\n# 47. 什么是最左前缀原则？什么是最左匹配原则？\n\n>  * 最左前缀原则，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。\n>  * 当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。。\n\n\n# 48. b树和b+树的区别，数据库为什么使用b+树而不是b树？\n\n * 在b树中，键和值即存放在内部节点又存放在叶子节点；在b+树中，内部节点只存键，叶子节点则同时存放键和值。\n * b+树的叶子节点有一条链相连，而b树的叶子节点各自独立的。\n\n>  * b+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么b+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。.\n>  * b+树非叶子节点上是不存储数据的，仅存储键值，而b树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16kb，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的io次数有会再次减少，数据查询的效率也会更快.\n\n\n# 49. 覆盖索引、回表等这些，了解过吗？\n\n * 覆盖索引：查询列要被所建的索引覆盖，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。\n * 回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。\n\n\n# 50. b+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？\n\n>  * 在b+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。在innodb中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。\n>  * 当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。\n\n\n# 51. 何时使用聚簇索引与非聚簇索引\n\n\n\n\n# 52. 非聚簇索引一定会回表查询吗？\n\n不一定，如果查询语句的字段全部命中了索引，那么就不必再进行回表查询（哈哈，覆盖索引就是这么回事）。\n\n> 举个简单的例子，假设我们在学生表的上建立了索引，那么当进行select age from student where age < 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。\n\n\n# 53. 组合索引是什么？为什么需要注意组合索引中的顺序？\n\n组合索引，用户可以在多个列上建立索引,这种索引叫做组合索引。\n\n因为innodb引擎中的索引策略的最左原则，所以需要注意组合索引中的顺序。\n\n\n# 54. 什么是数据库事务？\n\n数据库事务（简称：事务），是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。\n\n\n# 55. 隔离级别与锁的关系\n\n回答这个问题，可以先阐述四种隔离级别，再阐述它们的实现原理。隔离级别就是依赖锁和mvcc实现的。\n\n可以看我这篇文章哈：一文彻底读懂mysql事务的四大隔离级别\n\n\n# 56. 按照锁的粒度分，数据库锁有哪些呢？锁机制与innodb锁算法\n\n\n\n * 按锁粒度分有：表锁，页锁，行锁\n * 按锁机制分有：乐观锁，悲观锁\n\n\n# 57. 从锁的类别角度讲，mysql都有哪些锁呢？\n\n从锁的类别上来讲，有共享锁和排他锁。\n\n * 共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。\n * 排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。\n\n锁兼容性如下：\n\n\n# 58. mysql中innodb引擎的行锁是怎么实现的？\n\n基于索引来完成行锁的。\n\nselect * from t where id = 666 for update;\n\n\n1\n\n\nfor update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么innodb将实行表锁。\n\n\n# 59. 什么是死锁？怎么解决？\n\n死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。看图形象一点，如下：死锁有四个必要条件：互斥条件，请求和保持条件，环路等待条件，不剥夺条件。\n\n解决死锁思路，一般就是切断环路，尽量避免并发形成环路。\n\n>  * 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。\n>  * 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；\n>  * 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；\n>  * 如果业务处理不好可以用分布式事务锁或者使用乐观锁\n>  * 死锁与索引密不可分，解决索引问题，需要合理优化你的索引，\n\n有兴趣的朋友，可以看我的这篇死锁分析：手把手教你分析mysql死锁问题\n\n\n# 60. 为什么要使用视图？什么是视图？\n\n为什么要使用视图？\n\n为了提高复杂sql语句的复用性和表操作的安全性，mysql数据库管理系统提供了视图特性。\n\n什么是视图？\n\n> 视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询select语句组成。\n\n\n# 61. 视图有哪些特点？哪些使用场景？\n\n视图特点：\n\n * 视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。\n * 视图是由基本表(实表)产生的表(虚表)。\n * 视图的建立和删除不影响基本表。\n * 对视图内容的更新(添加，删除和修改)直接影响基本表。\n * 当视图来自多个基本表时，不允许添加和删除数据。\n\n视图用途： 简化sql查询，提高开发效率，兼容老的表结构。\n\n视图的常见使用场景：\n\n * 重用sql语句；\n * 简化复杂的sql操作。\n * 使用表的组成部分而不是整个表；\n * 保护数据\n * 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。\n\n\n# 62. 视图的优点，缺点，讲一下？\n\n * 查询简单化。视图能简化用户的操作\n * 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护\n * 逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性\n\n\n# 63. count(1)、count(*) 与 count(列名) 的区别？\n\n * count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为null\n * count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为null\n * count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为null时，不统计。\n\n\n# 64. 什么是游标？\n\n游标提供了一种对从表中检索出的数据进行操作的灵活手段，就本质而言，游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制。\n\n\n# 65. 什么是存储过程？有哪些优缺点？\n\n存储过程，就是一些编译好了的sql语句，这些sql语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后给这些代码块取一个名字，在用到这个功能的时候调用即可。\n\n优点：\n\n * 存储过程是一个预编译的代码块，执行效率比较高\n * 存储过程在服务器端运行，减少客户端的压力\n * 允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用\n * 一个存储过程替代大量t_sql语句 ，可以降低网络通信量，提高通信速率\n * 可以一定程度上确保数据安全\n\n缺点：\n\n * 调试麻烦\n * 可移植性不灵活\n * 重新编译问题\n\n\n# 66. 什么是触发器？触发器的使用场景有哪些？\n\n触发器，指一段代码，当触发某个事件时，自动执行这些代码。\n\n使用场景：\n\n * 可以通过数据库中的相关表实现级联更改。\n * 实时监控某张表中的某个字段的更改而需要做出相应的处理。\n * 例如可以生成某些业务的编号。\n * 注意不要滥用，否则会造成数据库及应用程序的维护困难。\n\n\n# 67. mysql中都有哪些触发器？\n\nmysql 数据库中有六种触发器：\n\n * before insert\n * after insert\n * before update\n * after update\n * before delete\n * after delete\n\n\n# 68. 超键、候选键、主键、外键分别是什么？\n\n * 超键：在关系模式中，能唯一知标识元组的属性集称为超键。\n * 候选键：是最小超键，即没有冗余元素的超键。\n * 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（null）。\n * 外键：在一个表中存在的另一个表的主键称此表的外键。。\n\n\n# 69. sql 约束有哪几种呢？\n\n * not null: 约束字段的内容一定不能为null。\n * unique: 约束字段唯一性，一个表允许有多个 unique 约束。\n * primary key: 约束字段唯一，不可重复，一个表只允许存在一个。\n * foreign key: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键。\n * check: 用于控制字段的值范围。\n\n\n# 70. 谈谈六种关联查询，使用场景。\n\n * 交叉连接\n * 内连接\n * 外连接\n * 联合查询\n * 全连接\n * 交叉连接\n\n\n# 71. varchar(50)中50的涵义\n\n * 字段最多存放 50 个字符\n * 如 varchar(50) 和 varchar(200) 存储 "jay" 字符串所占空间是一样的，后者在排序时会消耗更多内存\n\n\n# 72. mysql中int(20)和char(20)以及varchar(20)的区别\n\n * int(20) 表示字段是int类型，显示长度是 20\n * char(20)表示字段是固定长度字符串，长度为 20\n * varchar(20) 表示字段是可变长度字符串，长度为 20\n\n\n# 73. drop、delete与truncate的区别\n\n       delete                 truncate          drop\n类型     dml                    ddl               ddl\n回滚     可回滚                    不可回滚              不可回滚\n删除内容   表结构还在，删除表的全部或者一部分数据行   表结构还在，删除表中的所有数据   从数据库中删除表，所有的数据行，索引和权限也会被删除\n删除速度   删除速度慢，逐行删除             删除速度快             删除速度最快\n\n\n# 74. union与union all的区别？\n\n * union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；\n * union all：对两个结果集进行并集操作，包括重复行，不进行排序；\n * union的效率高于 union all\n\n\n# 75. sql的生命周期？\n\n>  * 服务器与数据库建立连接\n>  * 数据库进程拿到请求sql\n>  * 解析并生成执行计划，执行\n>  * 读取数据到内存，并进行逻辑处理\n>  * 通过步骤一的连接，发送结果到客户端\n>  * 关掉连接，释放资源\n\n\n# 76. 一条sql的执行顺序？\n\n\n\n\n# 77. 列值为null时，查询是否会用到索引？\n\n列值为null也是可以走索引的\n\n计划对列进行索引，应尽量避免把它设置为可空，因为这会让 mysql 难以优化引用了可空列的查询，同时增加了引擎的复杂度\n\n\n# 78. 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？\n\n * 我们平时写sql时，都要养成用explain分析的习惯。\n * 慢查询的统计，运维会定期统计给我们\n\n优化慢查询：\n\n * 分析语句，是否加载了不必要的字段/数据。\n * 分析sql执行句话，是否命中索引等。\n * 如果sql很复杂，优化sql结构\n * 如果表数据量太大，考虑分表\n\n可以看我这篇文章哈：后端程序员必备：书写高质量sql的30条建议\n\n\n# 79. 主键使用自增id还是uuid，为什么？\n\n如果是单机的话，选择自增id；如果是分布式系统，优先考虑uuid吧，但还是最好自己公司有一套分布式唯一id生产方案吧。\n\n * 自增id：数据存储空间小，查询效率高。但是如果数据量过大,会超出自增长的值范围，多库合并，也有可能有问题。\n * uuid：适合大量数据的插入和更新操作，但是它无序的，插入数据效率慢，占用空间大。\n\n\n# 80. mysql自增主键用完了怎么办？\n\n自增主键一般用int类型，一般达不到最大值，可以考虑提前分库分表的。\n\n\n# 81. 字段为什么要求定义为not null？\n\nnull值会占用更多的字节，并且null有很多坑的。\n\n\n# 82. 如果要存储用户的密码散列，应该使用什么字段进行存储？\n\n> 密码散列，盐，用户身份证号等固定长度的字符串，应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。\n\n\n# 83. mysql驱动程序是什么？\n\n这个jar包：mysql-connector-java-5.1.18.jar\n\nmysql驱动程序主要帮助编程语言与 mysql服务端进行通信，如连接、传输数据、关闭等。\n\n\n# 84. 如何优化长难的查询语句？有实战过吗？\n\n * 将一个大的查询分为多个小的相同的查询\n * 减少冗余记录的查询。\n * 一个复杂查询可以考虑拆成多个简单查询\n * 分解关联查询，让缓存的效率更高。\n\n\n# 85. 优化特定类型的查询语句\n\n平时积累吧：\n\n * 比如使用select 具体字段代替 select *\n * 使用count(*) 而不是count(列名)\n * 在不影响业务的情况，使用缓存\n * explain 分析你的sql\n\n可以看我这篇文章哈：后端程序员必备：书写高质量sql的30条建议\n\n\n# 86. mysql数据库cpu飙升的话，要怎么处理呢？\n\n排查过程：\n\n * 使用top 命令观察，确定是mysqld导致还是其他原因。\n * 如果是mysqld导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行。\n * 找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。\n\n处理：\n\n * kill 掉这些线程(同时观察 cpu 使用率是否下降)，\n * 进行相应的调整(比如说加索引、改 sql、改内存参数)\n * 重新跑这些 sql。\n\n其他情况：\n\n也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等\n\n\n# 87. 读写分离常见方案？\n\n * 应用程序根据业务逻辑来判断，增删改等写操作命令发给主库，查询命令发给备库。\n * 利用中间件来做代理，负责对数据库的请求识别出读还是写，并分发到不同的数据库中。（如：amoeba，mysql-proxy）\n\n\n# 88. mysql的复制原理以及流程\n\n主从复制原理，简言之，就三步曲，如下：\n\n * 主数据库有个bin-log二进制文件，纪录了所有增删改sql语句。（binlog线程）\n * 从数据库把主数据库的bin-log文件的sql语句复制过来。（io线程）\n * 从数据库的relay-log重做日志文件中再执行一次这些sql语句。（sql执行线程）\n\n如下图所示：\n\n\n\n上图主从复制分了五个步骤进行：\n\n步骤一：主库的更新事件(update、insert、delete)被写到binlog\n\n步骤二：从库发起连接，连接到主库。\n\n步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。\n\n步骤四：从库启动之后，创建一个i/o线程，读取主库传过来的binlog内容并写入到relay log\n\n步骤五：还会创建一个sql线程，从relay log里面读取内容，从execmasterlog_pos位置开始执行读取到的更新事件，将更新内容写入到slave的db\n\n\n# 89. mysql中datetime和timestamp的区别\n\n存储精度都为秒\n\n区别：\n\n * datetime 的日期范围是 1001——9999 年；timestamp 的时间范围是 1970——2038 年\n * datetime 存储时间与时区无关；timestamp 存储时间与时区有关，显示的值也依赖于时区\n * datetime 的存储空间为 8 字节；timestamp 的存储空间为 4 字节\n * datetime 的默认值为 null；timestamp 的字段默认不为空(not null)，默认值为当前时间(current_timestamp)\n\n\n# 90. innodb的事务实现原理？\n\n * 原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。\n * 持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。\n * 隔离性：通过锁以及mvcc,使事务相互隔离开。\n * 一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。\n\n\n# 91. 谈谈mysql的explain\n\nexplain 执行计划包含字段信息如下：分别是 id、selecttype、table、partitions、type、possiblekeys、key、key_len、ref、rows、filtered、extra 等12个字段。\n\n我们重点关注的是type，它的属性排序如下：\n\nsystem  > const > eq_ref > ref  > ref_or_null >index_merge > unique_subquery > index_subquery > range > index > all\n\n\n1\n\n\n推荐大家看这篇文章哈：面试官：不会看 explain执行计划，简历敢写 sql 优化？\n\n\n# 92. innodb的事务与日志的实现方式\n\n# 有多少种日志\n\ninnodb两种日志redo和undo。\n\n# 日志的存放形式\n\n * redo：在页修改的时候，先写到 redo log buffer 里面， 然后写到 redo log 的文件系统缓存里面(fwrite)，然后再同步到磁盘文件（ fsync）。\n * undo：在 mysql5.5 之前， undo 只能存放在 ibdata文件里面， 5.6 之后，可以通过设置 innodbundotablespaces 参数把 undo log 存放在 ibdata之外。\n\n# 事务是如何通过日志来实现的\n\n * 因为事务在修改页时，要先记 undo，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。\n * 当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的 状态，崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。\n * 如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。\n\n\n# 93. mysql中text数据类型的最大长度\n\n * tinytext：256 bytes\n * text：65,535 bytes(64kb)\n * mediumtext：16,777,215 bytes(16mb)\n * longtext：4,294,967,295 bytes(4gb)\n\n\n# 94. 500台db，在最快时间之内重启。\n\n * 可以使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。\n * 也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务\n\n\n# 95. 你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？\n\n监控的工具有很多，例如zabbix，lepus，我这里用的是lepus\n\n\n# 96. 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？\n\n主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等\n\n\n# 97. 你们数据库是否支持emoji表情存储，如果不支持，如何操作？\n\n更换字符集utf8--\x3eutf8mb4\n\n\n# 98. mysql如何获取当前日期？\n\nselect current_date();\n\n\n# 99. 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。\n\n1、如果a表tid是自增长,并且是连续的,b表的id为索引 select * from a,b where a.tid = b.id and a.tid>500000 limit 200;\n\n2、如果a表的tid不是连续的,那么就需要使用覆盖索引.tid要么是主键,要么是辅助索引,b表id也需要有索引。select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;\n\n\n# 100. mysql一条sql加锁分析\n\n一条sql加锁，可以分9种情况进行哈：\n\n * 组合一：id列是主键，rc隔离级别\n * 组合二：id列是二级唯一索引，rc隔离级别\n * 组合三：id列是二级非唯一索引，rc隔离级别\n * 组合四：id列上没有索引，rc隔离级别\n * 组合五：id列是主键，rr隔离级别\n * 组合六：id列是二级唯一索引，rr隔离级别\n * 组合七：id列是二级非唯一索引，rr隔离级别\n * 组合八：id列上没有索引，rr隔离级别\n * 组合九：serializable隔离级别\n\n往期精彩推荐：\n\n * 一文带你夯实双指针基础\n * 一道非常经典的队列面试题\n * 看看这篇文章能不能把那个著名的接雨水问题讲明白\n * 什么锅配什么盖（一个老生常谈的匹配问题）\n * 栈和队列的那些事，你读完这个文章就懂了\n * 链表的一二三四五六七全都在这了',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"oracle",frontmatter:{title:"oracle",date:"2021-07-12T10:08:29.000Z",permalink:"/pages/349793/",categories:["后端","数据库","Oracle"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/20.%E6%95%B0%E6%8D%AE%E5%BA%93/01.Oracle/00.oracle.html",relativePath:"01.后端/20.数据库/01.Oracle/00.oracle.md",key:"v-8ab2f9f8",path:"/pages/349793/",headers:[{level:2,title:"常用sql",slug:"常用sql",normalizedTitle:"常用sql",charIndex:13},{level:2,title:"一.Union、Union  Al(求并集)",slug:"一-union、union-al-求并集",normalizedTitle:"一.union、union  al(求并集)",charIndex:null},{level:2,title:"二.创建触发器，方便追错误",slug:"二-创建触发器-方便追错误",normalizedTitle:"二.创建触发器，方便追错误",charIndex:837},{level:2,title:"三.group一定放到where后面",slug:"三-group一定放到where后面",normalizedTitle:"三.group一定放到where后面",charIndex:1609},{level:2,title:"四.创建视图",slug:"四-创建视图",normalizedTitle:"四.创建视图",charIndex:1935}],headersStr:"常用sql 一.Union、Union  Al(求并集) 二.创建触发器，方便追错误 三.group一定放到where后面 四.创建视图",content:"# Oracle\n\n\n# 常用sql\n\n1.备份数据库表   cmp_apply_b备份到cmp_apply_b_20210430 \ncreate table cmp_apply_b_20210430 as select * from cmp_apply_b\ncreate table employees_cp as select * from employees where 1=2; --只备份表结构\n\n2.一个表中的字段复制到另一个字段  vdef25复制到vdef49  \nupdate cmp_apply_b set vdef49 = vdef25 \n\n3.一个表中的字段更改为另一个表的字段 比如：付款申请表体vdef25 保存的是银行账户的编号，现在需要改为银行账户的PK， 但是vdef25有些是银行账户的编号，有些是PK，所以过滤掉,主键是以1001A、1001L开头的 \nupdate cmp_apply_b a\n   set a.vdef25 =\n       (select b.pk_bankaccsub from bd_bankaccsub b where a.vdef25 = b.accnum)\n       where a.vdef25 not like '1001L%' and a.vdef25 not like '1001A%'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 一.Union、Union Al(求并集)\n\nUnion：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；\n\nUnion All：对两个结果集进行并集操作，包括重复行，不进行排序；\n\n返回的列必须一致\n\n--对两个结果集进行并集操作，不包括重复行\nselect * from TestA where id<3 \nunion \nselect * from TestA where id<6;\n\n\n1\n2\n3\n4\n\n\n\n# 二.创建触发器，方便追错误\n\n模板：\n--XXXXXX_TRIGGER:本触发器的命名\n--begin与end之间的代码为这个触发器所要执行的动作\nCREATE OR REPLACE TRIGGER  \"XXXXXX_TRIGGER\"\nafter UPDATE OR INSERT  on TB_FD_SHT5830523\nfor each row\n \nbegin\n    raise_application_error(-20002,'在做测试...');\nend;\n\n\n例子：\n--XXXXXX_TRIGGER:本触发器的命名\n--begin与end之间的代码为这个触发器所要执行的动作\nCREATE OR REPLACE TRIGGER  \"SETTLEMENT_SAVE_TRIGGER\"\nBEFORE INSERT  on CMP_SETTLEMENT\nfor each row\n \nbegin\n    raise_application_error(-20002,'在做测试...');\nend;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n2.创建修改某个表中的某个值时触发\n\nCREATE OR REPLACE TRIGGER  \"cmp_informer_TRIGGER\"\nafter UPDATE on cmp_informer \nfor each row  --行级触发\nbegin\n  IF :new.generateflag = 'hasrelease' THEN \n    raise_application_error(-20002,'在做测试...');\n   END IF;\nend;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 三.group一定放到where后面\n\n**注意:**group by name，那么找name那一列，具有相同name值的行，合并成一行，\n\n需求：通过线下预约表，统计预约人员表的人数\n\nSELECT\n\to.*,COUNT(u.id) as count_user\nFROM\n\tmy_course_order o\nleft JOIN my_course_order_user u on o.id=u.order_id\nWHERE\n\to.course_id = 2\nGROUP BY\n\to.id\nORDER BY\n\to.STATUS desc,\n\to.create_time DESC\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 四.创建视图\n\n--创建视图\nCREATE OR REPLACE VIEW v_cmp_informer\nAS\nselect * from cmp_informer where generateflag='hasnogenerate' and  pk_informer ='0001A7100000000AA4W3'    --1001A71000000064B5NG\n\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# oracle\n\n\n# 常用sql\n\n1.备份数据库表   cmp_apply_b备份到cmp_apply_b_20210430 \ncreate table cmp_apply_b_20210430 as select * from cmp_apply_b\ncreate table employees_cp as select * from employees where 1=2; --只备份表结构\n\n2.一个表中的字段复制到另一个字段  vdef25复制到vdef49  \nupdate cmp_apply_b set vdef49 = vdef25 \n\n3.一个表中的字段更改为另一个表的字段 比如：付款申请表体vdef25 保存的是银行账户的编号，现在需要改为银行账户的pk， 但是vdef25有些是银行账户的编号，有些是pk，所以过滤掉,主键是以1001a、1001l开头的 \nupdate cmp_apply_b a\n   set a.vdef25 =\n       (select b.pk_bankaccsub from bd_bankaccsub b where a.vdef25 = b.accnum)\n       where a.vdef25 not like '1001l%' and a.vdef25 not like '1001a%'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 一.union、union al(求并集)\n\nunion：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；\n\nunion all：对两个结果集进行并集操作，包括重复行，不进行排序；\n\n返回的列必须一致\n\n--对两个结果集进行并集操作，不包括重复行\nselect * from testa where id<3 \nunion \nselect * from testa where id<6;\n\n\n1\n2\n3\n4\n\n\n\n# 二.创建触发器，方便追错误\n\n模板：\n--xxxxxx_trigger:本触发器的命名\n--begin与end之间的代码为这个触发器所要执行的动作\ncreate or replace trigger  \"xxxxxx_trigger\"\nafter update or insert  on tb_fd_sht5830523\nfor each row\n \nbegin\n    raise_application_error(-20002,'在做测试...');\nend;\n\n\n例子：\n--xxxxxx_trigger:本触发器的命名\n--begin与end之间的代码为这个触发器所要执行的动作\ncreate or replace trigger  \"settlement_save_trigger\"\nbefore insert  on cmp_settlement\nfor each row\n \nbegin\n    raise_application_error(-20002,'在做测试...');\nend;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n2.创建修改某个表中的某个值时触发\n\ncreate or replace trigger  \"cmp_informer_trigger\"\nafter update on cmp_informer \nfor each row  --行级触发\nbegin\n  if :new.generateflag = 'hasrelease' then \n    raise_application_error(-20002,'在做测试...');\n   end if;\nend;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 三.group一定放到where后面\n\n**注意:**group by name，那么找name那一列，具有相同name值的行，合并成一行，\n\n需求：通过线下预约表，统计预约人员表的人数\n\nselect\n\to.*,count(u.id) as count_user\nfrom\n\tmy_course_order o\nleft join my_course_order_user u on o.id=u.order_id\nwhere\n\to.course_id = 2\ngroup by\n\to.id\norder by\n\to.status desc,\n\to.create_time desc\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 四.创建视图\n\n--创建视图\ncreate or replace view v_cmp_informer\nas\nselect * from cmp_informer where generateflag='hasnogenerate' and  pk_informer ='0001a7100000000aa4w3'    --1001a71000000064b5ng\n\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"Oracle基础知识",frontmatter:{title:"Oracle基础知识",date:"2021-07-12T11:26:10.000Z",permalink:"/pages/f1ccdf/",categories:["后端","数据库","Oracle"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/20.%E6%95%B0%E6%8D%AE%E5%BA%93/01.Oracle/01.Oracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html",relativePath:"01.后端/20.数据库/01.Oracle/01.Oracle基础知识.md",key:"v-3fa66498",path:"/pages/f1ccdf/",headers:[{level:2,title:"字符函数",slug:"字符函数",normalizedTitle:"字符函数",charIndex:116},{level:2,title:"数值函数",slug:"数值函数",normalizedTitle:"数值函数",charIndex:124},{level:2,title:"日期类型",slug:"日期类型",normalizedTitle:"日期类型",charIndex:2751},{level:2,title:"日期函数",slug:"日期函数",normalizedTitle:"日期函数",charIndex:132},{level:2,title:"转换函数",slug:"转换函数",normalizedTitle:"转换函数",charIndex:140},{level:2,title:"日期 **->** **字符串**",slug:"日期-字符串",normalizedTitle:"日期 <strong>-&gt;</strong> <strong>字符串</strong>",charIndex:null},{level:2,title:"常用日期格式符",slug:"常用日期格式符",normalizedTitle:"常用日期格式符",charIndex:4817},{level:2,title:"字符串 **->** **日期**",slug:"字符串-日期",normalizedTitle:"字符串 <strong>-&gt;</strong> <strong>日期</strong>",charIndex:null},{level:2,title:"数字",slug:"数字",normalizedTitle:"数字",charIndex:2778},{level:2,title:"字符串 **->** **数字**",slug:"字符串-数字",normalizedTitle:"字符串 <strong>-&gt;</strong> <strong>数字</strong>",charIndex:null},{level:2,title:"通用函数",slug:"通用函数",normalizedTitle:"通用函数",charIndex:148},{level:2,title:"NVL()**函数**",slug:"nvl-函数",normalizedTitle:"nvl()<strong>函数</strong>",charIndex:null},{level:2,title:"NVL2()**函数**",slug:"nvl2-函数",normalizedTitle:"nvl2()<strong>函数</strong>",charIndex:null},{level:2,title:"NULLIF()**函数**",slug:"nullif-函数",normalizedTitle:"nullif()<strong>函数</strong>",charIndex:null},{level:2,title:"COALESCE()**函数**",slug:"coalesce-函数",normalizedTitle:"coalesce()<strong>函数</strong>",charIndex:null},{level:2,title:"CASE()**函数**",slug:"case-函数",normalizedTitle:"case()<strong>函数</strong>",charIndex:null},{level:3,title:"case高阶用法：",slug:"case高阶用法",normalizedTitle:"case高阶用法：",charIndex:8391},{level:2,title:"DECODE()**函数**",slug:"decode-函数",normalizedTitle:"decode()<strong>函数</strong>",charIndex:null},{level:2,title:"函数嵌套",slug:"函数嵌套",normalizedTitle:"函数嵌套",charIndex:10625},{level:2,title:"COUNT()**函数**",slug:"count-函数",normalizedTitle:"count()<strong>函数</strong>",charIndex:null},{level:2,title:"分组函数与空值",slug:"分组函数与空值",normalizedTitle:"分组函数与空值",charIndex:11722},{level:2,title:"GROUP BY**子句**",slug:"group-by-子句",normalizedTitle:"group by<strong>子句</strong>",charIndex:null},{level:2,title:"HAVING **子句**",slug:"having-子句",normalizedTitle:"having <strong>子句</strong>",charIndex:null},{level:2,title:"交叉连接(Cross join)",slug:"交叉连接-cross-join",normalizedTitle:"交叉连接(cross join)",charIndex:13982},{level:2,title:"Natural join自然连接",slug:"natural-join自然连接",normalizedTitle:"natural join自然连接",charIndex:16140},{level:2,title:"Using **子句**",slug:"using-子句",normalizedTitle:"using <strong>子句</strong>",charIndex:null},{level:2,title:"On **子句**",slug:"on-子句",normalizedTitle:"on <strong>子句</strong>",charIndex:null},{level:2,title:"内连接和外连接",slug:"内连接和外连接",normalizedTitle:"内连接和外连接",charIndex:18737},{level:2,title:"子查询**(Sub Query)**",slug:"子查询-sub-query",normalizedTitle:"子查询**(sub query)**",charIndex:null},{level:2,title:"注意：子查询配合表连接使用，子查询不能和left连接使用",slug:"注意-子查询配合表连接使用-子查询不能和left连接使用",normalizedTitle:"注意：子查询配合表连接使用，子查询不能和left连接使用",charIndex:21726},{level:2,title:"1.添加",slug:"_1-添加",normalizedTitle:"1.添加",charIndex:21945},{level:2,title:"1.对表的操作",slug:"_1-对表的操作",normalizedTitle:"1.对表的操作",charIndex:22784},{level:3,title:"建表语句：",slug:"建表语句",normalizedTitle:"建表语句：",charIndex:22937},{level:3,title:"复制表：",slug:"复制表",normalizedTitle:"复制表：",charIndex:23039},{level:3,title:"删除表",slug:"删除表",normalizedTitle:"删除表",charIndex:23171},{level:3,title:"更改表名",slug:"更改表名",normalizedTitle:"更改表名",charIndex:23691},{level:2,title:"2.对列的操作：",slug:"_2-对列的操作",normalizedTitle:"2.对列的操作：",charIndex:23743},{level:2,title:"3.约束",slug:"_3-约束",normalizedTitle:"3.约束",charIndex:23994},{level:3,title:"3.1.添加约束",slug:"_3-1-添加约束",normalizedTitle:"3.1.添加约束",charIndex:24285},{level:3,title:"3.2.删除约束",slug:"_3-2-删除约束",normalizedTitle:"3.2.删除约束",charIndex:24606},{level:3,title:"3.3.约束失效",slug:"_3-3-约束失效",normalizedTitle:"3.3.约束失效",charIndex:24677},{level:3,title:"3.4.查看某个表有哪些约束",slug:"_3-4-查看某个表有哪些约束",normalizedTitle:"3.4.查看某个表有哪些约束",charIndex:24752},{level:2,title:"4.试图",slug:"_4-试图",normalizedTitle:"4.试图",charIndex:24894},{level:3,title:"4.1.创建视图",slug:"_4-1-创建视图",normalizedTitle:"4.1.创建视图",charIndex:24903},{level:3,title:"4.2.删除试图",slug:"_4-2-删除试图",normalizedTitle:"4.2.删除试图",charIndex:25032},{level:3,title:"4.3.TOP-N 查询：查询某个表前N行数据，并显示行号",slug:"_4-3-top-n-查询-查询某个表前n行数据-并显示行号",normalizedTitle:"4.3.top-n 查询：查询某个表前n行数据，并显示行号",charIndex:25069},{level:3,title:"4.4.视图可以修改吗？",slug:"_4-4-视图可以修改吗",normalizedTitle:"4.4.视图可以修改吗？",charIndex:25230},{level:2,title:"5.序列（类似mysql中的自增主键）",slug:"_5-序列-类似mysql中的自增主键",normalizedTitle:"5.序列（类似mysql中的自增主键）",charIndex:25381},{level:3,title:"5.1.创建序列",slug:"_5-1-创建序列",normalizedTitle:"5.1.创建序列",charIndex:25615},{level:3,title:"5.2.使用序列",slug:"_5-2-使用序列",normalizedTitle:"5.2.使用序列",charIndex:26710},{level:3,title:"5.3.更改序列",slug:"_5-3-更改序列",normalizedTitle:"5.3.更改序列",charIndex:26905},{level:3,title:"5.4.删除序列",slug:"_5-4-删除序列",normalizedTitle:"5.4.删除序列",charIndex:27013},{level:2,title:"6.索引",slug:"_6-索引",normalizedTitle:"6.索引",charIndex:27062},{level:3,title:"6.1.oracle中索引的区别：",slug:"_6-1-oracle中索引的区别",normalizedTitle:"6.1.oracle中索引的区别：",charIndex:27071},{level:3,title:"6.2.创建索引",slug:"_6-2-创建索引",normalizedTitle:"6.2.创建索引",charIndex:28307},{level:3,title:"6.3.什么时候适合索引",slug:"_6-3-什么时候适合索引",normalizedTitle:"6.3.什么时候适合索引",charIndex:28474},{level:3,title:"6.4.索引函数",slug:"_6-4-索引函数",normalizedTitle:"6.4.索引函数",charIndex:28733},{level:2,title:"7.同义词",slug:"_7-同义词",normalizedTitle:"7.同义词",charIndex:29083},{level:3,title:"7.1.DB-LINK（不同数据库）",slug:"_7-1-db-link-不同数据库",normalizedTitle:"7.1.db-link（不同数据库）",charIndex:29093},{level:3,title:"7.2.同义词",slug:"_7-2-同义词",normalizedTitle:"7.2.同义词",charIndex:29356},{level:3,title:"7.2.创建同义词",slug:"_7-2-创建同义词",normalizedTitle:"7.2.创建同义词",charIndex:29546},{level:2,title:"8.控制权限",slug:"_8-控制权限",normalizedTitle:"8.控制权限",charIndex:29647},{level:3,title:"8.1.给某个用户赋予权限",slug:"_8-1-给某个用户赋予权限",normalizedTitle:"8.1.给某个用户赋予权限",charIndex:29749},{level:3,title:"8.2.添加角色",slug:"_8-2-添加角色",normalizedTitle:"8.2.添加角色",charIndex:29968},{level:3,title:"8.3.给用户赋予修改某个表某个字段权限",slug:"_8-3-给用户赋予修改某个表某个字段权限",normalizedTitle:"8.3.给用户赋予修改某个表某个字段权限",charIndex:30156},{level:3,title:"8.4.权限传递",slug:"_8-4-权限传递",normalizedTitle:"8.4.权限传递",charIndex:30269},{level:3,title:"8.5.所有人都有某权限",slug:"_8-5-所有人都有某权限",normalizedTitle:"8.5.所有人都有某权限",charIndex:30415},{level:3,title:"8.6.权限数据字典",slug:"_8-6-权限数据字典",normalizedTitle:"8.6.权限数据字典",charIndex:30487},{level:3,title:"8.7.收回权限",slug:"_8-7-收回权限",normalizedTitle:"8.7.收回权限",charIndex:30504},{level:2,title:"9.Oracle集合",slug:"_9-oracle集合",normalizedTitle:"9.oracle集合",charIndex:30612},{level:3,title:"9.1.并集",slug:"_9-1-并集",normalizedTitle:"9.1.并集",charIndex:30627},{level:3,title:"9.2.交集",slug:"_9-2-交集",normalizedTitle:"9.2.交集",charIndex:30670},{level:3,title:"9.3.差集",slug:"_9-3-差集",normalizedTitle:"9.3.差集",charIndex:30697},{level:2,title:"10.Group by子句增强",slug:"_10-group-by子句增强",normalizedTitle:"10.group by子句增强",charIndex:30720},{level:3,title:"10.1.ROLLUP关键字",slug:"_10-1-rollup关键字",normalizedTitle:"10.1.rollup关键字",charIndex:30740},{level:3,title:"10.2.Cube",slug:"_10-2-cube",normalizedTitle:"10.2.cube",charIndex:31003},{level:3,title:"10.3.grouping关键字",slug:"_10-3-grouping关键字",normalizedTitle:"10.3.grouping关键字",charIndex:31202},{level:3,title:"10.4.grouping set关键字",slug:"_10-4-grouping-set关键字",normalizedTitle:"10.4.grouping set关键字",charIndex:31282},{level:2,title:"11.子查询进阶",slug:"_11-子查询进阶",normalizedTitle:"11.子查询进阶",charIndex:31599},{level:3,title:"11.1.把查询结果当做一个表",slug:"_11-1-把查询结果当做一个表",normalizedTitle:"11.1.把查询结果当做一个表",charIndex:31612},{level:3,title:"11.2.当做某个判断条件",slug:"_11-2-当做某个判断条件",normalizedTitle:"11.2.当做某个判断条件",charIndex:31949},{level:3,title:"11.3.exists关键字",slug:"_11-3-exists关键字",normalizedTitle:"11.3.exists关键字",charIndex:32208},{level:3,title:"11.4.Not Exists",slug:"_11-4-not-exists",normalizedTitle:"11.4.not exists",charIndex:32861},{level:3,title:"11.5某个表的字段更新为另一个表的字段（慎用）",slug:"_11-5某个表的字段更新为另一个表的字段-慎用",normalizedTitle:"11.5某个表的字段更新为另一个表的字段（慎用）",charIndex:33265},{level:3,title:"11.6.子查询delete（不用）",slug:"_11-6-子查询delete-不用",normalizedTitle:"11.6.子查询delete（不用）",charIndex:33485},{level:3,title:"11.7.With关键字",slug:"_11-7-with关键字",normalizedTitle:"11.7.with关键字",charIndex:33933},{level:2,title:"12.递归查询",slug:"_12-递归查询",normalizedTitle:"12.递归查询",charIndex:34436},{level:2,title:"13.insert增强（插入几个表）",slug:"_13-insert增强-插入几个表",normalizedTitle:"13.insert增强（插入几个表）",charIndex:35409},{level:3,title:"13.1.一个来源插入多个目标表（无条件）。",slug:"_13-1-一个来源插入多个目标表-无条件-。",normalizedTitle:"13.1.一个来源插入多个目标表（无条件）。",charIndex:35432},{level:3,title:"13.2.一个来源插入多个目标表（有条件，首次匹配即跳到下一条）",slug:"_13-2-一个来源插入多个目标表-有条件-首次匹配即跳到下一条",normalizedTitle:"13.2.一个来源插入多个目标表（有条件，首次匹配即跳到下一条）",charIndex:35738},{level:2,title:"14.sql进阶",slug:"_14-sql进阶",normalizedTitle:"14.sql进阶",charIndex:36231},{level:3,title:"14.1.查询部门的平均工资、最高工资和最低工资，并且把员工都查询出来",slug:"_14-1-查询部门的平均工资、最高工资和最低工资-并且把员工都查询出来",normalizedTitle:"14.1.查询部门的平均工资、最高工资和最低工资，并且把员工都查询出来",charIndex:36244},{level:3,title:"14.2.将一个部门内的员工的工资从高到低进行排序，注意三种排序结果是不一样的。",slug:"_14-2-将一个部门内的员工的工资从高到低进行排序-注意三种排序结果是不一样的。",normalizedTitle:"14.2.将一个部门内的员工的工资从高到低进行排序，注意三种排序结果是不一样的。",charIndex:37115},{level:3,title:"14.3.Oracle的闪回机制",slug:"_14-3-oracle的闪回机制",normalizedTitle:"14.3.oracle的闪回机制",charIndex:37162}],headersStr:"字符函数 数值函数 日期类型 日期函数 转换函数 日期 **->** **字符串** 常用日期格式符 字符串 **->** **日期** 数字 字符串 **->** **数字** 通用函数 NVL()**函数** NVL2()**函数** NULLIF()**函数** COALESCE()**函数** CASE()**函数** case高阶用法： DECODE()**函数** 函数嵌套 COUNT()**函数** 分组函数与空值 GROUP BY**子句** HAVING **子句** 交叉连接(Cross join) Natural join自然连接 Using **子句** On **子句** 内连接和外连接 子查询**(Sub Query)** 注意：子查询配合表连接使用，子查询不能和left连接使用 1.添加 1.对表的操作 建表语句： 复制表： 删除表 更改表名 2.对列的操作： 3.约束 3.1.添加约束 3.2.删除约束 3.3.约束失效 3.4.查看某个表有哪些约束 4.试图 4.1.创建视图 4.2.删除试图 4.3.TOP-N 查询：查询某个表前N行数据，并显示行号 4.4.视图可以修改吗？ 5.序列（类似mysql中的自增主键） 5.1.创建序列 5.2.使用序列 5.3.更改序列 5.4.删除序列 6.索引 6.1.oracle中索引的区别： 6.2.创建索引 6.3.什么时候适合索引 6.4.索引函数 7.同义词 7.1.DB-LINK（不同数据库） 7.2.同义词 7.2.创建同义词 8.控制权限 8.1.给某个用户赋予权限 8.2.添加角色 8.3.给用户赋予修改某个表某个字段权限 8.4.权限传递 8.5.所有人都有某权限 8.6.权限数据字典 8.7.收回权限 9.Oracle集合 9.1.并集 9.2.交集 9.3.差集 10.Group by子句增强 10.1.ROLLUP关键字 10.2.Cube 10.3.grouping关键字 10.4.grouping set关键字 11.子查询进阶 11.1.把查询结果当做一个表 11.2.当做某个判断条件 11.3.exists关键字 11.4.Not Exists 11.5某个表的字段更新为另一个表的字段（慎用） 11.6.子查询delete（不用） 11.7.With关键字 12.递归查询 13.insert增强（插入几个表） 13.1.一个来源插入多个目标表（无条件）。 13.2.一个来源插入多个目标表（有条件，首次匹配即跳到下一条） 14.sql进阶 14.1.查询部门的平均工资、最高工资和最低工资，并且把员工都查询出来 14.2.将一个部门内的员工的工资从高到低进行排序，注意三种排序结果是不一样的。 14.3.Oracle的闪回机制",content:"# Oracle函数\n\n* Oracle 函数分为单行函数和多行函数两大类\n\n* 单行函数\n\n- 操作数据项\n\n- 接受参数并返回处理结果\n\n- 对每一返回行起作用\n\n- 可修改数据类型\n\n- 可嵌套使用\n\n* 单行函数分类\n\n- 字符函数\n\n- 数值函数\n\n- 日期函数\n\n- 转换函数\n\n- 通用函数\n\n\n# 字符函数\n\n* 字符大小写转换函数\n\n* 函数 功能 用法 返回结果\n\n- lower() 转换为小写 lower('John Smith') john smith\n\n- upper() 转换为大写 upper('John Smith') JOHN SMITH\n\n- initcap() 单词首字母大写 initcap('JOHN smith') John Smith\n\n* 例:\n\n- select lower('John Smith') from dual;->(john smith)\n\n- select upper('John Smith') from dual;->(JOHN SMITH)\n\n- select initcap('JOHN smith') from dual;->(John Smith)\n\n*字符处理函数\n\n* 函数 功能 用法 返回结果\n\n- concat() 字符串连接 concat('Hello', 'World') Hello World\n\n- substr() 截取子串 substr('HelloWorld', 4, 3) loW\n\n- length() 返回字符串长度 length('Hello World') 11\n\n- instr() 定位子串 instr('Hello World', 'or') 8\n\n- lpad() 左侧填充 lpad('Smith', 10, '*') *****Smith\n\n- rpad() 右侧填充 rpad('Smith', 10, '*') Smith*****\n\n- trim() 过滤首尾空格 trim(' Mr Smith ') Mr Smith\n\n- replace() 替换 replace('ABA', 'A', 'C') CBC\n\n* 注意:函数可嵌套使用\n\n* 例:\n\n- select concat('Hello', 'World') from dual;->(HelloWorld)\n\n- select concat(concat(ename, ' is a '), job) info from emp where empno=7369;->(SMITH is a CLERK)\n\n- select substr('HelloWorld', 4, 3) from dual;->(loW)\n\n- select substr(substr('HelloWorld', 3, 6), 3, 3) from dual->(oWo)\n\n- select length('Hello World') from dual;->(11)\n\n- select instr('Hello World', 'or') from dual;->(8)\n\n- select lpad('Smith', 10, '*') from dual;->(*****Smith)\n\n- select rpad('Smith', 10, '*') from dual;->(Smith*****)\n\n- select trim(' Mr Smith ') from dual;->(Mr Smith)\n\n- select replace('ABA', 'A', 'C') from dual;->(CBC)\n\n\n# 数值函数\n\n* 函数 功能 用法 返回结果\n\n- abs() 取绝对值 abs(-3.14) 3.14\n\n- round() 四舍五入 round(3.1415) 3\n\nround(3.1415, 3) 3.142\n\nround(314.1592, -2) 300\n\n- trunc() 截断 trunc(3.1415, 3) 3.141\n\n- ceil() 向上取整 ceil(3.14) 4\n\n- floor() 向下取整 floor(3.14) 3\n\n- sign() 判断数值正负 sign(-3.14) -1\n\n- sin().. 三角函数.. sin(3.14) .001592653\n\n- power() 幂运算 power(4.5, 2) 20.25\n\n- sqrt() 开平方根 sqrt(9) 3\n\n- mod() 取模 mod(10, 3) 1\n\n- exp() 基数为e的幂运算exp(1) 2.71828183\n\n- log() 对数运算 log(4, 16.0) 2\n\n- ln() 自然对数运算 ln(7) 1.94591015\n\n* 例:\n\n- select abs(-3.14) from dual;->(3.14)\n\n- select round(3.1415) from dual;->(3)\n\n- select round(3.1415, 3) from dual;->(3.142)\n\n- select round(314.1592, -2) from dual;->(300)\n\n- select trunc(3.1415, 3) from dual;->(3.141)\n\n- select trunc(3.1415, -3) from dual;->(0)\n\n- select trunc(3.1415, 7) from dual;->(3.1415)\n\n- select ceil(3.14) from dual;->(4)\n\n- select floor(3.14) from dual;->(3)\n\n- select sign(-3.14) from dual;->(-1)\n\n- select sin(3.14) from dual;->(.001592653)\n\n- select power(4.5, 2) from dual;->(20.25)\n\n- select sqrt(9) from dual;->(3)\n\n- select mod(10, 3) from dual;->(1)\n\n- select exp(1) from dual;->(2.71828183)\n\n- select log(4, 16.0) from dual;->(2)\n\n- select ln(7) from dual;->(1.94591015)\n\n\n# 日期类型\n\n* 关于日期类型\n\n- Oracle内部以数字格式存储日期和时间信息:世纪,年,月,日,小时,分钟,秒\n\n- 缺省的日期格式是DD-MON-YY\n\n- 可使用sysdate函数获取当前系统日期和时间\n\n* 日期型数据的算术运算\n\n- 日期型数据可以直接加或减一个数值,结果仍为日期\n\n- 两个日期型数据可以相减,结果为二者相差多少天\n\n* 查询200-12-25减1991-12-25一共有多少天\n\n- select to_date('25-12月 -09') - to_date('25-12月-1991') from dual;\n\n\n# 日期函数\n\n* 函数 功能 用法 返回结果\n\n- add_months(x, y) 计算在日期x基础上增加y个月后的日期add_months(sysdate, 2)\n\n- last_day(x) 返回日期x当月最后一天的日期 last_day(sysdate)\n\n- months_between(x, y) 返回日期x和y之间相差的月数 months_between(sysdate, hiredate)\n\n- round(x, y) 将日期x四舍五入到y所指定的 round(sysdate, 'month')\n\n日期单位(月或年)的第一天 round(sysdate, 'year')\n\n- trunc(x, y) 将日期x截断到y所指定的 trunc(sysdate, 'month')\n\n日期单位(月或年)的第一天 trunc(sysdate, 'year')\n\n- next_day 计算指定日期x后的第一个星期几 next_day(sysdate, '星期二')\n\n(由参数y指定)对应的日期\n\n* 例:\n\n- select add_months(sysdate, 2) from dual;->(05-10月-09)\n\n- select last_day(sysdate) from dual;->(31-8月-09)\n\n- select hiredate, months_between(sysdate, hiredate) from emp;\n\n- select months_between(sysdate, '17-12月-80') from dual;->(343.63907)\n\n- select round(sysdate, 'month') from dual;->(01-8月-09)\n\n- select round(to_date('16-8月 -09'), 'month') from dual;->(01-9月-09)\n\n- select round(sysdate, 'year') from dual;->(01-1月-10)\n\n- select round(to_date('1-7月 -09'), 'year') from dual;->(01-1月-10)\n\n- select round(to_date('25-6月 -09'), 'year') from dual;->(01-9月-09)\n\n- select trunc(sysdate, 'month') from dual;->(01-8月-09)\n\n- select trunc(sysdate, 'year') from dual;->(01-1月-09)\n\n- select next_day(sysdate, '星期二') from dual;->(11-8月-09)\n\n- select next_day(next_day(sysdate, '星期二'), '星期二') from dual;->(18-8月-09)\n\n\n# 转换函数\n\n* 数据类型转换包括隐含转换和显式转换两方式,建议使用显式的数据类型转换,确保SQL语句的可靠性\n\n* 字符类型 ->数值类型 -> to_number()\n\n* 字符类型 ->日期类型 -> to_date()\n\n* 数值类型 ->字符类型 -> to_char()\n\n* 日期类型 ->字符类型 -> to_char()\n\n\n# 日期 *->* *字符串*\n\n* to_char()函数可以将日期型数值转换为字符串形式\n\n* 格式:\n\n- to_char(date) // 缺省转换为'dd-mm-yy'格式\n\n- to_char(date, 'format_model') // 转换为模式串指定的格式\n\n* 例:\n\n- select empno, ename, sal, to_char(hiredate, 'yyyy-mm-dd') from emp;\n\n- select to_char(sysdate, 'yyyy-mm-dd hh:mi:ss') from dual;\n\n- select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') from dual;\n\n\n# 常用日期格式符\n\n* 格式符 说明 举列\n\n- yyyy 年份 2008\n\n- mm 用数字显示月份 02\n\n- dd 在当月中是第几天 28\n\n- day 星期几 星期五\n\n- am/pm 显示上午/下午 上午\n\n- hh/hh12/hh24 小时 2:30 14:30\n\n- mi 分钟 30\n\n- ss 秒钟 46\n\n* 说明:除上述格式符外,日期模式串中还可直接出现如下字符( - : ; / );\n\n* 如要显示其它文本字符串则需使用双引号括起来;也可在械串的开头使用\"fm\"标\n\n* 记以去掉数字前面的零\n\n* 例:\n\n- select to_char(sysdate, 'yyyy\"年\"mm\"月\"dd\"日\" day hh24:mi:ss') from dual;\n\n- select to_char(sysdate, 'fmyyyy\"年\"mm\"月\"dd\"日\" day hh24:mi:ss') from dual;\n\n\n# 字符串 *->* *日期*\n\n* to_date()函数可以将字符串转换为日期型数值形式\n\n* 格式:\n\n- to_date(char) // 按缺省格式'dd-mm-yy'进行解析\n\n- to_date(char, 'format_model') // 按模式串指定的格式进行解析\n\n* 例:\n\n- insert into t5 values('BOBO', to_date('2008-02-28', 'yyyy-mm-dd'));\n\n- select to_date(to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') from dual;\n\n- select to_char(to_date(to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'), 'dd/mm/yyyy') from dual;\n\n\n# 数字\n\n* to_char()函数可以将数字值转换为字符串形式\n\n* 格式:\n\n- to_char(number)\n\n- to_char(number, 'format_model')\n\n* 例:\n\n- select to_char(12345.678901) from dual;\n\n- select to_char(12345.678901, '$99,999.0000') from dual;\n\n* 数字模式符:\n\n* 格式符 说 明\n\n- 9 代表一位数字\n\n- 0 代表一位数字,强制显示0\n\n- $ 放置一个美圆符$\n\n- L 放置一个本地货币符\n\n- . 小数点\n\n- , 千位指示符\n\n* 例:\n\n- select to_char(12345.6, 'L999,999.0000') from dual;\n\n\n# 字符串 *->* *数字*\n\n* to_number()函数可以将字符串转换为数字值形式\n\n* 格式:\n\n- to_number(char)\n\n- to_number(char, 'format_model')\n\n* 例:\n\n- select to_number('12345.678901') from dual;\n\n- select to_number('$12,345.6789', '$99,999.0000') from dual;\n\n2）如果数字在格式范围内的话，就是正确的，否则就是错误的；如：\n\n$12345.678小数点位数必须小于等于后面规定的格式\nselect to_number('$12345.678', '$999999.99') from dual;  X\nselect to_number('$12345.678', '$999999.999') from dual; √\nselect to_number('$12345.67', '$999999.999') from dual;  √\n\n\n1\n2\n3\n4\n\n\n\n# 通用函数\n\n* 通用函数适用于任何类型数据(包括空值):\n\n- nvl()\n\n- nvl2()\n\n- nullif()\n\n- coalesce()\n\n- case表达式\n\n- decode()\n\n\n# NVL()*函数*\n\n* NVL()函数用于将空值null替换为指定的缺省值,适用于字符,数字,日期等类型数据\n\n* 语法格式:\n\n- NVL(exp1, exp2)\n\n* 说明:\n\n- 如果表达式exp1的值为null,则返回exp2的值,否则返回exp1的值\n\n* 用法举例:\n\n- select empno, ename, sal, comm, sal+nvl(comm, 0) from emp;\n\n- select empno, ename, hiredate, nvl(hiredate, sysdate) from emp;\n\n- select empno, ename, job, nvl(job, 'NO job yet') from emp;\n\n\n# NVL2()*函数*\n\n* NVL2()函数用于实现条件表达式功能\n\n* 语法格式:\n\n- NVL2(exp1, exp2, exp3)\n\n* 说明:\n\n- 如果表达式exp1的值不为null,则返回exp2的值,否则返回exp3的值\n\n* 用法举例:\n\n- select empno, ename, sal, comm, nvl2(comm, sal+comm, sal) from emp;\n\n\n# NULLIF()*函数*\n\n* NULLIF()函数用于数据等价性比较并根据比较结果返回null或其中一个被比较的数值\n\n* 语法格式:\n\n- NULLIF(exp1, exp2)\n\n* 说明:\n\n- 如果表达式exp1与exp2的值相等返回null,否则返回exp1的值\n\n* 用法举例:\n\n- select name 原名, nullif(pen_name, name)化名 from author;\n\n\n# COALESCE()*函数*\n\n* COALESCE()函数用于实现数据\"接合\"功能\n\n* 语法格式:\n\n- COALESCE(exp1, exp2, ...)\n\n* 说明:\n\n- 依次考察各参数表达式,遇到非null值即停止并返回该值\n\n* 用法举例:\n\n- select empno, ename, sal, comm, coalesce(sal+comm, sal, 0) 总收入 from emp;\n\n\n# CASE()*函数*\n\n* CASE()表达式用于实现多路分支结构\n\n* 语法格式:\n\n- CASE exp1 when comparison_exp1 then return_exp1\n\n- [when comparison_exp2 then return_exp2\n\n- when comparison_expn then return_expn\n\n- else esle_exp]\n\n- end [TempName]\n\n* 说明:\n\n- 如果 exp1是 comparison_exp1的时候,就返回return_exp1\n\n- [ comparison_exp2 的时候,就返回return_exp2\n\n- comparison_expn 的时候,就返回return_expn\n\n- else 就返回 esle_exp ]\n\n- end [别名]\n\n* 用法举例:\n\n- select empno, ename, sal,\n\n\\-     case deptno when 10 then '财务部'\n\n\\-           when 20 then '研发部'\n\n\\-           when 30 then '销售部'\n\n\\-           else '未知部门'\n\n\\-     end 部门\n\n\\- from emp;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n通配符：\n\nselect \nJOB_ID,\n  case  when JOB_ID like '%AD%' then 'AD'\n    when JOB_ID like 'IT_PROG' then 'IT'\n    when JOB_ID like '%FI%' then 'FI' \n    else 'No'\n  end 部门简称\nfrom employees\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# case高阶用法：\n\n--case语句的种类:\n1.简单case语句\n语法:\n   case exp when comexp then returnvalue\n            ...\n            when comexp then returnvalue\n            else returnvalue\n    end\n      \n  case到end之间相当于一个具体的值，可以做运算，取别名，嵌套case 等等。\n  只要把case到end当作一个运算结果的表达式就可以了。\n\n举例:\n   select cust_last_name,\n          case credit_limit when 100 then 'low'\n                            when 5000 then 'high'\n                            else 'medium'\n          end\n     from customers;\n     \n2.搜索case语句\n语法:\n    case when boolean then return value\n         ...\n         when boolean then return value\n         else retur nvalue\n     end\n     \n举例:\nselect case when id between 1 and 10 then 'low'\n            when id between 20 and 30 then 'mid'\n            when id between 40 and 50 then 'high'\n            else 'unknow'\n       end\nfrom product;\n\n--简单case和搜索case之间的区别：\n1. 简单case只能是when后面的表达式完全匹配case后的表达式，相当于 =，所以也不能匹配null。\n2. searched case可以作为比较条件，那么可以使用like、!=、between ..and、<、=、is null、is not null等，比简单case的使用更加广泛，完全可以替代简单case。\n\n--注意事项:\n1.case 表达式返回的是一个确定的value，若前面的都不匹配，则返回else中的项.\n2.简单case 中的表达式，when 后面的表达式类型应该全部保持一致.\n3.所有的then 后面的return_value类型要保持一致.\n4.对于简单case 表达式，也就是case 表达式 when…那么when null 总是取不到。也就是case 后面的表达式如果值为null，不会与when null 匹配，只会与else匹配.\n5.对于searched case来说，有自动类型转换，只要条件成立就可以。\n如:select case when 1='1' then 1 end from dual; 其中1='1'条件成立\n\n值得一提的是: sql中的case语句与pl/sql中的case语句的不同之处:\n前者的else不是必须的，如果没有匹配就返回null;后者的else不写，则报case_not_found异常.\n\n--case中嵌套子查询\nCase语句中可以使用子查询，但是必须返回一行，不可以是多行.\n如：\nselect case (select count(*) as s1 from t1 where a = 1)\n           when (select count(*) as s2 from t1, t2 where t1.a = t2.a and t2.a = 1) then '相等'\n           else '不相等'\n       end\n  from dual;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# DECODE()*函数*\n\n* 和CASE()表达式类似,DECODE()函数也用于实现多路分支结构\n\n* 语法格式:\n\n- decode(col|expression, search1, result1\n\n- [, search2, result2, ...,]\n\n- [, default])\n\n* 说明:\n\n- 如果 col|expression是 search1的时候,就返回result1\n\n- [ search2 的时候,就返回result2, ...]\n\n- [, default])\n\n- [别名]\n\n* 用法举例:\n\n- select empno, ename, sal,\n\n- decode(deptno, 10, '财务部',\n\n- 20, '研发部',\n\n- 30, '销售部',\n\n- '未知部门')\n\n- 部门\n\n- from emp;\n\n\n# 函数嵌套\n\n* 单行孙数可以嵌套使用,嵌套层次无限制\n\n* 嵌套函数的执行顺序是由内到外\n\n- select empno, lpad(initcap(trim(ename)), 10, '*') name, job, sal from emp;\n\n##########[ 单行函数小结 ]##########\n\n* 使用系统提供的单行函数可实现如下功能:\n\n- 对数据进行计算\n\n- 控制数据的输出格式\n\n- 设置/改变日期的显示格式\n\n- 进行数据类型转换\n\n- 使用NVL函数处理空值\n\n- 实现IF-THEN-ELSE多路分支逻辑\n\n\n# 分组函数\n\n* 分组函数对一组数据进行运算,针对一组数据(多行记录)只返回一个结果,也称多行函数\n\n* 常用分组函数\n\n- 函数 功能说明 适用类型\n\n- avg() 计算平均值 数值型\n\n- count() 返回查询所行到的记录行数 任何类型数据\n\n- max() 计算最大值 任何类型数据\n\n- min() 计算最小值 任何类型数据\n\n- sun() 求和 数值型\n\n> 1.上述函数除了count(*)会处理null，其他都会忽略null，可用nvl函数处理\n> \n> 2.备注:MIN,MAX可用于任何数据类型，便AVG， SUM，STDDEV,VARIANCE仅适用于数值型字段。\n\n* 举例:\n\n- select avg(sal), max(sal), min(sal), sum(sal) from emp;\n\n- select max(hiredate), min(hiredate) from emp;\n\n\n# COUNT()*函数*\n\n* count(*) 返回组中总记录数目包括空行\n\n* count(exp) 返回表达式exp值非空的记录数目\n\n* count(distinct(exp)) 返回表达式exp值不重复的,非空的记录数目\n\n* 举例:\n\n- select count(*) from emp; ==== select count(*1) from emp;\n\n- select count(comm) from emp;\n\n- select count(distinct(deptno)) from emp;\n\n select count(distinct(deptno)) from emp;\n 不用distinct，使用group by改为：\n select count(deptno) from (select deptno from emp group by deptno)\n\n\n1\n2\n3\n\n\n\n# 分组函数与空值\n\n* 分组函数省略列中的空值\n\n- select avg(comm) from emp;\n\n- select sum(comm) from emp;\n\n* 可使用NVL()函数强制分组函数处理空值\n\n- select avg(nvl(comm, 0)) from emp;\n\n\n# GROUP BY*子句*\n\n* GROUP BY 子句将表中数据分成若干小组\n\n* 语法格式\n\n- select column, group_function(column)\n\n- from table\n\n- [where condition]\n\n- [group by group_by_expression]\n\n- [order by column]\n\n* 例:\n\n- select deptno, avg(sal) from emp group by deptno;\n\n- select deptno, avg(sal) from emp where deptno > 10 group by deptno;\n\n- select deptno, avg(sal) from emp group by deptno order by deptno desc;\n\n* 说明:\n\n> - 出现在SELECT列表中的字段,如果不是包含在组函数中,那么该字段必须同时在GROUP BY 子句中出现\n> \n> - 包含在 GROUP BY子句中的字段则不必须出现在 SELECT列表中\n> \n> - 可使用 where子句限定查询条件\n> \n> - 可使用 order by子句指定排序方式\n\n* 注意:\n\n- 执行顺序: where -> group by -> select ... from ... -> order by..\n\n##########[ 基于多字段分组 ]##########\n\n- select deptno, job, avg(sal) from emp group by deptno, job;\n\n##########[ 组函数的错误用法 ]##########\n\n* 如果没有 GROUP BY子句, SELECT列表中不允许出现字段(单行函数)与分组函数混用的情况\n\n- select empno, sal from emp; -> (Y)\n\n- select avg(sal) from emp; -> (Y)\n\n- select empno, initcap(ename), avg(sal) from emp; -> (N)\n\n* 不允许在 WHERE子句中使用分组函数\n\n- select deptno, avg(sal)\n\n- from emp\n\n- where avg(sal) > 2000; -> (N)\n\n- group by deptno;\n\n- 注:这跟子句运行顺序有关,\n\n- where 最先执行,\n\n- 在执行 where子句时,\n\n- 还没有执行 group by子句,\n\n- 还不知道什么分组,\n\n- 也没计算过 avg(sal)组内的平均工资\n\n\n# HAVING *子句*\n\n* HAVING 子句用于过滤分组\n\n* 语法格式\n\n- select column, group_function(column)\n\n- from table\n\n- [where condition]\n\n- [group by group_by_expression]\n\n- [order by column];\n\n* 例:\n\n- select deptno, job, avg(sal)\n\n- from emp\n\n- where hiredate >= to_date('1981-05-01', 'yyyy-mm-dd')\n\n- group by deptno, job\n\n- having avg(sal) > 1200\n\n- order by deptno, job;\n\n##########[ 分组函数嵌套 ]##########\n\n* 分组函数最多可嵌套两层\n\n- select max(avg(sal))\n\n- from emp\n\n- group by deptno;\n\n\n# Oracle 表连接\n\n* SQL/Oracle 使用表连接从多个表中查询数据\n\n* 语法格式:\n\n- select 字段列表\n\n- from table1, table2\n\n- where table1.column1 = table2.column2\n\n* 说明:\n\n- 在 where子句中指定连接条件\n\n- 当被连接的多个表中存在同名字段时,必须在该字段前加上\"表名.\"作为前缀\n\n* 例:\n\n- select empno, ename, job, emp.deptno, dname\n\n- from emp, dept\n\n- where emp.deptno = dept.deptno;\n\n* 提示:加上前缀可以提高效率\n\n##########[ 连接的类型 ]##########\n\n* Oracle8i之前的表连接\n\n- 等值连接(Equijoin)\n\n- 非等值连接(Non-Equijoin)\n\n- 外连接(Outer join)\n\n- 左外连接\n\n- 右外连接\n\n- 自连接(Selfjoin)\n\n* Oracle9i新引入的连接形式(支持SQL99规范):\n\n- 交叉连接(Cross join)\n\n- 自然连接(Natural join)\n\n- 使用 Using子句建立连接\n\n- 使用 On子句建立连接\n\n- 外连接(Outer join)\n\n- 左外连接\n\n- 右外连接\n\n- 全外连接\n\n##########[ 多表连接 ]##########\n\n* 多表连接中:\n\n- 可使用 AND操作符增加查询条件\n\n- 使用表别名可以简化查询\n\n- 使用表名(表别名)前缀可提高查询效率\n\n- 为了连接 n个表,至少需要 n-1个连接条件\n\n##########[ 等值连接(Equijion) ]##########\n\n* 什么是等值连接\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp, dept\n\n- where emp.deptno = dept.deptno;\n\n##########[ 非等值连接(Not-Equijion) ]##########\n\n* 问题:如何查得每个员工的工资等级\n\n* 方法1:\n\n- select empno, ename, sal, grade, losal, hisal\n\n- from emp, salgrade\n\n- where sal >= losal and sal <= hisal;\n\n* 方法2:\n\n- select empno, ename, sal, grade, losal, hisal\n\n- from emp, salgrade\n\n- where sal between losal and hisal;\n\n##########[ 外连接(Outer jion) ]##########\n\n* 使用外连接可以看到参与连接的某一方不满足连接条件的记录\n\n* 外连接运算符为(+)\n\n* 传统的外连接分为左外连接和右外边接两种\n\n* 语法格式:\n\n- select 字段列表\n\n- from table1, table2\n\n- where table1.column1(+)=table2.column2;\n\n- select 字段列表\n\n- from table1, table2\n\n- where table1.column1=table2.column2(+);\n\n* 例:\n\n* 左外连接'(+)'放在右边,将左表中不符合条件的也显示出来\n\n- select EMPLOYEE_ID, FIRST_NAME, SALARY, e.DEPARTMENT_ID, DEPARTMENT_NAME\n\n- from employees e, departments d\n\n- where e.DEPARTMENT_ID = d.DEPARTMENT_ID(+)\n\n- order by EMPLOYEE_ID;\n\n* 右外连接'(+)'放在左边,将右表中不符合条件的也显示出来\n\n- select EMPLOYEE_ID, FIRST_NAME, SALARY, e.DEPARTMENT_ID, DEPARTMENT_NAME\n\n- from employees e, departments d\n\n- where e.DEPARTMENT_ID(+) = d.DEPARTMENT_ID\n\n- order by EMPLOYEE_ID;\n\n##########[ 自连接(Self jion) ]##########\n\n* 问题:如何查得每个员工及其上司的工号和姓名\n\n- select a.empno, a.ename, a.mgr, b.ename\n\n- from emp a, emp b\n\n- where a.mgr = b.empno\n\n- order by a.empno;\n\n##########[ SQL99 连接语法 ]##########\n\n* SQL1999 规范中规定的连接查询语法\n\n- select 字段列表\n\n- from table1\n\n- [cross join table2] |\n\n- [natural join table2] |\n\n- [join table2 using(字段名)] |\n\n- [join table2 on(table.column_name = table2.column_name)] |\n\n- [(left | right | full outer) join table2\n\n- on(table1.column_name = table2.column_name)];\n\n##########[ 交叉连接(Cross join) ]##########\n\n\n# 交叉连接(Cross join)\n\n* Cross join产生了一个笛卡尔集,其效果等同于在两个表进行连接时未使用WHERE 子句阴定连接条件\n\n* 举例:\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp cross join dept;\n\n##########[ 自然连接(Natural join) ]##########\n\n\n# Natural join自然连接\n\n* Natural join 基于两个表中的全部同名列建立连接\n\n- 从两个表中选出同名列的值均对应相等的所有行\n\n- 如果两个表中同名列的数据类型不同,则出错\n\n- 不允许在参照列上使用表名或者别名作为前缀\n\n* 举例:\n\n- select empno, ename, sal, deptno, dname\n\n- from emp natural join dept;\n\n- 上面SQL语句等同于:\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp, dept\n\n- where emp.deptno = dept.deptno;\n\n* 注意:第一种方法的deptno不能加上表名前缀,第二种方法必须加上表名前缀\n\n\n# Using *子句*\n\n* 如果不希望参照被连接表的所有同名列进行等值连接,自然连接将无法满足\n\n* 要求,可以在连接时使用Using子句来设置用于等值连接的列(参照列)名.\n\n* 举例:\n\n- select empno, ename, sal, deptno, dname\n\n- from emp join dept\n\n- using(deptno);\n\n* 不允许在参照列上使用表名或者别名作为前缀\n\n\n# On *子句*\n\n* 如果要参照非同名的列进行等值连接,或想设置任意的连接条件,可以使用ON 子句\n\n* 举例:\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp join dept\n\n- on(emp.deptno = dept.deptno);\n\n* 必须加上表名前缀(emp.deptno)\n\n- 上面SQL语句等同于:\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp, dept\n\n- where emp.deptno = dept.deptno;\n\n--------------------------------------------------\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp join dept\n\n- on(emp.deptno = dept.deptno and sal > 2500);\n\n- 上面SQL语句等同于:\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp, dept\n\n- where emp.deptno = dept.deptno and sal > 2500;\n\n多表连接\n\n* 使用SQL99连接语法,两个以上的表进行连接时应依次/分别指定相临的两个表之间的连接条件\n\n* 语法格式:\n\n- select 字段列表\n\n- from table1\n\n- [cross join table2] |\n\n- [natural join table2] |\n\n- [join table2 using(字段名)] |\n\n- [join table2 on(table1.column_name=table2.column_name)] |\n\n- [(left | right | full outer) join table2\n\n- on(table1.column_name=table2.column_name)]\n\n- [cross join table3] |\n\n- [natural join table3] |\n\n- [join table3 using(字段名)] |\n\n- [join table3 on(table2.colimn_name=table3.column_name)] |\n\n- [(left | right | full outer) join table3\n\n- on(table2.column_name=table3.column_name)];\n\n* 举例:\n\n- SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID, CITY\n\n- FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) NATURAL JOIN LOCATIONS;\n\n- 上面SQL语句等同于:\n\n- SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID, CITY\n\n- FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) JOIN LOCATIONS USING(LOCATION_ID);\n\n- 等同于:\n\n- SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, emp.DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID, CITY\n\n- FROM EMPLOYEES emp JOIN DEPARTMENTS dep ON(emp.DEPARTMENT_ID = dep.DEPARTMENT_ID)\n\n- JOIN LOCATIONS loc USING(LOCATION_ID);\n\n- 等同于:\n\n- SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, emp.DEPARTMENT_ID, DEPARTMENT_NAME, dep.LOCATION_ID, CITY\n\n- FROM EMPLOYEES emp JOIN DEPARTMENTS dep ON(emp.DEPARTMENT_ID = dep.DEPARTMENT_ID)\n\n- JOIN LOCATIONS loc ON(dep.LOCATION_ID = loc.LOCATION_ID);\n\n\n# 内连接和外连接\n\n* 内连接(Inner Join)\n\n- 在 SQL99规范中,内连接只返回满足连接条件的数据\n\n* 外连接(Outer Join)\n\n- 左外联接(Left Outer Join)\n\n- 两个表在连接过程中除返回满足连接条件的行以外,还返回左表中不满足条件的行,这种连接称为左外联接\n\n- 右外联接(Right Outer Join)\n\n- 两个表在连接过程中除返回满足连接条件的行以外,还返回右表中不满足条件的行,这种连接称为右外联接\n\n- 满外联接(Full Outer Join)\n\n- Oracle9i 开始新增功能,两个表在连接过程中除返回满足连接条件的行以外,还返回两个表中不满足条件的所有行,这种连接称为满外联接\n\n* 举例:\n\n* 不满足条件的不返回(内连接(Inner Join))\n\n- SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME\n\n- FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID);\n\n* 左表中不满足条件也返回(左外联接(Left Outer Join))\n\n- SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME\n\n- FROM EMPLOYEES LEFT JOIN DEPARTMENTS USING(DEPARTMENT_ID);\n\n* 右表中不满足条件也返回(右外联接(Right Outer Join))\n\n- SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME\n\n- FROM EMPLOYEES RIGHT JOIN DEPARTMENTS USING(DEPARTMENT_ID);\n\n* 将满足条件的和左表中不满足条件的还有右表中不满足条件的,都返回(满外联接(Full Outer Join))\n\n- SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME\n\n- FROM EMPLOYEES FULL OUTER JOIN DEPARTMENTS USING(DEPARTMENT_ID);\n\n\n# 子查询*(Sub Query)*\n\n* 问题引入\n\n- 如何查得所有比'张三'工资高的员工的信息\n\n* 子查询\n\n- 子查询在主查询前执行一次\n\n- 主查询使用子查询的结果\n\n- 语法格式:\n\n- select 字段列表\n\n- from table\n\n- where 表达式 operator(select字段列表 from table);\n\n* 举例:\n\n- select * from emp where sal > (select sal from emp where empno = 7654);\n\n##########[ 使用子查询注意事项 ]##########\n\n* 在查询是基于未知值时应考虑使用子查询\n\n* 子查询必须包含在括号内\n\n* 建议将子查询放在比较运算符的右侧,以增强可读性\n\n* 除非进行 Top-N分析,否则不要在子查询中使用ORDER BY 子句\n\n* 对单行子查询使用单行运算符\n\n* 对多行子查询使用多行运算符\n\n##########[ 单行子查询 ]##########\n\n* 单行子查询只返回一行记录\n\n* 对单行子查询可使用单行记录比较运算符\n\n- 运算符 含义\n\n- = 等于\n\n- > 大于\n\n- >= 大于等于\n\n- < 小于\n\n- <= 小于等于\n\n- <> 不等于\n\n* 举例:\n\n- select * from emp\n\n- where sal > (select sal from emp where empno = 7566);\n\n##########[ 子查询空值/多值问题]##########\n\n* 如果子查询未返回任何行,则主查询也不会返回任何结果\n\n- select * from emp\n\n- where sal > (select sal from emp where empno = 8888);\n\n* 如果子查询返回单行结果,则为单行子查询,可以在主查询中对其使用相应的单行记录比较运算符\n\n- select * from emp\n\n- where sal > (select sal from emp where empno = 7566);\n\n* 如果子查询返回多行结果,则为多行子查询,此时不允许对其使用单行记录比较运算符\n\n- select * from emp\n\n- where sal > (select avg(sal) from emp group by deptno); -> (N)\n\n- SELECT EMPLOYEE_ID, LAST_NAME, SALARY FROM EMPLOYEES\n\n- WHERE JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE LAST_NAME = 'Grant'); -> (Y)\n\n##########[ 多行子查询 ]##########\n\n* 多行子查询返回多行记录\n\n* 对多行子查询只能使用多行记录比较运算符\n\n* 运算符 含义\n\n- IN 等于列表中的任何一个\n\n- ANY 和子查询返回的任意一个值比较\n\n- ALL 和子查询返回的所有值比较\n\n* 举例:\n\n- select * from emp where sal > any(select avg(sal) from emp group by deptno);\n\n- select * from emp where sal > all(select avg(sal) from emp group by deptno);\n\n- select * from emp where job in(select job from emp where ename = 'MARTIN' or ename = 'SMITH');\n\n##########[ TopN查询 ]##########\n\n* 在 ORACLE中通常用子查询的方式来实现 TOP N查询\n\n* 语法格式:\n\n- select 字段列表\n\n- from (select 字段列表 from table order by排序字段)\n\n- where rownum <= n;\n\n* 例:\n\n- select * from (select * from emp order by sal desc) where rownum <= 5;\n\n- select * from (select rownum myno, a.* from (select * from emp order by sal desc) a)\n\n- where myno >= 5 and myno <= 10;\n\n\n# 注意：子查询配合表连接使用，子查询不能和left连接使用\n\n\n# Oracle三范式\n\n第一范式：（1NF）无重复的列\n第二范式：（2NF）属性完全依赖于主键\n第三范式：（3NF）属性不依赖于其它非主属性\n\n\n1\n2\n3\n\n\n\n# Oracle项目不推荐使用\n\n> distinct ：推荐使用group by\n> \n> 子查询：使用多表查询\n> \n> （+） ：使用left/right\n\n\n# Oracle DML（增删改）\n\n\n# 1.添加\n\n> 从一个表中某行数据添加到另一个表中\n\ninsert into departments0713(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)\nselect DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID from departments where DEPARTMENT_ID in (20,30)\n\n\n1\n2\n\n\n\n# Oracle事务\n\n> 在Commit或者Rollback前后数据的状态: 1、在数据已经被更改，但没有Commit前，被更改记录处于被锁定状态，其他用户无法进行更改; 2、在数据已经被更改，但没有Commit前，只有当前Session的用户可以看到这种变更，其他Session的用户看不到数据的变化。 3、在数据已经被更改，并且被Commit后，被更改记录自动解锁，其他用户可以进行更改;| 4、在数据已经被更改，并且被Commit后，其他Session的用户再次访问这些数据时，看到的是变化后的数据。\n\n当有用户修改数据时，Oracle先把那部分原始数据备份到回滚段，在Commit之前，其他Session用户读到的这部分数据是回滚段上的;在提交之后，回滚段被释放。\n\n查询某个表是否有锁\n\nselect a.*, C.type, C.LMODE\n from v$locked_object a, all_objects b, v$lock c\nwhere a.OBJECT_ID = b.OBJECT_ID\n and a.SESSION_ID = c.SID\n and b.OBJECT_NAME = 'TESTTAB3'\n\n\n1\n2\n3\n4\n5\n\n\n查询某个表是否整在被锁\n\n select * from testtab3 for update nowait;\n\n\n1\n\n\n\n# 三.Oracle对象-表\n\n\n# 1.对表的操作\n\n> 表的命名要求和表中列的命名要求：\n> \n> 1、必须以字母开头\n> \n> 2、长度不能超过30个字符\n> \n> 3、只能包含 A–Z, a–z, 0–9, _, $, and #\n> \n> 4、不能与数据库中的已有对象重名\n> \n> 5、不能使用Oracle 数据库的保留字\n\n\n# 建表语句：\n\nCREATE TABLE [schema.]table\n (column datatype [DEFAULT expr][, ...]);\n\n\n1\n2\n\n\n常用的字段数据类型：\n\n\n\n\n# 复制表：\n\n复制表和数据\nCREATE TABLEA table as select * from tableb\n复制表结构\nCREATE TABLEA table as select * from tableb where 1=2\n\n\n1\n2\n3\n4\n\n\n\n# 删除表\n\n注意：表被删 除后，任何依赖于这张表的视图、Package等数据库对象都自动变为无效：\n\nDROP TABLE tableName;  --删除表与数据\nTRUNCATE TABLE tableName; ——清空表数据 但保留表结构：\ndelete from tableName;    ——清空表数据\n\n\n1\n2\n3\n\n\n> 注意TRUNCATE 与DELETE FROM table 的区别： 1）没有Rollback机会 2）HWM标记复位\n> \n> 补充：HWM标记复位是什么？\n> \n> > 所有的oracle段都有一个在段内容纳数据的上限，我们把这个上限称为\"high water mark\"或HWM。这个HWM是一个标记，用来说明已经有多少没有使用的数据块分配给这个segment。HWM通常增长的幅度为一次5个数据块，原则上HWM只会增大，不会缩小，即使将表中的数据全部删除，HWM还是为原值，由于这个特点，使HWM很象一个水库的历史最高水位，这也就是HWM的原始含义，当然不能说一个水库没水了，就说该水库的历史最高水位为0。但是如果我们在表上使用了truncate命令，则该表的HWM会被重新置为0。\n\n\n# 更改表名\n\nRENAME oldtablename to newtableName;\n\n\n1\n\n\n\n# 2.对列的操作：\n\n添加列：\nALTER TABLE table\nADD (column datatype [DEFAULT expr]\n [, column datatype]...);\n更改列：\nALTER TABLE table\nMODIFY (column datatype [DEFAULT expr]\n [, column datatype]...);\n删除列：\nALTER TABLE table\nDROP (column)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3.约束\n\n> 常用的约束有如下几种：\n> NOT NULL （非空约束）\n> UNIQUE （唯一性约束）\n> PRIMARY KEY （主键约束）  :尽量别用\n> FOREIGN KEY （外键约束）\n> CHECK （自定义约束）：\n> \tcheck的使用：salary必须大于0\n>     .., salary NUMBER(2)\n>     CONSTRAINT emp_salary_min \n>     CHECK (salary > 0),.\n> \n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\n\n# 3.1.添加约束\n\n建表的时候添加约束：\n\nCREATE TABLE employees(\n employee_id NUMBER(6),\n first_name VARCHAR2(20),\n ...\n job_id VARCHAR2(10) NOT NULL,\n CONSTRAINT emp_emp_id_pk\n PRIMARY KEY (EMPLOYEE_ID));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n单独创建约束语法：\n\nALTER TABLE CUX_LES_JE_LINES ADD CONSTRAINT CUX_LES_JE_LINES_PK \n PRIMARY KEY(JE_LINE_ID);\n\n\n1\n2\n\n\n\n# 3.2.删除约束\n\nALTER TABLE departments\nDROP PRIMARY KEY CASCADE;\n\n\n1\n2\n\n\n\n# 3.3.约束失效\n\nALTER TABLE employees\nENABLE CONSTRAINTemp_emp_id_pk;\n\n\n1\n2\n\n\n\n# 3.4.查看某个表有哪些约束\n\nSELECT constraint_name, constraint_type,\nsearch_condition\nFROM user_constraints\nWHERE table_name = 'EMPLOYEES'\n\n\n1\n2\n3\n4\n\n\n\n# 4.试图\n\n\n# 4.1.创建视图\n\nCREATE VIEW empvu80\nAS SELECT employee_id, last_name, salary\n FROM employees\n WHERE department_id = 80;\n\n\n1\n2\n3\n4\n\n\n\n# 4.2.删除试图\n\nDROP VIEW empvu80\n\n\n1\n\n\n\n# 4.3.TOP-N 查询：查询某个表前N行数据，并显示行号\n\nSELECT [column_list], ROWNUM \nFROM (SELECT [column_list] \n FROM table\n ORDER BY Top-N_column)\nWHERE ROWNUM <= N;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.4.视图可以修改吗？\n\n> update的情况，必须是一下情况\n> \n> \\1. view的字段只涉及一个表。 \\2. 如果涉及多个表的话，被(涉及到的)view列所映射table列(或列的组合)必须是有主健约束的\\3. 强制执行，方法是加上hint /*+ BYPASS_UJVC */\n\n\n# 5.序列（类似mysql中的自增主键）\n\n注意：是不存在与某一个表，保存在内存中，通过sequence.NEXTVAL获取下一个，sequence.CURRVAL 获取上一个\n\n> 有的时候我们定义某一张表中某一列为主键，当我们往表中插入数据的时候，对于主键字段的赋值要求唯一性， 我们希望能有个自增长类型的数据库对象，我们每获取一次，它自动增长，保证下次获取时肯定是不一样的值， 这样我们就方便了，Oracle 数据库提供“序列”这种对象来满足我们的要求。\n\n\n# 5.1.创建序列\n\nCREATE SEQUENCE sequence\n [INCREMENT BY n]  //自增阶梯  默认1\n [START WITH n]   //从多少开始\n [{MAXVALUE n | NOMAXVALUE}] //最大值\n [{MINVALUE n | NOMINVALUE}] //最小值\n [{CYCLE | NOCYCLE}]\n [{CACHE n | NOCACHE}];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n>  1. INCREMENT BY用于定义序列的步长，如果省略，则默认为1，如果出现负值，则代表Oracle序列的值是按照此步长递减的。\n> \n>  2. START WITH 定义序列的初始值(即产生的第一个值)，默认为1。\n> \n>  3. MAXVALUE 定义序列生成器能产生的最大值。选项NOMAXVALUE是默认选项，代表没有最大值定义，这时对于递增Oracle序列，系统能够产生的最大值是10的27次方;对于递减序列，最大值是-1。\n> \n>  4. MINVALUE定义序列生成器能产生的最小值。选项NOMAXVALUE是默认选项，代表没有最小值定义，这时对于递减序列，系统能够产生的最小值是?10的26次方;对于递增序列，最小值是1。\n> \n>  5. CYCLE和NOCYCLE 表示当序列生成器的值达到限制值后是否循环。CYCLE代表循环，NOCYCLE代表不循环。如果循环，则当递增序列达到最大值时，循环到最小值;对于递减序列达到最小值时，循环到最大值。如果不循环，达到限制值后，继续产生新值就会发生错误。\n> \n>  6. CACHE(缓冲)定义存放序列的内存块的大小，默认为20。NOCACHE表示不对序列进行内存缓冲。对序列进行内存缓冲，可以改善序列的性能。\n> \n> 大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。Oracle序列允许将序列提前生成 cache x个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数也不能设置太大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入cache x个。这种情况也能会在数据库关闭时也会导致序号不连续。\n> \n>  7. NEXTVAL 返回序列中下一个有效的值，任何用户都可以引用。\n> \n>  8. CURRVAL 中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。\n\n\n# 5.2.使用序列\n\nINSERT INTO departments(department_id, \n department_name, location_id)\nVALUES (dept_deptid_seq.NEXTVAL, \n 'Support', 2500);\nSELECT dept_deptid_seq.CURRVAL\nFROM dual;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3.更改序列\n\nALTER SEQUENCE dept_deptid_seq\n INCREMENT BY 20\n MAXVALUE 999999\n NOCACHE NOCYCLE;\n\n\n1\n2\n3\n4\n\n\n\n# 5.4.删除序列\n\nDROP SEQUENCE dept_deptid_seq\n\n\n1\n\n\n\n# 6.索引\n\n\n# 6.1.oracle中索引的区别：\n\n逻辑上：\nSingle column 单行索引\nConcatenated 多行索引\nUnique 唯一索引\nNonUnique 非唯一索引\nFunction-based函数索引\nDomain 域索引\n \n物理上：\nPartitioned 分区索引\nNonPartitioned 非分区索引\nB-tree：\nNormal 正常型B树\nRever Key 反转型B树 \nBitmap 位图索引\n \n索引结构：\nB-tree：\n适合与大量的增、删、改（OLTP）；\n不能用包含OR操作符的查询；\n适合高基数的列（唯一值多）\n典型的树状结构；\n每个结点都是数据块；\n大多都是物理上一层、两层或三层不定，逻辑上三层；\n叶子块数据是排序的，从左向右递增；\n在分支块和根块中放的是索引的范围；\nBitmap:\n适合与决策支持系统；\n做UPDATE代价非常高；\n非常适合OR操作符的查询； \n基数比较少的时候才能建位图索引；\n \n树型结构：\n索引头 \n开始ROWID，结束ROWID（先列出索引的最大范围）\nBITMAP\n每一个BIT对应着一个ROWID，它的值是1还是0，如果是1，表示着BIT对应的ROWID有值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n1. b-tree索引\nOracle数据库中最常见的索引类型是b-tree索引，也就是B-树索引，以其同名的计算科学结构命名。CREATE \nINDEX语句时，默认就是在创建b-tree索引。没有特别规定可用于任何情况。\n2. 位图索引(bitmap index)\n位图索引特定于该列只有几个枚举值的情况，比如性别字段，标示字段比如只有0和1的情况。\n3. 基于函数的索引\n比如经常对某个字段做查询的时候是带函数操作的，那么此时建一个函数索引就有价值了。\n4. 分区索引和全局索引\n这2个是用于分区表的时候。前者是分区内索引，后者是全表索引\n5. 反向索引（REVERSE）\n这个索引不常见，但是特定情况特别有效，比如一个varchar(5)位字段(员工编号)含值\n（10001,10002,10033,10005,10016..）\n这种情况默认索引分布过于密集，不能利用好服务器的并行\n但是反向之后10001,20001,33001,50001,61001就有了一个很好的分布，能高效的利用好并行运算。\n6.HASH索引\nHASH索引可能是访问数据库中数据的最快方法，但它也有自身的缺点。集群键上不同值的数目必须在创建HASH集群之前就要知道。需要在创建HASH集群的时候指定这个值。使用HASH索引必须要使用HASH集群。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 6.2.创建索引\n\n--普通索引Normal\nCREATE INDEX emp_last_name_idx\nON employees(last_name);\n--唯一索引Unique\nCREATE INDEX emp_last_name_idx\nON employees(last_name);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 6.3.什么时候适合索引\n\n在什么样的情况下创建索引对加快查询有利呢：\n\n> 查询条件中使用到这个列（或者这个列于其他列的组合），且这个列（或者与其他列的组合）上的数字 范围跨度很大，而大多数情况下我们要获取的数据的量占整个表的数据总量 小于4%；\n\n在什么样的情况下不适合创建索引呢：\n\n> 被查询的表本身就很小，即是是全表扫描也非常快； 或者基于这张表的查询，大多数情况下需要获取 的数据量都超过了总量的4%；或者这张表需要频繁的被更新，建立索引的话会引起索引的频繁更新，从而反而 降低数据库的整体效率。\n\n\n# 6.4.索引函数\n\n当查询语句的Where条件中，对于某些列使用了函数表达式时，普通索引对查询没有帮助，如果想利用索引，则 必须创建函数索引，比如在下面的例子中，\n\nSELECT *\nFROM departments\nWHERE UPPER(department_name) = 'SALES'\n\n\n1\n2\n3\n\n\n对于上述查询语句，如果建立普通索引，比如Create index dp_idx2 on departments(department_name) 那么上述SQL执行的时候，Oracle是不会走索引的，需要建立函数索引：\n\nCREATE INDEX upper_dept_name_idx ON departments(UPPER(department_name))\n\n\n1\n\n\n\n# 7.同义词\n\n\n# 7.1.DB-LINK（不同数据库）\n\n> Database Link , 如果你需要在当前数据库中访问另一个数据库中表，最简单的方法是在当前数据库中创建一个 数据库连接指向另一个数据库，然后通过@数据库连接的后缀就可以访问另一个数据库中的表了。\n\n创建 DB-LINK，通过DB-LINK 访问另一数据库中的\n\nCREATE PUBLIC DATABASE LINK hq.acme.com \n\nUSING 'sales';\n\nSELECT * FROM emp@HQ.ACME.COM;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 7.2.同义词\n\n当同一个数据库的A用户要访问B用户的表，需要加上前端B.table\n\n当我们要通过DB-LINK访问另一个数据库中的某张表的时候我们需要加@后缀 @db-link-name\n\n> 为了在程序中能够简化写法，Oracle 提供同义词，也就是可以在A用户下建立一个同义词指向B用户下的 Table1, 以后访问的时候可以直接访问这个同义词，而不用加前缀了。\n\n\n# 7.2.创建同义词\n\nCREATE SYNONYM Table1 for B.Table1\n\n\n1\n\n\nA用户就可以通过同义词访问B的表：\n\nselect * from Table1\n\n\n1\n\n\n\n# 8.控制权限\n\n每个人登录Oracle数据库都是以某个特定的数据库用户登录的，用户能否创建表？ 该用户能否访问其他用户 下面的表。。等等这些事情都是可以利用Oracle的权限控制机制进行控制的。\n\n\n# 8.1.给某个用户赋予权限\n\nGRANT create session //会员权限\n , create table//表权限\n , create procedure //存储过程权限\n , create sequence//序列\n , create trigger\n , create view\n , create synonym \n , alter session\nTO HPOS;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 8.2.添加角色\n\nCREATE ROLE manager ;  --创建manager角色\nGRANT create table, create view to manager; --manager赋予创建表、视图权限\nGRANT manager to DEHAAN, KOCHHAR; --DEHAAN, KOCHHAR拥有manager的权限\n\n\n1\n2\n3\n\n\n\n# 8.3.给用户赋予修改某个表某个字段权限\n\nGRANT update (department_name, location_id)\nON departments\nTO scott, manager;\n\n\n1\n2\n3\n\n\n\n# 8.4.权限传递\n\n如果你想让其他用户也有权 把你赋给他的权限进一步赋予给别人，那么需要带 WITH GRANT OPTION;\nGRANT select, insert\nON departments\nTO scott\nWITH GRANT OPTION;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 8.5.所有人都有某权限\n\nGRANT select\nON alice.departments\nTO PUBLIC;\n\n\n1\n2\n3\n\n\n\n# 8.6.权限数据字典\n\n\n\n\n# 8.7.收回权限\n\nREVOKE {privilege [, privilege...]|ALL}\nON object\nFROM {user[, user...]|role|PUBLIC}\n\n\n1\n2\n3\n\n\n\n# 9.Oracle集合\n\n\n# 9.1.并集\n\nUNION 去重\nUNION ALL  不去重\n\n\n1\n2\n\n\n\n# 9.2.交集\n\nINTERSECT\n\n\n1\n\n\n\n# 9.3.差集\n\nMINUS\n\n\n1\n\n\n\n# 10.Group by子句增强\n\n\n# 10.1.ROLLUP关键字\n\nRollup 后面跟了n个字段，就将进行n+1次分组，从右到左每次减少一个字段进行分组；然后进行 union\n\nSELECT department_id, job_id, SUM(salary)\nFROM employees \nWHERE department_id < 60\nGROUP BY ROLLUP(department_id, job_id);\n\n\n1\n2\n3\n4\n\n\n查询出来的结果：从group by右边每次减少一个，所以对department_id再进行一次分组\n\n\n\n\n# 10.2.Cube\n\nCube 后面跟了n个字段，就将进行2的N次方的分组运算，然后进行；\n\nSELECT department_id, job_id ,SUM(salary)\nFROM employees \nWHERE department_id < 60\nGROUP BY cube(department_id, job_id);  --对两个字段都额外分组\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 10.3.grouping关键字\n\n由于ROLLUP、CUBE对字段进行额外的分组，可以使用grouping函数，没有被分组的列返回1，否则返回0\n\n\n\n\n# 10.4.grouping set关键字\n\n分别对（department_id,job_id）、（job_id,manager_id）进行分组\n\n--GROUPING SETS\nSELECT department_id, job_id, grouping(department_id),grouping(job_id),grouping(manager_id)\n manager_id,avg(salary)\nFROM employees_copy\nGROUP BY GROUPING SETS \n((department_id,job_id), (job_id,manager_id));\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n# 11.子查询进阶\n\n\n# 11.1.把查询结果当做一个表\n\n--把查询结果当做一个表\n--查询员工大于自己部门的平均工资\nSELECT a.last_name, a.salary, a.department_id, b.salavg\n  FROM employees_copy a,\n       (SELECT department_id, AVG(salary) salavg\n          FROM employees_copy\n         GROUP BY department_id) b\n WHERE a.department_id = b.department_id\n   AND a.salary > b.salavg;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 11.2.当做某个判断条件\n\n--查询工资大于平均工资的员工信息\nSELECT last_name, salary, department_id\n  FROM employees\n outer WHERE salary > (SELECT AVG(salary)\n                         FROM employees\n                        WHERE department_id = outer.department_id);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 11.3.exists关键字\n\n> EXISTS(包括 NOT EXISTS )子句的返回值是一个BOOL值。 EXISTS内部有一个子查询语句(SELECT ... FROM...)， 我将其称为EXIST的内查询语句。其内查询语句返回一个结果集。 EXISTS子句根据其内查询语句的结果集空或者非空，返回一个布尔值。\n> \n> 一种通俗的可以理解为：将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则EXISTS子句返回TRUE，这一行行可作为外查询的结果行，否则不能作为结果。\n\nSELECT employee_id, last_name, job_id, department_id\n  FROM employees\n outer WHERE EXISTS\n --满足一条就执行\n (SELECT 'X' FROM employees WHERE manager_id = outer.employee_id);\n\nSELECT employee_id, last_name, job_id, department_id\n  FROM employees\n WHERE employee_id IN\n       (SELECT manager_id FROM employees WHERE manager_id IS NOT NULL);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nIN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。\n\n\n# 11.4.Not Exists\n\nSELECT department_id, department_name\n  FROM departments d\n WHERE NOT EXISTS\n (SELECT 'X' FROM employees WHERE department_id = d.department_id);\n \nSELECT department_id, department_name\n  FROM departments\n WHERE department_id NOT IN (SELECT department_id FROM employees);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 注意：Not In 里面只要有一个NULL ，就不成立了，这是很容易出错的地方； 正确的方法请在后 面的子查询中加上where department_id is not null\n\n\n# 11.5某个表的字段更新为另一个表的字段（慎用）\n\n员工表的department_name去查询部门表获取，通过department_id关联\n\nUPDATE employees e\nSET department_name = \n (SELECT department_name\n FROM departments d\n WHERE e.department_id = d.department_id);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 11.6.子查询delete（不用）\n\n删除工作年限五年，并且开始时间与员工入职时间相同的\n\nDELETE FROM job_history JH\n WHERE employee_id =\n (SELECT employee_id\n FROM employees E\n WHERE JH.employee_id = E.employee_id\n AND start_date =\n (SELECT MIN(start_date) \n FROM job_history JH\n WHERE JH.employee_id = E.employee_id)\n AND 5 > (SELECT COUNT(*) \n FROM job_history JH\n WHERE JH.employee_id = E.employee_id\n GROUP BY employee_id\nHAVING COUNT(*) >= 4));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 11.7.With关键字\n\n类似于取别名\n\n --with关键字\nWITH dept_costs AS\n (SELECT d.department_name, SUM(e.salary) AS dept_total\n    FROM employees e, departments d\n   WHERE e.department_id = d.department_id\n   GROUP BY d.department_name),\navg_cost AS\n (SELECT SUM(dept_total) / COUNT(*) AS dept_avg FROM dept_costs)\n\n--使用别名\nSELECT *\n  FROM dept_costs\n WHERE dept_total > (SELECT dept_avg FROM avg_cost)\n ORDER BY department_name;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n使用WITH好处：\n\n> 1） 如果在后面多次使用则可以简化SQL ;\n> \n>  2. 适当提高性能\n\n\n# 12.递归查询\n\n递归语句：\n\nSELECT [LEVEL], column, expr...\nFROM table\n[WHERE condition(s)]\n[START WITH condition(s)]\n[CONNECT BY PRIOR condition(s)] ;\n\n\nmanager_id===员工上级ID  ,employee_id ===员工ID\n--查找employee_id=100的下级员工\nSELECT last_name || ' reports to ' || PRIOR last_name as \"列名\",\n       PRIOR job_id as \"parent_jobid\",\n       job_id\n  FROM employees\n START WITH employee_id=100\nCONNECT BY PRIOR employee_id = manager_id;\n\n--查找employee_id=100的上级员工\nSELECT last_name || ' reports to ' || PRIOR last_name as \"列名\",\n       PRIOR job_id as \"parent_jobid\",\n       job_id\n  FROM employees\n START WITH employee_id=100\nCONNECT BY PRIOR manager_id = employee_id;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nLEVEL关键字和 LPAD函数 ，在OUTPUT中显示树形层次。\n\n--递归查找employee_id=100的下级  根据树形级别在左边填充*\nSELECT LPAD(last_name, LENGTH(last_name) + (LEVEL * 2) - 2, '*') AS org_chart,LEVEL\n  FROM employees\n START WITH employee_id = 100\nCONNECT BY PRIOR employee_id = manager_id\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\n# 13.insert增强（插入几个表）\n\n\n# 13.1.一个来源插入多个目标表（无条件）。\n\n--根据查询的结果分别插入到sal_history、mgr_history表\nINSERT ALL \nINTO sal_history VALUES(EMPID, HIREDATE, SAL) \nINTO mgr_history VALUES(EMPID, MGR, SAL)\n  SELECT employee_id EMPID, hire_date HIREDATE, salary SAL, manager_id MGR\n    FROM employees\n   WHERE employee_id > 200;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 13.2.一个来源插入多个目标表（有条件，首次匹配即跳到下一条）\n\n--依次匹配，插入到一个表中即可\nINSERT FIRST\n WHEN SAL > 25000 THEN INTO special_sal VALUES(DEPTID, SAL)\n WHEN HIREDATE like ('%00%') THEN INTO hiredate_history_00 VALUES(DEPTID,HIREDATE)\n WHEN HIREDATE like ('%99%') THEN INTO hiredate_history_99 VALUES(DEPTID, HIREDATE)\n ELSE INTO hiredate_history VALUES(DEPTID, HIREDATE)\n   SELECT department_id DEPTID, SUM(salary) SAL,\n   MAX(hire_date) HIREDATE\n   FROM employees\n   GROUP BY department_id;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 14.sql进阶\n\n\n# 14.1.查询部门的平均工资、最高工资和最低工资，并且把员工都查询出来\n\n--查询根据部门名的平均工资、最高工资和最低工资（每个员工都要被查出来）\nSELECT e.last_name,\n       e.salary,\n       d.department_name,\n       AVG(e.salary) over(PARTITION BY d.department_name) department_avg_salary,\n       MAX(e.salary) over(PARTITION BY d.department_name) department_max_salary,\n       MIN(e.salary) over(PARTITION BY d.department_name) department_min_salary\n  FROM employees e, departments d\n WHERE 1 = 1\n   AND e.department_id = d.department_id;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用子查询+表连接配合也可以实现：\n\nselect e1.last_name,e1.salary,e1.department_id,e2.avgFiled,e2.maxFiled,e2.minFiled \nfrom employees e1,\n(select department_id, AVG(salary) as avgFiled,MAX(salary) as maxFiled,MIN(salary) as minFiled from employees group by department_id) e2,\ndepartments d \nwhere e1.department_id = e2.department_id\nand e1.department_id = d.department_id;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n# 14.2.将一个部门内的员工的工资从高到低进行排序，注意三种排序结果是不一样的。\n\n\n\n\n# 14.3.Oracle的闪回机制\n\n> Oracle数据库中提供一种机制可以用来查询之前一段时间内修改行原先的值，比如我们错误的提 交了修改结果，现在又想查看修改行原来的值，这时候就可以使用闪回。\n\n--通过AS OF TIMESTAMP SYSDATE-5/(24*60)  回退到五分钟前\nSELECT * FROM departments AS OF TIMESTAMP SYSDATE-5/(24*60) \nWHERE department_name = 'Sales';\n\n\n1\n2\n3\n\n\n查询被删除的department_name = 'Sales'并还原数据\n\n--开始有数据\nselect * from departments WHERE department_name = 'Sales';\n\n--删除\nDELETE FROM departments WHERE department_name = 'Sales';\nCOMMMIT;\n\n--查询数据已经被删除\nselect * from departments WHERE department_name = 'Sales';\n\n--闪回到5分钟之前，再执行下查询试试有没有结果。\nSELECT * FROM departments AS OF TIMESTAMP SYSDATE-5/(24*60) \nWHERE department_name = 'Sales';\n\n--还原数据\ninsert into departments \nSELECT * FROM departments AS OF TIMESTAMP SYSDATE-5/(24*60) \nWHERE department_name = 'Sales';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# oracle函数\n\n* oracle 函数分为单行函数和多行函数两大类\n\n* 单行函数\n\n- 操作数据项\n\n- 接受参数并返回处理结果\n\n- 对每一返回行起作用\n\n- 可修改数据类型\n\n- 可嵌套使用\n\n* 单行函数分类\n\n- 字符函数\n\n- 数值函数\n\n- 日期函数\n\n- 转换函数\n\n- 通用函数\n\n\n# 字符函数\n\n* 字符大小写转换函数\n\n* 函数 功能 用法 返回结果\n\n- lower() 转换为小写 lower('john smith') john smith\n\n- upper() 转换为大写 upper('john smith') john smith\n\n- initcap() 单词首字母大写 initcap('john smith') john smith\n\n* 例:\n\n- select lower('john smith') from dual;->(john smith)\n\n- select upper('john smith') from dual;->(john smith)\n\n- select initcap('john smith') from dual;->(john smith)\n\n*字符处理函数\n\n* 函数 功能 用法 返回结果\n\n- concat() 字符串连接 concat('hello', 'world') hello world\n\n- substr() 截取子串 substr('helloworld', 4, 3) low\n\n- length() 返回字符串长度 length('hello world') 11\n\n- instr() 定位子串 instr('hello world', 'or') 8\n\n- lpad() 左侧填充 lpad('smith', 10, '*') *****smith\n\n- rpad() 右侧填充 rpad('smith', 10, '*') smith*****\n\n- trim() 过滤首尾空格 trim(' mr smith ') mr smith\n\n- replace() 替换 replace('aba', 'a', 'c') cbc\n\n* 注意:函数可嵌套使用\n\n* 例:\n\n- select concat('hello', 'world') from dual;->(helloworld)\n\n- select concat(concat(ename, ' is a '), job) info from emp where empno=7369;->(smith is a clerk)\n\n- select substr('helloworld', 4, 3) from dual;->(low)\n\n- select substr(substr('helloworld', 3, 6), 3, 3) from dual->(owo)\n\n- select length('hello world') from dual;->(11)\n\n- select instr('hello world', 'or') from dual;->(8)\n\n- select lpad('smith', 10, '*') from dual;->(*****smith)\n\n- select rpad('smith', 10, '*') from dual;->(smith*****)\n\n- select trim(' mr smith ') from dual;->(mr smith)\n\n- select replace('aba', 'a', 'c') from dual;->(cbc)\n\n\n# 数值函数\n\n* 函数 功能 用法 返回结果\n\n- abs() 取绝对值 abs(-3.14) 3.14\n\n- round() 四舍五入 round(3.1415) 3\n\nround(3.1415, 3) 3.142\n\nround(314.1592, -2) 300\n\n- trunc() 截断 trunc(3.1415, 3) 3.141\n\n- ceil() 向上取整 ceil(3.14) 4\n\n- floor() 向下取整 floor(3.14) 3\n\n- sign() 判断数值正负 sign(-3.14) -1\n\n- sin().. 三角函数.. sin(3.14) .001592653\n\n- power() 幂运算 power(4.5, 2) 20.25\n\n- sqrt() 开平方根 sqrt(9) 3\n\n- mod() 取模 mod(10, 3) 1\n\n- exp() 基数为e的幂运算exp(1) 2.71828183\n\n- log() 对数运算 log(4, 16.0) 2\n\n- ln() 自然对数运算 ln(7) 1.94591015\n\n* 例:\n\n- select abs(-3.14) from dual;->(3.14)\n\n- select round(3.1415) from dual;->(3)\n\n- select round(3.1415, 3) from dual;->(3.142)\n\n- select round(314.1592, -2) from dual;->(300)\n\n- select trunc(3.1415, 3) from dual;->(3.141)\n\n- select trunc(3.1415, -3) from dual;->(0)\n\n- select trunc(3.1415, 7) from dual;->(3.1415)\n\n- select ceil(3.14) from dual;->(4)\n\n- select floor(3.14) from dual;->(3)\n\n- select sign(-3.14) from dual;->(-1)\n\n- select sin(3.14) from dual;->(.001592653)\n\n- select power(4.5, 2) from dual;->(20.25)\n\n- select sqrt(9) from dual;->(3)\n\n- select mod(10, 3) from dual;->(1)\n\n- select exp(1) from dual;->(2.71828183)\n\n- select log(4, 16.0) from dual;->(2)\n\n- select ln(7) from dual;->(1.94591015)\n\n\n# 日期类型\n\n* 关于日期类型\n\n- oracle内部以数字格式存储日期和时间信息:世纪,年,月,日,小时,分钟,秒\n\n- 缺省的日期格式是dd-mon-yy\n\n- 可使用sysdate函数获取当前系统日期和时间\n\n* 日期型数据的算术运算\n\n- 日期型数据可以直接加或减一个数值,结果仍为日期\n\n- 两个日期型数据可以相减,结果为二者相差多少天\n\n* 查询200-12-25减1991-12-25一共有多少天\n\n- select to_date('25-12月 -09') - to_date('25-12月-1991') from dual;\n\n\n# 日期函数\n\n* 函数 功能 用法 返回结果\n\n- add_months(x, y) 计算在日期x基础上增加y个月后的日期add_months(sysdate, 2)\n\n- last_day(x) 返回日期x当月最后一天的日期 last_day(sysdate)\n\n- months_between(x, y) 返回日期x和y之间相差的月数 months_between(sysdate, hiredate)\n\n- round(x, y) 将日期x四舍五入到y所指定的 round(sysdate, 'month')\n\n日期单位(月或年)的第一天 round(sysdate, 'year')\n\n- trunc(x, y) 将日期x截断到y所指定的 trunc(sysdate, 'month')\n\n日期单位(月或年)的第一天 trunc(sysdate, 'year')\n\n- next_day 计算指定日期x后的第一个星期几 next_day(sysdate, '星期二')\n\n(由参数y指定)对应的日期\n\n* 例:\n\n- select add_months(sysdate, 2) from dual;->(05-10月-09)\n\n- select last_day(sysdate) from dual;->(31-8月-09)\n\n- select hiredate, months_between(sysdate, hiredate) from emp;\n\n- select months_between(sysdate, '17-12月-80') from dual;->(343.63907)\n\n- select round(sysdate, 'month') from dual;->(01-8月-09)\n\n- select round(to_date('16-8月 -09'), 'month') from dual;->(01-9月-09)\n\n- select round(sysdate, 'year') from dual;->(01-1月-10)\n\n- select round(to_date('1-7月 -09'), 'year') from dual;->(01-1月-10)\n\n- select round(to_date('25-6月 -09'), 'year') from dual;->(01-9月-09)\n\n- select trunc(sysdate, 'month') from dual;->(01-8月-09)\n\n- select trunc(sysdate, 'year') from dual;->(01-1月-09)\n\n- select next_day(sysdate, '星期二') from dual;->(11-8月-09)\n\n- select next_day(next_day(sysdate, '星期二'), '星期二') from dual;->(18-8月-09)\n\n\n# 转换函数\n\n* 数据类型转换包括隐含转换和显式转换两方式,建议使用显式的数据类型转换,确保sql语句的可靠性\n\n* 字符类型 ->数值类型 -> to_number()\n\n* 字符类型 ->日期类型 -> to_date()\n\n* 数值类型 ->字符类型 -> to_char()\n\n* 日期类型 ->字符类型 -> to_char()\n\n\n# 日期 *->* *字符串*\n\n* to_char()函数可以将日期型数值转换为字符串形式\n\n* 格式:\n\n- to_char(date) // 缺省转换为'dd-mm-yy'格式\n\n- to_char(date, 'format_model') // 转换为模式串指定的格式\n\n* 例:\n\n- select empno, ename, sal, to_char(hiredate, 'yyyy-mm-dd') from emp;\n\n- select to_char(sysdate, 'yyyy-mm-dd hh:mi:ss') from dual;\n\n- select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') from dual;\n\n\n# 常用日期格式符\n\n* 格式符 说明 举列\n\n- yyyy 年份 2008\n\n- mm 用数字显示月份 02\n\n- dd 在当月中是第几天 28\n\n- day 星期几 星期五\n\n- am/pm 显示上午/下午 上午\n\n- hh/hh12/hh24 小时 2:30 14:30\n\n- mi 分钟 30\n\n- ss 秒钟 46\n\n* 说明:除上述格式符外,日期模式串中还可直接出现如下字符( - : ; / );\n\n* 如要显示其它文本字符串则需使用双引号括起来;也可在械串的开头使用\"fm\"标\n\n* 记以去掉数字前面的零\n\n* 例:\n\n- select to_char(sysdate, 'yyyy\"年\"mm\"月\"dd\"日\" day hh24:mi:ss') from dual;\n\n- select to_char(sysdate, 'fmyyyy\"年\"mm\"月\"dd\"日\" day hh24:mi:ss') from dual;\n\n\n# 字符串 *->* *日期*\n\n* to_date()函数可以将字符串转换为日期型数值形式\n\n* 格式:\n\n- to_date(char) // 按缺省格式'dd-mm-yy'进行解析\n\n- to_date(char, 'format_model') // 按模式串指定的格式进行解析\n\n* 例:\n\n- insert into t5 values('bobo', to_date('2008-02-28', 'yyyy-mm-dd'));\n\n- select to_date(to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') from dual;\n\n- select to_char(to_date(to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'), 'dd/mm/yyyy') from dual;\n\n\n# 数字\n\n* to_char()函数可以将数字值转换为字符串形式\n\n* 格式:\n\n- to_char(number)\n\n- to_char(number, 'format_model')\n\n* 例:\n\n- select to_char(12345.678901) from dual;\n\n- select to_char(12345.678901, '$99,999.0000') from dual;\n\n* 数字模式符:\n\n* 格式符 说 明\n\n- 9 代表一位数字\n\n- 0 代表一位数字,强制显示0\n\n- $ 放置一个美圆符$\n\n- l 放置一个本地货币符\n\n- . 小数点\n\n- , 千位指示符\n\n* 例:\n\n- select to_char(12345.6, 'l999,999.0000') from dual;\n\n\n# 字符串 *->* *数字*\n\n* to_number()函数可以将字符串转换为数字值形式\n\n* 格式:\n\n- to_number(char)\n\n- to_number(char, 'format_model')\n\n* 例:\n\n- select to_number('12345.678901') from dual;\n\n- select to_number('$12,345.6789', '$99,999.0000') from dual;\n\n2）如果数字在格式范围内的话，就是正确的，否则就是错误的；如：\n\n$12345.678小数点位数必须小于等于后面规定的格式\nselect to_number('$12345.678', '$999999.99') from dual;  x\nselect to_number('$12345.678', '$999999.999') from dual; √\nselect to_number('$12345.67', '$999999.999') from dual;  √\n\n\n1\n2\n3\n4\n\n\n\n# 通用函数\n\n* 通用函数适用于任何类型数据(包括空值):\n\n- nvl()\n\n- nvl2()\n\n- nullif()\n\n- coalesce()\n\n- case表达式\n\n- decode()\n\n\n# nvl()*函数*\n\n* nvl()函数用于将空值null替换为指定的缺省值,适用于字符,数字,日期等类型数据\n\n* 语法格式:\n\n- nvl(exp1, exp2)\n\n* 说明:\n\n- 如果表达式exp1的值为null,则返回exp2的值,否则返回exp1的值\n\n* 用法举例:\n\n- select empno, ename, sal, comm, sal+nvl(comm, 0) from emp;\n\n- select empno, ename, hiredate, nvl(hiredate, sysdate) from emp;\n\n- select empno, ename, job, nvl(job, 'no job yet') from emp;\n\n\n# nvl2()*函数*\n\n* nvl2()函数用于实现条件表达式功能\n\n* 语法格式:\n\n- nvl2(exp1, exp2, exp3)\n\n* 说明:\n\n- 如果表达式exp1的值不为null,则返回exp2的值,否则返回exp3的值\n\n* 用法举例:\n\n- select empno, ename, sal, comm, nvl2(comm, sal+comm, sal) from emp;\n\n\n# nullif()*函数*\n\n* nullif()函数用于数据等价性比较并根据比较结果返回null或其中一个被比较的数值\n\n* 语法格式:\n\n- nullif(exp1, exp2)\n\n* 说明:\n\n- 如果表达式exp1与exp2的值相等返回null,否则返回exp1的值\n\n* 用法举例:\n\n- select name 原名, nullif(pen_name, name)化名 from author;\n\n\n# coalesce()*函数*\n\n* coalesce()函数用于实现数据\"接合\"功能\n\n* 语法格式:\n\n- coalesce(exp1, exp2, ...)\n\n* 说明:\n\n- 依次考察各参数表达式,遇到非null值即停止并返回该值\n\n* 用法举例:\n\n- select empno, ename, sal, comm, coalesce(sal+comm, sal, 0) 总收入 from emp;\n\n\n# case()*函数*\n\n* case()表达式用于实现多路分支结构\n\n* 语法格式:\n\n- case exp1 when comparison_exp1 then return_exp1\n\n- [when comparison_exp2 then return_exp2\n\n- when comparison_expn then return_expn\n\n- else esle_exp]\n\n- end [tempname]\n\n* 说明:\n\n- 如果 exp1是 comparison_exp1的时候,就返回return_exp1\n\n- [ comparison_exp2 的时候,就返回return_exp2\n\n- comparison_expn 的时候,就返回return_expn\n\n- else 就返回 esle_exp ]\n\n- end [别名]\n\n* 用法举例:\n\n- select empno, ename, sal,\n\n\\-     case deptno when 10 then '财务部'\n\n\\-           when 20 then '研发部'\n\n\\-           when 30 then '销售部'\n\n\\-           else '未知部门'\n\n\\-     end 部门\n\n\\- from emp;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n通配符：\n\nselect \njob_id,\n  case  when job_id like '%ad%' then 'ad'\n    when job_id like 'it_prog' then 'it'\n    when job_id like '%fi%' then 'fi' \n    else 'no'\n  end 部门简称\nfrom employees\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# case高阶用法：\n\n--case语句的种类:\n1.简单case语句\n语法:\n   case exp when comexp then returnvalue\n            ...\n            when comexp then returnvalue\n            else returnvalue\n    end\n      \n  case到end之间相当于一个具体的值，可以做运算，取别名，嵌套case 等等。\n  只要把case到end当作一个运算结果的表达式就可以了。\n\n举例:\n   select cust_last_name,\n          case credit_limit when 100 then 'low'\n                            when 5000 then 'high'\n                            else 'medium'\n          end\n     from customers;\n     \n2.搜索case语句\n语法:\n    case when boolean then return value\n         ...\n         when boolean then return value\n         else retur nvalue\n     end\n     \n举例:\nselect case when id between 1 and 10 then 'low'\n            when id between 20 and 30 then 'mid'\n            when id between 40 and 50 then 'high'\n            else 'unknow'\n       end\nfrom product;\n\n--简单case和搜索case之间的区别：\n1. 简单case只能是when后面的表达式完全匹配case后的表达式，相当于 =，所以也不能匹配null。\n2. searched case可以作为比较条件，那么可以使用like、!=、between ..and、<、=、is null、is not null等，比简单case的使用更加广泛，完全可以替代简单case。\n\n--注意事项:\n1.case 表达式返回的是一个确定的value，若前面的都不匹配，则返回else中的项.\n2.简单case 中的表达式，when 后面的表达式类型应该全部保持一致.\n3.所有的then 后面的return_value类型要保持一致.\n4.对于简单case 表达式，也就是case 表达式 when…那么when null 总是取不到。也就是case 后面的表达式如果值为null，不会与when null 匹配，只会与else匹配.\n5.对于searched case来说，有自动类型转换，只要条件成立就可以。\n如:select case when 1='1' then 1 end from dual; 其中1='1'条件成立\n\n值得一提的是: sql中的case语句与pl/sql中的case语句的不同之处:\n前者的else不是必须的，如果没有匹配就返回null;后者的else不写，则报case_not_found异常.\n\n--case中嵌套子查询\ncase语句中可以使用子查询，但是必须返回一行，不可以是多行.\n如：\nselect case (select count(*) as s1 from t1 where a = 1)\n           when (select count(*) as s2 from t1, t2 where t1.a = t2.a and t2.a = 1) then '相等'\n           else '不相等'\n       end\n  from dual;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# decode()*函数*\n\n* 和case()表达式类似,decode()函数也用于实现多路分支结构\n\n* 语法格式:\n\n- decode(col|expression, search1, result1\n\n- [, search2, result2, ...,]\n\n- [, default])\n\n* 说明:\n\n- 如果 col|expression是 search1的时候,就返回result1\n\n- [ search2 的时候,就返回result2, ...]\n\n- [, default])\n\n- [别名]\n\n* 用法举例:\n\n- select empno, ename, sal,\n\n- decode(deptno, 10, '财务部',\n\n- 20, '研发部',\n\n- 30, '销售部',\n\n- '未知部门')\n\n- 部门\n\n- from emp;\n\n\n# 函数嵌套\n\n* 单行孙数可以嵌套使用,嵌套层次无限制\n\n* 嵌套函数的执行顺序是由内到外\n\n- select empno, lpad(initcap(trim(ename)), 10, '*') name, job, sal from emp;\n\n##########[ 单行函数小结 ]##########\n\n* 使用系统提供的单行函数可实现如下功能:\n\n- 对数据进行计算\n\n- 控制数据的输出格式\n\n- 设置/改变日期的显示格式\n\n- 进行数据类型转换\n\n- 使用nvl函数处理空值\n\n- 实现if-then-else多路分支逻辑\n\n\n# 分组函数\n\n* 分组函数对一组数据进行运算,针对一组数据(多行记录)只返回一个结果,也称多行函数\n\n* 常用分组函数\n\n- 函数 功能说明 适用类型\n\n- avg() 计算平均值 数值型\n\n- count() 返回查询所行到的记录行数 任何类型数据\n\n- max() 计算最大值 任何类型数据\n\n- min() 计算最小值 任何类型数据\n\n- sun() 求和 数值型\n\n> 1.上述函数除了count(*)会处理null，其他都会忽略null，可用nvl函数处理\n> \n> 2.备注:min,max可用于任何数据类型，便avg， sum，stddev,variance仅适用于数值型字段。\n\n* 举例:\n\n- select avg(sal), max(sal), min(sal), sum(sal) from emp;\n\n- select max(hiredate), min(hiredate) from emp;\n\n\n# count()*函数*\n\n* count(*) 返回组中总记录数目包括空行\n\n* count(exp) 返回表达式exp值非空的记录数目\n\n* count(distinct(exp)) 返回表达式exp值不重复的,非空的记录数目\n\n* 举例:\n\n- select count(*) from emp; ==== select count(*1) from emp;\n\n- select count(comm) from emp;\n\n- select count(distinct(deptno)) from emp;\n\n select count(distinct(deptno)) from emp;\n 不用distinct，使用group by改为：\n select count(deptno) from (select deptno from emp group by deptno)\n\n\n1\n2\n3\n\n\n\n# 分组函数与空值\n\n* 分组函数省略列中的空值\n\n- select avg(comm) from emp;\n\n- select sum(comm) from emp;\n\n* 可使用nvl()函数强制分组函数处理空值\n\n- select avg(nvl(comm, 0)) from emp;\n\n\n# group by*子句*\n\n* group by 子句将表中数据分成若干小组\n\n* 语法格式\n\n- select column, group_function(column)\n\n- from table\n\n- [where condition]\n\n- [group by group_by_expression]\n\n- [order by column]\n\n* 例:\n\n- select deptno, avg(sal) from emp group by deptno;\n\n- select deptno, avg(sal) from emp where deptno > 10 group by deptno;\n\n- select deptno, avg(sal) from emp group by deptno order by deptno desc;\n\n* 说明:\n\n> - 出现在select列表中的字段,如果不是包含在组函数中,那么该字段必须同时在group by 子句中出现\n> \n> - 包含在 group by子句中的字段则不必须出现在 select列表中\n> \n> - 可使用 where子句限定查询条件\n> \n> - 可使用 order by子句指定排序方式\n\n* 注意:\n\n- 执行顺序: where -> group by -> select ... from ... -> order by..\n\n##########[ 基于多字段分组 ]##########\n\n- select deptno, job, avg(sal) from emp group by deptno, job;\n\n##########[ 组函数的错误用法 ]##########\n\n* 如果没有 group by子句, select列表中不允许出现字段(单行函数)与分组函数混用的情况\n\n- select empno, sal from emp; -> (y)\n\n- select avg(sal) from emp; -> (y)\n\n- select empno, initcap(ename), avg(sal) from emp; -> (n)\n\n* 不允许在 where子句中使用分组函数\n\n- select deptno, avg(sal)\n\n- from emp\n\n- where avg(sal) > 2000; -> (n)\n\n- group by deptno;\n\n- 注:这跟子句运行顺序有关,\n\n- where 最先执行,\n\n- 在执行 where子句时,\n\n- 还没有执行 group by子句,\n\n- 还不知道什么分组,\n\n- 也没计算过 avg(sal)组内的平均工资\n\n\n# having *子句*\n\n* having 子句用于过滤分组\n\n* 语法格式\n\n- select column, group_function(column)\n\n- from table\n\n- [where condition]\n\n- [group by group_by_expression]\n\n- [order by column];\n\n* 例:\n\n- select deptno, job, avg(sal)\n\n- from emp\n\n- where hiredate >= to_date('1981-05-01', 'yyyy-mm-dd')\n\n- group by deptno, job\n\n- having avg(sal) > 1200\n\n- order by deptno, job;\n\n##########[ 分组函数嵌套 ]##########\n\n* 分组函数最多可嵌套两层\n\n- select max(avg(sal))\n\n- from emp\n\n- group by deptno;\n\n\n# oracle 表连接\n\n* sql/oracle 使用表连接从多个表中查询数据\n\n* 语法格式:\n\n- select 字段列表\n\n- from table1, table2\n\n- where table1.column1 = table2.column2\n\n* 说明:\n\n- 在 where子句中指定连接条件\n\n- 当被连接的多个表中存在同名字段时,必须在该字段前加上\"表名.\"作为前缀\n\n* 例:\n\n- select empno, ename, job, emp.deptno, dname\n\n- from emp, dept\n\n- where emp.deptno = dept.deptno;\n\n* 提示:加上前缀可以提高效率\n\n##########[ 连接的类型 ]##########\n\n* oracle8i之前的表连接\n\n- 等值连接(equijoin)\n\n- 非等值连接(non-equijoin)\n\n- 外连接(outer join)\n\n- 左外连接\n\n- 右外连接\n\n- 自连接(selfjoin)\n\n* oracle9i新引入的连接形式(支持sql99规范):\n\n- 交叉连接(cross join)\n\n- 自然连接(natural join)\n\n- 使用 using子句建立连接\n\n- 使用 on子句建立连接\n\n- 外连接(outer join)\n\n- 左外连接\n\n- 右外连接\n\n- 全外连接\n\n##########[ 多表连接 ]##########\n\n* 多表连接中:\n\n- 可使用 and操作符增加查询条件\n\n- 使用表别名可以简化查询\n\n- 使用表名(表别名)前缀可提高查询效率\n\n- 为了连接 n个表,至少需要 n-1个连接条件\n\n##########[ 等值连接(equijion) ]##########\n\n* 什么是等值连接\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp, dept\n\n- where emp.deptno = dept.deptno;\n\n##########[ 非等值连接(not-equijion) ]##########\n\n* 问题:如何查得每个员工的工资等级\n\n* 方法1:\n\n- select empno, ename, sal, grade, losal, hisal\n\n- from emp, salgrade\n\n- where sal >= losal and sal <= hisal;\n\n* 方法2:\n\n- select empno, ename, sal, grade, losal, hisal\n\n- from emp, salgrade\n\n- where sal between losal and hisal;\n\n##########[ 外连接(outer jion) ]##########\n\n* 使用外连接可以看到参与连接的某一方不满足连接条件的记录\n\n* 外连接运算符为(+)\n\n* 传统的外连接分为左外连接和右外边接两种\n\n* 语法格式:\n\n- select 字段列表\n\n- from table1, table2\n\n- where table1.column1(+)=table2.column2;\n\n- select 字段列表\n\n- from table1, table2\n\n- where table1.column1=table2.column2(+);\n\n* 例:\n\n* 左外连接'(+)'放在右边,将左表中不符合条件的也显示出来\n\n- select employee_id, first_name, salary, e.department_id, department_name\n\n- from employees e, departments d\n\n- where e.department_id = d.department_id(+)\n\n- order by employee_id;\n\n* 右外连接'(+)'放在左边,将右表中不符合条件的也显示出来\n\n- select employee_id, first_name, salary, e.department_id, department_name\n\n- from employees e, departments d\n\n- where e.department_id(+) = d.department_id\n\n- order by employee_id;\n\n##########[ 自连接(self jion) ]##########\n\n* 问题:如何查得每个员工及其上司的工号和姓名\n\n- select a.empno, a.ename, a.mgr, b.ename\n\n- from emp a, emp b\n\n- where a.mgr = b.empno\n\n- order by a.empno;\n\n##########[ sql99 连接语法 ]##########\n\n* sql1999 规范中规定的连接查询语法\n\n- select 字段列表\n\n- from table1\n\n- [cross join table2] |\n\n- [natural join table2] |\n\n- [join table2 using(字段名)] |\n\n- [join table2 on(table.column_name = table2.column_name)] |\n\n- [(left | right | full outer) join table2\n\n- on(table1.column_name = table2.column_name)];\n\n##########[ 交叉连接(cross join) ]##########\n\n\n# 交叉连接(cross join)\n\n* cross join产生了一个笛卡尔集,其效果等同于在两个表进行连接时未使用where 子句阴定连接条件\n\n* 举例:\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp cross join dept;\n\n##########[ 自然连接(natural join) ]##########\n\n\n# natural join自然连接\n\n* natural join 基于两个表中的全部同名列建立连接\n\n- 从两个表中选出同名列的值均对应相等的所有行\n\n- 如果两个表中同名列的数据类型不同,则出错\n\n- 不允许在参照列上使用表名或者别名作为前缀\n\n* 举例:\n\n- select empno, ename, sal, deptno, dname\n\n- from emp natural join dept;\n\n- 上面sql语句等同于:\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp, dept\n\n- where emp.deptno = dept.deptno;\n\n* 注意:第一种方法的deptno不能加上表名前缀,第二种方法必须加上表名前缀\n\n\n# using *子句*\n\n* 如果不希望参照被连接表的所有同名列进行等值连接,自然连接将无法满足\n\n* 要求,可以在连接时使用using子句来设置用于等值连接的列(参照列)名.\n\n* 举例:\n\n- select empno, ename, sal, deptno, dname\n\n- from emp join dept\n\n- using(deptno);\n\n* 不允许在参照列上使用表名或者别名作为前缀\n\n\n# on *子句*\n\n* 如果要参照非同名的列进行等值连接,或想设置任意的连接条件,可以使用on 子句\n\n* 举例:\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp join dept\n\n- on(emp.deptno = dept.deptno);\n\n* 必须加上表名前缀(emp.deptno)\n\n- 上面sql语句等同于:\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp, dept\n\n- where emp.deptno = dept.deptno;\n\n--------------------------------------------------\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp join dept\n\n- on(emp.deptno = dept.deptno and sal > 2500);\n\n- 上面sql语句等同于:\n\n- select empno, ename, sal, emp.deptno, dname\n\n- from emp, dept\n\n- where emp.deptno = dept.deptno and sal > 2500;\n\n多表连接\n\n* 使用sql99连接语法,两个以上的表进行连接时应依次/分别指定相临的两个表之间的连接条件\n\n* 语法格式:\n\n- select 字段列表\n\n- from table1\n\n- [cross join table2] |\n\n- [natural join table2] |\n\n- [join table2 using(字段名)] |\n\n- [join table2 on(table1.column_name=table2.column_name)] |\n\n- [(left | right | full outer) join table2\n\n- on(table1.column_name=table2.column_name)]\n\n- [cross join table3] |\n\n- [natural join table3] |\n\n- [join table3 using(字段名)] |\n\n- [join table3 on(table2.colimn_name=table3.column_name)] |\n\n- [(left | right | full outer) join table3\n\n- on(table2.column_name=table3.column_name)];\n\n* 举例:\n\n- select employee_id, first_name, salary, department_id, department_name, location_id, city\n\n- from employees join departments using(department_id) natural join locations;\n\n- 上面sql语句等同于:\n\n- select employee_id, first_name, salary, department_id, department_name, location_id, city\n\n- from employees join departments using(department_id) join locations using(location_id);\n\n- 等同于:\n\n- select employee_id, first_name, salary, emp.department_id, department_name, location_id, city\n\n- from employees emp join departments dep on(emp.department_id = dep.department_id)\n\n- join locations loc using(location_id);\n\n- 等同于:\n\n- select employee_id, first_name, salary, emp.department_id, department_name, dep.location_id, city\n\n- from employees emp join departments dep on(emp.department_id = dep.department_id)\n\n- join locations loc on(dep.location_id = loc.location_id);\n\n\n# 内连接和外连接\n\n* 内连接(inner join)\n\n- 在 sql99规范中,内连接只返回满足连接条件的数据\n\n* 外连接(outer join)\n\n- 左外联接(left outer join)\n\n- 两个表在连接过程中除返回满足连接条件的行以外,还返回左表中不满足条件的行,这种连接称为左外联接\n\n- 右外联接(right outer join)\n\n- 两个表在连接过程中除返回满足连接条件的行以外,还返回右表中不满足条件的行,这种连接称为右外联接\n\n- 满外联接(full outer join)\n\n- oracle9i 开始新增功能,两个表在连接过程中除返回满足连接条件的行以外,还返回两个表中不满足条件的所有行,这种连接称为满外联接\n\n* 举例:\n\n* 不满足条件的不返回(内连接(inner join))\n\n- select employee_id, last_name, salary, department_id, department_name\n\n- from employees join departments using(department_id);\n\n* 左表中不满足条件也返回(左外联接(left outer join))\n\n- select employee_id, last_name, salary, department_id, department_name\n\n- from employees left join departments using(department_id);\n\n* 右表中不满足条件也返回(右外联接(right outer join))\n\n- select employee_id, last_name, salary, department_id, department_name\n\n- from employees right join departments using(department_id);\n\n* 将满足条件的和左表中不满足条件的还有右表中不满足条件的,都返回(满外联接(full outer join))\n\n- select employee_id, last_name, salary, department_id, department_name\n\n- from employees full outer join departments using(department_id);\n\n\n# 子查询*(sub query)*\n\n* 问题引入\n\n- 如何查得所有比'张三'工资高的员工的信息\n\n* 子查询\n\n- 子查询在主查询前执行一次\n\n- 主查询使用子查询的结果\n\n- 语法格式:\n\n- select 字段列表\n\n- from table\n\n- where 表达式 operator(select字段列表 from table);\n\n* 举例:\n\n- select * from emp where sal > (select sal from emp where empno = 7654);\n\n##########[ 使用子查询注意事项 ]##########\n\n* 在查询是基于未知值时应考虑使用子查询\n\n* 子查询必须包含在括号内\n\n* 建议将子查询放在比较运算符的右侧,以增强可读性\n\n* 除非进行 top-n分析,否则不要在子查询中使用order by 子句\n\n* 对单行子查询使用单行运算符\n\n* 对多行子查询使用多行运算符\n\n##########[ 单行子查询 ]##########\n\n* 单行子查询只返回一行记录\n\n* 对单行子查询可使用单行记录比较运算符\n\n- 运算符 含义\n\n- = 等于\n\n- > 大于\n\n- >= 大于等于\n\n- < 小于\n\n- <= 小于等于\n\n- <> 不等于\n\n* 举例:\n\n- select * from emp\n\n- where sal > (select sal from emp where empno = 7566);\n\n##########[ 子查询空值/多值问题]##########\n\n* 如果子查询未返回任何行,则主查询也不会返回任何结果\n\n- select * from emp\n\n- where sal > (select sal from emp where empno = 8888);\n\n* 如果子查询返回单行结果,则为单行子查询,可以在主查询中对其使用相应的单行记录比较运算符\n\n- select * from emp\n\n- where sal > (select sal from emp where empno = 7566);\n\n* 如果子查询返回多行结果,则为多行子查询,此时不允许对其使用单行记录比较运算符\n\n- select * from emp\n\n- where sal > (select avg(sal) from emp group by deptno); -> (n)\n\n- select employee_id, last_name, salary from employees\n\n- where job_id = (select job_id from employees where last_name = 'grant'); -> (y)\n\n##########[ 多行子查询 ]##########\n\n* 多行子查询返回多行记录\n\n* 对多行子查询只能使用多行记录比较运算符\n\n* 运算符 含义\n\n- in 等于列表中的任何一个\n\n- any 和子查询返回的任意一个值比较\n\n- all 和子查询返回的所有值比较\n\n* 举例:\n\n- select * from emp where sal > any(select avg(sal) from emp group by deptno);\n\n- select * from emp where sal > all(select avg(sal) from emp group by deptno);\n\n- select * from emp where job in(select job from emp where ename = 'martin' or ename = 'smith');\n\n##########[ topn查询 ]##########\n\n* 在 oracle中通常用子查询的方式来实现 top n查询\n\n* 语法格式:\n\n- select 字段列表\n\n- from (select 字段列表 from table order by排序字段)\n\n- where rownum <= n;\n\n* 例:\n\n- select * from (select * from emp order by sal desc) where rownum <= 5;\n\n- select * from (select rownum myno, a.* from (select * from emp order by sal desc) a)\n\n- where myno >= 5 and myno <= 10;\n\n\n# 注意：子查询配合表连接使用，子查询不能和left连接使用\n\n\n# oracle三范式\n\n第一范式：（1nf）无重复的列\n第二范式：（2nf）属性完全依赖于主键\n第三范式：（3nf）属性不依赖于其它非主属性\n\n\n1\n2\n3\n\n\n\n# oracle项目不推荐使用\n\n> distinct ：推荐使用group by\n> \n> 子查询：使用多表查询\n> \n> （+） ：使用left/right\n\n\n# oracle dml（增删改）\n\n\n# 1.添加\n\n> 从一个表中某行数据添加到另一个表中\n\ninsert into departments0713(department_id,department_name,manager_id,location_id)\nselect department_id,department_name,manager_id,location_id from departments where department_id in (20,30)\n\n\n1\n2\n\n\n\n# oracle事务\n\n> 在commit或者rollback前后数据的状态: 1、在数据已经被更改，但没有commit前，被更改记录处于被锁定状态，其他用户无法进行更改; 2、在数据已经被更改，但没有commit前，只有当前session的用户可以看到这种变更，其他session的用户看不到数据的变化。 3、在数据已经被更改，并且被commit后，被更改记录自动解锁，其他用户可以进行更改;| 4、在数据已经被更改，并且被commit后，其他session的用户再次访问这些数据时，看到的是变化后的数据。\n\n当有用户修改数据时，oracle先把那部分原始数据备份到回滚段，在commit之前，其他session用户读到的这部分数据是回滚段上的;在提交之后，回滚段被释放。\n\n查询某个表是否有锁\n\nselect a.*, c.type, c.lmode\n from v$locked_object a, all_objects b, v$lock c\nwhere a.object_id = b.object_id\n and a.session_id = c.sid\n and b.object_name = 'testtab3'\n\n\n1\n2\n3\n4\n5\n\n\n查询某个表是否整在被锁\n\n select * from testtab3 for update nowait;\n\n\n1\n\n\n\n# 三.oracle对象-表\n\n\n# 1.对表的操作\n\n> 表的命名要求和表中列的命名要求：\n> \n> 1、必须以字母开头\n> \n> 2、长度不能超过30个字符\n> \n> 3、只能包含 a–z, a–z, 0–9, _, $, and #\n> \n> 4、不能与数据库中的已有对象重名\n> \n> 5、不能使用oracle 数据库的保留字\n\n\n# 建表语句：\n\ncreate table [schema.]table\n (column datatype [default expr][, ...]);\n\n\n1\n2\n\n\n常用的字段数据类型：\n\n\n\n\n# 复制表：\n\n复制表和数据\ncreate tablea table as select * from tableb\n复制表结构\ncreate tablea table as select * from tableb where 1=2\n\n\n1\n2\n3\n4\n\n\n\n# 删除表\n\n注意：表被删 除后，任何依赖于这张表的视图、package等数据库对象都自动变为无效：\n\ndrop table tablename;  --删除表与数据\ntruncate table tablename; ——清空表数据 但保留表结构：\ndelete from tablename;    ——清空表数据\n\n\n1\n2\n3\n\n\n> 注意truncate 与delete from table 的区别： 1）没有rollback机会 2）hwm标记复位\n> \n> 补充：hwm标记复位是什么？\n> \n> > 所有的oracle段都有一个在段内容纳数据的上限，我们把这个上限称为\"high water mark\"或hwm。这个hwm是一个标记，用来说明已经有多少没有使用的数据块分配给这个segment。hwm通常增长的幅度为一次5个数据块，原则上hwm只会增大，不会缩小，即使将表中的数据全部删除，hwm还是为原值，由于这个特点，使hwm很象一个水库的历史最高水位，这也就是hwm的原始含义，当然不能说一个水库没水了，就说该水库的历史最高水位为0。但是如果我们在表上使用了truncate命令，则该表的hwm会被重新置为0。\n\n\n# 更改表名\n\nrename oldtablename to newtablename;\n\n\n1\n\n\n\n# 2.对列的操作：\n\n添加列：\nalter table table\nadd (column datatype [default expr]\n [, column datatype]...);\n更改列：\nalter table table\nmodify (column datatype [default expr]\n [, column datatype]...);\n删除列：\nalter table table\ndrop (column)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3.约束\n\n> 常用的约束有如下几种：\n> not null （非空约束）\n> unique （唯一性约束）\n> primary key （主键约束）  :尽量别用\n> foreign key （外键约束）\n> check （自定义约束）：\n> \tcheck的使用：salary必须大于0\n>     .., salary number(2)\n>     constraint emp_salary_min \n>     check (salary > 0),.\n> \n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\n\n# 3.1.添加约束\n\n建表的时候添加约束：\n\ncreate table employees(\n employee_id number(6),\n first_name varchar2(20),\n ...\n job_id varchar2(10) not null,\n constraint emp_emp_id_pk\n primary key (employee_id));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n单独创建约束语法：\n\nalter table cux_les_je_lines add constraint cux_les_je_lines_pk \n primary key(je_line_id);\n\n\n1\n2\n\n\n\n# 3.2.删除约束\n\nalter table departments\ndrop primary key cascade;\n\n\n1\n2\n\n\n\n# 3.3.约束失效\n\nalter table employees\nenable constraintemp_emp_id_pk;\n\n\n1\n2\n\n\n\n# 3.4.查看某个表有哪些约束\n\nselect constraint_name, constraint_type,\nsearch_condition\nfrom user_constraints\nwhere table_name = 'employees'\n\n\n1\n2\n3\n4\n\n\n\n# 4.试图\n\n\n# 4.1.创建视图\n\ncreate view empvu80\nas select employee_id, last_name, salary\n from employees\n where department_id = 80;\n\n\n1\n2\n3\n4\n\n\n\n# 4.2.删除试图\n\ndrop view empvu80\n\n\n1\n\n\n\n# 4.3.top-n 查询：查询某个表前n行数据，并显示行号\n\nselect [column_list], rownum \nfrom (select [column_list] \n from table\n order by top-n_column)\nwhere rownum <= n;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.4.视图可以修改吗？\n\n> update的情况，必须是一下情况\n> \n> \\1. view的字段只涉及一个表。 \\2. 如果涉及多个表的话，被(涉及到的)view列所映射table列(或列的组合)必须是有主健约束的\\3. 强制执行，方法是加上hint /*+ bypass_ujvc */\n\n\n# 5.序列（类似mysql中的自增主键）\n\n注意：是不存在与某一个表，保存在内存中，通过sequence.nextval获取下一个，sequence.currval 获取上一个\n\n> 有的时候我们定义某一张表中某一列为主键，当我们往表中插入数据的时候，对于主键字段的赋值要求唯一性， 我们希望能有个自增长类型的数据库对象，我们每获取一次，它自动增长，保证下次获取时肯定是不一样的值， 这样我们就方便了，oracle 数据库提供“序列”这种对象来满足我们的要求。\n\n\n# 5.1.创建序列\n\ncreate sequence sequence\n [increment by n]  //自增阶梯  默认1\n [start with n]   //从多少开始\n [{maxvalue n | nomaxvalue}] //最大值\n [{minvalue n | nominvalue}] //最小值\n [{cycle | nocycle}]\n [{cache n | nocache}];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n>  1. increment by用于定义序列的步长，如果省略，则默认为1，如果出现负值，则代表oracle序列的值是按照此步长递减的。\n> \n>  2. start with 定义序列的初始值(即产生的第一个值)，默认为1。\n> \n>  3. maxvalue 定义序列生成器能产生的最大值。选项nomaxvalue是默认选项，代表没有最大值定义，这时对于递增oracle序列，系统能够产生的最大值是10的27次方;对于递减序列，最大值是-1。\n> \n>  4. minvalue定义序列生成器能产生的最小值。选项nomaxvalue是默认选项，代表没有最小值定义，这时对于递减序列，系统能够产生的最小值是?10的26次方;对于递增序列，最小值是1。\n> \n>  5. cycle和nocycle 表示当序列生成器的值达到限制值后是否循环。cycle代表循环，nocycle代表不循环。如果循环，则当递增序列达到最大值时，循环到最小值;对于递减序列达到最小值时，循环到最大值。如果不循环，达到限制值后，继续产生新值就会发生错误。\n> \n>  6. cache(缓冲)定义存放序列的内存块的大小，默认为20。nocache表示不对序列进行内存缓冲。对序列进行内存缓冲，可以改善序列的性能。\n> \n> 大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。oracle序列允许将序列提前生成 cache x个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数也不能设置太大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入cache x个。这种情况也能会在数据库关闭时也会导致序号不连续。\n> \n>  7. nextval 返回序列中下一个有效的值，任何用户都可以引用。\n> \n>  8. currval 中存放序列的当前值,nextval 应在 currval 之前指定 ，二者应同时有效。\n\n\n# 5.2.使用序列\n\ninsert into departments(department_id, \n department_name, location_id)\nvalues (dept_deptid_seq.nextval, \n 'support', 2500);\nselect dept_deptid_seq.currval\nfrom dual;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3.更改序列\n\nalter sequence dept_deptid_seq\n increment by 20\n maxvalue 999999\n nocache nocycle;\n\n\n1\n2\n3\n4\n\n\n\n# 5.4.删除序列\n\ndrop sequence dept_deptid_seq\n\n\n1\n\n\n\n# 6.索引\n\n\n# 6.1.oracle中索引的区别：\n\n逻辑上：\nsingle column 单行索引\nconcatenated 多行索引\nunique 唯一索引\nnonunique 非唯一索引\nfunction-based函数索引\ndomain 域索引\n \n物理上：\npartitioned 分区索引\nnonpartitioned 非分区索引\nb-tree：\nnormal 正常型b树\nrever key 反转型b树 \nbitmap 位图索引\n \n索引结构：\nb-tree：\n适合与大量的增、删、改（oltp）；\n不能用包含or操作符的查询；\n适合高基数的列（唯一值多）\n典型的树状结构；\n每个结点都是数据块；\n大多都是物理上一层、两层或三层不定，逻辑上三层；\n叶子块数据是排序的，从左向右递增；\n在分支块和根块中放的是索引的范围；\nbitmap:\n适合与决策支持系统；\n做update代价非常高；\n非常适合or操作符的查询； \n基数比较少的时候才能建位图索引；\n \n树型结构：\n索引头 \n开始rowid，结束rowid（先列出索引的最大范围）\nbitmap\n每一个bit对应着一个rowid，它的值是1还是0，如果是1，表示着bit对应的rowid有值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n1. b-tree索引\noracle数据库中最常见的索引类型是b-tree索引，也就是b-树索引，以其同名的计算科学结构命名。create \nindex语句时，默认就是在创建b-tree索引。没有特别规定可用于任何情况。\n2. 位图索引(bitmap index)\n位图索引特定于该列只有几个枚举值的情况，比如性别字段，标示字段比如只有0和1的情况。\n3. 基于函数的索引\n比如经常对某个字段做查询的时候是带函数操作的，那么此时建一个函数索引就有价值了。\n4. 分区索引和全局索引\n这2个是用于分区表的时候。前者是分区内索引，后者是全表索引\n5. 反向索引（reverse）\n这个索引不常见，但是特定情况特别有效，比如一个varchar(5)位字段(员工编号)含值\n（10001,10002,10033,10005,10016..）\n这种情况默认索引分布过于密集，不能利用好服务器的并行\n但是反向之后10001,20001,33001,50001,61001就有了一个很好的分布，能高效的利用好并行运算。\n6.hash索引\nhash索引可能是访问数据库中数据的最快方法，但它也有自身的缺点。集群键上不同值的数目必须在创建hash集群之前就要知道。需要在创建hash集群的时候指定这个值。使用hash索引必须要使用hash集群。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 6.2.创建索引\n\n--普通索引normal\ncreate index emp_last_name_idx\non employees(last_name);\n--唯一索引unique\ncreate index emp_last_name_idx\non employees(last_name);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 6.3.什么时候适合索引\n\n在什么样的情况下创建索引对加快查询有利呢：\n\n> 查询条件中使用到这个列（或者这个列于其他列的组合），且这个列（或者与其他列的组合）上的数字 范围跨度很大，而大多数情况下我们要获取的数据的量占整个表的数据总量 小于4%；\n\n在什么样的情况下不适合创建索引呢：\n\n> 被查询的表本身就很小，即是是全表扫描也非常快； 或者基于这张表的查询，大多数情况下需要获取 的数据量都超过了总量的4%；或者这张表需要频繁的被更新，建立索引的话会引起索引的频繁更新，从而反而 降低数据库的整体效率。\n\n\n# 6.4.索引函数\n\n当查询语句的where条件中，对于某些列使用了函数表达式时，普通索引对查询没有帮助，如果想利用索引，则 必须创建函数索引，比如在下面的例子中，\n\nselect *\nfrom departments\nwhere upper(department_name) = 'sales'\n\n\n1\n2\n3\n\n\n对于上述查询语句，如果建立普通索引，比如create index dp_idx2 on departments(department_name) 那么上述sql执行的时候，oracle是不会走索引的，需要建立函数索引：\n\ncreate index upper_dept_name_idx on departments(upper(department_name))\n\n\n1\n\n\n\n# 7.同义词\n\n\n# 7.1.db-link（不同数据库）\n\n> database link , 如果你需要在当前数据库中访问另一个数据库中表，最简单的方法是在当前数据库中创建一个 数据库连接指向另一个数据库，然后通过@数据库连接的后缀就可以访问另一个数据库中的表了。\n\n创建 db-link，通过db-link 访问另一数据库中的\n\ncreate public database link hq.acme.com \n\nusing 'sales';\n\nselect * from emp@hq.acme.com;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 7.2.同义词\n\n当同一个数据库的a用户要访问b用户的表，需要加上前端b.table\n\n当我们要通过db-link访问另一个数据库中的某张表的时候我们需要加@后缀 @db-link-name\n\n> 为了在程序中能够简化写法，oracle 提供同义词，也就是可以在a用户下建立一个同义词指向b用户下的 table1, 以后访问的时候可以直接访问这个同义词，而不用加前缀了。\n\n\n# 7.2.创建同义词\n\ncreate synonym table1 for b.table1\n\n\n1\n\n\na用户就可以通过同义词访问b的表：\n\nselect * from table1\n\n\n1\n\n\n\n# 8.控制权限\n\n每个人登录oracle数据库都是以某个特定的数据库用户登录的，用户能否创建表？ 该用户能否访问其他用户 下面的表。。等等这些事情都是可以利用oracle的权限控制机制进行控制的。\n\n\n# 8.1.给某个用户赋予权限\n\ngrant create session //会员权限\n , create table//表权限\n , create procedure //存储过程权限\n , create sequence//序列\n , create trigger\n , create view\n , create synonym \n , alter session\nto hpos;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 8.2.添加角色\n\ncreate role manager ;  --创建manager角色\ngrant create table, create view to manager; --manager赋予创建表、视图权限\ngrant manager to dehaan, kochhar; --dehaan, kochhar拥有manager的权限\n\n\n1\n2\n3\n\n\n\n# 8.3.给用户赋予修改某个表某个字段权限\n\ngrant update (department_name, location_id)\non departments\nto scott, manager;\n\n\n1\n2\n3\n\n\n\n# 8.4.权限传递\n\n如果你想让其他用户也有权 把你赋给他的权限进一步赋予给别人，那么需要带 with grant option;\ngrant select, insert\non departments\nto scott\nwith grant option;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 8.5.所有人都有某权限\n\ngrant select\non alice.departments\nto public;\n\n\n1\n2\n3\n\n\n\n# 8.6.权限数据字典\n\n\n\n\n# 8.7.收回权限\n\nrevoke {privilege [, privilege...]|all}\non object\nfrom {user[, user...]|role|public}\n\n\n1\n2\n3\n\n\n\n# 9.oracle集合\n\n\n# 9.1.并集\n\nunion 去重\nunion all  不去重\n\n\n1\n2\n\n\n\n# 9.2.交集\n\nintersect\n\n\n1\n\n\n\n# 9.3.差集\n\nminus\n\n\n1\n\n\n\n# 10.group by子句增强\n\n\n# 10.1.rollup关键字\n\nrollup 后面跟了n个字段，就将进行n+1次分组，从右到左每次减少一个字段进行分组；然后进行 union\n\nselect department_id, job_id, sum(salary)\nfrom employees \nwhere department_id < 60\ngroup by rollup(department_id, job_id);\n\n\n1\n2\n3\n4\n\n\n查询出来的结果：从group by右边每次减少一个，所以对department_id再进行一次分组\n\n\n\n\n# 10.2.cube\n\ncube 后面跟了n个字段，就将进行2的n次方的分组运算，然后进行；\n\nselect department_id, job_id ,sum(salary)\nfrom employees \nwhere department_id < 60\ngroup by cube(department_id, job_id);  --对两个字段都额外分组\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 10.3.grouping关键字\n\n由于rollup、cube对字段进行额外的分组，可以使用grouping函数，没有被分组的列返回1，否则返回0\n\n\n\n\n# 10.4.grouping set关键字\n\n分别对（department_id,job_id）、（job_id,manager_id）进行分组\n\n--grouping sets\nselect department_id, job_id, grouping(department_id),grouping(job_id),grouping(manager_id)\n manager_id,avg(salary)\nfrom employees_copy\ngroup by grouping sets \n((department_id,job_id), (job_id,manager_id));\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n# 11.子查询进阶\n\n\n# 11.1.把查询结果当做一个表\n\n--把查询结果当做一个表\n--查询员工大于自己部门的平均工资\nselect a.last_name, a.salary, a.department_id, b.salavg\n  from employees_copy a,\n       (select department_id, avg(salary) salavg\n          from employees_copy\n         group by department_id) b\n where a.department_id = b.department_id\n   and a.salary > b.salavg;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 11.2.当做某个判断条件\n\n--查询工资大于平均工资的员工信息\nselect last_name, salary, department_id\n  from employees\n outer where salary > (select avg(salary)\n                         from employees\n                        where department_id = outer.department_id);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 11.3.exists关键字\n\n> exists(包括 not exists )子句的返回值是一个bool值。 exists内部有一个子查询语句(select ... from...)， 我将其称为exist的内查询语句。其内查询语句返回一个结果集。 exists子句根据其内查询语句的结果集空或者非空，返回一个布尔值。\n> \n> 一种通俗的可以理解为：将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则exists子句返回true，这一行行可作为外查询的结果行，否则不能作为结果。\n\nselect employee_id, last_name, job_id, department_id\n  from employees\n outer where exists\n --满足一条就执行\n (select 'x' from employees where manager_id = outer.employee_id);\n\nselect employee_id, last_name, job_id, department_id\n  from employees\n where employee_id in\n       (select manager_id from employees where manager_id is not null);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nin适合于外表大而内表小的情况；exists适合于外表小而内表大的情况。\n\n\n# 11.4.not exists\n\nselect department_id, department_name\n  from departments d\n where not exists\n (select 'x' from employees where department_id = d.department_id);\n \nselect department_id, department_name\n  from departments\n where department_id not in (select department_id from employees);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 注意：not in 里面只要有一个null ，就不成立了，这是很容易出错的地方； 正确的方法请在后 面的子查询中加上where department_id is not null\n\n\n# 11.5某个表的字段更新为另一个表的字段（慎用）\n\n员工表的department_name去查询部门表获取，通过department_id关联\n\nupdate employees e\nset department_name = \n (select department_name\n from departments d\n where e.department_id = d.department_id);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 11.6.子查询delete（不用）\n\n删除工作年限五年，并且开始时间与员工入职时间相同的\n\ndelete from job_history jh\n where employee_id =\n (select employee_id\n from employees e\n where jh.employee_id = e.employee_id\n and start_date =\n (select min(start_date) \n from job_history jh\n where jh.employee_id = e.employee_id)\n and 5 > (select count(*) \n from job_history jh\n where jh.employee_id = e.employee_id\n group by employee_id\nhaving count(*) >= 4));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 11.7.with关键字\n\n类似于取别名\n\n --with关键字\nwith dept_costs as\n (select d.department_name, sum(e.salary) as dept_total\n    from employees e, departments d\n   where e.department_id = d.department_id\n   group by d.department_name),\navg_cost as\n (select sum(dept_total) / count(*) as dept_avg from dept_costs)\n\n--使用别名\nselect *\n  from dept_costs\n where dept_total > (select dept_avg from avg_cost)\n order by department_name;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n使用with好处：\n\n> 1） 如果在后面多次使用则可以简化sql ;\n> \n>  2. 适当提高性能\n\n\n# 12.递归查询\n\n递归语句：\n\nselect [level], column, expr...\nfrom table\n[where condition(s)]\n[start with condition(s)]\n[connect by prior condition(s)] ;\n\n\nmanager_id===员工上级id  ,employee_id ===员工id\n--查找employee_id=100的下级员工\nselect last_name || ' reports to ' || prior last_name as \"列名\",\n       prior job_id as \"parent_jobid\",\n       job_id\n  from employees\n start with employee_id=100\nconnect by prior employee_id = manager_id;\n\n--查找employee_id=100的上级员工\nselect last_name || ' reports to ' || prior last_name as \"列名\",\n       prior job_id as \"parent_jobid\",\n       job_id\n  from employees\n start with employee_id=100\nconnect by prior manager_id = employee_id;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nlevel关键字和 lpad函数 ，在output中显示树形层次。\n\n--递归查找employee_id=100的下级  根据树形级别在左边填充*\nselect lpad(last_name, length(last_name) + (level * 2) - 2, '*') as org_chart,level\n  from employees\n start with employee_id = 100\nconnect by prior employee_id = manager_id\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\n# 13.insert增强（插入几个表）\n\n\n# 13.1.一个来源插入多个目标表（无条件）。\n\n--根据查询的结果分别插入到sal_history、mgr_history表\ninsert all \ninto sal_history values(empid, hiredate, sal) \ninto mgr_history values(empid, mgr, sal)\n  select employee_id empid, hire_date hiredate, salary sal, manager_id mgr\n    from employees\n   where employee_id > 200;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 13.2.一个来源插入多个目标表（有条件，首次匹配即跳到下一条）\n\n--依次匹配，插入到一个表中即可\ninsert first\n when sal > 25000 then into special_sal values(deptid, sal)\n when hiredate like ('%00%') then into hiredate_history_00 values(deptid,hiredate)\n when hiredate like ('%99%') then into hiredate_history_99 values(deptid, hiredate)\n else into hiredate_history values(deptid, hiredate)\n   select department_id deptid, sum(salary) sal,\n   max(hire_date) hiredate\n   from employees\n   group by department_id;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 14.sql进阶\n\n\n# 14.1.查询部门的平均工资、最高工资和最低工资，并且把员工都查询出来\n\n--查询根据部门名的平均工资、最高工资和最低工资（每个员工都要被查出来）\nselect e.last_name,\n       e.salary,\n       d.department_name,\n       avg(e.salary) over(partition by d.department_name) department_avg_salary,\n       max(e.salary) over(partition by d.department_name) department_max_salary,\n       min(e.salary) over(partition by d.department_name) department_min_salary\n  from employees e, departments d\n where 1 = 1\n   and e.department_id = d.department_id;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用子查询+表连接配合也可以实现：\n\nselect e1.last_name,e1.salary,e1.department_id,e2.avgfiled,e2.maxfiled,e2.minfiled \nfrom employees e1,\n(select department_id, avg(salary) as avgfiled,max(salary) as maxfiled,min(salary) as minfiled from employees group by department_id) e2,\ndepartments d \nwhere e1.department_id = e2.department_id\nand e1.department_id = d.department_id;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n# 14.2.将一个部门内的员工的工资从高到低进行排序，注意三种排序结果是不一样的。\n\n\n\n\n# 14.3.oracle的闪回机制\n\n> oracle数据库中提供一种机制可以用来查询之前一段时间内修改行原先的值，比如我们错误的提 交了修改结果，现在又想查看修改行原来的值，这时候就可以使用闪回。\n\n--通过as of timestamp sysdate-5/(24*60)  回退到五分钟前\nselect * from departments as of timestamp sysdate-5/(24*60) \nwhere department_name = 'sales';\n\n\n1\n2\n3\n\n\n查询被删除的department_name = 'sales'并还原数据\n\n--开始有数据\nselect * from departments where department_name = 'sales';\n\n--删除\ndelete from departments where department_name = 'sales';\ncommmit;\n\n--查询数据已经被删除\nselect * from departments where department_name = 'sales';\n\n--闪回到5分钟之前，再执行下查询试试有没有结果。\nselect * from departments as of timestamp sysdate-5/(24*60) \nwhere department_name = 'sales';\n\n--还原数据\ninsert into departments \nselect * from departments as of timestamp sysdate-5/(24*60) \nwhere department_name = 'sales';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"SQL调优简介",frontmatter:{title:"SQL调优简介",date:"2021-07-16T10:05:32.000Z",permalink:"/pages/f59efe/",categories:["后端","数据库","Oracle"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/20.%E6%95%B0%E6%8D%AE%E5%BA%93/01.Oracle/03.SQL%E8%B0%83%E4%BC%98%E7%AE%80%E4%BB%8B.html",relativePath:"01.后端/20.数据库/01.Oracle/03.SQL调优简介.md",key:"v-dc38c17c",path:"/pages/f59efe/",headers:[{level:2,title:"1.索引",slug:"_1-索引",normalizedTitle:"1.索引",charIndex:3217},{level:3,title:"索引的建立",slug:"索引的建立",normalizedTitle:"索引的建立",charIndex:3226},{level:3,title:"遇到的问题",slug:"遇到的问题",normalizedTitle:"遇到的问题",charIndex:3446},{level:3,title:"索引的使用",slug:"索引的使用",normalizedTitle:"索引的使用",charIndex:4652},{level:2,title:"2.索引失效",slug:"_2-索引失效",normalizedTitle:"2.索引失效",charIndex:5437},{level:2,title:"3.SQL优化",slug:"_3-sql优化",normalizedTitle:"3.sql优化",charIndex:6078},{level:2,title:"4.查看执行计划",slug:"_4-查看执行计划",normalizedTitle:"4.查看执行计划",charIndex:7453}],headersStr:"1.索引 索引的建立 遇到的问题 索引的使用 2.索引失效 3.SQL优化 4.查看执行计划",content:"# SQL调优简介\n\n\n# 前言\n\n实际项目开发过程中会遇到很多的性能问题。针对这些问题，不外乎以下几种解决途径：\n\n1.服务层：硬件扩容，负载均衡等方式，保证每个请求能及时得到响应；\n\n2.代码层：项目前期开发过程中，可能会遗留下不好的代码，比如多层for循环嵌套，这些代码增加了代码的复杂度，当编译器执行到这些代码时，需要耗费很大的资源与时间。针对代码的优化，可以使用 sonarqube ，这个软件能帮你检测出代码中隐藏的问题，包括但不限于空指针风险，代码复杂度过高等一系列问题；\n\n3.数据层：数据层优化又可以分为多个方向；\n\n使用缓存：缓存是个很好的技术架构，他允许用户在启动项目时把一些数据加载到缓存中，当你要用到这些数据时，直接在缓存中查找，而不需要再次链接数据库执行sql查询语句。需要注意的是，缓存的数据一般要求是变动较小的数据，比如公司的组织架构，员工的信息等；\n\nSQL优化：这种方式可以视作java层的代码优化。同样的查询要求，可以有多种写法，那么如何去分辨哪一种写法更加合适呢？这是本文着重要讲的。\n\n\n# 索引原则\n\n> 1、索引应该经常建在Where 子句经常用到的列上。如果某个大表经常使用某个字段进行查询，并且检索行数小于总表行数的5%。则应该考虑。\n> \n> 2、对于两表连接的字段，应该建立索引。如果经常在某表的一个字段进行Order By 则也经过进行索引。\n> \n> 3、不应该在小表上建设索引。\n\n优缺点: 　1、索引主要进行提高数据的查询速度。 当进行DML时，会更新索引。因此索引越多，则DML越慢，其需要维护索引。 因此在创建索引及DML需要权衡。\n\n创建索引: 　单一索引:Create Index On <Table_Name>(Column_Name);\n\n复合索引: Create Index i_deptno_job on emp(deptno,job); —>在emp表的deptno、job列建立索引。\n\nselect * from emp where deptno=66 and job='sals' ->走索引。\n\nselect * from emp where deptno=66 OR job='sals' ->将进行全表扫描。不走索引\n\nselect * from emp where deptno=66 ->走索引。\n\nselect * from emp where job='sals' ->进行全表扫描、不走索引。\n\n如果在where 子句中有OR 操作符或单独引用Job 列(索引列的后面列) 则将不会走索引，将会进行全表扫描。\n\n\n# 查询优化\n\nSQL优化的方式不外乎两种，一是建立索引，避免全表扫描，另一种就是优化编写的SQL语句\n\n当Oracle数据库拿到SQL语句时，其会根据查询优化器分析该语句，并根据分析结果生成查询执行计划。 也就是说，数据库是执行的查询计划，而不是Sql语句。 查询优化器有rule-based-optimizer(基于规则的查询优化器) 和Cost-Based-optimizer(基于成本的查询优化器)。 其中基于规则的查询优化器在10g版本中消失。 对于规则查询，其最后查询的是全表扫描。而CBO则会根据统计信息进行最后的选择。\n\n1、先执行From ->Where ->Group By->Order By\n\n2、执行From 字句是从右往左进行执行。因此必须选择记录条数最少的表放在右边。这是为什么呢？\n\n3、对于Where字句其执行顺序是从后向前执行、因此可以过滤最大数量记录的条件必须写在Where子句的末尾，而对于多表之间的连接，则写在之前。 因为这样进行连接时，可以去掉大多不重复的项。\n\n\\4. SELECT子句中避免使用()ORACLE在解析的过程中, 会将’’ 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间\n\n5、索引失效的情况: 　① Not Null/Null 如果某列建立索引,当进行Select * from emp where depto is not null/is null。 则会是索引失效。 　② 索引列上不要使用函数,SELECT Col FROM tbl WHERE substr(name ,1 ,3 ) = 'ABC' 或者SELECT Col FROM tbl WHERE name LIKE '%ABC%' 而SELECT Col FROM tbl WHERE name LIKE 'ABC%' 会使用索引。\n\n③ 索引列上不能进行计算SELECT Col FROM tbl WHERE col / 10 > 10 则会使索引失效，应该改成 SELECT Col FROM tbl WHERE col > 10 * 10\n\n④ 索引列上不要使用NOT （ != 、 <> ）如:SELECT Col FROM tbl WHERE col ! = 10 应该 改成：SELECT Col FROM tbl WHERE col > 10 OR col < 10 。\n\n6、用UNION替换OR(适用于索引列) 　 union:是将两个查询的结果集进行追加在一起，它不会引起列的变化。 由于是追加操作，需要两个结果集的列数应该是相关的， 并且相应列的数据类型也应该相当的。union 返回两个结果集，同时将两个结果集重复的项进行消除。 如果不进行消除，用UNOIN ALL.\n\n通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果. 对索引列使用OR将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低. 在下面的例子中, LOC_ID 和REGION上都建有索引.\n\n高效: 　　SELECT LOC_ID , LOC_DESC , REGION 　　FROM LOCATION 　　WHERE LOC_ID = 10 　　UNION 　　SELECT LOC_ID , LOC_DESC , REGION 　　FROM LOCATION 　　WHERE REGION = “MELBOURNE”\n\n低效: 　　SELECT LOC_ID , LOC_DESC , REGION 　　FROM LOCATION 　　WHERE LOC_ID = 10 OR REGION = “MELBOURNE” 　　如果你坚持要用OR, 那就需要返回记录最少的索引列写在最前面.\n\n\\7. 用EXISTS替代IN、用NOT EXISTS替代NOT IN 在许多基于基础表的查询中, 为了满足一个条件, 往往需要对另一个表进行联接. 在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率. 在子查询中, NOT IN子句将执行一个内部的排序和合并. 无论在哪种情况下, NOT IN都是最低效的(因为它对子查询中的表执行了一个全表遍历). 为了避免使用NOT IN, 我们可以把它改写成外连接(Outer Joins)或NOT EXISTS.\n\n例子：\n\n高效: SELECT * FROM EMP (基础表) WHERE EMPNO > 0 AND EXISTS (SELECT ‘X’ FROM DEPT WHERE DEPT.DEPTNO = EMP.DEPTNO AND LOC = ‘MELB’)\n\n低效: SELECT * FROM EMP (基础表) WHERE EMPNO > 0 AND DEPTNO IN(SELECT DEPTNO FROM DEPT WHERE LOC = ‘MELB’)\n\n\n# 1.索引\n\n\n# 索引的建立\n\n创建索引的方式很简单\n\ncreate [unique] index index_name on table_name(column1,column2,...);\n\n\n1\n\n\n上述的语句就是一个标准的索引创建语句，索引可以分为两种，普通索引和唯一索引。\n\n普通索引唯一的作用就是加快查询速率，加索引的列值可为空，可重复；\n\n唯一索引比普通索引多了个唯一值的限定，列值可为空，如果唯一索引是组合索引的话，要求组合值也唯一\n\n\n# 遇到的问题\n\n# 问题一：\n\n创建唯一索引的时候报错，起初以为是有一个重复的索引名字，换了几个名字都不行，最后发现是应该建立的符合索引存在重复的列；\n\n> 解决：删除表中重复的数据\n> \n> 例 :表中有两个字段 id,year,创建唯一联合索引,出现上面的错误,可通过下面的语句删除重复的记录并在重复记录中只保留最小rowid的记录.\n> \n> DELETE FROM 表名 A WHERE (A.ID,A.YEAR) IN (SELECT ID,YEAR FROM 表名 GROUP BY ID,YEAR HAVING COUNT(*) > 1) AND ROWID NOT IN (SELECT MIN(ROWID) FROM 表名 GROUP BY ID,YEAR HAVING COUNT(*)>1);\n> commit;\n> \n> \n> 1\n> 2\n> \n> \n> 执行完上述语句后,再次执行创建唯一索引的语句就不会报错了.\n\n1.遇到问题过程：\n\n\n\n2.最后发现合同信息-20826有重复的数据两条：\n\nselect region_name,DOC_REGION_ID,count(*) from CMF_BASE_DOC_REGIONS_WCY group by region_name,DOC_REGION_ID HAVING COUNT(*) > 1\n\n\n1\n\n\n\n\n3.删除重复的记录并在重复记录中只保留最小rowid的记录.\n\nDELETE FROM CMF_BASE_DOC_REGIONS_WCY A \nWHERE (A.region_name,A.DOC_REGION_ID) IN \n(SELECT region_name,DOC_REGION_ID FROM CMF_BASE_DOC_REGIONS_WCY GROUP BY region_name,DOC_REGION_ID HAVING COUNT(*) > 1) \nAND ROWID NOT IN (SELECT MIN(ROWID) FROM CMF_BASE_DOC_REGIONS_WCY GROUP BY region_name,DOC_REGION_ID HAVING COUNT(*)>1);\n\n\n1\n2\n3\n4\n\n\n4.创建索引(成功)\n\ncreate unique index CMF_BASE_DOC_REGIONS_WCY_U2 on CMF_BASE_DOC_REGIONS_WCY(region_name,DOC_REGION_ID)\n\n\n1\n\n\n# 问题二：\n\n> 创建了(region_name,DOC_REGION_ID)的组合索引，但是region_name like '客户%'未走索引\n\n解决：\n\n> 不要select *,由于花费了大量的时间去查找列，导致未走索引\n\n\n\n\n# 索引的使用\n\n给大家看个例子\n\n查询dept表，限制条件为department_name = '20'，这个查询很简单，但是在查看执行计划后，发现是全表扫描的，假设这张表的数据量很大，那么再执行这条sql锁花费的时间必然同步上升。具体表现会在cost和bytes列体现出来。\n\n现在我们更改下查询条件，用department_id来查询。再次查看执行计划，这次不再是全表扫描了，而是走了索引。在dept表的department列添加了唯一索引约束，当在执行查询sql时，编译器会通过department_id这列的索引访问，大大降低的查询的消耗，提升了查询速率。\n\n上述例子中可以看到，索引对于查询效率有着显著的提升。那么，是不是索引越多越好呢？索引什么时候建立呢？\n\n对于第一个问题，索引是不是越多越好，我们先假设是，那应该把所有字段都建立起索引，对于ORACLE公司来说，那直接把表所有的字段变成索引不就行了，何必让用户在一个个的手动去建立呢？\n\n实际情况与上述的假设恰恰相反，索引并不是越多越好。\n\n每个索引的建立，都需要消耗数据库的资源，索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上，并且当字段值更新时，索引也会同步更新，从而减低的更新速度。\n\n索引的建立原则：\n\n1、装载数据后再建立索引\n\n2、频繁搜索的列可以作为索引\n\n3、在联接属性上建立索引\n\n4、经常排序分组的列\n\n5、删除不经常使用的索引\n\n6、指定索引块的参数，如果将来会在表上执行大量的insert操作，建立索引时设定较大的ptcfree\n\n7、指定索引所在的表空间，将表和索引放在不同的表空间上可以提高性能\n\n8、对大型索引，考虑使用NOLOGGING子句创建大型索引\n\n不要在下面的列创建索引：\n\n1、仅包含几个不同值得列\n\n2、表中仅包含几条记录\n\n\n# 2.索引失效\n\n在某些情况下，已经添加了索引，但是在实际执行过程中，并没有走索引，针对这种情况，主要总结了以下几种\n\n 1.  <> ， !=\n\n 2.  单独的>,<,(查询的数据量占总量超过10%)\n\n 3.  like \"%_\" 百分号在前.\n\n 4.  表没分析.\n\n 5.  单独引用复合索引里非第一位置的索引列.\n\n 6.  字符型字段为数字时在where条件里不添加引号（隐式类型转换）.\n\n 7.  对索引列进行运算，索引列使用了函数.\n\n 8.  not in ,not exist.\n\n 9.  当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况。\n\n 10. 索引失效。\n\n 11. 基于cost成本分析(oracle因为走全表成本会更小)：查询小表,或者返回值大概在10%以上\n\n 12. B-tree索引 is null不会走,is not null会走，位图索引 is null,is not null 都会走\n\n 13. 联合索引 is not null 只要在建立的索引列（不分先后）都会走, is null时 必须要和建立索引第一列一起使用,当建立索引第一位置条件是is null 时,其他建立索引的列可以是is null（但必须在所有列都满足is null的时候）,或者=一个值； 当建立索引的第一位置是=一个值时,其他索引列可以是任何情况（包括is null =一个值）,以上两种情况索引都会走。其他情况不会走\n\n\n# 3.SQL优化\n\n除了添加索引，sql语句优化也能提高查询效率，那么如何去优化SQL呢？\n\n 1. 表连接顺序：\n\nORACLE的解析器按照从右到左的顺序处理FROM子句中的表名，因此FROM子句中写在最后的表(基础表 driving table)将被最先处理\n\n在FROM子句中包含多个表的情况下，选择记录条数最少的表作为基础表。当ORACLE处理多个表时，会运用排序及合并的方式连接它们。首先，扫描第一个表(FROM子句中最后的那个表)并对记录进行派序，然后扫描第二个表(FROM子句中最后第二个表)，最后将所有从第二个表中检索出的记录与第一个表中合适记录进行合并\n\n如果有3个以上的表连接查询，那就需要选择交叉表作为基础表，交叉表是指那个被其他表所引用的表\n\n 2. WHERE子句中的连接顺序\n\nORACLE采用自下而上的顺序解析WHERE子句，根据这个原理,表之间的连接写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾\n\n 3. SELECT子句中避免使用 ‘ * ‘\n    \n    当你想在SELECT子句中列出所有的列时，使用动态SQL列引用 * 是一个方便的方法。\n    \n    实际上，ORACLE在解析的过程中，会将 * 依次转换成所有的列名, 这个工作是通过查询数据字典完成的， 这意味着将耗费更多的时间\n\n 4. 用Where子句替换HAVING子句\n\n避免使用HAVING子句，HAVING 只会在检索出所有记录之后才对结果集进行过滤。 这个处理需要排序，总计等操作。 如果能通过WHERE子句限制记录的数目,那就能减少这方面的开销\n\n 5. 使用表的别名\n\n当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上。这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误\n\n 6. SQL语句用大写的\n    \n    因为Oracle总是先解析SQL语句，把小写的字母转换成大写的再执行\n\n 7. 避免在索引列上使用NOT，通常，我们要避免在索引列上使用NOT, NOT会产生在和在索引列上使用函数相同的影响。当Oracle“遇到”NOT,他就会停止使用索引转而执行全表扫描\n\n 8. 避免在索引列上使用计算与函数，WHERE子句中，如果索引列是函数的一部分。优化器将不使用索引而使用全表扫描\n\n 9. 用>=替代>：\n\n高效：SELECT * FROM EMP WHERE DEPTNO >=4 低效: SELECT * FROM EMP WHERE DEPTNO >3\n\n 10. 用UNION替换OR ，IN来替换OR\n\n 11. 避免在索引列上使用 IS NULL 和 IS NOT NULL\n\n 12. 用UNION-ALL 替换UNION ( 如果有可能的话)；\n\n当SQL语句需要UNION两个查询结果集合时，这两个结果集合会以UNION-ALL的方式被合并，然后在输出最终结果前进行排序。如果用UNION ALL替代UNION，这样排序就不是必要了。效率就会因此得到提高。需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录。\n\n 13. 减少与DB交互次数\n 14. 多使用commit命令\n\n\n# 4.查看执行计划",normalizedContent:"# sql调优简介\n\n\n# 前言\n\n实际项目开发过程中会遇到很多的性能问题。针对这些问题，不外乎以下几种解决途径：\n\n1.服务层：硬件扩容，负载均衡等方式，保证每个请求能及时得到响应；\n\n2.代码层：项目前期开发过程中，可能会遗留下不好的代码，比如多层for循环嵌套，这些代码增加了代码的复杂度，当编译器执行到这些代码时，需要耗费很大的资源与时间。针对代码的优化，可以使用 sonarqube ，这个软件能帮你检测出代码中隐藏的问题，包括但不限于空指针风险，代码复杂度过高等一系列问题；\n\n3.数据层：数据层优化又可以分为多个方向；\n\n使用缓存：缓存是个很好的技术架构，他允许用户在启动项目时把一些数据加载到缓存中，当你要用到这些数据时，直接在缓存中查找，而不需要再次链接数据库执行sql查询语句。需要注意的是，缓存的数据一般要求是变动较小的数据，比如公司的组织架构，员工的信息等；\n\nsql优化：这种方式可以视作java层的代码优化。同样的查询要求，可以有多种写法，那么如何去分辨哪一种写法更加合适呢？这是本文着重要讲的。\n\n\n# 索引原则\n\n> 1、索引应该经常建在where 子句经常用到的列上。如果某个大表经常使用某个字段进行查询，并且检索行数小于总表行数的5%。则应该考虑。\n> \n> 2、对于两表连接的字段，应该建立索引。如果经常在某表的一个字段进行order by 则也经过进行索引。\n> \n> 3、不应该在小表上建设索引。\n\n优缺点: 　1、索引主要进行提高数据的查询速度。 当进行dml时，会更新索引。因此索引越多，则dml越慢，其需要维护索引。 因此在创建索引及dml需要权衡。\n\n创建索引: 　单一索引:create index on <table_name>(column_name);\n\n复合索引: create index i_deptno_job on emp(deptno,job); —>在emp表的deptno、job列建立索引。\n\nselect * from emp where deptno=66 and job='sals' ->走索引。\n\nselect * from emp where deptno=66 or job='sals' ->将进行全表扫描。不走索引\n\nselect * from emp where deptno=66 ->走索引。\n\nselect * from emp where job='sals' ->进行全表扫描、不走索引。\n\n如果在where 子句中有or 操作符或单独引用job 列(索引列的后面列) 则将不会走索引，将会进行全表扫描。\n\n\n# 查询优化\n\nsql优化的方式不外乎两种，一是建立索引，避免全表扫描，另一种就是优化编写的sql语句\n\n当oracle数据库拿到sql语句时，其会根据查询优化器分析该语句，并根据分析结果生成查询执行计划。 也就是说，数据库是执行的查询计划，而不是sql语句。 查询优化器有rule-based-optimizer(基于规则的查询优化器) 和cost-based-optimizer(基于成本的查询优化器)。 其中基于规则的查询优化器在10g版本中消失。 对于规则查询，其最后查询的是全表扫描。而cbo则会根据统计信息进行最后的选择。\n\n1、先执行from ->where ->group by->order by\n\n2、执行from 字句是从右往左进行执行。因此必须选择记录条数最少的表放在右边。这是为什么呢？\n\n3、对于where字句其执行顺序是从后向前执行、因此可以过滤最大数量记录的条件必须写在where子句的末尾，而对于多表之间的连接，则写在之前。 因为这样进行连接时，可以去掉大多不重复的项。\n\n\\4. select子句中避免使用()oracle在解析的过程中, 会将’’ 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间\n\n5、索引失效的情况: 　① not null/null 如果某列建立索引,当进行select * from emp where depto is not null/is null。 则会是索引失效。 　② 索引列上不要使用函数,select col from tbl where substr(name ,1 ,3 ) = 'abc' 或者select col from tbl where name like '%abc%' 而select col from tbl where name like 'abc%' 会使用索引。\n\n③ 索引列上不能进行计算select col from tbl where col / 10 > 10 则会使索引失效，应该改成 select col from tbl where col > 10 * 10\n\n④ 索引列上不要使用not （ != 、 <> ）如:select col from tbl where col ! = 10 应该 改成：select col from tbl where col > 10 or col < 10 。\n\n6、用union替换or(适用于索引列) 　 union:是将两个查询的结果集进行追加在一起，它不会引起列的变化。 由于是追加操作，需要两个结果集的列数应该是相关的， 并且相应列的数据类型也应该相当的。union 返回两个结果集，同时将两个结果集重复的项进行消除。 如果不进行消除，用unoin all.\n\n通常情况下, 用union替换where子句中的or将会起到较好的效果. 对索引列使用or将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有column没有被索引, 查询效率可能会因为你没有选择or而降低. 在下面的例子中, loc_id 和region上都建有索引.\n\n高效: 　　select loc_id , loc_desc , region 　　from location 　　where loc_id = 10 　　union 　　select loc_id , loc_desc , region 　　from location 　　where region = “melbourne”\n\n低效: 　　select loc_id , loc_desc , region 　　from location 　　where loc_id = 10 or region = “melbourne” 　　如果你坚持要用or, 那就需要返回记录最少的索引列写在最前面.\n\n\\7. 用exists替代in、用not exists替代not in 在许多基于基础表的查询中, 为了满足一个条件, 往往需要对另一个表进行联接. 在这种情况下, 使用exists(或not exists)通常将提高查询的效率. 在子查询中, not in子句将执行一个内部的排序和合并. 无论在哪种情况下, not in都是最低效的(因为它对子查询中的表执行了一个全表遍历). 为了避免使用not in, 我们可以把它改写成外连接(outer joins)或not exists.\n\n例子：\n\n高效: select * from emp (基础表) where empno > 0 and exists (select ‘x’ from dept where dept.deptno = emp.deptno and loc = ‘melb’)\n\n低效: select * from emp (基础表) where empno > 0 and deptno in(select deptno from dept where loc = ‘melb’)\n\n\n# 1.索引\n\n\n# 索引的建立\n\n创建索引的方式很简单\n\ncreate [unique] index index_name on table_name(column1,column2,...);\n\n\n1\n\n\n上述的语句就是一个标准的索引创建语句，索引可以分为两种，普通索引和唯一索引。\n\n普通索引唯一的作用就是加快查询速率，加索引的列值可为空，可重复；\n\n唯一索引比普通索引多了个唯一值的限定，列值可为空，如果唯一索引是组合索引的话，要求组合值也唯一\n\n\n# 遇到的问题\n\n# 问题一：\n\n创建唯一索引的时候报错，起初以为是有一个重复的索引名字，换了几个名字都不行，最后发现是应该建立的符合索引存在重复的列；\n\n> 解决：删除表中重复的数据\n> \n> 例 :表中有两个字段 id,year,创建唯一联合索引,出现上面的错误,可通过下面的语句删除重复的记录并在重复记录中只保留最小rowid的记录.\n> \n> delete from 表名 a where (a.id,a.year) in (select id,year from 表名 group by id,year having count(*) > 1) and rowid not in (select min(rowid) from 表名 group by id,year having count(*)>1);\n> commit;\n> \n> \n> 1\n> 2\n> \n> \n> 执行完上述语句后,再次执行创建唯一索引的语句就不会报错了.\n\n1.遇到问题过程：\n\n\n\n2.最后发现合同信息-20826有重复的数据两条：\n\nselect region_name,doc_region_id,count(*) from cmf_base_doc_regions_wcy group by region_name,doc_region_id having count(*) > 1\n\n\n1\n\n\n\n\n3.删除重复的记录并在重复记录中只保留最小rowid的记录.\n\ndelete from cmf_base_doc_regions_wcy a \nwhere (a.region_name,a.doc_region_id) in \n(select region_name,doc_region_id from cmf_base_doc_regions_wcy group by region_name,doc_region_id having count(*) > 1) \nand rowid not in (select min(rowid) from cmf_base_doc_regions_wcy group by region_name,doc_region_id having count(*)>1);\n\n\n1\n2\n3\n4\n\n\n4.创建索引(成功)\n\ncreate unique index cmf_base_doc_regions_wcy_u2 on cmf_base_doc_regions_wcy(region_name,doc_region_id)\n\n\n1\n\n\n# 问题二：\n\n> 创建了(region_name,doc_region_id)的组合索引，但是region_name like '客户%'未走索引\n\n解决：\n\n> 不要select *,由于花费了大量的时间去查找列，导致未走索引\n\n\n\n\n# 索引的使用\n\n给大家看个例子\n\n查询dept表，限制条件为department_name = '20'，这个查询很简单，但是在查看执行计划后，发现是全表扫描的，假设这张表的数据量很大，那么再执行这条sql锁花费的时间必然同步上升。具体表现会在cost和bytes列体现出来。\n\n现在我们更改下查询条件，用department_id来查询。再次查看执行计划，这次不再是全表扫描了，而是走了索引。在dept表的department列添加了唯一索引约束，当在执行查询sql时，编译器会通过department_id这列的索引访问，大大降低的查询的消耗，提升了查询速率。\n\n上述例子中可以看到，索引对于查询效率有着显著的提升。那么，是不是索引越多越好呢？索引什么时候建立呢？\n\n对于第一个问题，索引是不是越多越好，我们先假设是，那应该把所有字段都建立起索引，对于oracle公司来说，那直接把表所有的字段变成索引不就行了，何必让用户在一个个的手动去建立呢？\n\n实际情况与上述的假设恰恰相反，索引并不是越多越好。\n\n每个索引的建立，都需要消耗数据库的资源，索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上，并且当字段值更新时，索引也会同步更新，从而减低的更新速度。\n\n索引的建立原则：\n\n1、装载数据后再建立索引\n\n2、频繁搜索的列可以作为索引\n\n3、在联接属性上建立索引\n\n4、经常排序分组的列\n\n5、删除不经常使用的索引\n\n6、指定索引块的参数，如果将来会在表上执行大量的insert操作，建立索引时设定较大的ptcfree\n\n7、指定索引所在的表空间，将表和索引放在不同的表空间上可以提高性能\n\n8、对大型索引，考虑使用nologging子句创建大型索引\n\n不要在下面的列创建索引：\n\n1、仅包含几个不同值得列\n\n2、表中仅包含几条记录\n\n\n# 2.索引失效\n\n在某些情况下，已经添加了索引，但是在实际执行过程中，并没有走索引，针对这种情况，主要总结了以下几种\n\n 1.  <> ， !=\n\n 2.  单独的>,<,(查询的数据量占总量超过10%)\n\n 3.  like \"%_\" 百分号在前.\n\n 4.  表没分析.\n\n 5.  单独引用复合索引里非第一位置的索引列.\n\n 6.  字符型字段为数字时在where条件里不添加引号（隐式类型转换）.\n\n 7.  对索引列进行运算，索引列使用了函数.\n\n 8.  not in ,not exist.\n\n 9.  当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况。\n\n 10. 索引失效。\n\n 11. 基于cost成本分析(oracle因为走全表成本会更小)：查询小表,或者返回值大概在10%以上\n\n 12. b-tree索引 is null不会走,is not null会走，位图索引 is null,is not null 都会走\n\n 13. 联合索引 is not null 只要在建立的索引列（不分先后）都会走, is null时 必须要和建立索引第一列一起使用,当建立索引第一位置条件是is null 时,其他建立索引的列可以是is null（但必须在所有列都满足is null的时候）,或者=一个值； 当建立索引的第一位置是=一个值时,其他索引列可以是任何情况（包括is null =一个值）,以上两种情况索引都会走。其他情况不会走\n\n\n# 3.sql优化\n\n除了添加索引，sql语句优化也能提高查询效率，那么如何去优化sql呢？\n\n 1. 表连接顺序：\n\noracle的解析器按照从右到左的顺序处理from子句中的表名，因此from子句中写在最后的表(基础表 driving table)将被最先处理\n\n在from子句中包含多个表的情况下，选择记录条数最少的表作为基础表。当oracle处理多个表时，会运用排序及合并的方式连接它们。首先，扫描第一个表(from子句中最后的那个表)并对记录进行派序，然后扫描第二个表(from子句中最后第二个表)，最后将所有从第二个表中检索出的记录与第一个表中合适记录进行合并\n\n如果有3个以上的表连接查询，那就需要选择交叉表作为基础表，交叉表是指那个被其他表所引用的表\n\n 2. where子句中的连接顺序\n\noracle采用自下而上的顺序解析where子句，根据这个原理,表之间的连接写在其他where条件之前, 那些可以过滤掉最大数量记录的条件必须写在where子句的末尾\n\n 3. select子句中避免使用 ‘ * ‘\n    \n    当你想在select子句中列出所有的列时，使用动态sql列引用 * 是一个方便的方法。\n    \n    实际上，oracle在解析的过程中，会将 * 依次转换成所有的列名, 这个工作是通过查询数据字典完成的， 这意味着将耗费更多的时间\n\n 4. 用where子句替换having子句\n\n避免使用having子句，having 只会在检索出所有记录之后才对结果集进行过滤。 这个处理需要排序，总计等操作。 如果能通过where子句限制记录的数目,那就能减少这方面的开销\n\n 5. 使用表的别名\n\n当在sql语句中连接多个表时，请使用表的别名并把别名前缀于每个column上。这样一来,就可以减少解析的时间并减少那些由column歧义引起的语法错误\n\n 6. sql语句用大写的\n    \n    因为oracle总是先解析sql语句，把小写的字母转换成大写的再执行\n\n 7. 避免在索引列上使用not，通常，我们要避免在索引列上使用not, not会产生在和在索引列上使用函数相同的影响。当oracle“遇到”not,他就会停止使用索引转而执行全表扫描\n\n 8. 避免在索引列上使用计算与函数，where子句中，如果索引列是函数的一部分。优化器将不使用索引而使用全表扫描\n\n 9. 用>=替代>：\n\n高效：select * from emp where deptno >=4 低效: select * from emp where deptno >3\n\n 10. 用union替换or ，in来替换or\n\n 11. 避免在索引列上使用 is null 和 is not null\n\n 12. 用union-all 替换union ( 如果有可能的话)；\n\n当sql语句需要union两个查询结果集合时，这两个结果集合会以union-all的方式被合并，然后在输出最终结果前进行排序。如果用union all替代union，这样排序就不是必要了。效率就会因此得到提高。需要注意的是，union all 将重复输出两个结果集合中相同记录。\n\n 13. 减少与db交互次数\n 14. 多使用commit命令\n\n\n# 4.查看执行计划",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"oracle锁表",frontmatter:{title:"oracle锁表",date:"2021-12-15T18:33:45.000Z",permalink:"/pages/78011c/",categories:["后端","数据库","Oracle"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/20.%E6%95%B0%E6%8D%AE%E5%BA%93/01.Oracle/04.oracle%E9%94%81%E8%A1%A8.html",relativePath:"01.后端/20.数据库/01.Oracle/04.oracle锁表.md",key:"v-1e2f1c3d",path:"/pages/78011c/",headersStr:null,content:"--查看锁表情况\nSELECT A.USERNAME,\n       A.MACHINE,\n       A.PROGRAM,\n       A.SID,\n       A.SERIAL#,\n       A.STATUS,\n       C.PIECE,\n       C.SQL_TEXT\n  FROM V$SESSION A, V$SQLTEXT C\n WHERE A.SID IN (SELECT DISTINCT T2.SID\n                   FROM V$LOCKED_OBJECT T1, V$SESSION T2\n                  WHERE T1.SESSION_ID = T2.SID)\n   AND A.SQL_ADDRESS = C.ADDRESS(+)\n ORDER BY C.PIECE;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n alter system kill session '313,62086';--分别为SID和SERIAL#号\n\n\n1\n\n\n新版\n\nselect a.object_name,\nb.session_id,\nc.serial#,\nc.program,\nc.username,\nc.command,\nc.machine,\nc.lockwait,\nc.inst_id,\nb.Locked_mode,\nc.blocking_instance,\nc.blocking_session,\n'alter system kill session '''|| b.session_id ||','|| c.serial# || ',@' || c.inst_id ||'''' kill_sql,\nc.SQL_EXEC_START,\nc.sql_address,\nc.sql_hash_value,\nc.sql_id,\nb.*,\nc.*\nfrom dba_objects a, gv$locked_object b, gv$session c\nwhere a.object_id = b.object_id\nand c.sid = b.session_id\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",normalizedContent:"--查看锁表情况\nselect a.username,\n       a.machine,\n       a.program,\n       a.sid,\n       a.serial#,\n       a.status,\n       c.piece,\n       c.sql_text\n  from v$session a, v$sqltext c\n where a.sid in (select distinct t2.sid\n                   from v$locked_object t1, v$session t2\n                  where t1.session_id = t2.sid)\n   and a.sql_address = c.address(+)\n order by c.piece;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n alter system kill session '313,62086';--分别为sid和serial#号\n\n\n1\n\n\n新版\n\nselect a.object_name,\nb.session_id,\nc.serial#,\nc.program,\nc.username,\nc.command,\nc.machine,\nc.lockwait,\nc.inst_id,\nb.locked_mode,\nc.blocking_instance,\nc.blocking_session,\n'alter system kill session '''|| b.session_id ||','|| c.serial# || ',@' || c.inst_id ||'''' kill_sql,\nc.sql_exec_start,\nc.sql_address,\nc.sql_hash_value,\nc.sql_id,\nb.*,\nc.*\nfrom dba_objects a, gv$locked_object b, gv$session c\nwhere a.object_id = b.object_id\nand c.sid = b.session_id\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",charsets:{cjk:!0}},{title:"Linux",frontmatter:{title:"Linux",date:"2021-07-09T13:21:34.000Z",permalink:"/pages/44c61f/",categories:["后端","linux"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/30.linux/00.Linux.html",relativePath:"01.后端/30.linux/00.Linux.md",key:"v-030111c0",path:"/pages/44c61f/",headers:[{level:2,title:"1.lsof 列出某个程序所打开的文件信息",slug:"_1-lsof-列出某个程序所打开的文件信息",normalizedTitle:"1.lsof 列出某个程序所打开的文件信息",charIndex:12},{level:2,title:"2.grep 查找文件里符合条件的字符串",slug:"_2-grep-查找文件里符合条件的字符串",normalizedTitle:"2.grep 查找文件里符合条件的字符串",charIndex:74},{level:2,title:"3.df 查看磁盘情况",slug:"_3-df-查看磁盘情况",normalizedTitle:"3.df 查看磁盘情况",charIndex:186},{level:2,title:"4.查看文件前几行、后几行等等",slug:"_4-查看文件前几行、后几行等等",normalizedTitle:"4.查看文件前几行、后几行等等",charIndex:202},{level:2,title:"5.将一个目录下指定的所有文件中的字符串A全部替换为B",slug:"_5-将一个目录下指定的所有文件中的字符串a全部替换为b",normalizedTitle:"5.将一个目录下指定的所有文件中的字符串a全部替换为b",charIndex:642}],headersStr:"1.lsof 列出某个程序所打开的文件信息 2.grep 查找文件里符合条件的字符串 3.df 查看磁盘情况 4.查看文件前几行、后几行等等 5.将一个目录下指定的所有文件中的字符串A全部替换为B",content:"# Linux\n\n\n# 1.lsof 列出某个程序所打开的文件信息\n\n列出某个程序所打开的文件信息\n\nlsof -c mysql\n\n\n1\n\n\n\n# 2.grep 查找文件里符合条件的字符串\n\n在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：\n\ngrep test *file \n\n\n1\n\n\n\n# 3.df 查看磁盘情况\n\n\n# 4.查看文件前几行、后几行等等\n\n * 查看文件 查看/home/user/test.txt\n\ncat /home/user/test.txt\n\n\n1\n\n * 查看文件开头几行 查看/home/user/test.txt的前20行\n\nhead -n 20 /home/user/test.txt\n\n\n1\n\n * 查看末尾几行 查看/home/user/test.txt的最后10行\n\ntail -n 10 /home/user/test.txt\n\n\n1\n\n * 查看中间几行 查看/home/user/test.txt的10~20行\n\ncat /home/user/test.txt| head -n 20 | tail -n +10 \n\nhead -n 20 表示前20行\ntail -n 10 表示后10行\ntail -n +10 表示第10行之后的\n\n\n1\n2\n3\n4\n5\n\n\n或\n\nsed -n '10,20p' /home/user/test.txt\n\n\n1\n\n\n\n# 5.将一个目录下指定的所有文件中的字符串A全部替换为B\n\nsed -i \"s/A/B/g\" `grep A -rl D`\n\n-i 直接在源文件上处理\n\ngrep -rl 递归查找并列出来\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# linux\n\n\n# 1.lsof 列出某个程序所打开的文件信息\n\n列出某个程序所打开的文件信息\n\nlsof -c mysql\n\n\n1\n\n\n\n# 2.grep 查找文件里符合条件的字符串\n\n在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：\n\ngrep test *file \n\n\n1\n\n\n\n# 3.df 查看磁盘情况\n\n\n# 4.查看文件前几行、后几行等等\n\n * 查看文件 查看/home/user/test.txt\n\ncat /home/user/test.txt\n\n\n1\n\n * 查看文件开头几行 查看/home/user/test.txt的前20行\n\nhead -n 20 /home/user/test.txt\n\n\n1\n\n * 查看末尾几行 查看/home/user/test.txt的最后10行\n\ntail -n 10 /home/user/test.txt\n\n\n1\n\n * 查看中间几行 查看/home/user/test.txt的10~20行\n\ncat /home/user/test.txt| head -n 20 | tail -n +10 \n\nhead -n 20 表示前20行\ntail -n 10 表示后10行\ntail -n +10 表示第10行之后的\n\n\n1\n2\n3\n4\n5\n\n\n或\n\nsed -n '10,20p' /home/user/test.txt\n\n\n1\n\n\n\n# 5.将一个目录下指定的所有文件中的字符串a全部替换为b\n\nsed -i \"s/a/b/g\" `grep a -rl d`\n\n-i 直接在源文件上处理\n\ngrep -rl 递归查找并列出来\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"常用命令",frontmatter:{title:"常用命令",date:"2021-08-10T10:06:27.000Z",permalink:"/pages/1aff84/",categories:["后端","linux"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/30.linux/01.%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"01.后端/30.linux/01.常用命令.md",key:"v-4e759c6e",path:"/pages/1aff84/",headers:[{level:2,title:"1.防火墙",slug:"_1-防火墙",normalizedTitle:"1.防火墙",charIndex:2},{level:2,title:"2.清空内存缓存",slug:"_2-清空内存缓存",normalizedTitle:"2.清空内存缓存",charIndex:132}],headersStr:"1.防火墙 2.清空内存缓存",content:"# 1.防火墙\n\nsystemctl status firewalld  --查看防火墙状态\nsystemctl start firewalld   --开启防火墙\nsystemctl stop firewalld    --关闭防火墙\n\n\n1\n2\n3\n\n\n\n# 2.清空内存缓存\n\n1、同步数据到磁盘\n\nsync\n\n\n1\n\n\n2、根据需求清除对应缓存\n\necho 3 > /proc/sys/vm/drop_caches\n参数说明：\n0 //默认是0；\n1-清空页缓存；\n2-清空inode和目录树缓存；\n3-清空所有缓存\n\n\n1\n2\n3\n4\n5\n6\n\n\n3、再次查看\n\nfree -h\n\n\n1\n",normalizedContent:"# 1.防火墙\n\nsystemctl status firewalld  --查看防火墙状态\nsystemctl start firewalld   --开启防火墙\nsystemctl stop firewalld    --关闭防火墙\n\n\n1\n2\n3\n\n\n\n# 2.清空内存缓存\n\n1、同步数据到磁盘\n\nsync\n\n\n1\n\n\n2、根据需求清除对应缓存\n\necho 3 > /proc/sys/vm/drop_caches\n参数说明：\n0 //默认是0；\n1-清空页缓存；\n2-清空inode和目录树缓存；\n3-清空所有缓存\n\n\n1\n2\n3\n4\n5\n6\n\n\n3、再次查看\n\nfree -h\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"链表",frontmatter:{title:"链表",date:"2021-07-09T15:03:30.000Z",permalink:"/pages/261ec0/",categories:["后端","数据结构"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/40.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/00.%E9%93%BE%E8%A1%A8.html",relativePath:"01.后端/40.数据结构/00.链表.md",key:"v-2fed3cf2",path:"/pages/261ec0/",headers:[{level:3,title:"1.给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。",slug:"_1-给你一个链表-删除链表的倒数第-n-个结点-并且返回链表的头结点。",normalizedTitle:"1.给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。",charIndex:2}],headersStr:"1.给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。",content:"# 1.给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n\nhttps://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ 力扣链接\n\n\n\n    方法一：使用快慢指针\n    public static ListNode removeNthFromEnd (ListNode head, int n) {\n        ListNode resultNode=new ListNode(-1,head);//重新构造一个链表\n        ListNode fast=head;//快慢指针\n        ListNode slow=head;\n        int i=0;\n        while (fast != null){\n            fast=fast.next;\n            slow=slow.next;\n            i++;\n            if(i==n){//当i和n相等，slow就从头开始\n                slow=resultNode;\n            }\n        }\n        //出循环slow这个位置删除就行\n        slow.next=slow.next.next;\n        return resultNode.next;\n    }\n    方法一：使用list集合存储\n    public static ListNode removeNthFromEnd (ListNode head, int n) {\n        ListNode temp=new ListNode(-1);\n        ListNode resultNode=temp;\n        List<ListNode> list=new ArrayList<>();\n        while (head!=null){\n            list.add(new ListNode(head.val));\n            head=head.next;\n        }\n        for(int i=0;i<list.size();i++){\n            if(i != (list.size()-n)){\n                temp.next=list.get(i);\n                temp=temp.next;\n            }\n        }\n        return resultNode.next;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n",normalizedContent:"# 1.给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n\nhttps://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ 力扣链接\n\n\n\n    方法一：使用快慢指针\n    public static listnode removenthfromend (listnode head, int n) {\n        listnode resultnode=new listnode(-1,head);//重新构造一个链表\n        listnode fast=head;//快慢指针\n        listnode slow=head;\n        int i=0;\n        while (fast != null){\n            fast=fast.next;\n            slow=slow.next;\n            i++;\n            if(i==n){//当i和n相等，slow就从头开始\n                slow=resultnode;\n            }\n        }\n        //出循环slow这个位置删除就行\n        slow.next=slow.next.next;\n        return resultnode.next;\n    }\n    方法一：使用list集合存储\n    public static listnode removenthfromend (listnode head, int n) {\n        listnode temp=new listnode(-1);\n        listnode resultnode=temp;\n        list<listnode> list=new arraylist<>();\n        while (head!=null){\n            list.add(new listnode(head.val));\n            head=head.next;\n        }\n        for(int i=0;i<list.size();i++){\n            if(i != (list.size()-n)){\n                temp.next=list.get(i);\n                temp=temp.next;\n            }\n        }\n        return resultnode.next;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"阿里云增加虚拟内存",frontmatter:{title:"阿里云增加虚拟内存",date:"2022-01-27T10:13:58.000Z",permalink:"/pages/1adf94/",categories:["后端","linux"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/30.linux/02.%E9%98%BF%E9%87%8C%E4%BA%91%E5%A2%9E%E5%8A%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html",relativePath:"01.后端/30.linux/02.阿里云增加虚拟内存.md",key:"v-0d219152",path:"/pages/1adf94/",headers:[{level:2,title:"1.查看内存使用情况",slug:"_1-查看内存使用情况",normalizedTitle:"1.查看内存使用情况",charIndex:16},{level:2,title:"2.创建虚拟内存磁盘卷",slug:"_2-创建虚拟内存磁盘卷",normalizedTitle:"2.创建虚拟内存磁盘卷",charIndex:45},{level:2,title:"3.将磁盘卷转为虚拟内存卷",slug:"_3-将磁盘卷转为虚拟内存卷",normalizedTitle:"3.将磁盘卷转为虚拟内存卷",charIndex:210},{level:2,title:"4.启用虚拟内存服务",slug:"_4-启用虚拟内存服务",normalizedTitle:"4.启用虚拟内存服务",charIndex:255},{level:2,title:"5.再来查看内存使用情况",slug:"_5-再来查看内存使用情况",normalizedTitle:"5.再来查看内存使用情况",charIndex:297},{level:2,title:"6.关闭虚拟内存服务",slug:"_6-关闭虚拟内存服务",normalizedTitle:"6.关闭虚拟内存服务",charIndex:606},{level:2,title:"7.移动虚拟内存空间",slug:"_7-移动虚拟内存空间",normalizedTitle:"7.移动虚拟内存空间",charIndex:652}],headersStr:"1.查看内存使用情况 2.创建虚拟内存磁盘卷 3.将磁盘卷转为虚拟内存卷 4.启用虚拟内存服务 5.再来查看内存使用情况 6.关闭虚拟内存服务 7.移动虚拟内存空间",content:"# 阿里云增加虚拟内存\n\n\n# 1.查看内存使用情况\n\nfree -m\n\n\n1\n\n\n\n# 2.创建虚拟内存磁盘卷\n\n# 大概count=2024288，2G左右，可以视磁盘大小和需求创建。\n# 默认存放在/swap/swapadd，可以是自己的任何目录。\nmkdir /swap\ndd if=/dev/zero of=/swap/swapadd bs=1024 count=2024288\n\n\n1\n2\n3\n4\n\n\n\n# 3.将磁盘卷转为虚拟内存卷\n\nmkswap /swap/swapadd\n\n\n1\n\n\n\n# 4.启用虚拟内存服务\n\nswapon /swap/swapadd\n\n\n1\n\n\n\n# 5.再来查看内存使用情况\n\n[root@VM_0_8_centos ~]# free -m\n              total        used        free      shared  buff/cache   available\nMem:           1838        1503          75           0         258         180\nSwap:          1976           0        1976\n[root@VM_0_8_centos ~]# \n\n\n1\n2\n3\n4\n5\n\n\n多出来2G左右的swap空间。\n\n\n# 6.关闭虚拟内存服务\n\nswapoff -v /swap/swapadd\n\n\n1\n\n\n\n# 7.移动虚拟内存空间\n\n如果当前的虚存所在的磁盘空间不够，可以首先关闭虚存服务，将其移动到别的磁盘，再启用即可。\n\nswapoff -v /swap/swapadd\nmv /swap/swapadd /mnt/swap\nswapon /swap/swapadd\n\n\n1\n2\n3\n\n\n全部执行过程：\n\n[root@VM_0_8_centos ~]# free -m\n              total        used        free      shared  buff/cache   available\nMem:           1838        1502          69           0         265         183\nSwap:             0           0           0\n[root@VM_0_8_centos ~]# dd if=/dev/zero of=/swap/swapadd bs=1024 count=2024288\ndd: failed to open ‘/swap/swapadd’: No such file or directory\n[root@VM_0_8_centos ~]# mkdir /swap\n[root@VM_0_8_centos ~]# dd if=/dev/zero of=/swap/swapadd bs=1024 count=2024288\n2024288+0 records in\n2024288+0 records out\n2072870912 bytes (2.1 GB) copied, 18.7357 s, 111 MB/s\n[root@VM_0_8_centos ~]# mkswap /swap/swapadd\nSetting up swapspace version 1, size = 2024284 KiB\nno label, UUID=a6a67e41-fb1f-417c-aa03-cf8c91fc0d65\n[root@VM_0_8_centos ~]# swapon /swap/swapadd\nswapon: /swap/swapadd: insecure permissions 0644, 0600 suggested.\n[root@VM_0_8_centos ~]# free -m\n              total        used        free      shared  buff/cache   available\nMem:           1838        1503          75           0         258         180\nSwap:          1976           0        1976\n[root@VM_0_8_centos ~]# \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# 阿里云增加虚拟内存\n\n\n# 1.查看内存使用情况\n\nfree -m\n\n\n1\n\n\n\n# 2.创建虚拟内存磁盘卷\n\n# 大概count=2024288，2g左右，可以视磁盘大小和需求创建。\n# 默认存放在/swap/swapadd，可以是自己的任何目录。\nmkdir /swap\ndd if=/dev/zero of=/swap/swapadd bs=1024 count=2024288\n\n\n1\n2\n3\n4\n\n\n\n# 3.将磁盘卷转为虚拟内存卷\n\nmkswap /swap/swapadd\n\n\n1\n\n\n\n# 4.启用虚拟内存服务\n\nswapon /swap/swapadd\n\n\n1\n\n\n\n# 5.再来查看内存使用情况\n\n[root@vm_0_8_centos ~]# free -m\n              total        used        free      shared  buff/cache   available\nmem:           1838        1503          75           0         258         180\nswap:          1976           0        1976\n[root@vm_0_8_centos ~]# \n\n\n1\n2\n3\n4\n5\n\n\n多出来2g左右的swap空间。\n\n\n# 6.关闭虚拟内存服务\n\nswapoff -v /swap/swapadd\n\n\n1\n\n\n\n# 7.移动虚拟内存空间\n\n如果当前的虚存所在的磁盘空间不够，可以首先关闭虚存服务，将其移动到别的磁盘，再启用即可。\n\nswapoff -v /swap/swapadd\nmv /swap/swapadd /mnt/swap\nswapon /swap/swapadd\n\n\n1\n2\n3\n\n\n全部执行过程：\n\n[root@vm_0_8_centos ~]# free -m\n              total        used        free      shared  buff/cache   available\nmem:           1838        1502          69           0         265         183\nswap:             0           0           0\n[root@vm_0_8_centos ~]# dd if=/dev/zero of=/swap/swapadd bs=1024 count=2024288\ndd: failed to open ‘/swap/swapadd’: no such file or directory\n[root@vm_0_8_centos ~]# mkdir /swap\n[root@vm_0_8_centos ~]# dd if=/dev/zero of=/swap/swapadd bs=1024 count=2024288\n2024288+0 records in\n2024288+0 records out\n2072870912 bytes (2.1 gb) copied, 18.7357 s, 111 mb/s\n[root@vm_0_8_centos ~]# mkswap /swap/swapadd\nsetting up swapspace version 1, size = 2024284 kib\nno label, uuid=a6a67e41-fb1f-417c-aa03-cf8c91fc0d65\n[root@vm_0_8_centos ~]# swapon /swap/swapadd\nswapon: /swap/swapadd: insecure permissions 0644, 0600 suggested.\n[root@vm_0_8_centos ~]# free -m\n              total        used        free      shared  buff/cache   available\nmem:           1838        1503          75           0         258         180\nswap:          1976           0        1976\n[root@vm_0_8_centos ~]# \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0}},{title:"常见排序算法知识体系详解",frontmatter:{title:"常见排序算法知识体系详解",date:"2021-10-14T11:34:04.000Z",permalink:"/pages/7b4831/",categories:["后端","数据结构","常见的排序算法"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/40.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/00.%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.html",relativePath:"01.后端/40.数据结构/10.常见的排序算法/00.常见排序算法知识体系详解.md",key:"v-7b37fec3",path:"/pages/7b4831/",headers:[{level:2,title:"知识体系文章",slug:"知识体系文章",normalizedTitle:"知识体系文章",charIndex:19},{level:2,title:"学习推荐",slug:"学习推荐",normalizedTitle:"学习推荐",charIndex:1542},{level:2,title:"不同情况下排序选择",slug:"不同情况下排序选择",normalizedTitle:"不同情况下排序选择",charIndex:1635},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:1846}],headersStr:"知识体系文章 学习推荐 不同情况下排序选择 参考文章",content:'# 常见排序算法知识体系详解\n\n\n# 知识体系文章\n\n知识体系系统性梳理\n\n\n\n相关文章\n\n> A. 常见排序概要：重点理解几个排序之间的对比，时间和空间复杂度，以及应用。PS：越简单越要提高认知效率，做到战略上藐视战术上重视。\n\n * 排序 - Overview\n\n> B. 常见排序详解：具体分析各种排序及其复杂度，查漏补缺；在综合复杂度及稳定性情况下，通常希尔, 快排和 归并需要重点掌握。\n\n * 排序 - 冒泡排序(Bubble Sort)\n   * 它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止\n * 排序 - 快速排序(Quick Sort)\n   * 它的基本思想是: 选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n * 排序 - 插入排序(Insertion Sort)\n   * 直接插入排序(Straight Insertion Sort)的基本思想是: 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。\n * 排序 - Shell排序(Shell Sort)\n   * 希尔排序实质上是一种分组插入方法。它的基本思想是: 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。\n * 排序 - 选择排序(Selection sort)\n   * 它的基本思想是: 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n * 排序 - 堆排序(Heap Sort)\n   * 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n * 排序 - 归并排序(Merge Sort)\n   * 将两个的有序数列合并成一个有序数列，我们称之为"归并"。归并排序(Merge Sort)就是利用归并思想对数列进行排序。\n * 排序 - 桶排序(Bucket Sort)\n   * 桶排序(Bucket Sort)的原理很简单，将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）\n * 排序 - 基数排序(Radix Sort)\n   * 它的基本思想是: 将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是: 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列\n\n\n# 学习推荐\n\n * 学习排序 - 动画展示排序 (opens new window)\n * 整体性比较好系列 - @skywang12345 (opens new window)\n\n\n# 不同情况下排序选择\n\n在不同的情形下，排序速度前三名也不尽相同:\n\n排序场景            排序效率\nRandom          希尔>快排>归并\nFew unique      快排>希尔>归并\nReversed        快排>希尔>归并\nAlmost sorted   插入排序>基数排序>快排>希尔>归并\n\n总结来看: 快速排序和希尔排序在排序速度上表现是比较优秀的,而归并排序稍微次之.\n\n\n# 参考文章\n\n * https://www.pdai.tech/md/algorithm/alg-sort-overview.html',normalizedContent:'# 常见排序算法知识体系详解\n\n\n# 知识体系文章\n\n知识体系系统性梳理\n\n\n\n相关文章\n\n> a. 常见排序概要：重点理解几个排序之间的对比，时间和空间复杂度，以及应用。ps：越简单越要提高认知效率，做到战略上藐视战术上重视。\n\n * 排序 - overview\n\n> b. 常见排序详解：具体分析各种排序及其复杂度，查漏补缺；在综合复杂度及稳定性情况下，通常希尔, 快排和 归并需要重点掌握。\n\n * 排序 - 冒泡排序(bubble sort)\n   * 它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止\n * 排序 - 快速排序(quick sort)\n   * 它的基本思想是: 选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n * 排序 - 插入排序(insertion sort)\n   * 直接插入排序(straight insertion sort)的基本思想是: 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。\n * 排序 - shell排序(shell sort)\n   * 希尔排序实质上是一种分组插入方法。它的基本思想是: 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。\n * 排序 - 选择排序(selection sort)\n   * 它的基本思想是: 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n * 排序 - 堆排序(heap sort)\n   * 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n * 排序 - 归并排序(merge sort)\n   * 将两个的有序数列合并成一个有序数列，我们称之为"归并"。归并排序(merge sort)就是利用归并思想对数列进行排序。\n * 排序 - 桶排序(bucket sort)\n   * 桶排序(bucket sort)的原理很简单，将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）\n * 排序 - 基数排序(radix sort)\n   * 它的基本思想是: 将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是: 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列\n\n\n# 学习推荐\n\n * 学习排序 - 动画展示排序 (opens new window)\n * 整体性比较好系列 - @skywang12345 (opens new window)\n\n\n# 不同情况下排序选择\n\n在不同的情形下，排序速度前三名也不尽相同:\n\n排序场景            排序效率\nrandom          希尔>快排>归并\nfew unique      快排>希尔>归并\nreversed        快排>希尔>归并\nalmost sorted   插入排序>基数排序>快排>希尔>归并\n\n总结来看: 快速排序和希尔排序在排序速度上表现是比较优秀的,而归并排序稍微次之.\n\n\n# 参考文章\n\n * https://www.pdai.tech/md/algorithm/alg-sort-overview.html',charsets:{cjk:!0},lastUpdated:"2021/10/19, 17:13:24"},{title:"排序 - 冒泡排序(Bubble Sort)",frontmatter:{title:"排序 - 冒泡排序(Bubble Sort)",date:"2021-10-14T11:37:04.000Z",permalink:"/pages/b5b5a5/",categories:["后端","数据结构","常见的排序算法"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/40.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01.%E6%8E%92%E5%BA%8F_%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F(BubbleSort).html",relativePath:"01.后端/40.数据结构/10.常见的排序算法/01.排序_冒泡排序(BubbleSort).md",key:"v-52f4fef2",path:"/pages/b5b5a5/",headers:[{level:2,title:"冒泡排序介绍",slug:"冒泡排序介绍",normalizedTitle:"冒泡排序介绍",charIndex:29},{level:2,title:"冒泡排序实现",slug:"冒泡排序实现",normalizedTitle:"冒泡排序实现",charIndex:187},{level:2,title:"复杂度和稳定性",slug:"复杂度和稳定性",normalizedTitle:"复杂度和稳定性",charIndex:720},{level:3,title:"冒泡排序时间复杂度",slug:"冒泡排序时间复杂度",normalizedTitle:"冒泡排序时间复杂度",charIndex:732},{level:3,title:"冒泡排序稳定性",slug:"冒泡排序稳定性",normalizedTitle:"冒泡排序稳定性",charIndex:831},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:947},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:3033}],headersStr:"冒泡排序介绍 冒泡排序实现 复杂度和稳定性 冒泡排序时间复杂度 冒泡排序稳定性 代码实现 参考文章",content:'# 排序 - 冒泡排序(Bubble Sort)\n\n\n# 冒泡排序介绍\n\n它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！\n\n\n# 冒泡排序实现\n\n下面以数列{20,40,30,10,60,50}为例，演示它的冒泡排序过程(如下图)。\n\n\n\n我们先分析第1趟排序\n\n * 当i=5,j=0时，a[0]<a[1]。此时，不做任何处理！\n * 当i=5,j=1时，a[1]>a[2]。此时，交换a[1]和a[2]的值；交换之后，a[1]=30，a[2]=40。\n * 当i=5,j=2时，a[2]>a[3]。此时，交换a[2]和a[3]的值；交换之后，a[2]=10，a[3]=40。\n * 当i=5,j=3时，a[3]<a[4]。此时，不做任何处理！\n * 当i=5,j=4时，a[4]>a[5]。此时，交换a[4]和a[5]的值；交换之后，a[4]=50，a[3]=60。\n\n于是，第1趟排序完之后，数列{20,40,30,10,60,50}变成了{20,30,10,40,50,60}。此时，数列末尾的值最大。\n\n根据这种方法:\n\n * 第2趟排序完之后，数列中a[5...6]是有序的。\n * 第3趟排序完之后，数列中a[4...6]是有序的。\n * 第4趟排序完之后，数列中a[3...6]是有序的。\n * 第5趟排序完之后，数列中a[1...6]是有序的。整个数列也就是有序的了。\n\n\n# 复杂度和稳定性\n\n\n# 冒泡排序时间复杂度\n\n冒泡排序的时间复杂度是O(N2)。 假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢? N-1次！因此，冒泡排序的时间复杂度是O(N2)。\n\n\n# 冒泡排序稳定性\n\n冒泡排序是稳定的算法，它满足稳定算法的定义。 算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 代码实现\n\n/**\n * 冒泡排序: Java\n *\n * @author skywang\n * @date 2014/03/11\n */\n\npublic class BubbleSort {\n\n    /*\n     * 冒泡排序\n     *\n     * 参数说明: \n     *     a -- 待排序的数组\n     *     n -- 数组的长度\n     */\n    public static void bubbleSort1(int[] a, int n) {\n        int i,j;\n\n        for (i=n-1; i>0; i--) {\n            // 将a[0...i]中最大的数据放在末尾\n            for (j=0; j<i; j++) {\n\n                if (a[j] > a[j+1]) {\n                    // 交换a[j]和a[j+1]\n                    int tmp = a[j];\n                    a[j] = a[j+1];\n                    a[j+1] = tmp;\n                }\n            }\n        }\n    }\n\n    /*\n     * 冒泡排序(改进版)\n     * 如果某次排序都没有进行交换顺序，那么这个数据已经有序，后续都不用排序了，直接结束循环\n     * 参数说明: \n     *     a -- 待排序的数组\n     *     n -- 数组的长度\n     */\n    public static void bubbleSort2(int[] a, int n) {\n        int i,j;\n        int flag;                 // 标记\n\n        for (i=n-1; i>0; i--) {\n\n            flag = 0;            // 初始化标记为0\n            // 将a[0...i]中最大的数据放在末尾\n            for (j=0; j<i; j++) {\n                if (a[j] > a[j+1]) {\n                    // 交换a[j]和a[j+1]\n                    int tmp = a[j];\n                    a[j] = a[j+1];\n                    a[j+1] = tmp;\n\n                    flag = 1;    // 若发生交换，则设标记为1\n                }\n            }\n\n            if (flag==0)\n                break;            // 若没发生交换，则说明数列已有序。\n        }\n    }\n\n    public static void main(String[] args) {\n        int i;\n        int[] a = {20,40,30,10,60,50};\n\n        System.out.printf("before sort:");\n        for (i=0; i<a.length; i++)\n            System.out.printf("%d ", a[i]);\n        System.out.printf("\\n");\n\n        bubbleSort1(a, a.length);\n        //bubbleSort2(a, a.length);\n\n        System.out.printf("after  sort:");\n        for (i=0; i<a.length; i++)\n            System.out.printf("%d ", a[i]);\n        System.out.printf("\\n");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n\n\n# 参考文章\n\n * https://www.pdai.tech/md/algorithm/alg-sort-x-bubble.html',normalizedContent:'# 排序 - 冒泡排序(bubble sort)\n\n\n# 冒泡排序介绍\n\n它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！\n\n\n# 冒泡排序实现\n\n下面以数列{20,40,30,10,60,50}为例，演示它的冒泡排序过程(如下图)。\n\n\n\n我们先分析第1趟排序\n\n * 当i=5,j=0时，a[0]<a[1]。此时，不做任何处理！\n * 当i=5,j=1时，a[1]>a[2]。此时，交换a[1]和a[2]的值；交换之后，a[1]=30，a[2]=40。\n * 当i=5,j=2时，a[2]>a[3]。此时，交换a[2]和a[3]的值；交换之后，a[2]=10，a[3]=40。\n * 当i=5,j=3时，a[3]<a[4]。此时，不做任何处理！\n * 当i=5,j=4时，a[4]>a[5]。此时，交换a[4]和a[5]的值；交换之后，a[4]=50，a[3]=60。\n\n于是，第1趟排序完之后，数列{20,40,30,10,60,50}变成了{20,30,10,40,50,60}。此时，数列末尾的值最大。\n\n根据这种方法:\n\n * 第2趟排序完之后，数列中a[5...6]是有序的。\n * 第3趟排序完之后，数列中a[4...6]是有序的。\n * 第4趟排序完之后，数列中a[3...6]是有序的。\n * 第5趟排序完之后，数列中a[1...6]是有序的。整个数列也就是有序的了。\n\n\n# 复杂度和稳定性\n\n\n# 冒泡排序时间复杂度\n\n冒泡排序的时间复杂度是o(n2)。 假设被排序的数列中有n个数。遍历一趟的时间复杂度是o(n)，需要遍历多少次呢? n-1次！因此，冒泡排序的时间复杂度是o(n2)。\n\n\n# 冒泡排序稳定性\n\n冒泡排序是稳定的算法，它满足稳定算法的定义。 算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 代码实现\n\n/**\n * 冒泡排序: java\n *\n * @author skywang\n * @date 2014/03/11\n */\n\npublic class bubblesort {\n\n    /*\n     * 冒泡排序\n     *\n     * 参数说明: \n     *     a -- 待排序的数组\n     *     n -- 数组的长度\n     */\n    public static void bubblesort1(int[] a, int n) {\n        int i,j;\n\n        for (i=n-1; i>0; i--) {\n            // 将a[0...i]中最大的数据放在末尾\n            for (j=0; j<i; j++) {\n\n                if (a[j] > a[j+1]) {\n                    // 交换a[j]和a[j+1]\n                    int tmp = a[j];\n                    a[j] = a[j+1];\n                    a[j+1] = tmp;\n                }\n            }\n        }\n    }\n\n    /*\n     * 冒泡排序(改进版)\n     * 如果某次排序都没有进行交换顺序，那么这个数据已经有序，后续都不用排序了，直接结束循环\n     * 参数说明: \n     *     a -- 待排序的数组\n     *     n -- 数组的长度\n     */\n    public static void bubblesort2(int[] a, int n) {\n        int i,j;\n        int flag;                 // 标记\n\n        for (i=n-1; i>0; i--) {\n\n            flag = 0;            // 初始化标记为0\n            // 将a[0...i]中最大的数据放在末尾\n            for (j=0; j<i; j++) {\n                if (a[j] > a[j+1]) {\n                    // 交换a[j]和a[j+1]\n                    int tmp = a[j];\n                    a[j] = a[j+1];\n                    a[j+1] = tmp;\n\n                    flag = 1;    // 若发生交换，则设标记为1\n                }\n            }\n\n            if (flag==0)\n                break;            // 若没发生交换，则说明数列已有序。\n        }\n    }\n\n    public static void main(string[] args) {\n        int i;\n        int[] a = {20,40,30,10,60,50};\n\n        system.out.printf("before sort:");\n        for (i=0; i<a.length; i++)\n            system.out.printf("%d ", a[i]);\n        system.out.printf("\\n");\n\n        bubblesort1(a, a.length);\n        //bubblesort2(a, a.length);\n\n        system.out.printf("after  sort:");\n        for (i=0; i<a.length; i++)\n            system.out.printf("%d ", a[i]);\n        system.out.printf("\\n");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n\n\n# 参考文章\n\n * https://www.pdai.tech/md/algorithm/alg-sort-x-bubble.html',charsets:{cjk:!0}},{title:"排序 - 快速排序(Quick Sort)",frontmatter:{title:"排序 - 快速排序(Quick Sort)",date:"2021-10-14T11:40:29.000Z",permalink:"/pages/27b7f8/",categories:["后端","数据结构","常见的排序算法"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/40.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/02.%E6%8E%92%E5%BA%8F_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(QuickSort).html",relativePath:"01.后端/40.数据结构/10.常见的排序算法/02.排序_快速排序(QuickSort).md",key:"v-65c06378",path:"/pages/27b7f8/",headers:[{level:2,title:"快速排序介绍",slug:"快速排序介绍",normalizedTitle:"快速排序介绍",charIndex:58},{level:2,title:"快速排序实现",slug:"快速排序实现",normalizedTitle:"快速排序实现",charIndex:189},{level:2,title:"快速排序时间复杂度和稳定性",slug:"快速排序时间复杂度和稳定性",normalizedTitle:"快速排序时间复杂度和稳定性",charIndex:808},{level:3,title:"快速排序稳定性",slug:"快速排序稳定性",normalizedTitle:"快速排序稳定性",charIndex:826},{level:3,title:"快速排序时间复杂度",slug:"快速排序时间复杂度",normalizedTitle:"快速排序时间复杂度",charIndex:808},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:1254},{level:2,title:"个人实现",slug:"个人实现",normalizedTitle:"个人实现",charIndex:2771},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:3850}],headersStr:"快速排序介绍 快速排序实现 快速排序时间复杂度和稳定性 快速排序稳定性 快速排序时间复杂度 代码实现 个人实现 参考文章",content:'# 排序 - 快速排序(Quick Sort)\n\n> 快速排序(Quick Sort)使用分治法算法思想。\n\n\n# 快速排序介绍\n\n它的基本思想是: 选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n\n# 快速排序实现\n\n * 从数列中挑出一个基准值。\n * 将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。\n * 递归地把"基准值前面的子数列"和"基准值后面的子数列"进行排序。\n\n下面以数列a={30,40,60,10,20,50}为例，演示它的快速排序过程(如下图)。\n\n\n\n上图只是给出了第1趟快速排序的流程。在第1趟中，设置x=a[i]，即x=30。\n\n * 从"右 --\x3e 左"查找小于x的数: 找到满足条件的数a[j]=20，此时j=4；然后将a[j]赋值a[i]，此时i=0；接着从左往右遍历。\n * 从"左 --\x3e 右"查找大于x的数: 找到满足条件的数a[i]=40，此时i=1；然后将a[i]赋值a[j]，此时j=4；接着从右往左遍历。\n * 从"右 --\x3e 左"查找小于x的数: 找到满足条件的数a[j]=10，此时j=3；然后将a[j]赋值a[i]，此时i=1；接着从左往右遍历。\n * 从"左 --\x3e 右"查找大于x的数: 找到满足条件的数a[i]=60，此时i=2；然后将a[i]赋值a[j]，此时j=3；接着从右往左遍历。\n * 从"右 --\x3e 左"查找小于x的数: 没有找到满足条件的数。当i>=j时，停止查找；然后将x赋值给a[i]。此趟遍历结束！\n\n按照同样的方法，对子数列进行递归遍历。最后得到有序数组！\n\n\n# 快速排序时间复杂度和稳定性\n\n\n# 快速排序稳定性\n\n快速排序是不稳定的算法，它不满足稳定算法的定义。\n\n算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 快速排序时间复杂度\n\n> 快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。\n\n这句话很好理解: 假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢? 至少lg(N+1)次，最多N次。\n\n * 为什么最少是lg(N+1)次? 快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。\n * 为什么最多是N次? 这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。\n\n\n# 代码实现\n\n/**\n * 快速排序: Java\n *\n * @author skywang\n * @date 2014/03/11\n */\n\npublic class QuickSort {\n\n    /*\n     * 快速排序\n     *\n     * 参数说明: \n     *     a -- 待排序的数组\n     *     l -- 数组的左边界(例如，从起始位置开始排序，则l=0)\n     *     r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1)\n     */\n    public static void quickSort(int[] a, int l, int r) {\n\n        if (l < r) {\n            int i,j,x;\n\n            i = l;\n            j = r;\n            x = a[i];\n            while (i < j) {\n                while(i < j && a[j] > x)\n                    j--; // 从右向左找第一个小于x的数\n                if(i < j)\n                    a[i++] = a[j];\n                while(i < j && a[i] < x)\n                    i++; // 从左向右找第一个大于x的数\n                if(i < j)\n                    a[j--] = a[i];\n            }\n            a[i] = x;\n            quickSort(a, l, i-1); /* 递归调用 */\n            quickSort(a, i+1, r); /* 递归调用 */\n        }\n    }\n\n    public static void main(String[] args) {\n        int i;\n        int a[] = {30,40,60,10,20,50};\n\n        System.out.printf("before sort:");\n        for (i=0; i<a.length; i++)\n            System.out.printf("%d ", a[i]);\n        System.out.printf("\\n");\n\n        quickSort(a, 0, a.length-1);\n\n        System.out.printf("after  sort:");\n        for (i=0; i<a.length; i++)\n            System.out.printf("%d ", a[i]);\n        System.out.printf("\\n");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 个人实现\n\n原理：\n\n随机选取一个基数，头部指针和尾部指针，先从右边开始，若比基数的数大，则下标左移；左边同理，若比基数小，则右移；双方交换顺序，递归。\n\n效率：\n\n * 平均时间复杂度：NlogN（logN表示匹配一次的时间）\n\n * 最坏时间复杂度：NlogN（匹配了N次)\n\n * 最好时间复杂度：logN（只匹配一次就已经排序）\n   \n   public void quickSort(int a[],int left,int right){\n       //结束递归\n       if(left > right){\n           return;\n       }\n       int i=left,j=right,key=a[i];//基数默认取第一个\n       while (i<j){\n           //先从右边开始 找到比基数小的数\n           while (a[j] >= key && i<j){\n               j--;\n           }\n           //左边 找出比基数大的数\n           while (a[i] <= key && i<j){\n               i++;\n           }\n           if(i<j){\n               //不用中间变量交换顺序\n               a[i]=a[i]^a[j];\n               a[j]=a[i]^a[j];\n               a[i]=a[i]^a[j];\n           }\n       }\n   \n       //基数和第一个位置交换顺序\n       a[left]=a[i];//第一个位置为现在中间的数\n       a[i]=key;//中间的数为基数\n       \n       quickSort(a,left,i-1);\n       quickSort(a,i+1,right);\n   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   \n\n\n# 参考文章\n\n * https://www.pdai.tech/md/algorithm/alg-sort-x-fast.html',normalizedContent:'# 排序 - 快速排序(quick sort)\n\n> 快速排序(quick sort)使用分治法算法思想。\n\n\n# 快速排序介绍\n\n它的基本思想是: 选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n\n# 快速排序实现\n\n * 从数列中挑出一个基准值。\n * 将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。\n * 递归地把"基准值前面的子数列"和"基准值后面的子数列"进行排序。\n\n下面以数列a={30,40,60,10,20,50}为例，演示它的快速排序过程(如下图)。\n\n\n\n上图只是给出了第1趟快速排序的流程。在第1趟中，设置x=a[i]，即x=30。\n\n * 从"右 --\x3e 左"查找小于x的数: 找到满足条件的数a[j]=20，此时j=4；然后将a[j]赋值a[i]，此时i=0；接着从左往右遍历。\n * 从"左 --\x3e 右"查找大于x的数: 找到满足条件的数a[i]=40，此时i=1；然后将a[i]赋值a[j]，此时j=4；接着从右往左遍历。\n * 从"右 --\x3e 左"查找小于x的数: 找到满足条件的数a[j]=10，此时j=3；然后将a[j]赋值a[i]，此时i=1；接着从左往右遍历。\n * 从"左 --\x3e 右"查找大于x的数: 找到满足条件的数a[i]=60，此时i=2；然后将a[i]赋值a[j]，此时j=3；接着从右往左遍历。\n * 从"右 --\x3e 左"查找小于x的数: 没有找到满足条件的数。当i>=j时，停止查找；然后将x赋值给a[i]。此趟遍历结束！\n\n按照同样的方法，对子数列进行递归遍历。最后得到有序数组！\n\n\n# 快速排序时间复杂度和稳定性\n\n\n# 快速排序稳定性\n\n快速排序是不稳定的算法，它不满足稳定算法的定义。\n\n算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 快速排序时间复杂度\n\n> 快速排序的时间复杂度在最坏情况下是o(n2)，平均的时间复杂度是o(n*lgn)。\n\n这句话很好理解: 假设被排序的数列中有n个数。遍历一次的时间复杂度是o(n)，需要遍历多少次呢? 至少lg(n+1)次，最多n次。\n\n * 为什么最少是lg(n+1)次? 快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(n+1)。因此，快速排序的遍历次数最少是lg(n+1)次。\n * 为什么最多是n次? 这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是n。因此，快读排序的遍历次数最多是n次。\n\n\n# 代码实现\n\n/**\n * 快速排序: java\n *\n * @author skywang\n * @date 2014/03/11\n */\n\npublic class quicksort {\n\n    /*\n     * 快速排序\n     *\n     * 参数说明: \n     *     a -- 待排序的数组\n     *     l -- 数组的左边界(例如，从起始位置开始排序，则l=0)\n     *     r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1)\n     */\n    public static void quicksort(int[] a, int l, int r) {\n\n        if (l < r) {\n            int i,j,x;\n\n            i = l;\n            j = r;\n            x = a[i];\n            while (i < j) {\n                while(i < j && a[j] > x)\n                    j--; // 从右向左找第一个小于x的数\n                if(i < j)\n                    a[i++] = a[j];\n                while(i < j && a[i] < x)\n                    i++; // 从左向右找第一个大于x的数\n                if(i < j)\n                    a[j--] = a[i];\n            }\n            a[i] = x;\n            quicksort(a, l, i-1); /* 递归调用 */\n            quicksort(a, i+1, r); /* 递归调用 */\n        }\n    }\n\n    public static void main(string[] args) {\n        int i;\n        int a[] = {30,40,60,10,20,50};\n\n        system.out.printf("before sort:");\n        for (i=0; i<a.length; i++)\n            system.out.printf("%d ", a[i]);\n        system.out.printf("\\n");\n\n        quicksort(a, 0, a.length-1);\n\n        system.out.printf("after  sort:");\n        for (i=0; i<a.length; i++)\n            system.out.printf("%d ", a[i]);\n        system.out.printf("\\n");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 个人实现\n\n原理：\n\n随机选取一个基数，头部指针和尾部指针，先从右边开始，若比基数的数大，则下标左移；左边同理，若比基数小，则右移；双方交换顺序，递归。\n\n效率：\n\n * 平均时间复杂度：nlogn（logn表示匹配一次的时间）\n\n * 最坏时间复杂度：nlogn（匹配了n次)\n\n * 最好时间复杂度：logn（只匹配一次就已经排序）\n   \n   public void quicksort(int a[],int left,int right){\n       //结束递归\n       if(left > right){\n           return;\n       }\n       int i=left,j=right,key=a[i];//基数默认取第一个\n       while (i<j){\n           //先从右边开始 找到比基数小的数\n           while (a[j] >= key && i<j){\n               j--;\n           }\n           //左边 找出比基数大的数\n           while (a[i] <= key && i<j){\n               i++;\n           }\n           if(i<j){\n               //不用中间变量交换顺序\n               a[i]=a[i]^a[j];\n               a[j]=a[i]^a[j];\n               a[i]=a[i]^a[j];\n           }\n       }\n   \n       //基数和第一个位置交换顺序\n       a[left]=a[i];//第一个位置为现在中间的数\n       a[i]=key;//中间的数为基数\n       \n       quicksort(a,left,i-1);\n       quicksort(a,i+1,right);\n   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   \n\n\n# 参考文章\n\n * https://www.pdai.tech/md/algorithm/alg-sort-x-fast.html',charsets:{cjk:!0}},{title:"排序 - 插入排序(Insertion Sort)",frontmatter:{title:"排序 - 插入排序(Insertion Sort)",date:"2021-10-14T11:42:57.000Z",permalink:"/pages/4cf198/",categories:["后端","数据结构","常见的排序算法"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/40.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F_%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F(InsertionSort).html",relativePath:"01.后端/40.数据结构/10.常见的排序算法/03.排序_插入排序(InsertionSort).md",key:"v-1e0c4778",path:"/pages/4cf198/",headers:[{level:2,title:"插入排序介绍",slug:"插入排序介绍",normalizedTitle:"插入排序介绍",charIndex:32},{level:2,title:"插入排序实现",slug:"插入排序实现",normalizedTitle:"插入排序实现",charIndex:196},{level:2,title:"插入排序的时间复杂度和稳定性",slug:"插入排序的时间复杂度和稳定性",normalizedTitle:"插入排序的时间复杂度和稳定性",charIndex:391},{level:3,title:"插入排序时间复杂度",slug:"插入排序时间复杂度",normalizedTitle:"插入排序时间复杂度",charIndex:410},{level:3,title:"插入排序稳定性",slug:"插入排序稳定性",normalizedTitle:"插入排序稳定性",charIndex:513},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:632},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:1198}],headersStr:"插入排序介绍 插入排序实现 插入排序的时间复杂度和稳定性 插入排序时间复杂度 插入排序稳定性 代码实现 参考文章",content:"# 排序 - 插入排序(Insertion Sort)\n\n\n# 插入排序介绍\n\n直接插入排序(Straight Insertion Sort)的基本思想是: 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。\n\n\n# 插入排序实现\n\n下面选取直接插入排序的一个中间过程对其进行说明。假设{20,30,40,10,60,50}中的前3个数已经排列过，是有序的了；接下来对10进行排列。示意图如下:\n\n\n\n图中将数列分为有序区和无序区。我们需要做的工作只有两个: (1)取出无序区中的第1个数，并找出它在有序区对应的位置。(2)将无序区的数据插入到有序区；若有必要的话，则对有序区中的相关数据进行移位。\n\n\n# 插入排序的时间复杂度和稳定性\n\n\n# 插入排序时间复杂度\n\n直接插入排序的时间复杂度是O(N2)。\n\n假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢? N-1！因此，直接插入排序的时间复杂度是O(N2)。\n\n\n# 插入排序稳定性\n\n直接插入排序是稳定的算法，它满足稳定算法的定义。\n\n算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 代码实现\n\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        //默认第一个数有序\n        for (int i = 1; i < nums.length; i++) {\n            int temp=nums[i];\n            //找出temp在有序数组中的位置\n            int j;\n            for (j=i-1;j>=0;j--){\n                if(nums[j] > temp){\n                    nums[j+1]=nums[j];//后移\n                    continue;//继续寻找\n                }\n                break;//没有找到比temp大的数\n            }\n            nums[j+1]=temp;//temp放到对应的位置\n        }\n        return nums;\n   }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 参考文章\n\n * https://www.pdai.tech/md/algorithm/alg-sort-x-insert.html",normalizedContent:"# 排序 - 插入排序(insertion sort)\n\n\n# 插入排序介绍\n\n直接插入排序(straight insertion sort)的基本思想是: 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。\n\n\n# 插入排序实现\n\n下面选取直接插入排序的一个中间过程对其进行说明。假设{20,30,40,10,60,50}中的前3个数已经排列过，是有序的了；接下来对10进行排列。示意图如下:\n\n\n\n图中将数列分为有序区和无序区。我们需要做的工作只有两个: (1)取出无序区中的第1个数，并找出它在有序区对应的位置。(2)将无序区的数据插入到有序区；若有必要的话，则对有序区中的相关数据进行移位。\n\n\n# 插入排序的时间复杂度和稳定性\n\n\n# 插入排序时间复杂度\n\n直接插入排序的时间复杂度是o(n2)。\n\n假设被排序的数列中有n个数。遍历一趟的时间复杂度是o(n)，需要遍历多少次呢? n-1！因此，直接插入排序的时间复杂度是o(n2)。\n\n\n# 插入排序稳定性\n\n直接插入排序是稳定的算法，它满足稳定算法的定义。\n\n算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 代码实现\n\nclass solution {\n    public int[] sortarray(int[] nums) {\n        //默认第一个数有序\n        for (int i = 1; i < nums.length; i++) {\n            int temp=nums[i];\n            //找出temp在有序数组中的位置\n            int j;\n            for (j=i-1;j>=0;j--){\n                if(nums[j] > temp){\n                    nums[j+1]=nums[j];//后移\n                    continue;//继续寻找\n                }\n                break;//没有找到比temp大的数\n            }\n            nums[j+1]=temp;//temp放到对应的位置\n        }\n        return nums;\n   }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 参考文章\n\n * https://www.pdai.tech/md/algorithm/alg-sort-x-insert.html",charsets:{cjk:!0}},{title:"排序 - Shell排序(Shell Sort)",frontmatter:{title:"排序 - Shell排序(Shell Sort)",date:"2021-10-14T11:52:12.000Z",permalink:"/pages/c8e6c6/",categories:["后端","数据结构","常见的排序算法"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/40.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/04.%E6%8E%92%E5%BA%8F_Shell%E6%8E%92%E5%BA%8F(ShellSort).html",relativePath:"01.后端/40.数据结构/10.常见的排序算法/04.排序_Shell排序(ShellSort).md",key:"v-1e0d1a72",path:"/pages/c8e6c6/",headers:[{level:2,title:"希尔排序介绍",slug:"希尔排序介绍",normalizedTitle:"希尔排序介绍",charIndex:76},{level:2,title:"希尔排序实现",slug:"希尔排序实现",normalizedTitle:"希尔排序实现",charIndex:279},{level:2,title:"希尔排序的时间复杂度和稳定性",slug:"希尔排序的时间复杂度和稳定性",normalizedTitle:"希尔排序的时间复杂度和稳定性",charIndex:971},{level:3,title:"希尔排序时间复杂度",slug:"希尔排序时间复杂度",normalizedTitle:"希尔排序时间复杂度",charIndex:990},{level:3,title:"希尔排序稳定性",slug:"希尔排序稳定性",normalizedTitle:"希尔排序稳定性",charIndex:1104},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:1255},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:2233}],headersStr:"希尔排序介绍 希尔排序实现 希尔排序的时间复杂度和稳定性 希尔排序时间复杂度 希尔排序稳定性 代码实现 参考文章",content:"# 排序 - Shell排序(Shell Sort)\n\n> 希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。\n\n\n# 希尔排序介绍\n\n希尔排序实质上是一种分组插入方法。它的基本思想是: 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。\n\n\n# 希尔排序实现\n\n下面以数列{80,30,60,40,20,10,50,70}为例，演示它的希尔排序过程。\n\n第1趟: (gap=4)\n\n\n\n当gap=4时,意味着将数列分为4个组: {80,20},{30,10},{60,50},{40,70}。 对应数列: {80,30,60,40,20,10,50,70} 对这4个组分别进行排序，排序结果: {20,80},{10,30},{50,60},{40,70}。 对应数列: {20,10,50,40,80,30,60,70}\n\n第2趟: (gap=2)\n\n\n\n当gap=2时,意味着将数列分为2个组: {20,50,80,60}, {10,40,30,70}。 对应数列: {20,10,50,40,80,30,60,70} 注意: {20,50,80,60}实际上有两个有序的数列{20,80}和{50,60}组成。 {10,40,30,70}实际上有两个有序的数列{10,30}和{40,70}组成。 对这2个组分别进行排序，排序结果: {20,50,60,80}, {10,30,40,70}。 对应数列: {20,10,50,30,60,40,80,70}\n\n第3趟: (gap=1)\n\n\n\n当gap=1时,意味着将数列分为1个组: {20,10,50,30,60,40,80,70} 注意: {20,10,50,30,60,40,80,70}实际上有两个有序的数列{20,50,60,80}和{10,30,40,70}组成。 对这1个组分别进行排序，排序结果: {10,20,30,40,50,60,70,80}\n\n\n# 希尔排序的时间复杂度和稳定性\n\n\n# 希尔排序时间复杂度\n\n希尔排序的时间复杂度与增量(即，步长gap)的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为O(N²)，而Hibbard增量的希尔排序的时间复杂度为O(N3/2)。\n\n\n# 希尔排序稳定性\n\n希尔排序是不稳定的算法，它满足稳定算法的定义。对于相同的两个数，可能由于分在不同的组中而导致它们的顺序发生变化。\n\n算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 代码实现\n\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        //选择合适的增量\n        int increment=nums.length;\n        while (increment >= 1){\n            increment=increment/2;\n            for (int i = 0; i < increment; i++) {//分别进行插入排序\n                for (int j=increment+i;j<nums.length;j=j+increment){//下标 4 8\n                    int temp=nums[j];\n                    //k=j-increment:默认第一个数为有序的\n                    int k;\n                    for(k=j-increment;k>=0;k=k-increment){\n                        //判断是否有比temp值大的\n                        if(nums[k] > temp){\n                            nums[k+increment]=nums[k];//后移\n                            continue;\n                        }\n                        break;//没有比temp大的,直接结束\n                    }\n                    nums[k+increment]=temp;//temp放到后移腾出的位置\n                }\n            }\n        }\n        return nums;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 参考文章\n\n * https://www.pdai.tech/md/algorithm/alg-sort-x-shell.html",normalizedContent:"# 排序 - shell排序(shell sort)\n\n> 希尔排序(shell sort)是插入排序的一种，它是针对直接插入排序算法的改进。\n\n\n# 希尔排序介绍\n\n希尔排序实质上是一种分组插入方法。它的基本思想是: 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。\n\n\n# 希尔排序实现\n\n下面以数列{80,30,60,40,20,10,50,70}为例，演示它的希尔排序过程。\n\n第1趟: (gap=4)\n\n\n\n当gap=4时,意味着将数列分为4个组: {80,20},{30,10},{60,50},{40,70}。 对应数列: {80,30,60,40,20,10,50,70} 对这4个组分别进行排序，排序结果: {20,80},{10,30},{50,60},{40,70}。 对应数列: {20,10,50,40,80,30,60,70}\n\n第2趟: (gap=2)\n\n\n\n当gap=2时,意味着将数列分为2个组: {20,50,80,60}, {10,40,30,70}。 对应数列: {20,10,50,40,80,30,60,70} 注意: {20,50,80,60}实际上有两个有序的数列{20,80}和{50,60}组成。 {10,40,30,70}实际上有两个有序的数列{10,30}和{40,70}组成。 对这2个组分别进行排序，排序结果: {20,50,60,80}, {10,30,40,70}。 对应数列: {20,10,50,30,60,40,80,70}\n\n第3趟: (gap=1)\n\n\n\n当gap=1时,意味着将数列分为1个组: {20,10,50,30,60,40,80,70} 注意: {20,10,50,30,60,40,80,70}实际上有两个有序的数列{20,50,60,80}和{10,30,40,70}组成。 对这1个组分别进行排序，排序结果: {10,20,30,40,50,60,70,80}\n\n\n# 希尔排序的时间复杂度和稳定性\n\n\n# 希尔排序时间复杂度\n\n希尔排序的时间复杂度与增量(即，步长gap)的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为o(n²)，而hibbard增量的希尔排序的时间复杂度为o(n3/2)。\n\n\n# 希尔排序稳定性\n\n希尔排序是不稳定的算法，它满足稳定算法的定义。对于相同的两个数，可能由于分在不同的组中而导致它们的顺序发生变化。\n\n算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 代码实现\n\nclass solution {\n    public int[] sortarray(int[] nums) {\n        //选择合适的增量\n        int increment=nums.length;\n        while (increment >= 1){\n            increment=increment/2;\n            for (int i = 0; i < increment; i++) {//分别进行插入排序\n                for (int j=increment+i;j<nums.length;j=j+increment){//下标 4 8\n                    int temp=nums[j];\n                    //k=j-increment:默认第一个数为有序的\n                    int k;\n                    for(k=j-increment;k>=0;k=k-increment){\n                        //判断是否有比temp值大的\n                        if(nums[k] > temp){\n                            nums[k+increment]=nums[k];//后移\n                            continue;\n                        }\n                        break;//没有比temp大的,直接结束\n                    }\n                    nums[k+increment]=temp;//temp放到后移腾出的位置\n                }\n            }\n        }\n        return nums;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 参考文章\n\n * https://www.pdai.tech/md/algorithm/alg-sort-x-shell.html",charsets:{cjk:!0}},{title:"排序 - 堆排序(Heap Sort)",frontmatter:{title:"排序 - 堆排序(Heap Sort)",date:"2021-10-14T15:49:26.000Z",permalink:"/pages/decb9d/",categories:["后端","数据结构","常见的排序算法"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/40.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/06.%E6%8E%92%E5%BA%8F_%E5%A0%86%E6%8E%92%E5%BA%8F(HeapSort).html",relativePath:"01.后端/40.数据结构/10.常见的排序算法/06.排序_堆排序(HeapSort).md",key:"v-ca1e139c",path:"/pages/decb9d/",headers:[{level:2,title:"堆排序介绍",slug:"堆排序介绍",normalizedTitle:"堆排序介绍",charIndex:107},{level:2,title:"堆排序实现",slug:"堆排序实现",normalizedTitle:"堆排序实现",charIndex:735},{level:3,title:"初始化堆",slug:"初始化堆",normalizedTitle:"初始化堆",charIndex:311},{level:3,title:"交换数据",slug:"交换数据",normalizedTitle:"交换数据",charIndex:338},{level:2,title:"堆排序复杂度和稳定性",slug:"堆排序复杂度和稳定性",normalizedTitle:"堆排序复杂度和稳定性",charIndex:2152},{level:3,title:"堆排序时间复杂度",slug:"堆排序时间复杂度",normalizedTitle:"堆排序时间复杂度",charIndex:2167},{level:3,title:"堆排序稳定性",slug:"堆排序稳定性",normalizedTitle:"堆排序稳定性",charIndex:2419},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:2600}],headersStr:"堆排序介绍 堆排序实现 初始化堆 交换数据 堆排序复杂度和稳定性 堆排序时间复杂度 堆排序稳定性 代码实现",content:'# 排序 - 堆排序(Heap Sort)\n\n> 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n\n\n# 堆排序介绍\n\n学习堆排序之前，有必要了解堆！若读者不熟悉堆，建议先了解堆(建议可以通过二叉堆，左倾堆，斜堆，二项堆或斐波那契堆等文章进行了解)，然后再来学习本章。\n\n我们知道，堆分为"最大堆"和"最小堆"。最大堆通常被用来进行"升序"排序，而最小堆通常被用来进行"降序"排序。 鉴于最大堆和最小堆是对称关系，理解其中一种即可。本文将对最大堆实现的升序排序进行详细说明。\n\n最大堆进行升序排序的基本思想: ① 初始化堆: 将数列a[1...n]构造成最大堆。 ② 交换数据: 将a[1]和a[n]交换，使a[n]是a[1...n]中的最大值；然后将a[1...n-1]重新调整为最大堆。 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1...n-1]中的最大值；然后将a[1...n-2]重新调整为最大值。 依次类推，直到整个数列都是有序的。\n\n下面，通过图文来解析堆排序的实现过程。注意实现中用到了"数组实现的二叉堆的性质"。 在第一个元素的索引为 0 的情形中:\n\n * 性质一: 索引为i的左孩子的索引是 (2*i+1);\n * 性质二: 索引为i的右孩子的索引是 (2*i+2);\n * 性质三: 索引为i的父结点的索引是 floor((i-1)/2);\n\n\n\n例如，对于最大堆{110,100,90,40,80,20,60,10,30,50,70}而言: 索引为0的左孩子的所有是1；索引为0的右孩子是2；索引为8的父节点是3。\n\n\n# 堆排序实现\n\n下面演示heap_sort_asc(a, n)对a={20,30,90,40,70,110,60,10,100,50,80}, n=11进行堆排序过程。下面是数组a对应的初始化结构:\n\n\n\n\n# 初始化堆\n\n在堆排序算法中，首先要将待排序的数组转化成二叉堆。 下面演示将数组{20,30,90,40,70,110,60,10,100,50,80}转换为最大堆{110,100,90,40,80,20,60,10,30,50,70}的步骤。\n\n * 1.1 i=11/2-1，即i=4\n\n\n\n上面是maxheap_down(a, 4, 9)调整过程。maxheap_down(a, 4, 9)的作用是将a[4...9]进行下调；a[4]的左孩子是a[9]，右孩子是a[10]。调整时，选择左右孩子中较大的一个(即a[10])和a[4]交换。\n\n * 1.2 i=3\n\n\n\n上面是maxheap_down(a, 3, 9)调整过程。maxheap_down(a, 3, 9)的作用是将a[3...9]进行下调；a[3]的左孩子是a[7]，右孩子是a[8]。调整时，选择左右孩子中较大的一个(即a[8])和a[4]交换。\n\n * 1.3 i=2\n\n\n\n上面是maxheap_down(a, 2, 9)调整过程。maxheap_down(a, 2, 9)的作用是将a[2...9]进行下调；a[2]的左孩子是a[5]，右孩子是a[6]。调整时，选择左右孩子中较大的一个(即a[5])和a[2]交换。\n\n * 1.4 i=1\n\n\n\n上面是maxheap_down(a, 1, 9)调整过程。maxheap_down(a, 1, 9)的作用是将a[1...9]进行下调；a[1]的左孩子是a[3]，右孩子是a[4]。调整时，选择左右孩子中较大的一个(即a[3])和a[1]交换。交换之后，a[3]为30，它比它的右孩子a[8]要大，接着，再将它们交换。\n\n * 1.5 i=0\n\n\n\n上面是maxheap_down(a, 0, 9)调整过程。maxheap_down(a, 0, 9)的作用是将a[0...9]进行下调；a[0]的左孩子是a[1]，右孩子是a[2]。调整时，选择左右孩子中较大的一个(即a[2])和a[0]交换。交换之后，a[2]为20，它比它的左右孩子要大，选择较大的孩子(即左孩子)和a[2]交换。\n\n调整完毕，就得到了最大堆。此时，数组{20,30,90,40,70,110,60,10,100,50,80}也就变成了{110,100,90,40,80,20,60,10,30,50,70}。\n\n\n# 交换数据\n\n在将数组转换成最大堆之后，接着要进行交换数据，从而使数组成为一个真正的有序数组。 交换数据部分相对比较简单，下面仅仅给出将最大值放在数组末尾的示意图。\n\n\n\n上面是当n=10时，交换数据的示意图。 当n=10时，首先交换a[0]和a[10]，使得a[10]是a[0...10]之间的最大值；然后，调整a[0...9]使它称为最大堆。交换之后: a[10]是有序的！ 当n=9时， 首先交换a[0]和a[9]，使得a[9]是a[0...9]之间的最大值；然后，调整a[0...8]使它称为最大堆。交换之后: a[9...10]是有序的！ ... 依此类推，直到a[0...10]是有序的。\n\n\n# 堆排序复杂度和稳定性\n\n\n# 堆排序时间复杂度\n\n堆排序的时间复杂度是O(N*lgN)。\n\n假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢? 堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。最多是多少呢? 由于二叉堆是完全二叉树，因此，它的深度最多也不会超过lg(2N)。因此，遍历一趟的时间复杂度是O(N)，而遍历次数介于lg(N+1)和lg(2N)之间；因此得出它的时间复杂度是O(N*lgN)。\n\n\n# 堆排序稳定性\n\n堆排序是不稳定的算法，它不满足稳定算法的定义。它在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。\n\n算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 代码实现\n\n1.先分堆，由于堆的根节点比左右节点都大，所以把根节点和最后一个节点交换位置，然后再从第一个到倒数第二个重新分堆，如此往复即可排序；\n\n2.默认从第一个非叶子节点开始即array.lenght-1开始\n\n效率：\n\n * 平均时间复杂度：NlogN（logN表示匹配一次的时间）\n\n * 最坏时间复杂度：NlogN（匹配了N次)\n\n * 最好时间复杂度：logN（只匹配一次就已经排序）\n\npublic class Test {\n    public static void main(String[] args) {\n        int arr[]=new int[]{5,3,1,0,7,3,10,7,9,6,2,9,1};\n        for(int i=arr.length/2-1;i>=0;i--){//默认取第一个非叶子节点\n            sort(arr,i, arr.length);\n        }\n        for(int i=arr.length-1;i>=0;i--){\n            //交换位置 第一个和最后一个交换位置\n            int temp=arr[i];\n            arr[i]=arr[0];\n            arr[0]=temp;\n\n            sort(arr,0,i);//重新分堆\n        }\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i]+" ");\n        }\n    }\n    public static void sort(int arr[],int i,int lenght){\n        int temp=arr[i];//保留跟节点\n        for(int k=2*i+1;k<lenght;k=2*k+1){\n            if(k+1 <lenght && arr[k]< arr[k+1]){\n                //若右节点大于左节点\n                k++;\n            }\n            if(arr[k] > temp){\n                //判断跟节点是否小于左右节点\n                arr[i]=arr[k];\n                i=k;//保留下标，后续把根节点给它\n            }else{\n                break;\n            }\n        }\n        arr[i]=temp;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n',normalizedContent:'# 排序 - 堆排序(heap sort)\n\n> 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n\n\n# 堆排序介绍\n\n学习堆排序之前，有必要了解堆！若读者不熟悉堆，建议先了解堆(建议可以通过二叉堆，左倾堆，斜堆，二项堆或斐波那契堆等文章进行了解)，然后再来学习本章。\n\n我们知道，堆分为"最大堆"和"最小堆"。最大堆通常被用来进行"升序"排序，而最小堆通常被用来进行"降序"排序。 鉴于最大堆和最小堆是对称关系，理解其中一种即可。本文将对最大堆实现的升序排序进行详细说明。\n\n最大堆进行升序排序的基本思想: ① 初始化堆: 将数列a[1...n]构造成最大堆。 ② 交换数据: 将a[1]和a[n]交换，使a[n]是a[1...n]中的最大值；然后将a[1...n-1]重新调整为最大堆。 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1...n-1]中的最大值；然后将a[1...n-2]重新调整为最大值。 依次类推，直到整个数列都是有序的。\n\n下面，通过图文来解析堆排序的实现过程。注意实现中用到了"数组实现的二叉堆的性质"。 在第一个元素的索引为 0 的情形中:\n\n * 性质一: 索引为i的左孩子的索引是 (2*i+1);\n * 性质二: 索引为i的右孩子的索引是 (2*i+2);\n * 性质三: 索引为i的父结点的索引是 floor((i-1)/2);\n\n\n\n例如，对于最大堆{110,100,90,40,80,20,60,10,30,50,70}而言: 索引为0的左孩子的所有是1；索引为0的右孩子是2；索引为8的父节点是3。\n\n\n# 堆排序实现\n\n下面演示heap_sort_asc(a, n)对a={20,30,90,40,70,110,60,10,100,50,80}, n=11进行堆排序过程。下面是数组a对应的初始化结构:\n\n\n\n\n# 初始化堆\n\n在堆排序算法中，首先要将待排序的数组转化成二叉堆。 下面演示将数组{20,30,90,40,70,110,60,10,100,50,80}转换为最大堆{110,100,90,40,80,20,60,10,30,50,70}的步骤。\n\n * 1.1 i=11/2-1，即i=4\n\n\n\n上面是maxheap_down(a, 4, 9)调整过程。maxheap_down(a, 4, 9)的作用是将a[4...9]进行下调；a[4]的左孩子是a[9]，右孩子是a[10]。调整时，选择左右孩子中较大的一个(即a[10])和a[4]交换。\n\n * 1.2 i=3\n\n\n\n上面是maxheap_down(a, 3, 9)调整过程。maxheap_down(a, 3, 9)的作用是将a[3...9]进行下调；a[3]的左孩子是a[7]，右孩子是a[8]。调整时，选择左右孩子中较大的一个(即a[8])和a[4]交换。\n\n * 1.3 i=2\n\n\n\n上面是maxheap_down(a, 2, 9)调整过程。maxheap_down(a, 2, 9)的作用是将a[2...9]进行下调；a[2]的左孩子是a[5]，右孩子是a[6]。调整时，选择左右孩子中较大的一个(即a[5])和a[2]交换。\n\n * 1.4 i=1\n\n\n\n上面是maxheap_down(a, 1, 9)调整过程。maxheap_down(a, 1, 9)的作用是将a[1...9]进行下调；a[1]的左孩子是a[3]，右孩子是a[4]。调整时，选择左右孩子中较大的一个(即a[3])和a[1]交换。交换之后，a[3]为30，它比它的右孩子a[8]要大，接着，再将它们交换。\n\n * 1.5 i=0\n\n\n\n上面是maxheap_down(a, 0, 9)调整过程。maxheap_down(a, 0, 9)的作用是将a[0...9]进行下调；a[0]的左孩子是a[1]，右孩子是a[2]。调整时，选择左右孩子中较大的一个(即a[2])和a[0]交换。交换之后，a[2]为20，它比它的左右孩子要大，选择较大的孩子(即左孩子)和a[2]交换。\n\n调整完毕，就得到了最大堆。此时，数组{20,30,90,40,70,110,60,10,100,50,80}也就变成了{110,100,90,40,80,20,60,10,30,50,70}。\n\n\n# 交换数据\n\n在将数组转换成最大堆之后，接着要进行交换数据，从而使数组成为一个真正的有序数组。 交换数据部分相对比较简单，下面仅仅给出将最大值放在数组末尾的示意图。\n\n\n\n上面是当n=10时，交换数据的示意图。 当n=10时，首先交换a[0]和a[10]，使得a[10]是a[0...10]之间的最大值；然后，调整a[0...9]使它称为最大堆。交换之后: a[10]是有序的！ 当n=9时， 首先交换a[0]和a[9]，使得a[9]是a[0...9]之间的最大值；然后，调整a[0...8]使它称为最大堆。交换之后: a[9...10]是有序的！ ... 依此类推，直到a[0...10]是有序的。\n\n\n# 堆排序复杂度和稳定性\n\n\n# 堆排序时间复杂度\n\n堆排序的时间复杂度是o(n*lgn)。\n\n假设被排序的数列中有n个数。遍历一趟的时间复杂度是o(n)，需要遍历多少次呢? 堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(n+1)。最多是多少呢? 由于二叉堆是完全二叉树，因此，它的深度最多也不会超过lg(2n)。因此，遍历一趟的时间复杂度是o(n)，而遍历次数介于lg(n+1)和lg(2n)之间；因此得出它的时间复杂度是o(n*lgn)。\n\n\n# 堆排序稳定性\n\n堆排序是不稳定的算法，它不满足稳定算法的定义。它在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。\n\n算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 代码实现\n\n1.先分堆，由于堆的根节点比左右节点都大，所以把根节点和最后一个节点交换位置，然后再从第一个到倒数第二个重新分堆，如此往复即可排序；\n\n2.默认从第一个非叶子节点开始即array.lenght-1开始\n\n效率：\n\n * 平均时间复杂度：nlogn（logn表示匹配一次的时间）\n\n * 最坏时间复杂度：nlogn（匹配了n次)\n\n * 最好时间复杂度：logn（只匹配一次就已经排序）\n\npublic class test {\n    public static void main(string[] args) {\n        int arr[]=new int[]{5,3,1,0,7,3,10,7,9,6,2,9,1};\n        for(int i=arr.length/2-1;i>=0;i--){//默认取第一个非叶子节点\n            sort(arr,i, arr.length);\n        }\n        for(int i=arr.length-1;i>=0;i--){\n            //交换位置 第一个和最后一个交换位置\n            int temp=arr[i];\n            arr[i]=arr[0];\n            arr[0]=temp;\n\n            sort(arr,0,i);//重新分堆\n        }\n        for (int i = 0; i < arr.length; i++) {\n            system.out.print(arr[i]+" ");\n        }\n    }\n    public static void sort(int arr[],int i,int lenght){\n        int temp=arr[i];//保留跟节点\n        for(int k=2*i+1;k<lenght;k=2*k+1){\n            if(k+1 <lenght && arr[k]< arr[k+1]){\n                //若右节点大于左节点\n                k++;\n            }\n            if(arr[k] > temp){\n                //判断跟节点是否小于左右节点\n                arr[i]=arr[k];\n                i=k;//保留下标，后续把根节点给它\n            }else{\n                break;\n            }\n        }\n        arr[i]=temp;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n',charsets:{cjk:!0}},{title:"排序 - 桶排序(Bucket Sort)",frontmatter:{title:"排序 - 桶排序(Bucket Sort)",date:"2021-10-15T14:59:35.000Z",permalink:"/pages/d82d31/",categories:["后端","数据结构","常见的排序算法"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/40.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/08.%E6%8E%92%E5%BA%8F_%E6%A1%B6%E6%8E%92%E5%BA%8F(BucketSort).html",relativePath:"01.后端/40.数据结构/10.常见的排序算法/08.排序_桶排序(BucketSort).md",key:"v-1bf6726c",path:"/pages/d82d31/",headers:[{level:2,title:"桶排序介绍",slug:"桶排序介绍",normalizedTitle:"桶排序介绍",charIndex:111},{level:2,title:"桶排序实现",slug:"桶排序实现",normalizedTitle:"桶排序实现",charIndex:301},{level:2,title:"桶排序复杂度和稳定性",slug:"桶排序复杂度和稳定性",normalizedTitle:"桶排序复杂度和稳定性",charIndex:429},{level:3,title:"桶排序复杂度",slug:"桶排序复杂度",normalizedTitle:"桶排序复杂度",charIndex:429},{level:3,title:"桶排序稳定性",slug:"桶排序稳定性",normalizedTitle:"桶排序稳定性",charIndex:657},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:677}],headersStr:"桶排序介绍 桶排序实现 桶排序复杂度和稳定性 桶排序复杂度 桶排序稳定性 代码实现",content:'# 排序 - 桶排序(Bucket Sort)\n\n> 桶排序(Bucket Sort)的原理很简单，将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。\n\n\n# 桶排序介绍\n\n假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个"桶"。\n\n在排序时，逐个遍历数组a，将数组a的值，作为"桶数组r"的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。\n\n\n# 桶排序实现\n\n假设a={8,2,3,4,3,6,6,3,9}, max=10。此时，将数组a的所有数据都放到需要为0-9的桶中。如下图:\n\n\n\n在将数据放到桶中之后，再通过一定的算法，将桶中的数据提出出来并转换成有序数组。就得到我们想要的结果了。\n\n\n# 桶排序复杂度和稳定性\n\n\n# 桶排序复杂度\n\n * 平均时间复杂度: O(n + k)\n * 最佳时间复杂度: O(n + k)\n * 最差时间复杂度: O(n ^ 2)\n * 空间复杂度: O(n * k)\n\n桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。\n\n\n# 桶排序稳定性\n\n稳定性: 稳定\n\n\n# 代码实现\n\n * max：要比所有的数据都大\n * 只能对大于0的数据排序\n\n    /**\n     * 桶排序\n     * 前提：都为正数、由于要开辟数据中最大值的数据，所以需要的空间很大\n     * @param nums\n     * @param max:所有数据中最大的值\n     */\n    public static void bucketSort(int[] nums,int max){\n        if (nums==null || max<1)\n            return ;\n        // 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0。\n        int[] bucketArray=new int[max];\n        //放进桶\n        for (int i = 0; i < nums.length; i++) {\n            //数据值存放到bucketArray下标中，若有相同值则+1\n            bucketArray[nums[i]]++;\n        }\n        //排序\n        int j=0;\n        for (int i = 0; i < bucketArray.length; i++) {\n            while (bucketArray[i]-- > 0){\n                nums[j++]=i;//i是实际的值\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        int a[]=new int[]{2,7,3,4,3,34,8,9,2,6};\n        Sort.bucketSort(a,35);\n        for (int i = 0; i < a.length; i++) {\n            System.out.print(a[i]+" ");\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n',normalizedContent:'# 排序 - 桶排序(bucket sort)\n\n> 桶排序(bucket sort)的原理很简单，将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。\n\n\n# 桶排序介绍\n\n假设待排序的数组a中共有n个整数，并且已知数组a中数据的范围[0, max)。在桶排序时，创建容量为max的桶数组r，并将桶数组元素都初始化为0；将容量为max的桶数组中的每一个单元都看作一个"桶"。\n\n在排序时，逐个遍历数组a，将数组a的值，作为"桶数组r"的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。\n\n\n# 桶排序实现\n\n假设a={8,2,3,4,3,6,6,3,9}, max=10。此时，将数组a的所有数据都放到需要为0-9的桶中。如下图:\n\n\n\n在将数据放到桶中之后，再通过一定的算法，将桶中的数据提出出来并转换成有序数组。就得到我们想要的结果了。\n\n\n# 桶排序复杂度和稳定性\n\n\n# 桶排序复杂度\n\n * 平均时间复杂度: o(n + k)\n * 最佳时间复杂度: o(n + k)\n * 最差时间复杂度: o(n ^ 2)\n * 空间复杂度: o(n * k)\n\n桶排序最好情况下使用线性时间o(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为o(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。\n\n\n# 桶排序稳定性\n\n稳定性: 稳定\n\n\n# 代码实现\n\n * max：要比所有的数据都大\n * 只能对大于0的数据排序\n\n    /**\n     * 桶排序\n     * 前提：都为正数、由于要开辟数据中最大值的数据，所以需要的空间很大\n     * @param nums\n     * @param max:所有数据中最大的值\n     */\n    public static void bucketsort(int[] nums,int max){\n        if (nums==null || max<1)\n            return ;\n        // 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0。\n        int[] bucketarray=new int[max];\n        //放进桶\n        for (int i = 0; i < nums.length; i++) {\n            //数据值存放到bucketarray下标中，若有相同值则+1\n            bucketarray[nums[i]]++;\n        }\n        //排序\n        int j=0;\n        for (int i = 0; i < bucketarray.length; i++) {\n            while (bucketarray[i]-- > 0){\n                nums[j++]=i;//i是实际的值\n            }\n        }\n    }\n    \n    public static void main(string[] args) {\n        int a[]=new int[]{2,7,3,4,3,34,8,9,2,6};\n        sort.bucketsort(a,35);\n        for (int i = 0; i < a.length; i++) {\n            system.out.print(a[i]+" ");\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n',charsets:{cjk:!0}},{title:"排序 - 选择排序(Selection sort)",frontmatter:{title:"排序 - 选择排序(Selection sort)",date:"2021-10-14T15:29:23.000Z",permalink:"/pages/3de055/",categories:["后端","数据结构","常见的排序算法"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/40.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/05.%E6%8E%92%E5%BA%8F_%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F(Selectionsort).html",relativePath:"01.后端/40.数据结构/10.常见的排序算法/05.排序_选择排序(Selectionsort).md",key:"v-fe3f074c",path:"/pages/3de055/",headers:[{level:2,title:"选择排序介绍",slug:"选择排序介绍",normalizedTitle:"选择排序介绍",charIndex:32},{level:2,title:"选择排序实现",slug:"选择排序实现",normalizedTitle:"选择排序实现",charIndex:151},{level:2,title:"选择排序的时间复杂度和稳定性",slug:"选择排序的时间复杂度和稳定性",normalizedTitle:"选择排序的时间复杂度和稳定性",charIndex:589},{level:3,title:"选择排序时间复杂度",slug:"选择排序时间复杂度",normalizedTitle:"选择排序时间复杂度",charIndex:608},{level:3,title:"选择排序稳定性",slug:"选择排序稳定性",normalizedTitle:"选择排序稳定性",charIndex:707},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:824},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:1329}],headersStr:"选择排序介绍 选择排序实现 选择排序的时间复杂度和稳定性 选择排序时间复杂度 选择排序稳定性 代码实现 参考文章",content:"# 排序 - 选择排序(Selection sort)\n\n\n# 选择排序介绍\n\n它的基本思想是: 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n\n# 选择排序实现\n\n下面以数列{20,40,30,10,60,50}为例，演示它的选择排序过程(如下图)。\n\n\n\n排序流程\n\n * 第1趟: i=0。找出a[1...5]中的最小值a[3]=10，然后将a[0]和a[3]互换。 数列变化: 20,40,30,10,60,50 -- > 10,40,30,20,60,50\n * 第2趟: i=1。找出a[2...5]中的最小值a[3]=20，然后将a[1]和a[3]互换。 数列变化: 10,40,30,20,60,50 -- > 10,20,30,40,60,50\n * 第3趟: i=2。找出a[3...5]中的最小值，由于该最小值大于a[2]，该趟不做任何处理。\n * 第4趟: i=3。找出a[4...5]中的最小值，由于该最小值大于a[3]，该趟不做任何处理。\n * 第5趟: i=4。交换a[4]和a[5]的数据。 数列变化: 10,20,30,40,60,50 -- > 10,20,30,40,50,60\n\n\n# 选择排序的时间复杂度和稳定性\n\n\n# 选择排序时间复杂度\n\n选择排序的时间复杂度是O(N2)。\n\n假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢? N-1！因此，选择排序的时间复杂度是O(N2)。\n\n\n# 选择排序稳定性\n\n选择排序是稳定的算法，它满足稳定算法的定义。\n\n算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 代码实现\n\npublic static int[] selectSort(int[] nums){\n    for (int i = 0; i <nums.length ; i++) {\n        int temp=i;\n        for (int j = i+1; j < nums.length; j++) {\n            if(nums[j] > nums[temp]){\n                temp=j;\n            }\n        }\n        //交换\n        if(temp != i){//不需要中间值交换顺序\n            nums[i]=nums[i]+nums[temp];\n            nums[temp]=nums[i]-nums[temp];\n            nums[i]=nums[i]-nums[temp];\n        }\n    }\n    return nums;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 参考文章\n\n * https://www.pdai.tech/md/algorithm/alg-sort-x-select.html",normalizedContent:"# 排序 - 选择排序(selection sort)\n\n\n# 选择排序介绍\n\n它的基本思想是: 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n\n# 选择排序实现\n\n下面以数列{20,40,30,10,60,50}为例，演示它的选择排序过程(如下图)。\n\n\n\n排序流程\n\n * 第1趟: i=0。找出a[1...5]中的最小值a[3]=10，然后将a[0]和a[3]互换。 数列变化: 20,40,30,10,60,50 -- > 10,40,30,20,60,50\n * 第2趟: i=1。找出a[2...5]中的最小值a[3]=20，然后将a[1]和a[3]互换。 数列变化: 10,40,30,20,60,50 -- > 10,20,30,40,60,50\n * 第3趟: i=2。找出a[3...5]中的最小值，由于该最小值大于a[2]，该趟不做任何处理。\n * 第4趟: i=3。找出a[4...5]中的最小值，由于该最小值大于a[3]，该趟不做任何处理。\n * 第5趟: i=4。交换a[4]和a[5]的数据。 数列变化: 10,20,30,40,60,50 -- > 10,20,30,40,50,60\n\n\n# 选择排序的时间复杂度和稳定性\n\n\n# 选择排序时间复杂度\n\n选择排序的时间复杂度是o(n2)。\n\n假设被排序的数列中有n个数。遍历一趟的时间复杂度是o(n)，需要遍历多少次呢? n-1！因此，选择排序的时间复杂度是o(n2)。\n\n\n# 选择排序稳定性\n\n选择排序是稳定的算法，它满足稳定算法的定义。\n\n算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 代码实现\n\npublic static int[] selectsort(int[] nums){\n    for (int i = 0; i <nums.length ; i++) {\n        int temp=i;\n        for (int j = i+1; j < nums.length; j++) {\n            if(nums[j] > nums[temp]){\n                temp=j;\n            }\n        }\n        //交换\n        if(temp != i){//不需要中间值交换顺序\n            nums[i]=nums[i]+nums[temp];\n            nums[temp]=nums[i]-nums[temp];\n            nums[i]=nums[i]-nums[temp];\n        }\n    }\n    return nums;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 参考文章\n\n * https://www.pdai.tech/md/algorithm/alg-sort-x-select.html",charsets:{cjk:!0}},{title:"排序 - 归并排序(Merge Sort)",frontmatter:{title:"排序 - 归并排序(Merge Sort)",date:"2021-10-15T11:29:24.000Z",permalink:"/pages/b0b120/",categories:["后端","数据结构","常见的排序算法"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/40.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/07.%E6%8E%92%E5%BA%8F_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(MergeSort).html",relativePath:"01.后端/40.数据结构/10.常见的排序算法/07.排序_归并排序(MergeSort).md",key:"v-6b16421e",path:"/pages/b0b120/",headers:[{level:2,title:"归并排序介绍",slug:"归并排序介绍",normalizedTitle:"归并排序介绍",charIndex:92},{level:3,title:"从下往上的归并排序",slug:"从下往上的归并排序",normalizedTitle:"从下往上的归并排序",charIndex:137},{level:3,title:"从上往下的归并排序",slug:"从上往下的归并排序",normalizedTitle:"从上往下的归并排序",charIndex:273},{level:2,title:"归并排序实现",slug:"归并排序实现",normalizedTitle:"归并排序实现",charIndex:510},{level:3,title:"从上往下的归并排序",slug:"从上往下的归并排序-2",normalizedTitle:"从上往下的归并排序",charIndex:273},{level:3,title:"从下往上的归并排序",slug:"从下往上的归并排序-2",normalizedTitle:"从下往上的归并排序",charIndex:137},{level:2,title:"归并排序的时间复杂度和稳定性",slug:"归并排序的时间复杂度和稳定性",normalizedTitle:"归并排序的时间复杂度和稳定性",charIndex:1331},{level:3,title:"归并排序时间复杂度",slug:"归并排序时间复杂度",normalizedTitle:"归并排序时间复杂度",charIndex:1350},{level:3,title:"归并排序稳定性",slug:"归并排序稳定性",normalizedTitle:"归并排序稳定性",charIndex:1490},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:1607}],headersStr:"归并排序介绍 从下往上的归并排序 从上往下的归并排序 归并排序实现 从上往下的归并排序 从下往上的归并排序 归并排序的时间复杂度和稳定性 归并排序时间复杂度 归并排序稳定性 代码实现",content:'# 排序 - 归并排序(Merge Sort)\n\n> 将两个的有序数列合并成一个有序数列，我们称之为"归并"。归并排序(Merge Sort)就是利用归并思想对数列进行排序。\n\n\n# 归并排序介绍\n\n根据具体的实现，归并排序包括"从上往下"和"从下往上"2种方式。\n\n\n# 从下往上的归并排序\n\n将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。(参考下面的图片)\n\n\n# 从上往下的归并排序\n\n它与"从下往上"在排序上是反方向的。它基本包括3步:\n\n * 分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2;\n * 求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1。\n * 合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]。\n\n\n\n\n# 归并排序实现\n\n\n# 从上往下的归并排序\n\n从上往下的归并排序采用了递归的方式实现。它的原理非常简单，如下图:\n\n\n\n通过"从上往下的归并排序"来对数组{80,30,60,40,20,10,50,70}进行排序时:\n\n * 将数组{80,30,60,40,20,10,50,70}看作由两个有序的子数组{80,30,60,40}和{20,10,50,70}组成。对两个有序子树组进行排序即可。\n * 将子数组{80,30,60,40}看作由两个有序的子数组{80,30}和{60,40}组成。\n   * 将子数组{20,10,50,70}看作由两个有序的子数组{20,10}和{50,70}组成。\n * 将子数组{80,30}看作由两个有序的子数组{80}和{30}组成。\n   * 将子数组{60,40}看作由两个有序的子数组{60}和{40}组成。\n   * 将子数组{20,10}看作由两个有序的子数组{20}和{10}组成。\n   * 将子数组{50,70}看作由两个有序的子数组{50}和{70}组成。\n\n\n# 从下往上的归并排序\n\n从下往上的归并排序的思想正好与"从下往上的归并排序"相反。如下图:\n\n\n\n通过"从下往上的归并排序"来对数组{80,30,60,40,20,10,50,70}进行排序时:\n\n * 将数组{80,30,60,40,20,10,50,70}看作由8个有序的子数组{80},{30},{60},{40},{20},{10},{50}和{70}组成。\n * 将这8个有序的子数列两两合并。得到4个有序的子树列{30,80},{40,60},{10,20}和{50,70}。\n * 将这4个有序的子数列两两合并。得到2个有序的子树列{30,40,60,80}和{10,20,50,70}。\n * 将这2个有序的子数列两两合并。得到1个有序的子树列{10,20,30,40,50,60,70,80}。\n\n\n# 归并排序的时间复杂度和稳定性\n\n\n# 归并排序时间复杂度\n\n归并排序的时间复杂度是O(N*lgN)。\n\n假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢? 归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它的时间复杂度是O(N*lgN)。\n\n\n# 归并排序稳定性\n\n归并排序是稳定的算法，它满足稳定算法的定义。\n\n算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 代码实现\n\n    /**\n     * 归并排序\n     * @param nums\n     * @param left\n     * @param right\n     */\n    public static void mergeSort(int[] nums,int left,int right){\n        //把数组一分为二\n        if(left < right){\n            int mid = (left + right)/2;\n            mergeSort(nums,left,mid);\n            mergeSort(nums,mid+1,right);\n            merge(nums,left,mid,right);\n        }\n    }\n    \n        /*\n     * 将一个数组中的两个相邻有序区间合并成一个\n     *\n     * 参数说明:\n     *     a -- 包含两个有序区间的数组\n     *     start -- 第1个有序区间的起始地址。\n     *     mid   -- 第1个有序区间的结束地址。也是第2个有序区间的起始地址。\n     *     end   -- 第2个有序区间的结束地址。\n     */\n    private static void merge(int[] nums, int left, int mid, int right) {\n        int[] tempArray=new int[right-left+1];//定义临时数组\n        int index=0;\n        int i=left,j=mid+1; // i:第1个有序区的索引   j:第2个有序区的索引\n        while (i <= mid && j <= right){\n            if(nums[i] <= nums[j]){\n                tempArray[index++]=nums[i++];//第一个区间的值小一点放进临时数组\n            }else{\n                tempArray[index++]=nums[j++];\n            }\n        }\n        while (i <= mid){//第一个区间还有数据，依次放进去即可\n            tempArray[index++]=nums[i++];\n        }\n        while (j <= right){//第一个区间还有数据，依次放进去即可\n            tempArray[index++]=nums[j++];\n        }\n\t\t// 将排序后的元素，全部都整合到数组a中。\n        for (i = 0; i < index; i++)\n            nums[left + i] = tempArray[i];\n        tempArray=null;\n    }\n    \n    public static void main(String[] args) {\n        int a[]=new int[]{2,7,3,4,3,34,8,0,2,6};\n        Sort.mergeSort(a,0,a.length-1);\n        for (int i = 0; i < a.length; i++) {\n            System.out.print(a[i]+" ");\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n',normalizedContent:'# 排序 - 归并排序(merge sort)\n\n> 将两个的有序数列合并成一个有序数列，我们称之为"归并"。归并排序(merge sort)就是利用归并思想对数列进行排序。\n\n\n# 归并排序介绍\n\n根据具体的实现，归并排序包括"从上往下"和"从下往上"2种方式。\n\n\n# 从下往上的归并排序\n\n将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。(参考下面的图片)\n\n\n# 从上往下的归并排序\n\n它与"从下往上"在排序上是反方向的。它基本包括3步:\n\n * 分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2;\n * 求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1。\n * 合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]。\n\n\n\n\n# 归并排序实现\n\n\n# 从上往下的归并排序\n\n从上往下的归并排序采用了递归的方式实现。它的原理非常简单，如下图:\n\n\n\n通过"从上往下的归并排序"来对数组{80,30,60,40,20,10,50,70}进行排序时:\n\n * 将数组{80,30,60,40,20,10,50,70}看作由两个有序的子数组{80,30,60,40}和{20,10,50,70}组成。对两个有序子树组进行排序即可。\n * 将子数组{80,30,60,40}看作由两个有序的子数组{80,30}和{60,40}组成。\n   * 将子数组{20,10,50,70}看作由两个有序的子数组{20,10}和{50,70}组成。\n * 将子数组{80,30}看作由两个有序的子数组{80}和{30}组成。\n   * 将子数组{60,40}看作由两个有序的子数组{60}和{40}组成。\n   * 将子数组{20,10}看作由两个有序的子数组{20}和{10}组成。\n   * 将子数组{50,70}看作由两个有序的子数组{50}和{70}组成。\n\n\n# 从下往上的归并排序\n\n从下往上的归并排序的思想正好与"从下往上的归并排序"相反。如下图:\n\n\n\n通过"从下往上的归并排序"来对数组{80,30,60,40,20,10,50,70}进行排序时:\n\n * 将数组{80,30,60,40,20,10,50,70}看作由8个有序的子数组{80},{30},{60},{40},{20},{10},{50}和{70}组成。\n * 将这8个有序的子数列两两合并。得到4个有序的子树列{30,80},{40,60},{10,20}和{50,70}。\n * 将这4个有序的子数列两两合并。得到2个有序的子树列{30,40,60,80}和{10,20,50,70}。\n * 将这2个有序的子数列两两合并。得到1个有序的子树列{10,20,30,40,50,60,70,80}。\n\n\n# 归并排序的时间复杂度和稳定性\n\n\n# 归并排序时间复杂度\n\n归并排序的时间复杂度是o(n*lgn)。\n\n假设被排序的数列中有n个数。遍历一趟的时间复杂度是o(n)，需要遍历多少次呢? 归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它的时间复杂度是o(n*lgn)。\n\n\n# 归并排序稳定性\n\n归并排序是稳定的算法，它满足稳定算法的定义。\n\n算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n\n\n# 代码实现\n\n    /**\n     * 归并排序\n     * @param nums\n     * @param left\n     * @param right\n     */\n    public static void mergesort(int[] nums,int left,int right){\n        //把数组一分为二\n        if(left < right){\n            int mid = (left + right)/2;\n            mergesort(nums,left,mid);\n            mergesort(nums,mid+1,right);\n            merge(nums,left,mid,right);\n        }\n    }\n    \n        /*\n     * 将一个数组中的两个相邻有序区间合并成一个\n     *\n     * 参数说明:\n     *     a -- 包含两个有序区间的数组\n     *     start -- 第1个有序区间的起始地址。\n     *     mid   -- 第1个有序区间的结束地址。也是第2个有序区间的起始地址。\n     *     end   -- 第2个有序区间的结束地址。\n     */\n    private static void merge(int[] nums, int left, int mid, int right) {\n        int[] temparray=new int[right-left+1];//定义临时数组\n        int index=0;\n        int i=left,j=mid+1; // i:第1个有序区的索引   j:第2个有序区的索引\n        while (i <= mid && j <= right){\n            if(nums[i] <= nums[j]){\n                temparray[index++]=nums[i++];//第一个区间的值小一点放进临时数组\n            }else{\n                temparray[index++]=nums[j++];\n            }\n        }\n        while (i <= mid){//第一个区间还有数据，依次放进去即可\n            temparray[index++]=nums[i++];\n        }\n        while (j <= right){//第一个区间还有数据，依次放进去即可\n            temparray[index++]=nums[j++];\n        }\n\t\t// 将排序后的元素，全部都整合到数组a中。\n        for (i = 0; i < index; i++)\n            nums[left + i] = temparray[i];\n        temparray=null;\n    }\n    \n    public static void main(string[] args) {\n        int a[]=new int[]{2,7,3,4,3,34,8,0,2,6};\n        sort.mergesort(a,0,a.length-1);\n        for (int i = 0; i < a.length; i++) {\n            system.out.print(a[i]+" ");\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n',charsets:{cjk:!0}},{title:"排序 - 计数排序(Radix Sort)",frontmatter:{title:"排序 - 计数排序(Radix Sort)",date:"2021-10-15T16:58:12.000Z",permalink:"/pages/bddf9b/",categories:["后端","数据结构","常见的排序算法"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/40.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/09.%E6%8E%92%E5%BA%8F_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F(RadixSort).html",relativePath:"01.后端/40.数据结构/10.常见的排序算法/09.排序_计数排序(RadixSort).md",key:"v-28ef8a63",path:"/pages/bddf9b/",headers:[{level:2,title:"计数排序",slug:"计数排序",normalizedTitle:"计数排序",charIndex:2},{level:3,title:"计数排序实现",slug:"计数排序实现",normalizedTitle:"计数排序实现",charIndex:39},{level:3,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:1603}],headersStr:"计数排序 计数排序实现 代码实现",content:"# 计数排序\n\n> 基数排序(Radix Sort)是桶排序的扩展。\n\n\n# 计数排序实现\n\n假设数组：{1、2、3、5、0、2、2、4、5、9}\n\n通过之前的桶排序的方式，该数组在桶中的位置，下标表示实际的值，value代表个数\n\n\n\n * 统计次数数组：下标0表示值为0的有一个，下标5表示值为5的有两个；\n * 前缀和数组presum ：下标1表示值<=1的数有两个，下标为6表示值为<=6的数有九个；其实presum 下标表示值，数组value代表应该在有序数组的位置。\n\n> 因为我们是通过统计次数的数组得到了前缀和数组，那么我们来分析一下 presum 数组里面值的含义。\n> \n> 例如我们的 presum[2] = 5 ,代表的则是原数组小于等于 2 的值共有 5 个。presum[4] = 7 代表小于等于 4 的元素共有 7 个。\n> \n> 是不是感觉计数排序的含义要慢慢显现出来啦。\n> \n> 其实到这里我们已经可以理解的差不多了，还差最后一步，\n> \n> 此时我们要从后往前遍历原始数组，然后将遍历到的元素放到临时数组的合适位置，并修改 presum 数组的值，遍历结束后则达到了排序的目的。\n\n\n\n我们从后往前遍历，nums[9] = 9,则我们拿该值去 presum 数组中查找，发现 presum[nums[9]] = presum[9] = 10 ，大家还记得我们 presum 数组里面每个值得含义不，我们此时 presum[9] = 10,则代表在数组中，小于等于的数共有 10 个，则我们要将他排在临时数组的第 10 个位置，也就是 temp[9] = 9。\n\n我们还需要干什么呢？我们想一下，我们已经把 9 放入到 temp 数组里了，已经对其排好序了，那么我们的 presum 数组则不应该再统计他了，则将相应的位置减 1 即可，也就是 presum[9] = 10 - 1 = 9;\n\n\n\n下面我们继续遍历 5 ，然后同样执行上诉步骤\n\n\n\n我们继续查询 presum 数组，发现 presum[5] = 9,则说明小于等于 5 的数共有 9 个，我们将其放入到 temp 数组的第 9 个位置，也就是\n\ntemp[8] = 5。然后再将 presum[5] 减 1 。\n\n\n\n是不是到这里就理解了计数排序的大致思路啦。\n\n这个排序的过程像不像查字典呢？通过查询 presum 数组，得出自己应该排在临时数组的第几位。然后再修改下字典，直到遍历结束。\n\n那么我们先来用动画模拟一下我们这个 bug 版的计数排序，加深理解。\n\n注：我们得到 presum 数组的过程在动画中省略。直接模拟排序过程。\n\n# 解决空间问题\n\n但是到现在就完了吗？显然没有，我们思考下这个情况。\n\n假如我们的数字为 90，93，94，91，92 如果我们根据上面方法设置 presum 数组的长度，那我们则需要设置数组长度为 95（因为最大值是 94），这样显然是不合理的，会浪费掉很多空间。\n\n还有就是当我们需要对负数进行排序时同样会出现问题，因为我们求次数的时候是根据 nums[index] 的值来填充 presum 数组的，所以当 nums[index] 为负数时，填充 presum 数组时则会报错。而且此时通过最大值来定义数组长度也不合理。\n\n所以我们需要采取别的方法来定义数组长度。\n\n下面我们来说一下偏移量的概念。\n\n例如 90，93，94，91，92，我们 可以通过 max ，min 的值来设置数组长度即 94 - 90 + 1 = 5 。偏移量则为 min 值，也就是 90。\n\n见下图。\n\n\n\n# 解决负数排序\n\n这样我们填充 presum 数组时就不会出现浪费空间的情况了，负数？出现负数的情况当然也可以。继续看\n\n例如：-1，-3，0，2，1\n\n\n\n\n# 代码实现\n\n    /**\n     * 计数排序\n     * @param nums\n     * @return\n     */\n    public static int[] radixSort(int[] nums){\n        int len = nums.length;\n        if (nums.length < 1) {\n            return nums;\n        }\n        //1.求出最大最小值\n        int max = nums[0];\n        int min = nums[0];\n        for (int x : nums) {\n            if (max < x)  max = x;\n            if (min > x)  min = x;\n        }\n        //2.统计次数数组\n        int[] presum=new int[max-min+1];\n        for (int x : nums) {\n            presum[x-min]++;\n        }\n        //3.得出presum 数组长度  该值为前一个数加上自己的数\n        for (int i = 1; i < presum.length; ++i) {\n            presum[i] = presum[i-1]+presum[i];\n        }\n        //临时数组\n        int[] temp = new int[len];\n        //4.遍历数组，开始排序,注意偏移量\n        for (int i = len-1; i >= 0; --i) {//从最后开始编辑\n            //查找 presum 字典，然后将其放到临时数组，注意偏移度\n            int index = presum[nums[i]-min]-1;\n            temp[index] = nums[i];\n            //相应位置减一\n            presum[nums[i]-min]--;\n        }\n        //copy回原数组\n        System.arraycopy(temp,0,nums,0,len);\n        return nums;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n",normalizedContent:"# 计数排序\n\n> 基数排序(radix sort)是桶排序的扩展。\n\n\n# 计数排序实现\n\n假设数组：{1、2、3、5、0、2、2、4、5、9}\n\n通过之前的桶排序的方式，该数组在桶中的位置，下标表示实际的值，value代表个数\n\n\n\n * 统计次数数组：下标0表示值为0的有一个，下标5表示值为5的有两个；\n * 前缀和数组presum ：下标1表示值<=1的数有两个，下标为6表示值为<=6的数有九个；其实presum 下标表示值，数组value代表应该在有序数组的位置。\n\n> 因为我们是通过统计次数的数组得到了前缀和数组，那么我们来分析一下 presum 数组里面值的含义。\n> \n> 例如我们的 presum[2] = 5 ,代表的则是原数组小于等于 2 的值共有 5 个。presum[4] = 7 代表小于等于 4 的元素共有 7 个。\n> \n> 是不是感觉计数排序的含义要慢慢显现出来啦。\n> \n> 其实到这里我们已经可以理解的差不多了，还差最后一步，\n> \n> 此时我们要从后往前遍历原始数组，然后将遍历到的元素放到临时数组的合适位置，并修改 presum 数组的值，遍历结束后则达到了排序的目的。\n\n\n\n我们从后往前遍历，nums[9] = 9,则我们拿该值去 presum 数组中查找，发现 presum[nums[9]] = presum[9] = 10 ，大家还记得我们 presum 数组里面每个值得含义不，我们此时 presum[9] = 10,则代表在数组中，小于等于的数共有 10 个，则我们要将他排在临时数组的第 10 个位置，也就是 temp[9] = 9。\n\n我们还需要干什么呢？我们想一下，我们已经把 9 放入到 temp 数组里了，已经对其排好序了，那么我们的 presum 数组则不应该再统计他了，则将相应的位置减 1 即可，也就是 presum[9] = 10 - 1 = 9;\n\n\n\n下面我们继续遍历 5 ，然后同样执行上诉步骤\n\n\n\n我们继续查询 presum 数组，发现 presum[5] = 9,则说明小于等于 5 的数共有 9 个，我们将其放入到 temp 数组的第 9 个位置，也就是\n\ntemp[8] = 5。然后再将 presum[5] 减 1 。\n\n\n\n是不是到这里就理解了计数排序的大致思路啦。\n\n这个排序的过程像不像查字典呢？通过查询 presum 数组，得出自己应该排在临时数组的第几位。然后再修改下字典，直到遍历结束。\n\n那么我们先来用动画模拟一下我们这个 bug 版的计数排序，加深理解。\n\n注：我们得到 presum 数组的过程在动画中省略。直接模拟排序过程。\n\n# 解决空间问题\n\n但是到现在就完了吗？显然没有，我们思考下这个情况。\n\n假如我们的数字为 90，93，94，91，92 如果我们根据上面方法设置 presum 数组的长度，那我们则需要设置数组长度为 95（因为最大值是 94），这样显然是不合理的，会浪费掉很多空间。\n\n还有就是当我们需要对负数进行排序时同样会出现问题，因为我们求次数的时候是根据 nums[index] 的值来填充 presum 数组的，所以当 nums[index] 为负数时，填充 presum 数组时则会报错。而且此时通过最大值来定义数组长度也不合理。\n\n所以我们需要采取别的方法来定义数组长度。\n\n下面我们来说一下偏移量的概念。\n\n例如 90，93，94，91，92，我们 可以通过 max ，min 的值来设置数组长度即 94 - 90 + 1 = 5 。偏移量则为 min 值，也就是 90。\n\n见下图。\n\n\n\n# 解决负数排序\n\n这样我们填充 presum 数组时就不会出现浪费空间的情况了，负数？出现负数的情况当然也可以。继续看\n\n例如：-1，-3，0，2，1\n\n\n\n\n# 代码实现\n\n    /**\n     * 计数排序\n     * @param nums\n     * @return\n     */\n    public static int[] radixsort(int[] nums){\n        int len = nums.length;\n        if (nums.length < 1) {\n            return nums;\n        }\n        //1.求出最大最小值\n        int max = nums[0];\n        int min = nums[0];\n        for (int x : nums) {\n            if (max < x)  max = x;\n            if (min > x)  min = x;\n        }\n        //2.统计次数数组\n        int[] presum=new int[max-min+1];\n        for (int x : nums) {\n            presum[x-min]++;\n        }\n        //3.得出presum 数组长度  该值为前一个数加上自己的数\n        for (int i = 1; i < presum.length; ++i) {\n            presum[i] = presum[i-1]+presum[i];\n        }\n        //临时数组\n        int[] temp = new int[len];\n        //4.遍历数组，开始排序,注意偏移量\n        for (int i = len-1; i >= 0; --i) {//从最后开始编辑\n            //查找 presum 字典，然后将其放到临时数组，注意偏移度\n            int index = presum[nums[i]-min]-1;\n            temp[index] = nums[i];\n            //相应位置减一\n            presum[nums[i]-min]--;\n        }\n        //copy回原数组\n        system.arraycopy(temp,0,nums,0,len);\n        return nums;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n",charsets:{cjk:!0}},{title:"Kafka笔记",frontmatter:{title:"Kafka笔记",date:"2021-08-04T19:50:36.000Z",permalink:"/pages/6c0a61/",categories:["后端","消息队列"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/60.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/01.Kafka%E7%AC%94%E8%AE%B0.html",relativePath:"01.后端/60.消息队列/01.Kafka笔记.md",key:"v-630cc93a",path:"/pages/6c0a61/",headers:[{level:2,title:"一.消息队列的两种模式",slug:"一-消息队列的两种模式",normalizedTitle:"一.消息队列的两种模式",charIndex:12},{level:3,title:"（1）点对点模式",slug:"_1-点对点模式",normalizedTitle:"（1）点对点模式",charIndex:28},{level:3,title:"（2）发布/订阅模式",slug:"_2-发布-订阅模式",normalizedTitle:"（2）发布/订阅模式",charIndex:198},{level:2,title:"二.Kafka架构",slug:"二-kafka架构",normalizedTitle:"二.kafka架构",charIndex:521},{level:2,title:"三Kafka的集群搭建",slug:"三kafka的集群搭建",normalizedTitle:"三kafka的集群搭建",charIndex:1277},{level:3,title:"1.解压kafka",slug:"_1-解压kafka",normalizedTitle:"1.解压kafka",charIndex:1542},{level:3,title:"2.改名",slug:"_2-改名",normalizedTitle:"2.改名",charIndex:1632},{level:3,title:"3.创建数据文件",slug:"_3-创建数据文件",normalizedTitle:"3.创建数据文件",charIndex:1677},{level:3,title:"4.修改配置文件",slug:"_4-修改配置文件",normalizedTitle:"4.修改配置文件",charIndex:1841},{level:3,title:"5.复制到server2、server3",slug:"_5-复制到server2、server3",normalizedTitle:"5.复制到server2、server3",charIndex:3015},{level:3,title:"6.启动",slug:"_6-启动",normalizedTitle:"6.启动",charIndex:3159},{level:3,title:"7.测试",slug:"_7-测试",normalizedTitle:"7.测试",charIndex:4201},{level:2,title:"四.操作主题（topic）",slug:"四-操作主题-topic",normalizedTitle:"四.操作主题（topic）",charIndex:4220},{level:3,title:"1.创建topic",slug:"_1-创建topic",normalizedTitle:"1.创建topic",charIndex:4250},{level:3,title:"2.查看topic（有多少个topic）",slug:"_2-查看topic-有多少个topic",normalizedTitle:"2.查看topic（有多少个topic）",charIndex:4617},{level:3,title:"3.查看详情",slug:"_3-查看详情",normalizedTitle:"3.查看详情",charIndex:4702},{level:3,title:"4.删除topic",slug:"_4-删除topic",normalizedTitle:"4.删除topic",charIndex:4793},{level:2,title:"五.发送消息",slug:"五-发送消息",normalizedTitle:"五.发送消息",charIndex:4881},{level:2,title:"六.消费消息",slug:"六-消费消息",normalizedTitle:"六.消费消息",charIndex:4971},{level:3,title:"1.过时命令",slug:"_1-过时命令",normalizedTitle:"1.过时命令",charIndex:5043},{level:3,title:"2.新命令",slug:"_2-新命令",normalizedTitle:"2.新命令",charIndex:5280},{level:2,title:"七.kafka架构深入",slug:"七-kafka架构深入",normalizedTitle:"七.kafka架构深入",charIndex:5395},{level:2,title:"八.kafka文件存储",slug:"八-kafka文件存储",normalizedTitle:"八.kafka文件存储",charIndex:5744},{level:2,title:"九.生产者",slug:"九-生产者",normalizedTitle:"九.生产者",charIndex:6026},{level:3,title:"1.分区规则",slug:"_1-分区规则",normalizedTitle:"1.分区规则",charIndex:6036},{level:3,title:"2.数据可靠性",slug:"_2-数据可靠性",normalizedTitle:"2.数据可靠性",charIndex:6508},{level:3,title:"3.Exactly Once 语义（精准一次）",slug:"_3-exactly-once-语义-精准一次",normalizedTitle:"3.exactly once 语义（精准一次）",charIndex:8825},{level:2,title:"十.消费者",slug:"十-消费者",normalizedTitle:"十.消费者",charIndex:9731},{level:3,title:"1.消费方式",slug:"_1-消费方式",normalizedTitle:"1.消费方式",charIndex:9741},{level:3,title:"2.分区分配策略",slug:"_2-分区分配策略",normalizedTitle:"2.分区分配策略",charIndex:10085},{level:3,title:"3.offset 的维护",slug:"_3-offset-的维护",normalizedTitle:"3.offset 的维护",charIndex:10437},{level:3,title:"4.消费者组案例",slug:"_4-消费者组案例",normalizedTitle:"4.消费者组案例",charIndex:10750},{level:2,title:"十一.Kafka 高效读写数据",slug:"十一-kafka-高效读写数据",normalizedTitle:"十一.kafka 高效读写数据",charIndex:11620},{level:3,title:"1）顺序写磁盘",slug:"_1-顺序写磁盘",normalizedTitle:"1）顺序写磁盘",charIndex:11640},{level:3,title:"2）零复制技术",slug:"_2-零复制技术",normalizedTitle:"2）零复制技术",charIndex:11801},{level:2,title:"十二.Zookeeper 在 Kafka 中的作用",slug:"十二-zookeeper-在-kafka-中的作用",normalizedTitle:"十二.zookeeper 在 kafka 中的作用",charIndex:11836},{level:2,title:"十三. Kafka 事务",slug:"十三-kafka-事务",normalizedTitle:"十三. kafka 事务",charIndex:12024},{level:3,title:"Producer 事务",slug:"producer-事务",normalizedTitle:"producer 事务",charIndex:12167},{level:3,title:"Consumer 事务",slug:"consumer-事务",normalizedTitle:"consumer 事务",charIndex:12540},{level:2,title:"十四.API生产者流程",slug:"十四-api生产者流程",normalizedTitle:"十四.api生产者流程",charIndex:12718},{level:2,title:"十五.java中引入生产者",slug:"十五-java中引入生产者",normalizedTitle:"十五.java中引入生产者",charIndex:13047},{level:3,title:"1.生产者发送消息",slug:"_1-生产者发送消息",normalizedTitle:"1.生产者发送消息",charIndex:13065},{level:3,title:"2.自定义分区",slug:"_2-自定义分区",normalizedTitle:"2.自定义分区",charIndex:14951},{level:2,title:"十六.引入消费者",slug:"十六-引入消费者",normalizedTitle:"十六.引入消费者",charIndex:15695},{level:3,title:"1.消费者实现",slug:"_1-消费者实现",normalizedTitle:"1.消费者实现",charIndex:15708},{level:3,title:"2.消费者从头消费",slug:"_2-消费者从头消费",normalizedTitle:"2.消费者从头消费",charIndex:17831},{level:3,title:"3.消费者手动提交offset",slug:"_3-消费者手动提交offset",normalizedTitle:"3.消费者手动提交offset",charIndex:18207},{level:3,title:"4 .自定义存储 offset",slug:"_4-自定义存储-offset",normalizedTitle:"4 .自定义存储 offset",charIndex:24049},{level:2,title:"十七.自定义拦截器",slug:"十七-自定义拦截器",normalizedTitle:"十七.自定义拦截器",charIndex:28195},{level:3,title:"拦截器按钮",slug:"拦截器按钮",normalizedTitle:"拦截器按钮",charIndex:29163},{level:2,title:"十八.安装kafka-eagle监视",slug:"十八-安装kafka-eagle监视",normalizedTitle:"十八.安装kafka-eagle监视",charIndex:30687},{level:3,title:"1.解压",slug:"_1-解压",normalizedTitle:"1.解压",charIndex:1542},{level:3,title:"2.解压后还有个压缩文件，cd再解压",slug:"_2-解压后还有个压缩文件-cd再解压",normalizedTitle:"2.解压后还有个压缩文件，cd再解压",charIndex:30770},{level:3,title:"3.改名",slug:"_3-改名",normalizedTitle:"3.改名",charIndex:30885},{level:3,title:"4.给文件权限",slug:"_4-给文件权限",normalizedTitle:"4.给文件权限",charIndex:30932},{level:3,title:"5.修改配置文件",slug:"_5-修改配置文件",normalizedTitle:"5.修改配置文件",charIndex:30982},{level:3,title:"监控信息：",slug:"监控信息",normalizedTitle:"监控信息：",charIndex:35086},{level:2,title:"十九.面试题",slug:"十九-面试题",normalizedTitle:"十九.面试题",charIndex:35098},{level:2,title:"二十.SSM引入Kafka",slug:"二十-ssm引入kafka",normalizedTitle:"二十.ssm引入kafka",charIndex:35116},{level:3,title:"1.引入依赖",slug:"_1-引入依赖-2",normalizedTitle:"1.引入依赖",charIndex:13078},{level:3,title:"2.kafka配置信息",slug:"_2-kafka配置信息",normalizedTitle:"2.kafka配置信息",charIndex:35552},{level:3,title:"3.生产者配置",slug:"_3-生产者配置",normalizedTitle:"3.生产者配置",charIndex:35734},{level:3,title:"4.消费者配置",slug:"_4-消费者配置",normalizedTitle:"4.消费者配置",charIndex:38267},{level:3,title:"5.生产者发送消息",slug:"_5-生产者发送消息",normalizedTitle:"5.生产者发送消息",charIndex:42010}],headersStr:"一.消息队列的两种模式 （1）点对点模式 （2）发布/订阅模式 二.Kafka架构 三Kafka的集群搭建 1.解压kafka 2.改名 3.创建数据文件 4.修改配置文件 5.复制到server2、server3 6.启动 7.测试 四.操作主题（topic） 1.创建topic 2.查看topic（有多少个topic） 3.查看详情 4.删除topic 五.发送消息 六.消费消息 1.过时命令 2.新命令 七.kafka架构深入 八.kafka文件存储 九.生产者 1.分区规则 2.数据可靠性 3.Exactly Once 语义（精准一次） 十.消费者 1.消费方式 2.分区分配策略 3.offset 的维护 4.消费者组案例 十一.Kafka 高效读写数据 1）顺序写磁盘 2）零复制技术 十二.Zookeeper 在 Kafka 中的作用 十三. Kafka 事务 Producer 事务 Consumer 事务 十四.API生产者流程 十五.java中引入生产者 1.生产者发送消息 2.自定义分区 十六.引入消费者 1.消费者实现 2.消费者从头消费 3.消费者手动提交offset 4 .自定义存储 offset 十七.自定义拦截器 拦截器按钮 十八.安装kafka-eagle监视 1.解压 2.解压后还有个压缩文件，cd再解压 3.改名 4.给文件权限 5.修改配置文件 监控信息： 十九.面试题 二十.SSM引入Kafka 1.引入依赖 2.kafka配置信息 3.生产者配置 4.消费者配置 5.生产者发送消息",content:'# Kafka\n\n\n# 一.消息队列的两种模式\n\n\n# （1）点对点模式\n\n（一对一，消费者主动拉取数据，消息收到后消息清除）\n\n> 消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。 消息被消费以后，queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。 Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。\n\n\n# （2）发布/订阅模式\n\n（一对多，消费者消费数据之后不会清除消息）\n\n> 消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消 息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。\n\n发布订阅也有两种模式\n\n * 传统的发布订阅模式是队列（topic）推送给消费者，但是这样的坏处是，消费者处理能力不足可能造成宕机；\n * Kafka就是通过消费者主动去队列中拉数据：但是也有坏处，消费者就需要去轮训队列中是否有数据（浪费资源）\n * **队列在内部维护队列，存放某主题订阅的消费者，通知消费者去拉取数据，**该方式也有坏处，需要队列再多维护一个队列，消费者如果宕机了，队列照样要去通知。\n\n\n# 二.Kafka架构\n\n\n\n1）Producer ：消息生产者，就是向 kafka broker 发消息的客户端；\n\n2）Consumer ：消息消费者，向 kafka broker 取消息的客户端；\n\n3）Consumer Group （CG）：消费者组，由多个 consumer 组成。消费者组内每个消费者负 责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。所 有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。\n\n4）Broker ：一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。 5）Topic ：可以理解为一个队列，生产者和消费者面向的都是一个 topic；\n\n6）Partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上， 一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；\n\n7）Replica：副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失， 尚硅谷官网 且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本， 一个 leader 和若干个 follower。\n\n8）leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对 象都是 leader。\n\n9）follower：每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据 的同步。leader 发生故障时，某个 follower 会成为新的 follower。\n\n\n# 三Kafka的集群搭建\n\n> 本机搭建（伪集群）\n> \n> 前提：zookeeper集群已经启动\n> \n> 端口分别为：localhost:2181,localhost:2182,localhost:2183\n> \n> 参考：本网站搭建的zookeeper集群\n> \n> kafka端口：localhost:9092、localhost:9093、localhost:9094\n\n下载地址：http://kafka.apache.org/downloads\n\nkafka版本：kafka_2.11-0.11.0.0.gz\n\n\n# 1.解压kafka\n\ntar -zxvf kafka_2.11-0.11.0.0.tgz -C /opt/module/kafka/kafka/server1/\n\n\n1\n\n\n\n# 2.改名\n\nmv kafka_2.11-0.11.0.0/ kafka\n\n\n1\n\n\n\n# 3.创建数据文件\n\n存放生产者生产的数据\n\nmkdir /opt/module/kafka/kafka/server1/data\nmkdir /opt/module/kafka/kafka/server2/data\nmkdir /opt/module/kafka/kafka/server3/data\n\n\n1\n2\n3\n\n\n\n# 4.修改配置文件\n\ncd config/\nvi server.properties\n\n\n1\n2\n\n\n 1. broker.id=0 依次改为0,1,2\n\n 2. 开启delete.topic.enable=true\n\n 3. listeners=PLAINTEXT://localhost:9092 依次改为9092,9093,9094\n    \n    注意：\n    \n    * listeners：是kafka真正bind的地址\n    * advertised.listeners：是暴露给外部的listeners，如果没有设置，会用listeners\n    * 若要外部访问kafka，一定要把listeners配置为IP+端口，外部就能访问了，控制台消费者就需要通过IP+端口来访问了。\n\n 4. log.dirs=/opt/module/kafka/kafka/server1/data\n\n 5. zookeeper.connect=localhost:2181,localhost:2182,localhost:2183\n\n#broker 的全局唯一编号，不能重复\nbroker.id=0\n#删除 topic 功能使能\ndelete.topic.enable=true\n#配置端口号\nlisteners=PLAINTEXT://localhost:9092 \n#处理网络请求的线程数量\nnum.network.threads=3\n#用来处理磁盘 IO 的现成数量\nnum.io.threads=8\n#发送套接字的缓冲区大小\nsocket.send.buffer.bytes=102400\n#接收套接字的缓冲区大小\nsocket.receive.buffer.bytes=102400\n#请求套接字的缓冲区大小\nsocket.request.max.bytes=104857600\n#kafka 运行日志存放的路径\nlog.dirs=/opt/module/kafka/kafka/server1/data\n#topic 在当前 broker 上的分区个数\nnum.partitions=1\n#用来恢复和清理 data 下数据的线程数量\nnum.recovery.threads.per.data.dir=1\n#segment 文件保留的最长时间，超时将被删除\nlog.retention.hours=168\n#配置连接 Zookeeper 集群地址\nzookeeper.connect=localhost:2181,localhost:2182,localhost:2183\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 5.复制到server2、server3\n\ncp -r ./kafka /opt/module/kafka/kafka/server2/\ncp -r ./kafka /opt/module/kafka/kafka/server3/\n\n\n1\n2\n\n\n依次修改配置文件，参考上方修改\n\n\n# 6.启动\n\n# 方式一：一次启动\n\n 1. -daemon：后台启动\n 2. config/server.properties：加载配置文件\n\nbin/kafka-server-start.sh -daemon config/server.properties\n\n\n1\n\n\n# 方式二：sh文件启动\n\n1.脚本内容kkStart.sh\n\n#!/bin/bash\n\nif [ "$1" = "" ];\nthen\n    echo -e "\\033[0;31m 未输入操作名 \\033[0m  \\033[0;34m {start|stop} \\033[0m"\n    exit 1\nfi\n\nfunction start()\n{\n\tserver1/kafka/bin/kafka-server-start.sh -daemon start server1/kafka/config/server.properties\n\tserver2/kafka/bin/kafka-server-start.sh -daemon start server2/kafka/config/server.properties\n\tserver3/kafka/bin/kafka-server-start.sh -daemon start server3/kafka/config/server.properties\n}\n\nfunction stop()\n{\n\tserver1/kafka/bin/kafka-server-stop.sh stop\n\tserver2/kafka/bin/kafka-server-stop.sh stop\n\tserver3/kafka/bin/kafka-server-stop.sh stop\n}\n\n\n\ncase $1 in\n    start)\n    start;;\n    stop)\n    stop;;\n    *)\n\nesac\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n2.放到server1同一目录\n\n3.给权限\n\nchmod +x kkStart.sh\n\n\n1\n\n\n4.转化文件，通过wind10编辑后放入到linux，会出现文件格式不对\n\nsed -i "s/\\r//" kkStart.sh\n\n\n1\n\n\n\n# 7.测试\n\njps\n\n\n1\n\n\n\n# 四.操作主题（topic）\n\n先进入kafka目录\n\n\n# 1.创建topic\n\nbin/kafka-topics.sh --zookeeper localhost:2182 --create --partitions 3 --replication-factor 2 --topic first\n\n\n1\n\n * bin/kafka-topics.sh：执行主题相关操作\n * --zookeeper localhost:2182：与某台zookeeper关联，由于kafka依赖于zookeeper\n * --partitions 3：分区数，该数没有限制，比如创建first，则会创建first0、first1、first2\n * --replication-factor 2：副本，每个kafka集群只保存两个分区的副本，最多为集群数\n * --topic first：名字\n\n\n\n\n# 2.查看topic（有多少个topic）\n\nbin/kafka-topics.sh --zookeeper localhost:2182 --list\n\n\n1\n\n\n\n# 3.查看详情\n\nbin/kafka-topics.sh --zookeeper localhost:2182 --describe --topic first\n\n\n1\n\n\n\n\n\n# 4.删除topic\n\nbin/kafka-topics.sh --zookeeper localhost:2182 --delete --topic two\n\n\n1\n\n\n\n# 五.发送消息\n\nbin/kafka-console-producer.sh --broker-list localhost:9092 --topic first\n\n\n1\n\n\n\n# 六.消费消息\n\nkafka默认是消费者去拉数据，所以可以收到之前订阅主题的数据，但是控制台需要加上--from-beginning才行\n\n\n# 1.过时命令\n\n> 注意：下面方式已经过时，以前消息存在zookeeper中，现在存在kafka中\n\n./bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic first\n\n\n1\n\n\n从头开始接受数据\n\nbin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic first --from-beginning\n\n\n1\n\n\n\n# 2.新命令\n\n该方式则存在kafka配置的log里面\n\nbin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic first\n\n\n1\n\n\n\n# 七.kafka架构深入\n\n\n\n> 生产者发送消息，根据生产者的策略，发送给分区1、分区2、分区3，分区内部也自己维护了一个偏移量（offset），分区内部能保证顺序性，分区则不能保证。\n\nKafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，都是面向 topic 的。\n\ntopic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文 件，该 log 文件中存储的就是 producer 生产的数据。Producer 生产的数据会被不断追加到该 log 文件末端，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自己 消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。\n\n\n# 八.kafka文件存储\n\n\n\n> 消息都存放在分区的data文件中，消息会不断的追加到log文件末尾，为防止 log 文件过大导致数据定位 效率低下，Kafka 采取了分片和索引机制，里面有一个index文件和log文件，log存放的是实际的数据，index则是保存的消息的索引。\n\n\n\n生产者发送的消息的偏移量通过二分法找到对应的index文件，index文件每一行的数据大小是固定的，假如每一行大小为1024，如果要查找偏移量为3的，则直接3*1024就能找到存储数据的偏移量，根据这个偏移量（存储了偏移量和数据大小）去log文件中直接读取数据即可。\n\n\n# 九.生产者\n\n\n# 1.分区规则\n\n1）分区的原因\n\n * 方便在集群中扩展，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic 又可以有多个 Partition 组成，因此整个集群就可以适应任意大小的数据了；\n\n * 可以提高并发，因为可以以 Partition 为单位读写了。\n\n2）分区的原则\n\n我们需要将 producer 发送的数据封装成一个 ProducerRecord 对象。\n\n\n\n 1. 指明 partition 的情况下，直接将指明的值直接作为 partiton 值；\n 2. 没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值；\n 3. 既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后 面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是常说的 round-robin 算法。\n\n\n# 2.数据可靠性\n\n为保证 producer 发送的数据，能可靠的发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack（acknowledgement 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。\n\n# 1）副本数据同步策略\n\n方案               优点                                       缺点\n半数以上发送ACK则代表成功   延迟低                                      选取新的leader时，容忍n台节点故障，则需要2n+1个副本\n全部完成同步，才发送ACK    选举新的 leader 时，容忍 n 台 节点的故障，需要 n+1 个副 本   延迟高\n\nKafka 选择了第二种方案：\n\n原因如下：\n\n1.同样为了容忍 n 台节点的故障，第一种方案需要 2n+1 个副本，而第二种方案只需要 n+1 个副本，而 Kafka 的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。\n\n2.虽然第二种方案的网络延迟会比较高，但网络延迟对 Kafka 的影响较小。\n\n# 2）ISR\n\n采用第二种方案之后，设想以下情景：leader 收到数据，所有 follower 都开始同步数据， 但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去， 直到它完成同步，才能发送 ack。这个问题怎么解决呢？\n\nLeader 维护了一个动态的 in-sync replica set (ISR)，意为和 leader 保持同步的 follower 集 合。当 ISR 中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower 长时间 未 向 leader 同 步 数 据 ， 则 该 follower 将 被 踢 出 ISR ， 该 时 间 阈 值 replica.lag.time.max.ms 参数设定。Leader 发生故障之后，就会从 ISR 中选举新的 leader。\n\n> 注意：0.8版本是由时间和条数决定的，后面版本已经剔除条数了；\n> \n> 时间：follower 向leader发送ack的时间\n> \n> 条数：follower 同步leader数据的条数\n> \n> 剔除条数的原因：\n> \n> 假如条数低于10的剔除ISR，如果生产者不停的发送数据，那么条数一会大于10，一会小于10，那么就会不停的在操作ISR，并且ISR信息也会保存到ZK，那么同样也会操作ZK。\n\n# 3）ack 应答机制\n\n对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失， 所以没必要等 ISR 中的 follower 全部接收成功。 所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡， 选择以下的配置。\n\nacks 参数配置：\n\n 1. 0：producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还 没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据；\n\n 2. 1：producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据；\n\n 3. -1（all）：producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才 返回 ack。但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会 造成数据重复。\n    \n    > 重复：当leader和follower 都同步成功后，还未发送ack时，leader挂掉，重新选择新的leader，但是生产者未收到ack，则重新发送数据，那么数据就重复了。\n    \n    > -1也会造成数据丢失:：比如ISR中只有一个副本，那么该副本肯定是leader，一旦该副本挂掉数据就没了\n\n# 4）故障处理细节\n\nLEO：每个副本的最后一个offset\n\nHW：所有副本中最小的LEO\n\n\n\nLEO：指的是每个副本最大的 offset；\n\nHW：指的是**消费者能见到的最大的 offset，**ISR 队列中最小的 LEO。\n\n（1）follower 故障 follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后，follower 会读取本地磁盘 记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。 等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重 新加入 ISR 了。\n\n（2）leader 故障 leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的 数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。 注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。\n\n\n# 3.Exactly Once 语义（精准一次）\n\n将服务器的 ACK 级别设置为-1，可以保证 Producer 到 Server 之间不会丢失数据，即 At Least Once （最少一次）语义。相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 At Most Once （至多一次）语义。\n\nAt Least Once 可以保证数据不丢失，但是不能保证数据不重复；相对的，At Least Once 可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说 交易数据，下游数据消费者要求数据既不重复也不丢失，即 Exactly Once 语义。**在 0.11 版 本以前的 Kafka，对此是无能为力的，**只能保证数据不丢失，再在下游消费者对数据做全局 去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。\n\n0.11 版本的 Kafka，引入了一项重大特性：幂等性。所谓的幂等性就是指 Producer 不论 向 Server 发送多少次重复数据，Server 端都只会持久化一条。幂等性结合 At Least Once 语 义，就构成了 Kafka 的 Exactly Once 语义。即：\n\n> At Least Once + 幂等性 = Exactly Once\n\n要启用幂等性，只需要将 Producer 的参数中 enable.idompotence 设置为 true 即可。Kafka 的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的 Producer 在 初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而 Broker 端会对《PID、Partition 、Sequence Number》做缓存，当具有相同主键的消息提交时，Broker 只 会持久化一条。\n\n但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨 分区跨会话的 Exactly Once。\n\n\n# 十.消费者\n\n\n# 1.消费方式\n\nconsumer 采用 pull（拉）模式从 broker 中读取数据。\n\npush（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。 它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息， 典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适 当的速率消费消息。\n\npull 模式不足之处是，如果 kafka 没有数据，消费者可能会陷入循环中，一直返回空数 据。针对这一点，Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有 数据可供消费，consumer 会等待一段时间之后再返回，这段时长即为 timeout。\n\n\n# 2.分区分配策略\n\n> 消费者个数发生变化则触发：\n\n一个 consumer group 中有多个 consumer，一个 topic 有多个 partition，所以必然会涉及 到 partition 的分配问题，即确定那个 partition 由哪个 consumer 来消费。\n\nKafka 有两种分配策略，一是 RoundRobin，一是 Range。\n\n> RoundRobin：轮训策略（适用于消费者组订阅的主题是一样的），是以消费者组为单位，把消费者所订阅的主题进行hash排序，挨个轮训发送给消费者；\n> \n> 问题：若消费者订阅的主题不相同，那么就会收到不是自己订阅的主题。\n> \n> Range：范围，是以主题为单位，在一个主题的分区中，通过分区数/消费者数目来分发给消费者\n\n\n# 3.offset 的维护\n\n由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故 障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢 复后继续消费。\n\n\n\n存放在zookeeper中的/consumers/消费者/主题/分区：\n\n\n1\n\n\n\n\nKafka 0.9 版本之前，consumer 默认将 offset 保存在 Zookeeper 中，从 0.9 版本开始， consumer 默认将 offset 保存在 Kafka 一个内置的 topic 中，该 topic 为**__consumer_offsets**。\n\n\n# 4.消费者组案例\n\n1.)需求：测试同一个消费者组中的消费者，同一时刻只能有一个消费者消费。\n\n2)实操：\n\n（1）在 server1、server2上修改/opt/module/kafka/config/consumer.properties 配置 文件中的 group.id 属性为任意组名。\n\n$ vi consumer.properties\ngroup.id=wcy\n\n\n1\n2\n\n\n(2)在 server1、server2上分别启动消费者\n\nserver1上启动  加载刚才修改的配置文件\nbin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic bigdata --consumer.config config/consumer.properties\nserver2上启动   加载自己修改的配置文件\nbin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic bigdata --consumer.config config/consumer.properties\n\n\n1\n2\n3\n4\n\n\n现在server1、server2是同一个消费者组的了。\n\n（3）在 server3上启动消费者默认的配置文件\n\nbin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic bigdata\n\n\n1\n\n\n（4）随便启动一个生产者\n\nbin/kafka-console-producer.sh --broker-list localhost:9092 --topic bigdata\n\n\n1\n\n\n> 最后可以看到：\n> \n> 生产者发送一条消息后，消费者server1和server2只可能同时接受到一条消息，不可能同意都接收到消息，而server3则一直收到消息，因为server1和server2是同一个消费者组。\n\n\n# 十一.Kafka 高效读写数据\n\n\n# 1）顺序写磁盘\n\nKafka 的 producer 生产数据，要写入到 log 文件中，写的过程是一直追加到文件末端， 为顺序写。官网有数据表明，同样的磁盘，顺序写能到 600M/s，而随机写只有 100K/s。这 与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。\n\n> 顺序写数据速度快\n\n\n# 2）零复制技术\n\n\n\n> 直接把文件的拷贝交给操作系统来完成\n\n\n# 十二.Zookeeper 在 Kafka 中的作用\n\nKafka 集群中有一个 broker 会被选举为 Controller，负责管理集群 broker 的上下线，所 有 topic 的分区副本分配和 leader 选举等工作。\n\nController 的管理工作都是依赖于 Zookeeper 的。\n\n以下为 partition 的 leader 选举过程：\n\n\n\n\n# 十三. Kafka 事务\n\nKafka 从 0.11 版本开始引入了事务支持。事务可以保证 Kafka 在 Exactly Once 语义的基 础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败.\n\n> 主要是为了保证跨分区精准消费，之前的幂等性不能保证分区精准消费\n\n\n# Producer 事务\n\n为了实现跨分区跨会话的事务，需要引入一个全局唯一的 Transaction ID，并将 Producer 获得的PID 和Transaction ID 绑定。这样当Producer 重启后就可以通过正在进行的 Transaction ID 获得原来的 PID。\n\n为了管理 Transaction，Kafka 引入了一个新的组件 Transaction Coordinator。Producer 就 是通过和 Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。Transaction Coordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于 事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。\n\n\n# Consumer 事务\n\n上述事务机制主要是从 Producer 方面考虑，对于 Consumer 而言，事务的保证就会相对 较弱，尤其时无法保证 Commit 的信息被精确消费。这是由于 Consumer 可以通过 offset 访 问任意信息，而且不同的 Segment File 生命周期不同，同一事务的消息可能会出现重启后被 删除的情况。\n\n\n# 十四.API生产者流程\n\nKafka 的 Producer 发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了 两个线程——main 线程和 Sender 线程，以及一个线程共享变量——RecordAccumulator。 main 线程将消息发送给 RecordAccumulator，Sender 线程不断从 RecordAccumulator 中拉取 消息发送到 Kafka broker\n\n\n\n相关参数：\n\nbatch.size：只有数据积累到 batch.size 之后，sender 才会发送数据。\n\nlinger.ms：如果数据迟迟未达到 batch.size，sender 等待 linger.time 之后就会发送数据。\n\n\n# 十五.java中引入生产者\n\n\n# 1.生产者发送消息\n\n# 1.引入依赖\n\n        \x3c!--kafka客户端 根据本地的kafka版本--\x3e\n        <dependency>\n            <groupId>org.apache.kafka</groupId>\n            <artifactId>kafka-clients</artifactId>\n            <version>0.11.0.0</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 2.创建生产者\n\npackage com.wcy.produce;\n\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\n\nimport java.util.Properties;\n\npublic class MyProduce {\n    public static void main(String[] args) throws InterruptedException {\n        Properties properties=new Properties();\n        //kafka集群地址\n        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");\n        //kafka ack应答策略   -1：ISR中全部发送才发送ACK   0：不管有没有回应   1：leader应答即可\n        properties.put(ProducerConfig.ACKS_CONFIG,"all");\n        //重试次数\n        properties.put("retries", 1);\n        //批次大小  当数据到达16K才发送消息\n        properties.put("batch.size", 16384);\n        //等待时间 毫秒  一毫秒后发送消息\n        properties.put("linger.ms", 1);\n        //RecordAccumulator 缓冲区大小\n        properties.put("buffer.memory", 33554432);\n        //序列化\n        properties.put("key.serializer",\n                "org.apache.kafka.common.serialization.StringSerializer");\n        properties.put("value.serializer",\n                "org.apache.kafka.common.serialization.StringSerializer");\n\n        KafkaProducer<String, String> kafkaProducer = new KafkaProducer<>(properties);\n        for (int i = 0; i < 10; i++) {\n            kafkaProducer.send(new ProducerRecord<String,String>("bigdata","******"+i));\n        }\n        kafkaProducer.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\nProducerRecord()构造方法支持多种方式：\n\n由于分区内部的数据是有序的，如果要保证顺序性消费，则放到一个分区中。\n\n\n\n\n# 2.自定义分区\n\n# 1.自定义分区类实现Partitioner\n\npackage com.wcy.partition;\n\nimport org.apache.kafka.clients.producer.Partitioner;\nimport org.apache.kafka.common.Cluster;\n\nimport java.util.Map;\n\n/**\n * 自定义分区\n */\npublic class MyPartition implements Partitioner {\n    @Override\n    public int partition(String s, Object o, byte[] bytes, Object o1, byte[] bytes1, Cluster cluster) {\n        //可以参考默认的分区规则DefaultPartitioner\n        return 1;\n    }\n\n    @Override\n    public void close() {\n\n    }\n\n    @Override\n    public void configure(Map<String, ?> map) {\n\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 4.生产者配置自定义分区器\n\nproperties.put(ProducerConfig.PARTITIONER_CLASS_CONFIG,"com.wcy.partition.MyPartition");\n\n\n1\n\n\n\n# 十六.引入消费者\n\n\n# 1.消费者实现\n\n> 注意一定要开启自动提交，防止消费者重复消费\n> \n> 若关闭自动提交，那么消费者消费数据以后，再宕机之后，上线后又会重复消费数据\n\npackage com.wcy.consumer;\n\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\n\nimport java.util.Arrays;\nimport java.util.Properties;\n\n/**\n * 消费者\n */\npublic class MyConsumer {\n    public static void main(String[] args) {\n        Properties properties=new Properties();\n        //kafka集群信息\n        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");\n        //提交offset时间 单位：毫秒\n        properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000");\n        //自动提交\n        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"true");\n        //反序列化\n        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");\n        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");\n\n        /**\n         * 设置消费者从头消费\n         * 生效条件：\n         *  1.消费者组第一次消费\n         *  2.消费者组之前保存的offset失效（即七天后）\n         *\n         *  earliest：从头消费\n         *  latest：接受开启消费后的数据\n         */\n        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,"earliest");\n\n        //设置消费者组\n        properties.put(ConsumerConfig.GROUP_ID_CONFIG,"wcy1");\n\n        KafkaConsumer<String,String> kafkaConsumer = new KafkaConsumer<String,String>(properties);\n        kafkaConsumer.subscribe(Arrays.asList("first","bigdata"));//订阅主题\n\n        while (true){//不停的获取数据\n            ConsumerRecords<String, String> poll = kafkaConsumer.poll(1000);//获取到空数据阻塞一秒\n            for(ConsumerRecord<String,String> consumerRecord:poll){\n                System.out.println(consumerRecord.key()+":"+consumerRecord.value());\n            }\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# 2.消费者从头消费\n\n消费者限制条件：\n\n 1. 消费者组第一次消费才能生效\n 2. 消费者之前保存的offet失效就会重新读取\n\n        /**\n         * 设置消费者从头消费\n         * 生效条件：\n         *  1.消费者组第一次消费\n         *  2.消费者组之前保存的offset失效（即七天后）\n         *\n         *  earliest：从头消费\n         *  latest：接受开启消费后的数据\n         */\n        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,"earliest");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n记得要重新设置新的消费者组\n\n\n# 3.消费者手动提交offset\n\n若把 ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG设置为false，则不会自动提交offset，那么消费者宕机后下次来还是会消费之前的数据。\n\n虽然自动提交 offset 十分简介便利，但由于其是基于时间提交的，开发人员难以把握 offset 提交的时机。因此 Kafka 还提供了手动提交 offset 的 API。\n\n手动提交 offset 的方法有两种：分别是 commitSync（同步提交）和 commitAsync（异步 提交）。两者的相同点是，都会将本次 poll 的一批数据最高的偏移量提交；不同点是， commitSync 阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致， 也会出现提交失败）；而 commitAsync 则没有失败重试机制，故有可能提交失败。\n\n> 自动提交的补充：\n> \n> 1.若ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG设置为1秒钟提交offset，会造成数据丢失，假如消费者正在处理该数据，但是未处理完，已经提交到offset中，但是消费者挂掉了，那么该数据库就丢失了；\n> \n> 2.若ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG设置为10秒钟提交offset，会造成数据重复，假如消费者处理已经把消息处理完了，但是在6秒的时候宕机，还未写入到offset，就会造成数据重复\n\n# 3.1.同步提交offset\n\n问题：若数据处理完，在手动同步提交offset时宕机，那么消费者重启后会重复消费\n\n步骤：\n\n 1. 关闭自动提交\n 2. 调用kafkaConsumer.commitSync();//同步提交数据\n\npackage com.wcy.consumer;\n\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\n\nimport java.util.Arrays;\nimport java.util.Properties;\n\n/**\n * 消费者\n */\npublic class MyConsumer {\n    public static void main(String[] args) {\n        Properties properties=new Properties();\n        //kafka集群信息\n        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");\n        //提交offset时间 单位：毫秒\n        properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000");\n        //自动提交\n//        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"true");\n        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"false");\n        //反序列化\n        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");\n        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");\n\n        /**\n         * 设置消费者从头消费\n         * 生效条件：\n         *  1.消费者组第一次消费\n         *  2.消费者组之前保存的offset失效（即七天后）\n         *\n         *  earliest：从头消费\n         *  latest：接受开启消费后的数据\n         */\n        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,"earliest");\n\n        //设置消费者组\n        properties.put(ConsumerConfig.GROUP_ID_CONFIG,"wcy1");\n\n        KafkaConsumer<String,String> kafkaConsumer = new KafkaConsumer<String,String>(properties);\n        kafkaConsumer.subscribe(Arrays.asList("first","bigdata"));//订阅主题\n\n        while (true){//不停的获取数据\n            ConsumerRecords<String, String> poll = kafkaConsumer.poll(1000);//获取到空数据阻塞一秒\n            for(ConsumerRecord<String,String> consumerRecord:poll){\n                System.out.println(consumerRecord.key()+":"+consumerRecord.value());\n            }\n            kafkaConsumer.commitSync();//同步提交数据\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n# 3.2.异步提交offset\n\n问题：若数据处理完，在手动异步提交宕机也会出现重复消费。\n\n步骤：\n\n 1. 关闭自动提交\n\n 2. 调用\n    \n    kafkaConsumer.commitAsync(new OffsetCommitCallback() {\n                    @Override\n                    public void onComplete(Map<TopicPartition, OffsetAndMetadata> offsets, Exception exception) {\n                        if(exception!=null){\n                            System.out.println("手动提交失败");\n                        }\n                    }\n                });\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\npackage com.wcy.consumer;\n\nimport org.apache.kafka.clients.consumer.*;\nimport org.apache.kafka.common.TopicPartition;\n\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * 消费者\n */\npublic class MyConsumer {\n    public static void main(String[] args) {\n        Properties properties=new Properties();\n        //kafka集群信息\n        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");\n        //提交offset时间 单位：毫秒\n        properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000");\n        //自动提交\n//        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"true");\n        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"false");\n        //反序列化\n        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");\n        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");\n\n        /**\n         * 设置消费者从头消费\n         * 生效条件：\n         *  1.消费者组第一次消费\n         *  2.消费者组之前保存的offset失效（即七天后）\n         *\n         *  earliest：从头消费\n         *  latest：接受开启消费后的数据\n         */\n        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,"earliest");\n\n        //设置消费者组\n        properties.put(ConsumerConfig.GROUP_ID_CONFIG,"wcy1");\n\n        KafkaConsumer<String,String> kafkaConsumer = new KafkaConsumer<String,String>(properties);\n        kafkaConsumer.subscribe(Arrays.asList("first","bigdata"));//订阅主题\n\n        while (true){//不停的获取数据\n            ConsumerRecords<String, String> poll = kafkaConsumer.poll(1000);//获取到空数据阻塞一秒\n            for(ConsumerRecord<String,String> consumerRecord:poll){\n                System.out.println(consumerRecord.key()+":"+consumerRecord.value());\n            }\n            kafkaConsumer.commitAsync(new OffsetCommitCallback() {\n                @Override\n                public void onComplete(Map<TopicPartition, OffsetAndMetadata> offsets, Exception exception) {\n                    if(exception!=null){\n                        System.out.println("手动提交失败");\n                    }\n                }\n            });\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 4 .自定义存储 offset\n\n> 无论是同步提交还是异步提交 offset，都有可能会造成数据的漏消费或者重复消费。先 提交 offset 后消费，有可能造成数据的漏消费；而先消费后提交 offset，有可能会造成数据 的重复消费。\n\nKafka 0.9 版本之前，offset 存储在 zookeeper，0.9 版本及之后，默认将 offset 存储在 Kafka 的一个内置的 topic 中。除此之外，Kafka 还可以选择自定义存储 offset。\n\noffset 的维护是相当繁琐的，因为需要考虑到消费者的 Rebalace。\n\n当有新的消费者加入消费者组、已有的消费者推出消费者组或者所订阅的主题的分区发 生变化，就会触发到分区的重新分配，重新分配的过程叫做 Rebalance。\n\n消费者发生 Rebalance 之后，每个消费者消费的分区就会发生变化。因此消费者要首先获取到自己被重新分配到的分区，并且定位到每个分区最近提交的 offset 位置继续消费。\n\n要实现自定义存储 offset，需要借助 ConsumerRebalanceListener，以下为示例代码，其 中提交和获取 offset 的方法，需要根据所选的 offset 存储系统自行实现。\n\n步骤：\n\n 1. 自定义Map存储offset信息\n 2. 关闭自动提交\n 3. 在订阅的时候绑定重新分配的监听，在重新分配之前，提交offset到mysql，在重新分配之后，读取mysql数据，让消费者从该offset消费\n 4. 处理完消息后，记得手动提交数据，就算出现异常也会回滚数据（处理消息的逻辑放到一个mysql数据中）\n\npackage com.wcy.consumer.offset;\n\nimport org.apache.kafka.clients.consumer.*;\nimport org.apache.kafka.common.TopicPartition;\n\nimport java.util.*;\n\n/**\n * 自定义存储offset\n */\npublic class MyOffsetCusumer {\n    //维护offset\n    private static Map<TopicPartition, Long> currentOffset = new\n            HashMap<>();\n\n    public static void main(String[] args) {\n        Properties properties=new Properties();\n        //kafka集群信息\n        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");\n        //提交offset时间 单位：毫秒\n        properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000");\n        //自动提交\n//        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"true");\n        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"false");\n        //反序列化\n        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");\n        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,"org.apache.kafka.common.serialization.StringDeserializer");\n\n        /**\n         * 设置消费者从头消费\n         * 生效条件：\n         *  1.消费者组第一次消费\n         *  2.消费者组之前保存的offset失效（即七天后）\n         *\n         *  earliest：从头消费\n         *  latest：接受开启消费后的数据\n         */\n        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,"earliest");\n\n        //设置消费者组\n        properties.put(ConsumerConfig.GROUP_ID_CONFIG,"wcy1");\n\n        KafkaConsumer<String,String> kafkaConsumer = new KafkaConsumer<String,String>(properties);\n        kafkaConsumer.subscribe(Arrays.asList("first", "bigdata"), new ConsumerRebalanceListener() {\n            //该方法会在 Rebalance（重新分配） 之前调用\n            @Override\n            public void onPartitionsRevoked(Collection<TopicPartition> partitions) {\n                commitOffset(currentOffset);\n            }\n\n            //该方法会在 Rebalance（重新分配） 之后调用\n            @Override\n            public void onPartitionsAssigned(Collection<TopicPartition> partitions) {\n                currentOffset.clear();//清空offset\n                //重新计算消费\n                for (TopicPartition partition : partitions) {\n                    //定位到最近提交的 offset 位置继续消费\n                    kafkaConsumer.seek(partition, getOffset(partition));\n                }\n            }\n\n        });//订阅主题\n\n        while (true){//不停的获取数据\n            ConsumerRecords<String, String> poll = kafkaConsumer.poll(1000);//获取到空数据阻塞一秒\n            for(ConsumerRecord<String,String> consumerRecord:poll){\n                System.out.println(consumerRecord.key()+":"+consumerRecord.value());\n                currentOffset.put(new TopicPartition(consumerRecord.topic(),\n                        consumerRecord.partition()), consumerRecord.offset());\n            }\n            commitOffset(currentOffset);//手动提交\n        }\n    }\n\n    /**\n     * 自定义提交到mysql  通过事务实现\n     * 列：消费者组、主题、分区、offset\n     * @param currentOffset\n     */\n    private static void commitOffset(Map<TopicPartition, Long> currentOffset) {\n    }\n\n    /**\n     * 自定义读取offset\n     * @param partition\n     * @return\n     */\n    private static long getOffset(TopicPartition partition) {\n        return 0;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n\n# 十七.自定义拦截器\n\nProducer 拦截器(interceptor)是在 Kafka 0.10 版本被引入的，主要用于实现 clients 端的定 制化控制逻辑。\n\n对于 producer 而言，interceptor 使得用户在消息发送前以及 producer 回调逻辑前有机会 对消息做一些定制化需求，比如修改消息等。同时，producer 允许用户指定多个 interceptor 按序作用于同一条消息从而形成一个拦截链(interceptor chain)。Intercetpor 的实现接口是 org.apache.kafka.clients.producer.ProducerInterceptor，其定义的方法包括：\n\n（1）configure(configs) ：获取配置信息和初始化数据时调用。\n\n（2）onSend(ProducerRecord)： 消息发送前执行，该方法封装进 KafkaProducer.send 方法中，即它运行在用户主线程中。Producer 确保在消息被序列化以及计算分区前调用该方法。用户可以在该方法中对消息做任何操作，但最好 保证不要修改消息所属的 topic 和分区，否则会影响目标分区的计算。\n\n（3）onAcknowledgement(RecordMetadata, Exception)：消息发送后执行， 该方法会在消息从 RecordAccumulator 成功发送到 Kafka Broker 之后，或者在发送过程 中失败时调用。并且通常都是在 producer 回调逻辑触发之前。onAcknowledgement 运行在 producer 的 IO 线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢 producer 的消息 发送效率。\n\n（4）close： 关闭 interceptor，主要用于执行一些资源清理工作 如前所述，interceptor 可能被运行在多个线程中，因此在具体实现时用户需要自行确保 线程安全。另外倘若指定了多个 interceptor，则 producer 将按照指定顺序调用它们，并仅仅 是捕获每个 interceptor 可能抛出的异常记录到错误日志中而非在向上传递。这在使用过程中 要特别留意。 4.3.2 拦截器案\n\n\n# 拦截器按钮\n\n实现一个简单的双 interceptor 组成的拦截链。第一个 interceptor 会在消息发送前将时间 戳信息加到消息 value 的最前部；第二个 interceptor 会在消息发送后更新成功发送消息数或 失败发送消息数。\n\n# 1.自定义拦截器\n\npackage com.wcy.produce.interceptor;\n\nimport org.apache.kafka.clients.producer.ProducerInterceptor;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\n\nimport java.util.Map;\n\npublic class TimeInterceptor implements ProducerInterceptor {\n    int success;\n    int error;\n    @Override\n    public void configure(Map<String, ?> configs) {\n        System.out.println("配置信息：");\n        System.out.println(configs);\n    }\n    @Override\n    public ProducerRecord onSend(ProducerRecord record) {\n        String value= (String) record.value();\n        return new ProducerRecord(record.topic(),record.partition(),\n                record.timestamp(),record.key(),System.currentTimeMillis()+value,record.headers());\n    }\n\n    @Override\n    public void onAcknowledgement(RecordMetadata metadata, Exception exception) {\n        if(exception!=null){\n            success++;\n        }else{\n            error++;\n        }\n    }\n\n    @Override\n    public void close() {\n        System.out.println("成功条数："+success);\n        System.out.println("失败条数："+error);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# 2.生产者中引入\n\n注意：存放的是集合\n\n        properties.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, Arrays.asList("com.wcy.produce.interceptor.TimeInterceptor"));\n\n\n\n1\n2\n\n\n\n# 十八.安装kafka-eagle监视\n\n下载地址\n\n\n# 1.解压\n\ntar -zxvf kafka-eagle-bin-1.3.7.tar.gz\n\n\n1\n\n\n\n# 2.解压后还有个压缩文件，cd再解压\n\ncd kafka-eagle-bin-1.3.7\ntar -zxvf kafka-eagle-web-1.3.7-bin.tar.gz -C /opt/module/\n\n\n1\n2\n\n\n\n# 3.改名\n\nmv kafka-eagle-web-1.3.7/ eagle\n\n\n1\n\n\n\n# 4.给文件权限\n\ncd /eagle/bin\nchmod 777 ke.sh\n\n\n1\n2\n\n\n\n# 5.修改配置文件\n\ncd /conf\nvi system-config.properties\n\n\n1\n2\n\n\n修改：\n\neagle默认可以监控多个kafka环境\n\n 1. kafka.eagle.zk.cluster.alias=cluster1,cluster2:监控多个kafka环境\n 2. cluster1.zk.list：配置集群\n 3. cluster1.kafka.eagle.offset.storage:kafka的消息保存到kafka\n 4. kafka.eagle.metrics.charts：true界面有图表\n 5. 配置数据库\n\n######################################\n# multi zookeeper&kafka cluster list\n######################################\n#可以配置监控多个kafka\n#kafka.eagle.zk.cluster.alias=cluster1,cluster2\nkafka.eagle.zk.cluster.alias=cluster1\n#配置集群\ncluster1.zk.list=192.168.188.128:2181,192.168.188.128:2182,192.168.188.128:2183\n#cluster2.zk.list=xdn10:2181,xdn11:2181,xdn12:2181\n\n######################################\n# zk client thread limit\n######################################\nkafka.zk.limit.size=25\n\n######################################\n# kafka eagle webui port\n######################################\nkafka.eagle.webui.port=8048\n\n######################################\n# kafka offset storage\n######################################\n#kafka0.10版本默认存放到kafka\ncluster1.kafka.eagle.offset.storage=kafka\n#cluster2.kafka.eagle.offset.storage=zookeeper\n\n######################################\n# enable kafka metrics\n######################################\n#web界面显示图表\nkafka.eagle.metrics.charts=true\nkafka.eagle.sql.fix.error=false\n\n######################################\n# kafka sql topic records max\n######################################\nkafka.eagle.sql.topic.records.max=5000\n\n######################################\n# alarm email configure\n######################################\n#kafka异常发送邮件\nkafka.eagle.mail.enable=false\nkafka.eagle.mail.sa=alert_sa@163.com\nkafka.eagle.mail.username=alert_sa@163.com\nkafka.eagle.mail.password=mqslimczkdqabbbh\nkafka.eagle.mail.server.host=smtp.163.com\nkafka.eagle.mail.server.port=25\n\n######################################\n# alarm im configure\n######################################\n#kafka.eagle.im.dingding.enable=true\n#kafka.eagle.im.dingding.url=https://oapi.dingtalk.com/robot/send?access_token=\n\n#kafka.eagle.im.wechat.enable=true\n#kafka.eagle.im.wechat.token=https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=xxx&corpsecret=xxx\n#kafka.eagle.im.wechat.url=https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=\n#kafka.eagle.im.wechat.touser=\n#kafka.eagle.im.wechat.toparty=\n#kafka.eagle.im.wechat.totag=\n#kafka.eagle.im.wechat.agentid=\n\n######################################\n# delete kafka topic token\n######################################\nkafka.eagle.topic.token=keadmin\n\n######################################\n# kafka sasl authenticate\n######################################\ncluster1.kafka.eagle.sasl.enable=false\ncluster1.kafka.eagle.sasl.protocol=SASL_PLAINTEXT\ncluster1.kafka.eagle.sasl.mechanism=PLAIN\ncluster1.kafka.eagle.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="admin" password="kafka-eagle";\n\ncluster2.kafka.eagle.sasl.enable=false\ncluster2.kafka.eagle.sasl.protocol=SASL_PLAINTEXT\ncluster2.kafka.eagle.sasl.mechanism=PLAIN\ncluster2.kafka.eagle.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="admin" password="kafka-eagle";\n\n######################################\n# kafka jdbc driver address\n######################################\n#保存的数据库\n#kafka.eagle.driver=org.sqlite.JDBC\n#kafka.eagle.url=jdbc:sqlite:/hadoop/kafka-eagle/db/ke.db\n#kafka.eagle.username=root\n#kafka.eagle.password=www.kafka-eagle.org\n#配置mysql\nkafka.eagle.driver=com.mysql.jdbc.Driver\nkafka.eagle.url=jdbc:mysql://localhost:3306/ke?useUnicode=true&ch\naracterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull\nkafka.eagle.username=root\nkafka.eagle.password=2452952178\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n6.添加环境变量（必须）\n\nsudo vi /etc/profile\n--添加内容\nexport KE_HOME=/opt/module/eagle\nexport PATH=$PATH:$KE_HOME/bin\n重启\nsource /etc/profile\n\n\n1\n2\n3\n4\n5\n6\n\n\n7.启动\n\nke.sh start\n\n\n1\n\n\n\n# 监控信息：\n\n\n\n\n# 十九.面试题\n\nkafka\n\n\n# 二十.SSM引入Kafka\n\n\n# 1.引入依赖\n\n    \x3c!--kafka--\x3e\n    <dependency>\n      <groupId>org.springframework.kafka</groupId>\n      <artifactId>spring-kafka</artifactId>\n      <version>1.3.11.RELEASE</version>\n    </dependency>\n    \x3c!--kafka客户端 根据本地的kafka版本--\x3e\n    <dependency>\n      <groupId>org.apache.kafka</groupId>\n      <artifactId>kafka-clients</artifactId>\n      <version>0.11.0.0</version>\n    </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.kafka配置信息\n\n#bootstrap.servers=10.1.10.80\\:9092\n#bootstrap.servers=10.1.10.77\\:9092\nbootstrap.servers=192.168.188.128\\:9092,192.168.188.128\\:9093,192.168.188.128\\:9094\n\n\n1\n2\n3\n\n\n\n# 3.生产者配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n         http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context\n         http://www.springframework.org/schema/context/spring-context.xsd">\n\n    <context:property-placeholder location="classpath:kafkaConfig.properties" ignore-unresolvable="true"/>\n\n    \x3c!-- 定义producer的参数 --\x3e\n    <bean id="producerProperties" class="java.util.HashMap">\n        <constructor-arg>\n            <map>\n                <entry key="bootstrap.servers" value="${bootstrap.servers}"/>\n                \x3c!-- 组id标志 --\x3e\n                <entry key="group.id" value="test_group"/>\n                \x3c!--重试次数--\x3e\n                <entry key="retries" value="1"/>\n                \x3c!-- ack -1：ISR中全部发送才发送ACK   0：不管有没有回应   1：leader应答即可--\x3e\n                <entry key="acks" value="-1"/>\n                \x3c!-- 每次批量发送消息的数量 --\x3e\n                <entry key="batch.size" value="16384"/>\n                \x3c!-- 默认0ms，在异步IO线程被触发后（任何一个topic，partition满都可以触发） --\x3e\n                <entry key="linger.ms" value="1"/>\n                \x3c!--producer可以用来缓存数据的内存大小。如果数据产生速度大于向broker发送的速度，producer会阻塞或者抛出异常 --\x3e\n                <entry key="buffer.memory" value="33554432"/>\n                \x3c!--序列化--\x3e\n                <entry key="key.serializer" value="org.apache.kafka.common.serialization.StringSerializer"/>\n                <entry key="value.serializer" value="org.apache.kafka.common.serialization.StringSerializer"/>\n            </map>\n        </constructor-arg>\n    </bean>\n\n    \x3c!-- 创建kafkatemplate需要使用的producerfactory bean --\x3e\n    <bean id="producerFactory" class="org.springframework.kafka.core.DefaultKafkaProducerFactory">\n        <constructor-arg>\n            <ref bean="producerProperties"/>\n        </constructor-arg>\n    </bean>\n\n    \x3c!-- 创建kafkatemplate bean，使用的时候，只需要注入这个bean，即可使用template的send消息方法 --\x3e\n    <bean id="KafkaTemplate" class="org.springframework.kafka.core.KafkaTemplate">\n        <constructor-arg ref="producerFactory"/>\n        <constructor-arg name="autoFlush" value="true"/>\n        <property name="defaultTopic" value="myTopic"/>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 4.消费者配置\n\ncontainerProperties：可以监听多个topic主题\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n         http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context\n         http://www.springframework.org/schema/context/spring-context.xsd">\n\n    <context:property-placeholder location="classpath:kafkaConfig.properties" ignore-unresolvable="true"/>\n\n    \x3c!-- 定义producer的参数 --\x3e\n    <bean id="consumerProperties" class="java.util.HashMap">\n        <constructor-arg>\n            <map>\n                \x3c!--Kafka服务地址 --\x3e\n                <entry key="bootstrap.servers" value="${bootstrap.servers}" />\n                \x3c!--Consumer的组ID，相同group.id的consumer属于同一个组。 --\x3e\n                <entry key="group.id" value="test_group" />\n                \x3c!--如果此值设置为true，consumer会周期性的把当前消费的offset值保存到zookeeper。当consumer失败重启之后将会使用此值作为新开始消费的值。 --\x3e\n                <entry key="enable.auto.commit" value="true" />\n\x3c!--                提交offset时间 单位：毫秒--\x3e\n                <entry key="auto.commit.interval.ms" value="1000" />\n                \x3c!--网络请求的socket超时时间。实际超时时间由max.fetch.wait + socket.timeout.ms 确定 --\x3e\n                <entry key="session.timeout.ms" value="15000" />\n                \x3c!--设置从头消费    earliest   latest--\x3e\n                <entry key="auto.offset.reset" value="earliest" />\n\n                <entry key="key.deserializer"\n                       value="org.apache.kafka.common.serialization.StringDeserializer" />\n\n                <entry key="value.deserializer"\n                       value="org.apache.kafka.common.serialization.StringDeserializer" />\n            </map>\n        </constructor-arg>\n    </bean>\n\n    \x3c!-- 创建consumerFactory bean --\x3e\n    <bean id="consumerFactory" class="org.springframework.kafka.core.DefaultKafkaConsumerFactory">\n        <constructor-arg>\n            <ref bean="consumerProperties"/>\n        </constructor-arg>\n    </bean>\n\n    \x3c!-- 实际执行消息消费的类  自己定义的类 --\x3e\n    <bean id="messageListernerConsumerService" class="com.wcy.kafka.spring.KafkaConsumer"/>\n\n    \x3c!-- 消费者容器配置信息 --\x3e\n    <bean id="containerProperties" class="org.springframework.kafka.listener.config.ContainerProperties">\n        \x3c!-- 配置消费的主题 --\x3e\n\x3c!--        <constructor-arg value="myTopic"/>--\x3e\n        \x3c!-- 订阅多个主题 --\x3e\n        <constructor-arg>\n            <list>\n                <value>myTopic</value>\n                <value>newTopic</value>\n            </list>\n        </constructor-arg>\n        <property name="messageListener" ref="messageListernerConsumerService"/>\n    </bean>\n\n    \x3c!-- 创建kafkatemplate bean，使用的时候，只需要注入这个bean，即可使用template的send消息方法 --\x3e\n    <bean id="messageListenerContainer" class="org.springframework.kafka.listener.KafkaMessageListenerContainer" init-method="doStart">\n        <constructor-arg ref="consumerFactory"/>\n        <constructor-arg ref="containerProperties"/>\n    </bean>\n    \x3c!--ConcurrentMessageListenerContainer 这个是并发消费  concurrency这个属性就是并发消费者的数量--\x3e\n    \x3c!--<bean id="messageListenerContainer"\n        class="org.springframework.kafka.listener.ConcurrentMessageListenerContainer"\n        init-method="doStart">\n        <constructor-arg ref="consumerFactory" />\n        <constructor-arg ref="containerProperties" />\n        <property name="concurrency" value="3" />\n    </bean> --\x3e\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n# 5.生产者发送消息\n\n    @Autowired\n    private KafkaTemplate<String, String> kafkaTemplate;\n\n    public void testTemplateSend(String msg){\n        kafkaTemplate.send("newTopic",msg); //指定主题\n        kafkaTemplate.sendDefault("生产者默认主题");\n//        for(int i=0;i<10000;i++){\n//            kafkaTemplate.sendDefault("kafka发送消息****"+i);\n//            if (i % 1000 == 0) {\n//                System.out.println(i+"***kafka发送消息***"+i);\n//            }\n//        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n6.消费者接受消息\n\npackage com.wcy.kafka.spring;\n\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.springframework.kafka.listener.MessageListener;\n\npublic class KafkaConsumer implements MessageListener<Integer, String> {\n    private int i;\n    private int count;\n\n    @Override\n    public void onMessage(ConsumerRecord<Integer, String> record) {\n\t/*\t System.out.println("*****接受到消息开始***********");\n\t\t System.out.println("整个对象:"+record);\n//\t\t System.out.println("key:"+record.key());\n//\t\t System.out.println("value:"+record.value());\n\t\t System.out.println("partition:"+record.partition());*/\n        try {\n            System.out.println("key:"+record.key()+"value:"+record.value());\n        }catch (Exception e) {\n            e.printStackTrace();\n        }\n//        i++;\n//        if (i % 1000 == 0) {\n//            count++;\n//            System.out.println(i+"***接受到消息结束***"+count+"---"+record);\n//            i = 0;\n//        }\n\n    }\n\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n',normalizedContent:'# kafka\n\n\n# 一.消息队列的两种模式\n\n\n# （1）点对点模式\n\n（一对一，消费者主动拉取数据，消息收到后消息清除）\n\n> 消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。 消息被消费以后，queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。 queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。\n\n\n# （2）发布/订阅模式\n\n（一对多，消费者消费数据之后不会清除消息）\n\n> 消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消 息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。\n\n发布订阅也有两种模式\n\n * 传统的发布订阅模式是队列（topic）推送给消费者，但是这样的坏处是，消费者处理能力不足可能造成宕机；\n * kafka就是通过消费者主动去队列中拉数据：但是也有坏处，消费者就需要去轮训队列中是否有数据（浪费资源）\n * **队列在内部维护队列，存放某主题订阅的消费者，通知消费者去拉取数据，**该方式也有坏处，需要队列再多维护一个队列，消费者如果宕机了，队列照样要去通知。\n\n\n# 二.kafka架构\n\n\n\n1）producer ：消息生产者，就是向 kafka broker 发消息的客户端；\n\n2）consumer ：消息消费者，向 kafka broker 取消息的客户端；\n\n3）consumer group （cg）：消费者组，由多个 consumer 组成。消费者组内每个消费者负 责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。所 有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。\n\n4）broker ：一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。 5）topic ：可以理解为一个队列，生产者和消费者面向的都是一个 topic；\n\n6）partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上， 一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；\n\n7）replica：副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失， 尚硅谷官网 且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本， 一个 leader 和若干个 follower。\n\n8）leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对 象都是 leader。\n\n9）follower：每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据 的同步。leader 发生故障时，某个 follower 会成为新的 follower。\n\n\n# 三kafka的集群搭建\n\n> 本机搭建（伪集群）\n> \n> 前提：zookeeper集群已经启动\n> \n> 端口分别为：localhost:2181,localhost:2182,localhost:2183\n> \n> 参考：本网站搭建的zookeeper集群\n> \n> kafka端口：localhost:9092、localhost:9093、localhost:9094\n\n下载地址：http://kafka.apache.org/downloads\n\nkafka版本：kafka_2.11-0.11.0.0.gz\n\n\n# 1.解压kafka\n\ntar -zxvf kafka_2.11-0.11.0.0.tgz -c /opt/module/kafka/kafka/server1/\n\n\n1\n\n\n\n# 2.改名\n\nmv kafka_2.11-0.11.0.0/ kafka\n\n\n1\n\n\n\n# 3.创建数据文件\n\n存放生产者生产的数据\n\nmkdir /opt/module/kafka/kafka/server1/data\nmkdir /opt/module/kafka/kafka/server2/data\nmkdir /opt/module/kafka/kafka/server3/data\n\n\n1\n2\n3\n\n\n\n# 4.修改配置文件\n\ncd config/\nvi server.properties\n\n\n1\n2\n\n\n 1. broker.id=0 依次改为0,1,2\n\n 2. 开启delete.topic.enable=true\n\n 3. listeners=plaintext://localhost:9092 依次改为9092,9093,9094\n    \n    注意：\n    \n    * listeners：是kafka真正bind的地址\n    * advertised.listeners：是暴露给外部的listeners，如果没有设置，会用listeners\n    * 若要外部访问kafka，一定要把listeners配置为ip+端口，外部就能访问了，控制台消费者就需要通过ip+端口来访问了。\n\n 4. log.dirs=/opt/module/kafka/kafka/server1/data\n\n 5. zookeeper.connect=localhost:2181,localhost:2182,localhost:2183\n\n#broker 的全局唯一编号，不能重复\nbroker.id=0\n#删除 topic 功能使能\ndelete.topic.enable=true\n#配置端口号\nlisteners=plaintext://localhost:9092 \n#处理网络请求的线程数量\nnum.network.threads=3\n#用来处理磁盘 io 的现成数量\nnum.io.threads=8\n#发送套接字的缓冲区大小\nsocket.send.buffer.bytes=102400\n#接收套接字的缓冲区大小\nsocket.receive.buffer.bytes=102400\n#请求套接字的缓冲区大小\nsocket.request.max.bytes=104857600\n#kafka 运行日志存放的路径\nlog.dirs=/opt/module/kafka/kafka/server1/data\n#topic 在当前 broker 上的分区个数\nnum.partitions=1\n#用来恢复和清理 data 下数据的线程数量\nnum.recovery.threads.per.data.dir=1\n#segment 文件保留的最长时间，超时将被删除\nlog.retention.hours=168\n#配置连接 zookeeper 集群地址\nzookeeper.connect=localhost:2181,localhost:2182,localhost:2183\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 5.复制到server2、server3\n\ncp -r ./kafka /opt/module/kafka/kafka/server2/\ncp -r ./kafka /opt/module/kafka/kafka/server3/\n\n\n1\n2\n\n\n依次修改配置文件，参考上方修改\n\n\n# 6.启动\n\n# 方式一：一次启动\n\n 1. -daemon：后台启动\n 2. config/server.properties：加载配置文件\n\nbin/kafka-server-start.sh -daemon config/server.properties\n\n\n1\n\n\n# 方式二：sh文件启动\n\n1.脚本内容kkstart.sh\n\n#!/bin/bash\n\nif [ "$1" = "" ];\nthen\n    echo -e "\\033[0;31m 未输入操作名 \\033[0m  \\033[0;34m {start|stop} \\033[0m"\n    exit 1\nfi\n\nfunction start()\n{\n\tserver1/kafka/bin/kafka-server-start.sh -daemon start server1/kafka/config/server.properties\n\tserver2/kafka/bin/kafka-server-start.sh -daemon start server2/kafka/config/server.properties\n\tserver3/kafka/bin/kafka-server-start.sh -daemon start server3/kafka/config/server.properties\n}\n\nfunction stop()\n{\n\tserver1/kafka/bin/kafka-server-stop.sh stop\n\tserver2/kafka/bin/kafka-server-stop.sh stop\n\tserver3/kafka/bin/kafka-server-stop.sh stop\n}\n\n\n\ncase $1 in\n    start)\n    start;;\n    stop)\n    stop;;\n    *)\n\nesac\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n2.放到server1同一目录\n\n3.给权限\n\nchmod +x kkstart.sh\n\n\n1\n\n\n4.转化文件，通过wind10编辑后放入到linux，会出现文件格式不对\n\nsed -i "s/\\r//" kkstart.sh\n\n\n1\n\n\n\n# 7.测试\n\njps\n\n\n1\n\n\n\n# 四.操作主题（topic）\n\n先进入kafka目录\n\n\n# 1.创建topic\n\nbin/kafka-topics.sh --zookeeper localhost:2182 --create --partitions 3 --replication-factor 2 --topic first\n\n\n1\n\n * bin/kafka-topics.sh：执行主题相关操作\n * --zookeeper localhost:2182：与某台zookeeper关联，由于kafka依赖于zookeeper\n * --partitions 3：分区数，该数没有限制，比如创建first，则会创建first0、first1、first2\n * --replication-factor 2：副本，每个kafka集群只保存两个分区的副本，最多为集群数\n * --topic first：名字\n\n\n\n\n# 2.查看topic（有多少个topic）\n\nbin/kafka-topics.sh --zookeeper localhost:2182 --list\n\n\n1\n\n\n\n# 3.查看详情\n\nbin/kafka-topics.sh --zookeeper localhost:2182 --describe --topic first\n\n\n1\n\n\n\n\n\n# 4.删除topic\n\nbin/kafka-topics.sh --zookeeper localhost:2182 --delete --topic two\n\n\n1\n\n\n\n# 五.发送消息\n\nbin/kafka-console-producer.sh --broker-list localhost:9092 --topic first\n\n\n1\n\n\n\n# 六.消费消息\n\nkafka默认是消费者去拉数据，所以可以收到之前订阅主题的数据，但是控制台需要加上--from-beginning才行\n\n\n# 1.过时命令\n\n> 注意：下面方式已经过时，以前消息存在zookeeper中，现在存在kafka中\n\n./bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic first\n\n\n1\n\n\n从头开始接受数据\n\nbin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic first --from-beginning\n\n\n1\n\n\n\n# 2.新命令\n\n该方式则存在kafka配置的log里面\n\nbin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic first\n\n\n1\n\n\n\n# 七.kafka架构深入\n\n\n\n> 生产者发送消息，根据生产者的策略，发送给分区1、分区2、分区3，分区内部也自己维护了一个偏移量（offset），分区内部能保证顺序性，分区则不能保证。\n\nkafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，都是面向 topic 的。\n\ntopic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文 件，该 log 文件中存储的就是 producer 生产的数据。producer 生产的数据会被不断追加到该 log 文件末端，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自己 消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。\n\n\n# 八.kafka文件存储\n\n\n\n> 消息都存放在分区的data文件中，消息会不断的追加到log文件末尾，为防止 log 文件过大导致数据定位 效率低下，kafka 采取了分片和索引机制，里面有一个index文件和log文件，log存放的是实际的数据，index则是保存的消息的索引。\n\n\n\n生产者发送的消息的偏移量通过二分法找到对应的index文件，index文件每一行的数据大小是固定的，假如每一行大小为1024，如果要查找偏移量为3的，则直接3*1024就能找到存储数据的偏移量，根据这个偏移量（存储了偏移量和数据大小）去log文件中直接读取数据即可。\n\n\n# 九.生产者\n\n\n# 1.分区规则\n\n1）分区的原因\n\n * 方便在集群中扩展，每个 partition 可以通过调整以适应它所在的机器，而一个 topic 又可以有多个 partition 组成，因此整个集群就可以适应任意大小的数据了；\n\n * 可以提高并发，因为可以以 partition 为单位读写了。\n\n2）分区的原则\n\n我们需要将 producer 发送的数据封装成一个 producerrecord 对象。\n\n\n\n 1. 指明 partition 的情况下，直接将指明的值直接作为 partiton 值；\n 2. 没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值；\n 3. 既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后 面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是常说的 round-robin 算法。\n\n\n# 2.数据可靠性\n\n为保证 producer 发送的数据，能可靠的发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack（acknowledgement 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。\n\n# 1）副本数据同步策略\n\n方案               优点                                       缺点\n半数以上发送ack则代表成功   延迟低                                      选取新的leader时，容忍n台节点故障，则需要2n+1个副本\n全部完成同步，才发送ack    选举新的 leader 时，容忍 n 台 节点的故障，需要 n+1 个副 本   延迟高\n\nkafka 选择了第二种方案：\n\n原因如下：\n\n1.同样为了容忍 n 台节点的故障，第一种方案需要 2n+1 个副本，而第二种方案只需要 n+1 个副本，而 kafka 的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。\n\n2.虽然第二种方案的网络延迟会比较高，但网络延迟对 kafka 的影响较小。\n\n# 2）isr\n\n采用第二种方案之后，设想以下情景：leader 收到数据，所有 follower 都开始同步数据， 但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去， 直到它完成同步，才能发送 ack。这个问题怎么解决呢？\n\nleader 维护了一个动态的 in-sync replica set (isr)，意为和 leader 保持同步的 follower 集 合。当 isr 中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower 长时间 未 向 leader 同 步 数 据 ， 则 该 follower 将 被 踢 出 isr ， 该 时 间 阈 值 replica.lag.time.max.ms 参数设定。leader 发生故障之后，就会从 isr 中选举新的 leader。\n\n> 注意：0.8版本是由时间和条数决定的，后面版本已经剔除条数了；\n> \n> 时间：follower 向leader发送ack的时间\n> \n> 条数：follower 同步leader数据的条数\n> \n> 剔除条数的原因：\n> \n> 假如条数低于10的剔除isr，如果生产者不停的发送数据，那么条数一会大于10，一会小于10，那么就会不停的在操作isr，并且isr信息也会保存到zk，那么同样也会操作zk。\n\n# 3）ack 应答机制\n\n对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失， 所以没必要等 isr 中的 follower 全部接收成功。 所以 kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡， 选择以下的配置。\n\nacks 参数配置：\n\n 1. 0：producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还 没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据；\n\n 2. 1：producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据；\n\n 3. -1（all）：producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才 返回 ack。但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会 造成数据重复。\n    \n    > 重复：当leader和follower 都同步成功后，还未发送ack时，leader挂掉，重新选择新的leader，但是生产者未收到ack，则重新发送数据，那么数据就重复了。\n    \n    > -1也会造成数据丢失:：比如isr中只有一个副本，那么该副本肯定是leader，一旦该副本挂掉数据就没了\n\n# 4）故障处理细节\n\nleo：每个副本的最后一个offset\n\nhw：所有副本中最小的leo\n\n\n\nleo：指的是每个副本最大的 offset；\n\nhw：指的是**消费者能见到的最大的 offset，**isr 队列中最小的 leo。\n\n（1）follower 故障 follower 发生故障后会被临时踢出 isr，待该 follower 恢复后，follower 会读取本地磁盘 记录的上次的 hw，并将 log 文件高于 hw 的部分截取掉，从 hw 开始向 leader 进行同步。 等该 follower 的 leo 大于等于该 partition 的 hw，即 follower 追上 leader 之后，就可以重 新加入 isr 了。\n\n（2）leader 故障 leader 发生故障之后，会从 isr 中选出一个新的 leader，之后，为保证多个副本之间的 数据一致性，其余的 follower 会先将各自的 log 文件高于 hw 的部分截掉，然后从新的 leader 同步数据。 注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。\n\n\n# 3.exactly once 语义（精准一次）\n\n将服务器的 ack 级别设置为-1，可以保证 producer 到 server 之间不会丢失数据，即 at least once （最少一次）语义。相对的，将服务器 ack 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 at most once （至多一次）语义。\n\nat least once 可以保证数据不丢失，但是不能保证数据不重复；相对的，at least once 可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说 交易数据，下游数据消费者要求数据既不重复也不丢失，即 exactly once 语义。**在 0.11 版 本以前的 kafka，对此是无能为力的，**只能保证数据不丢失，再在下游消费者对数据做全局 去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。\n\n0.11 版本的 kafka，引入了一项重大特性：幂等性。所谓的幂等性就是指 producer 不论 向 server 发送多少次重复数据，server 端都只会持久化一条。幂等性结合 at least once 语 义，就构成了 kafka 的 exactly once 语义。即：\n\n> at least once + 幂等性 = exactly once\n\n要启用幂等性，只需要将 producer 的参数中 enable.idompotence 设置为 true 即可。kafka 的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的 producer 在 初始化的时候会被分配一个 pid，发往同一 partition 的消息会附带 sequence number。而 broker 端会对《pid、partition 、sequence number》做缓存，当具有相同主键的消息提交时，broker 只 会持久化一条。\n\n但是 pid 重启就会变化，同时不同的 partition 也具有不同主键，所以幂等性无法保证跨 分区跨会话的 exactly once。\n\n\n# 十.消费者\n\n\n# 1.消费方式\n\nconsumer 采用 pull（拉）模式从 broker 中读取数据。\n\npush（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。 它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息， 典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适 当的速率消费消息。\n\npull 模式不足之处是，如果 kafka 没有数据，消费者可能会陷入循环中，一直返回空数 据。针对这一点，kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有 数据可供消费，consumer 会等待一段时间之后再返回，这段时长即为 timeout。\n\n\n# 2.分区分配策略\n\n> 消费者个数发生变化则触发：\n\n一个 consumer group 中有多个 consumer，一个 topic 有多个 partition，所以必然会涉及 到 partition 的分配问题，即确定那个 partition 由哪个 consumer 来消费。\n\nkafka 有两种分配策略，一是 roundrobin，一是 range。\n\n> roundrobin：轮训策略（适用于消费者组订阅的主题是一样的），是以消费者组为单位，把消费者所订阅的主题进行hash排序，挨个轮训发送给消费者；\n> \n> 问题：若消费者订阅的主题不相同，那么就会收到不是自己订阅的主题。\n> \n> range：范围，是以主题为单位，在一个主题的分区中，通过分区数/消费者数目来分发给消费者\n\n\n# 3.offset 的维护\n\n由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故 障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢 复后继续消费。\n\n\n\n存放在zookeeper中的/consumers/消费者/主题/分区：\n\n\n1\n\n\n\n\nkafka 0.9 版本之前，consumer 默认将 offset 保存在 zookeeper 中，从 0.9 版本开始， consumer 默认将 offset 保存在 kafka 一个内置的 topic 中，该 topic 为**__consumer_offsets**。\n\n\n# 4.消费者组案例\n\n1.)需求：测试同一个消费者组中的消费者，同一时刻只能有一个消费者消费。\n\n2)实操：\n\n（1）在 server1、server2上修改/opt/module/kafka/config/consumer.properties 配置 文件中的 group.id 属性为任意组名。\n\n$ vi consumer.properties\ngroup.id=wcy\n\n\n1\n2\n\n\n(2)在 server1、server2上分别启动消费者\n\nserver1上启动  加载刚才修改的配置文件\nbin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic bigdata --consumer.config config/consumer.properties\nserver2上启动   加载自己修改的配置文件\nbin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic bigdata --consumer.config config/consumer.properties\n\n\n1\n2\n3\n4\n\n\n现在server1、server2是同一个消费者组的了。\n\n（3）在 server3上启动消费者默认的配置文件\n\nbin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic bigdata\n\n\n1\n\n\n（4）随便启动一个生产者\n\nbin/kafka-console-producer.sh --broker-list localhost:9092 --topic bigdata\n\n\n1\n\n\n> 最后可以看到：\n> \n> 生产者发送一条消息后，消费者server1和server2只可能同时接受到一条消息，不可能同意都接收到消息，而server3则一直收到消息，因为server1和server2是同一个消费者组。\n\n\n# 十一.kafka 高效读写数据\n\n\n# 1）顺序写磁盘\n\nkafka 的 producer 生产数据，要写入到 log 文件中，写的过程是一直追加到文件末端， 为顺序写。官网有数据表明，同样的磁盘，顺序写能到 600m/s，而随机写只有 100k/s。这 与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。\n\n> 顺序写数据速度快\n\n\n# 2）零复制技术\n\n\n\n> 直接把文件的拷贝交给操作系统来完成\n\n\n# 十二.zookeeper 在 kafka 中的作用\n\nkafka 集群中有一个 broker 会被选举为 controller，负责管理集群 broker 的上下线，所 有 topic 的分区副本分配和 leader 选举等工作。\n\ncontroller 的管理工作都是依赖于 zookeeper 的。\n\n以下为 partition 的 leader 选举过程：\n\n\n\n\n# 十三. kafka 事务\n\nkafka 从 0.11 版本开始引入了事务支持。事务可以保证 kafka 在 exactly once 语义的基 础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败.\n\n> 主要是为了保证跨分区精准消费，之前的幂等性不能保证分区精准消费\n\n\n# producer 事务\n\n为了实现跨分区跨会话的事务，需要引入一个全局唯一的 transaction id，并将 producer 获得的pid 和transaction id 绑定。这样当producer 重启后就可以通过正在进行的 transaction id 获得原来的 pid。\n\n为了管理 transaction，kafka 引入了一个新的组件 transaction coordinator。producer 就 是通过和 transaction coordinator 交互获得 transaction id 对应的任务状态。transaction coordinator 还负责将事务所有写入 kafka 的一个内部 topic，这样即使整个服务重启，由于 事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。\n\n\n# consumer 事务\n\n上述事务机制主要是从 producer 方面考虑，对于 consumer 而言，事务的保证就会相对 较弱，尤其时无法保证 commit 的信息被精确消费。这是由于 consumer 可以通过 offset 访 问任意信息，而且不同的 segment file 生命周期不同，同一事务的消息可能会出现重启后被 删除的情况。\n\n\n# 十四.api生产者流程\n\nkafka 的 producer 发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了 两个线程——main 线程和 sender 线程，以及一个线程共享变量——recordaccumulator。 main 线程将消息发送给 recordaccumulator，sender 线程不断从 recordaccumulator 中拉取 消息发送到 kafka broker\n\n\n\n相关参数：\n\nbatch.size：只有数据积累到 batch.size 之后，sender 才会发送数据。\n\nlinger.ms：如果数据迟迟未达到 batch.size，sender 等待 linger.time 之后就会发送数据。\n\n\n# 十五.java中引入生产者\n\n\n# 1.生产者发送消息\n\n# 1.引入依赖\n\n        \x3c!--kafka客户端 根据本地的kafka版本--\x3e\n        <dependency>\n            <groupid>org.apache.kafka</groupid>\n            <artifactid>kafka-clients</artifactid>\n            <version>0.11.0.0</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 2.创建生产者\n\npackage com.wcy.produce;\n\nimport org.apache.kafka.clients.producer.kafkaproducer;\nimport org.apache.kafka.clients.producer.producerconfig;\nimport org.apache.kafka.clients.producer.producerrecord;\n\nimport java.util.properties;\n\npublic class myproduce {\n    public static void main(string[] args) throws interruptedexception {\n        properties properties=new properties();\n        //kafka集群地址\n        properties.put(producerconfig.bootstrap_servers_config,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");\n        //kafka ack应答策略   -1：isr中全部发送才发送ack   0：不管有没有回应   1：leader应答即可\n        properties.put(producerconfig.acks_config,"all");\n        //重试次数\n        properties.put("retries", 1);\n        //批次大小  当数据到达16k才发送消息\n        properties.put("batch.size", 16384);\n        //等待时间 毫秒  一毫秒后发送消息\n        properties.put("linger.ms", 1);\n        //recordaccumulator 缓冲区大小\n        properties.put("buffer.memory", 33554432);\n        //序列化\n        properties.put("key.serializer",\n                "org.apache.kafka.common.serialization.stringserializer");\n        properties.put("value.serializer",\n                "org.apache.kafka.common.serialization.stringserializer");\n\n        kafkaproducer<string, string> kafkaproducer = new kafkaproducer<>(properties);\n        for (int i = 0; i < 10; i++) {\n            kafkaproducer.send(new producerrecord<string,string>("bigdata","******"+i));\n        }\n        kafkaproducer.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\nproducerrecord()构造方法支持多种方式：\n\n由于分区内部的数据是有序的，如果要保证顺序性消费，则放到一个分区中。\n\n\n\n\n# 2.自定义分区\n\n# 1.自定义分区类实现partitioner\n\npackage com.wcy.partition;\n\nimport org.apache.kafka.clients.producer.partitioner;\nimport org.apache.kafka.common.cluster;\n\nimport java.util.map;\n\n/**\n * 自定义分区\n */\npublic class mypartition implements partitioner {\n    @override\n    public int partition(string s, object o, byte[] bytes, object o1, byte[] bytes1, cluster cluster) {\n        //可以参考默认的分区规则defaultpartitioner\n        return 1;\n    }\n\n    @override\n    public void close() {\n\n    }\n\n    @override\n    public void configure(map<string, ?> map) {\n\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 4.生产者配置自定义分区器\n\nproperties.put(producerconfig.partitioner_class_config,"com.wcy.partition.mypartition");\n\n\n1\n\n\n\n# 十六.引入消费者\n\n\n# 1.消费者实现\n\n> 注意一定要开启自动提交，防止消费者重复消费\n> \n> 若关闭自动提交，那么消费者消费数据以后，再宕机之后，上线后又会重复消费数据\n\npackage com.wcy.consumer;\n\nimport org.apache.kafka.clients.consumer.consumerconfig;\nimport org.apache.kafka.clients.consumer.consumerrecord;\nimport org.apache.kafka.clients.consumer.consumerrecords;\nimport org.apache.kafka.clients.consumer.kafkaconsumer;\n\nimport java.util.arrays;\nimport java.util.properties;\n\n/**\n * 消费者\n */\npublic class myconsumer {\n    public static void main(string[] args) {\n        properties properties=new properties();\n        //kafka集群信息\n        properties.put(consumerconfig.bootstrap_servers_config,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");\n        //提交offset时间 单位：毫秒\n        properties.put(consumerconfig.auto_commit_interval_ms_config,"1000");\n        //自动提交\n        properties.put(consumerconfig.enable_auto_commit_config,"true");\n        //反序列化\n        properties.put(consumerconfig.key_deserializer_class_config,"org.apache.kafka.common.serialization.stringdeserializer");\n        properties.put(consumerconfig.value_deserializer_class_config,"org.apache.kafka.common.serialization.stringdeserializer");\n\n        /**\n         * 设置消费者从头消费\n         * 生效条件：\n         *  1.消费者组第一次消费\n         *  2.消费者组之前保存的offset失效（即七天后）\n         *\n         *  earliest：从头消费\n         *  latest：接受开启消费后的数据\n         */\n        properties.put(consumerconfig.auto_offset_reset_config,"earliest");\n\n        //设置消费者组\n        properties.put(consumerconfig.group_id_config,"wcy1");\n\n        kafkaconsumer<string,string> kafkaconsumer = new kafkaconsumer<string,string>(properties);\n        kafkaconsumer.subscribe(arrays.aslist("first","bigdata"));//订阅主题\n\n        while (true){//不停的获取数据\n            consumerrecords<string, string> poll = kafkaconsumer.poll(1000);//获取到空数据阻塞一秒\n            for(consumerrecord<string,string> consumerrecord:poll){\n                system.out.println(consumerrecord.key()+":"+consumerrecord.value());\n            }\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# 2.消费者从头消费\n\n消费者限制条件：\n\n 1. 消费者组第一次消费才能生效\n 2. 消费者之前保存的offet失效就会重新读取\n\n        /**\n         * 设置消费者从头消费\n         * 生效条件：\n         *  1.消费者组第一次消费\n         *  2.消费者组之前保存的offset失效（即七天后）\n         *\n         *  earliest：从头消费\n         *  latest：接受开启消费后的数据\n         */\n        properties.put(consumerconfig.auto_offset_reset_config,"earliest");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n记得要重新设置新的消费者组\n\n\n# 3.消费者手动提交offset\n\n若把 consumerconfig.enable_auto_commit_config设置为false，则不会自动提交offset，那么消费者宕机后下次来还是会消费之前的数据。\n\n虽然自动提交 offset 十分简介便利，但由于其是基于时间提交的，开发人员难以把握 offset 提交的时机。因此 kafka 还提供了手动提交 offset 的 api。\n\n手动提交 offset 的方法有两种：分别是 commitsync（同步提交）和 commitasync（异步 提交）。两者的相同点是，都会将本次 poll 的一批数据最高的偏移量提交；不同点是， commitsync 阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致， 也会出现提交失败）；而 commitasync 则没有失败重试机制，故有可能提交失败。\n\n> 自动提交的补充：\n> \n> 1.若consumerconfig.auto_commit_interval_ms_config设置为1秒钟提交offset，会造成数据丢失，假如消费者正在处理该数据，但是未处理完，已经提交到offset中，但是消费者挂掉了，那么该数据库就丢失了；\n> \n> 2.若consumerconfig.auto_commit_interval_ms_config设置为10秒钟提交offset，会造成数据重复，假如消费者处理已经把消息处理完了，但是在6秒的时候宕机，还未写入到offset，就会造成数据重复\n\n# 3.1.同步提交offset\n\n问题：若数据处理完，在手动同步提交offset时宕机，那么消费者重启后会重复消费\n\n步骤：\n\n 1. 关闭自动提交\n 2. 调用kafkaconsumer.commitsync();//同步提交数据\n\npackage com.wcy.consumer;\n\nimport org.apache.kafka.clients.consumer.consumerconfig;\nimport org.apache.kafka.clients.consumer.consumerrecord;\nimport org.apache.kafka.clients.consumer.consumerrecords;\nimport org.apache.kafka.clients.consumer.kafkaconsumer;\n\nimport java.util.arrays;\nimport java.util.properties;\n\n/**\n * 消费者\n */\npublic class myconsumer {\n    public static void main(string[] args) {\n        properties properties=new properties();\n        //kafka集群信息\n        properties.put(consumerconfig.bootstrap_servers_config,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");\n        //提交offset时间 单位：毫秒\n        properties.put(consumerconfig.auto_commit_interval_ms_config,"1000");\n        //自动提交\n//        properties.put(consumerconfig.enable_auto_commit_config,"true");\n        properties.put(consumerconfig.enable_auto_commit_config,"false");\n        //反序列化\n        properties.put(consumerconfig.key_deserializer_class_config,"org.apache.kafka.common.serialization.stringdeserializer");\n        properties.put(consumerconfig.value_deserializer_class_config,"org.apache.kafka.common.serialization.stringdeserializer");\n\n        /**\n         * 设置消费者从头消费\n         * 生效条件：\n         *  1.消费者组第一次消费\n         *  2.消费者组之前保存的offset失效（即七天后）\n         *\n         *  earliest：从头消费\n         *  latest：接受开启消费后的数据\n         */\n        properties.put(consumerconfig.auto_offset_reset_config,"earliest");\n\n        //设置消费者组\n        properties.put(consumerconfig.group_id_config,"wcy1");\n\n        kafkaconsumer<string,string> kafkaconsumer = new kafkaconsumer<string,string>(properties);\n        kafkaconsumer.subscribe(arrays.aslist("first","bigdata"));//订阅主题\n\n        while (true){//不停的获取数据\n            consumerrecords<string, string> poll = kafkaconsumer.poll(1000);//获取到空数据阻塞一秒\n            for(consumerrecord<string,string> consumerrecord:poll){\n                system.out.println(consumerrecord.key()+":"+consumerrecord.value());\n            }\n            kafkaconsumer.commitsync();//同步提交数据\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n# 3.2.异步提交offset\n\n问题：若数据处理完，在手动异步提交宕机也会出现重复消费。\n\n步骤：\n\n 1. 关闭自动提交\n\n 2. 调用\n    \n    kafkaconsumer.commitasync(new offsetcommitcallback() {\n                    @override\n                    public void oncomplete(map<topicpartition, offsetandmetadata> offsets, exception exception) {\n                        if(exception!=null){\n                            system.out.println("手动提交失败");\n                        }\n                    }\n                });\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\npackage com.wcy.consumer;\n\nimport org.apache.kafka.clients.consumer.*;\nimport org.apache.kafka.common.topicpartition;\n\nimport java.util.arrays;\nimport java.util.map;\nimport java.util.properties;\n\n/**\n * 消费者\n */\npublic class myconsumer {\n    public static void main(string[] args) {\n        properties properties=new properties();\n        //kafka集群信息\n        properties.put(consumerconfig.bootstrap_servers_config,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");\n        //提交offset时间 单位：毫秒\n        properties.put(consumerconfig.auto_commit_interval_ms_config,"1000");\n        //自动提交\n//        properties.put(consumerconfig.enable_auto_commit_config,"true");\n        properties.put(consumerconfig.enable_auto_commit_config,"false");\n        //反序列化\n        properties.put(consumerconfig.key_deserializer_class_config,"org.apache.kafka.common.serialization.stringdeserializer");\n        properties.put(consumerconfig.value_deserializer_class_config,"org.apache.kafka.common.serialization.stringdeserializer");\n\n        /**\n         * 设置消费者从头消费\n         * 生效条件：\n         *  1.消费者组第一次消费\n         *  2.消费者组之前保存的offset失效（即七天后）\n         *\n         *  earliest：从头消费\n         *  latest：接受开启消费后的数据\n         */\n        properties.put(consumerconfig.auto_offset_reset_config,"earliest");\n\n        //设置消费者组\n        properties.put(consumerconfig.group_id_config,"wcy1");\n\n        kafkaconsumer<string,string> kafkaconsumer = new kafkaconsumer<string,string>(properties);\n        kafkaconsumer.subscribe(arrays.aslist("first","bigdata"));//订阅主题\n\n        while (true){//不停的获取数据\n            consumerrecords<string, string> poll = kafkaconsumer.poll(1000);//获取到空数据阻塞一秒\n            for(consumerrecord<string,string> consumerrecord:poll){\n                system.out.println(consumerrecord.key()+":"+consumerrecord.value());\n            }\n            kafkaconsumer.commitasync(new offsetcommitcallback() {\n                @override\n                public void oncomplete(map<topicpartition, offsetandmetadata> offsets, exception exception) {\n                    if(exception!=null){\n                        system.out.println("手动提交失败");\n                    }\n                }\n            });\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 4 .自定义存储 offset\n\n> 无论是同步提交还是异步提交 offset，都有可能会造成数据的漏消费或者重复消费。先 提交 offset 后消费，有可能造成数据的漏消费；而先消费后提交 offset，有可能会造成数据 的重复消费。\n\nkafka 0.9 版本之前，offset 存储在 zookeeper，0.9 版本及之后，默认将 offset 存储在 kafka 的一个内置的 topic 中。除此之外，kafka 还可以选择自定义存储 offset。\n\noffset 的维护是相当繁琐的，因为需要考虑到消费者的 rebalace。\n\n当有新的消费者加入消费者组、已有的消费者推出消费者组或者所订阅的主题的分区发 生变化，就会触发到分区的重新分配，重新分配的过程叫做 rebalance。\n\n消费者发生 rebalance 之后，每个消费者消费的分区就会发生变化。因此消费者要首先获取到自己被重新分配到的分区，并且定位到每个分区最近提交的 offset 位置继续消费。\n\n要实现自定义存储 offset，需要借助 consumerrebalancelistener，以下为示例代码，其 中提交和获取 offset 的方法，需要根据所选的 offset 存储系统自行实现。\n\n步骤：\n\n 1. 自定义map存储offset信息\n 2. 关闭自动提交\n 3. 在订阅的时候绑定重新分配的监听，在重新分配之前，提交offset到mysql，在重新分配之后，读取mysql数据，让消费者从该offset消费\n 4. 处理完消息后，记得手动提交数据，就算出现异常也会回滚数据（处理消息的逻辑放到一个mysql数据中）\n\npackage com.wcy.consumer.offset;\n\nimport org.apache.kafka.clients.consumer.*;\nimport org.apache.kafka.common.topicpartition;\n\nimport java.util.*;\n\n/**\n * 自定义存储offset\n */\npublic class myoffsetcusumer {\n    //维护offset\n    private static map<topicpartition, long> currentoffset = new\n            hashmap<>();\n\n    public static void main(string[] args) {\n        properties properties=new properties();\n        //kafka集群信息\n        properties.put(consumerconfig.bootstrap_servers_config,"192.168.188.128:9092,192.168.188.128:9093,192.168.188.128:9094");\n        //提交offset时间 单位：毫秒\n        properties.put(consumerconfig.auto_commit_interval_ms_config,"1000");\n        //自动提交\n//        properties.put(consumerconfig.enable_auto_commit_config,"true");\n        properties.put(consumerconfig.enable_auto_commit_config,"false");\n        //反序列化\n        properties.put(consumerconfig.key_deserializer_class_config,"org.apache.kafka.common.serialization.stringdeserializer");\n        properties.put(consumerconfig.value_deserializer_class_config,"org.apache.kafka.common.serialization.stringdeserializer");\n\n        /**\n         * 设置消费者从头消费\n         * 生效条件：\n         *  1.消费者组第一次消费\n         *  2.消费者组之前保存的offset失效（即七天后）\n         *\n         *  earliest：从头消费\n         *  latest：接受开启消费后的数据\n         */\n        properties.put(consumerconfig.auto_offset_reset_config,"earliest");\n\n        //设置消费者组\n        properties.put(consumerconfig.group_id_config,"wcy1");\n\n        kafkaconsumer<string,string> kafkaconsumer = new kafkaconsumer<string,string>(properties);\n        kafkaconsumer.subscribe(arrays.aslist("first", "bigdata"), new consumerrebalancelistener() {\n            //该方法会在 rebalance（重新分配） 之前调用\n            @override\n            public void onpartitionsrevoked(collection<topicpartition> partitions) {\n                commitoffset(currentoffset);\n            }\n\n            //该方法会在 rebalance（重新分配） 之后调用\n            @override\n            public void onpartitionsassigned(collection<topicpartition> partitions) {\n                currentoffset.clear();//清空offset\n                //重新计算消费\n                for (topicpartition partition : partitions) {\n                    //定位到最近提交的 offset 位置继续消费\n                    kafkaconsumer.seek(partition, getoffset(partition));\n                }\n            }\n\n        });//订阅主题\n\n        while (true){//不停的获取数据\n            consumerrecords<string, string> poll = kafkaconsumer.poll(1000);//获取到空数据阻塞一秒\n            for(consumerrecord<string,string> consumerrecord:poll){\n                system.out.println(consumerrecord.key()+":"+consumerrecord.value());\n                currentoffset.put(new topicpartition(consumerrecord.topic(),\n                        consumerrecord.partition()), consumerrecord.offset());\n            }\n            commitoffset(currentoffset);//手动提交\n        }\n    }\n\n    /**\n     * 自定义提交到mysql  通过事务实现\n     * 列：消费者组、主题、分区、offset\n     * @param currentoffset\n     */\n    private static void commitoffset(map<topicpartition, long> currentoffset) {\n    }\n\n    /**\n     * 自定义读取offset\n     * @param partition\n     * @return\n     */\n    private static long getoffset(topicpartition partition) {\n        return 0;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n\n# 十七.自定义拦截器\n\nproducer 拦截器(interceptor)是在 kafka 0.10 版本被引入的，主要用于实现 clients 端的定 制化控制逻辑。\n\n对于 producer 而言，interceptor 使得用户在消息发送前以及 producer 回调逻辑前有机会 对消息做一些定制化需求，比如修改消息等。同时，producer 允许用户指定多个 interceptor 按序作用于同一条消息从而形成一个拦截链(interceptor chain)。intercetpor 的实现接口是 org.apache.kafka.clients.producer.producerinterceptor，其定义的方法包括：\n\n（1）configure(configs) ：获取配置信息和初始化数据时调用。\n\n（2）onsend(producerrecord)： 消息发送前执行，该方法封装进 kafkaproducer.send 方法中，即它运行在用户主线程中。producer 确保在消息被序列化以及计算分区前调用该方法。用户可以在该方法中对消息做任何操作，但最好 保证不要修改消息所属的 topic 和分区，否则会影响目标分区的计算。\n\n（3）onacknowledgement(recordmetadata, exception)：消息发送后执行， 该方法会在消息从 recordaccumulator 成功发送到 kafka broker 之后，或者在发送过程 中失败时调用。并且通常都是在 producer 回调逻辑触发之前。onacknowledgement 运行在 producer 的 io 线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢 producer 的消息 发送效率。\n\n（4）close： 关闭 interceptor，主要用于执行一些资源清理工作 如前所述，interceptor 可能被运行在多个线程中，因此在具体实现时用户需要自行确保 线程安全。另外倘若指定了多个 interceptor，则 producer 将按照指定顺序调用它们，并仅仅 是捕获每个 interceptor 可能抛出的异常记录到错误日志中而非在向上传递。这在使用过程中 要特别留意。 4.3.2 拦截器案\n\n\n# 拦截器按钮\n\n实现一个简单的双 interceptor 组成的拦截链。第一个 interceptor 会在消息发送前将时间 戳信息加到消息 value 的最前部；第二个 interceptor 会在消息发送后更新成功发送消息数或 失败发送消息数。\n\n# 1.自定义拦截器\n\npackage com.wcy.produce.interceptor;\n\nimport org.apache.kafka.clients.producer.producerinterceptor;\nimport org.apache.kafka.clients.producer.producerrecord;\nimport org.apache.kafka.clients.producer.recordmetadata;\n\nimport java.util.map;\n\npublic class timeinterceptor implements producerinterceptor {\n    int success;\n    int error;\n    @override\n    public void configure(map<string, ?> configs) {\n        system.out.println("配置信息：");\n        system.out.println(configs);\n    }\n    @override\n    public producerrecord onsend(producerrecord record) {\n        string value= (string) record.value();\n        return new producerrecord(record.topic(),record.partition(),\n                record.timestamp(),record.key(),system.currenttimemillis()+value,record.headers());\n    }\n\n    @override\n    public void onacknowledgement(recordmetadata metadata, exception exception) {\n        if(exception!=null){\n            success++;\n        }else{\n            error++;\n        }\n    }\n\n    @override\n    public void close() {\n        system.out.println("成功条数："+success);\n        system.out.println("失败条数："+error);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# 2.生产者中引入\n\n注意：存放的是集合\n\n        properties.put(producerconfig.interceptor_classes_config, arrays.aslist("com.wcy.produce.interceptor.timeinterceptor"));\n\n\n\n1\n2\n\n\n\n# 十八.安装kafka-eagle监视\n\n下载地址\n\n\n# 1.解压\n\ntar -zxvf kafka-eagle-bin-1.3.7.tar.gz\n\n\n1\n\n\n\n# 2.解压后还有个压缩文件，cd再解压\n\ncd kafka-eagle-bin-1.3.7\ntar -zxvf kafka-eagle-web-1.3.7-bin.tar.gz -c /opt/module/\n\n\n1\n2\n\n\n\n# 3.改名\n\nmv kafka-eagle-web-1.3.7/ eagle\n\n\n1\n\n\n\n# 4.给文件权限\n\ncd /eagle/bin\nchmod 777 ke.sh\n\n\n1\n2\n\n\n\n# 5.修改配置文件\n\ncd /conf\nvi system-config.properties\n\n\n1\n2\n\n\n修改：\n\neagle默认可以监控多个kafka环境\n\n 1. kafka.eagle.zk.cluster.alias=cluster1,cluster2:监控多个kafka环境\n 2. cluster1.zk.list：配置集群\n 3. cluster1.kafka.eagle.offset.storage:kafka的消息保存到kafka\n 4. kafka.eagle.metrics.charts：true界面有图表\n 5. 配置数据库\n\n######################################\n# multi zookeeper&kafka cluster list\n######################################\n#可以配置监控多个kafka\n#kafka.eagle.zk.cluster.alias=cluster1,cluster2\nkafka.eagle.zk.cluster.alias=cluster1\n#配置集群\ncluster1.zk.list=192.168.188.128:2181,192.168.188.128:2182,192.168.188.128:2183\n#cluster2.zk.list=xdn10:2181,xdn11:2181,xdn12:2181\n\n######################################\n# zk client thread limit\n######################################\nkafka.zk.limit.size=25\n\n######################################\n# kafka eagle webui port\n######################################\nkafka.eagle.webui.port=8048\n\n######################################\n# kafka offset storage\n######################################\n#kafka0.10版本默认存放到kafka\ncluster1.kafka.eagle.offset.storage=kafka\n#cluster2.kafka.eagle.offset.storage=zookeeper\n\n######################################\n# enable kafka metrics\n######################################\n#web界面显示图表\nkafka.eagle.metrics.charts=true\nkafka.eagle.sql.fix.error=false\n\n######################################\n# kafka sql topic records max\n######################################\nkafka.eagle.sql.topic.records.max=5000\n\n######################################\n# alarm email configure\n######################################\n#kafka异常发送邮件\nkafka.eagle.mail.enable=false\nkafka.eagle.mail.sa=alert_sa@163.com\nkafka.eagle.mail.username=alert_sa@163.com\nkafka.eagle.mail.password=mqslimczkdqabbbh\nkafka.eagle.mail.server.host=smtp.163.com\nkafka.eagle.mail.server.port=25\n\n######################################\n# alarm im configure\n######################################\n#kafka.eagle.im.dingding.enable=true\n#kafka.eagle.im.dingding.url=https://oapi.dingtalk.com/robot/send?access_token=\n\n#kafka.eagle.im.wechat.enable=true\n#kafka.eagle.im.wechat.token=https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=xxx&corpsecret=xxx\n#kafka.eagle.im.wechat.url=https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=\n#kafka.eagle.im.wechat.touser=\n#kafka.eagle.im.wechat.toparty=\n#kafka.eagle.im.wechat.totag=\n#kafka.eagle.im.wechat.agentid=\n\n######################################\n# delete kafka topic token\n######################################\nkafka.eagle.topic.token=keadmin\n\n######################################\n# kafka sasl authenticate\n######################################\ncluster1.kafka.eagle.sasl.enable=false\ncluster1.kafka.eagle.sasl.protocol=sasl_plaintext\ncluster1.kafka.eagle.sasl.mechanism=plain\ncluster1.kafka.eagle.sasl.jaas.config=org.apache.kafka.common.security.plain.plainloginmodule required username="admin" password="kafka-eagle";\n\ncluster2.kafka.eagle.sasl.enable=false\ncluster2.kafka.eagle.sasl.protocol=sasl_plaintext\ncluster2.kafka.eagle.sasl.mechanism=plain\ncluster2.kafka.eagle.sasl.jaas.config=org.apache.kafka.common.security.plain.plainloginmodule required username="admin" password="kafka-eagle";\n\n######################################\n# kafka jdbc driver address\n######################################\n#保存的数据库\n#kafka.eagle.driver=org.sqlite.jdbc\n#kafka.eagle.url=jdbc:sqlite:/hadoop/kafka-eagle/db/ke.db\n#kafka.eagle.username=root\n#kafka.eagle.password=www.kafka-eagle.org\n#配置mysql\nkafka.eagle.driver=com.mysql.jdbc.driver\nkafka.eagle.url=jdbc:mysql://localhost:3306/ke?useunicode=true&ch\naracterencoding=utf-8&zerodatetimebehavior=converttonull\nkafka.eagle.username=root\nkafka.eagle.password=2452952178\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n6.添加环境变量（必须）\n\nsudo vi /etc/profile\n--添加内容\nexport ke_home=/opt/module/eagle\nexport path=$path:$ke_home/bin\n重启\nsource /etc/profile\n\n\n1\n2\n3\n4\n5\n6\n\n\n7.启动\n\nke.sh start\n\n\n1\n\n\n\n# 监控信息：\n\n\n\n\n# 十九.面试题\n\nkafka\n\n\n# 二十.ssm引入kafka\n\n\n# 1.引入依赖\n\n    \x3c!--kafka--\x3e\n    <dependency>\n      <groupid>org.springframework.kafka</groupid>\n      <artifactid>spring-kafka</artifactid>\n      <version>1.3.11.release</version>\n    </dependency>\n    \x3c!--kafka客户端 根据本地的kafka版本--\x3e\n    <dependency>\n      <groupid>org.apache.kafka</groupid>\n      <artifactid>kafka-clients</artifactid>\n      <version>0.11.0.0</version>\n    </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.kafka配置信息\n\n#bootstrap.servers=10.1.10.80\\:9092\n#bootstrap.servers=10.1.10.77\\:9092\nbootstrap.servers=192.168.188.128\\:9092,192.168.188.128\\:9093,192.168.188.128\\:9094\n\n\n1\n2\n3\n\n\n\n# 3.生产者配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n         http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context\n         http://www.springframework.org/schema/context/spring-context.xsd">\n\n    <context:property-placeholder location="classpath:kafkaconfig.properties" ignore-unresolvable="true"/>\n\n    \x3c!-- 定义producer的参数 --\x3e\n    <bean id="producerproperties" class="java.util.hashmap">\n        <constructor-arg>\n            <map>\n                <entry key="bootstrap.servers" value="${bootstrap.servers}"/>\n                \x3c!-- 组id标志 --\x3e\n                <entry key="group.id" value="test_group"/>\n                \x3c!--重试次数--\x3e\n                <entry key="retries" value="1"/>\n                \x3c!-- ack -1：isr中全部发送才发送ack   0：不管有没有回应   1：leader应答即可--\x3e\n                <entry key="acks" value="-1"/>\n                \x3c!-- 每次批量发送消息的数量 --\x3e\n                <entry key="batch.size" value="16384"/>\n                \x3c!-- 默认0ms，在异步io线程被触发后（任何一个topic，partition满都可以触发） --\x3e\n                <entry key="linger.ms" value="1"/>\n                \x3c!--producer可以用来缓存数据的内存大小。如果数据产生速度大于向broker发送的速度，producer会阻塞或者抛出异常 --\x3e\n                <entry key="buffer.memory" value="33554432"/>\n                \x3c!--序列化--\x3e\n                <entry key="key.serializer" value="org.apache.kafka.common.serialization.stringserializer"/>\n                <entry key="value.serializer" value="org.apache.kafka.common.serialization.stringserializer"/>\n            </map>\n        </constructor-arg>\n    </bean>\n\n    \x3c!-- 创建kafkatemplate需要使用的producerfactory bean --\x3e\n    <bean id="producerfactory" class="org.springframework.kafka.core.defaultkafkaproducerfactory">\n        <constructor-arg>\n            <ref bean="producerproperties"/>\n        </constructor-arg>\n    </bean>\n\n    \x3c!-- 创建kafkatemplate bean，使用的时候，只需要注入这个bean，即可使用template的send消息方法 --\x3e\n    <bean id="kafkatemplate" class="org.springframework.kafka.core.kafkatemplate">\n        <constructor-arg ref="producerfactory"/>\n        <constructor-arg name="autoflush" value="true"/>\n        <property name="defaulttopic" value="mytopic"/>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 4.消费者配置\n\ncontainerproperties：可以监听多个topic主题\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n         http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context\n         http://www.springframework.org/schema/context/spring-context.xsd">\n\n    <context:property-placeholder location="classpath:kafkaconfig.properties" ignore-unresolvable="true"/>\n\n    \x3c!-- 定义producer的参数 --\x3e\n    <bean id="consumerproperties" class="java.util.hashmap">\n        <constructor-arg>\n            <map>\n                \x3c!--kafka服务地址 --\x3e\n                <entry key="bootstrap.servers" value="${bootstrap.servers}" />\n                \x3c!--consumer的组id，相同group.id的consumer属于同一个组。 --\x3e\n                <entry key="group.id" value="test_group" />\n                \x3c!--如果此值设置为true，consumer会周期性的把当前消费的offset值保存到zookeeper。当consumer失败重启之后将会使用此值作为新开始消费的值。 --\x3e\n                <entry key="enable.auto.commit" value="true" />\n\x3c!--                提交offset时间 单位：毫秒--\x3e\n                <entry key="auto.commit.interval.ms" value="1000" />\n                \x3c!--网络请求的socket超时时间。实际超时时间由max.fetch.wait + socket.timeout.ms 确定 --\x3e\n                <entry key="session.timeout.ms" value="15000" />\n                \x3c!--设置从头消费    earliest   latest--\x3e\n                <entry key="auto.offset.reset" value="earliest" />\n\n                <entry key="key.deserializer"\n                       value="org.apache.kafka.common.serialization.stringdeserializer" />\n\n                <entry key="value.deserializer"\n                       value="org.apache.kafka.common.serialization.stringdeserializer" />\n            </map>\n        </constructor-arg>\n    </bean>\n\n    \x3c!-- 创建consumerfactory bean --\x3e\n    <bean id="consumerfactory" class="org.springframework.kafka.core.defaultkafkaconsumerfactory">\n        <constructor-arg>\n            <ref bean="consumerproperties"/>\n        </constructor-arg>\n    </bean>\n\n    \x3c!-- 实际执行消息消费的类  自己定义的类 --\x3e\n    <bean id="messagelisternerconsumerservice" class="com.wcy.kafka.spring.kafkaconsumer"/>\n\n    \x3c!-- 消费者容器配置信息 --\x3e\n    <bean id="containerproperties" class="org.springframework.kafka.listener.config.containerproperties">\n        \x3c!-- 配置消费的主题 --\x3e\n\x3c!--        <constructor-arg value="mytopic"/>--\x3e\n        \x3c!-- 订阅多个主题 --\x3e\n        <constructor-arg>\n            <list>\n                <value>mytopic</value>\n                <value>newtopic</value>\n            </list>\n        </constructor-arg>\n        <property name="messagelistener" ref="messagelisternerconsumerservice"/>\n    </bean>\n\n    \x3c!-- 创建kafkatemplate bean，使用的时候，只需要注入这个bean，即可使用template的send消息方法 --\x3e\n    <bean id="messagelistenercontainer" class="org.springframework.kafka.listener.kafkamessagelistenercontainer" init-method="dostart">\n        <constructor-arg ref="consumerfactory"/>\n        <constructor-arg ref="containerproperties"/>\n    </bean>\n    \x3c!--concurrentmessagelistenercontainer 这个是并发消费  concurrency这个属性就是并发消费者的数量--\x3e\n    \x3c!--<bean id="messagelistenercontainer"\n        class="org.springframework.kafka.listener.concurrentmessagelistenercontainer"\n        init-method="dostart">\n        <constructor-arg ref="consumerfactory" />\n        <constructor-arg ref="containerproperties" />\n        <property name="concurrency" value="3" />\n    </bean> --\x3e\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n# 5.生产者发送消息\n\n    @autowired\n    private kafkatemplate<string, string> kafkatemplate;\n\n    public void testtemplatesend(string msg){\n        kafkatemplate.send("newtopic",msg); //指定主题\n        kafkatemplate.senddefault("生产者默认主题");\n//        for(int i=0;i<10000;i++){\n//            kafkatemplate.senddefault("kafka发送消息****"+i);\n//            if (i % 1000 == 0) {\n//                system.out.println(i+"***kafka发送消息***"+i);\n//            }\n//        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n6.消费者接受消息\n\npackage com.wcy.kafka.spring;\n\nimport org.apache.kafka.clients.consumer.consumerrecord;\nimport org.springframework.kafka.listener.messagelistener;\n\npublic class kafkaconsumer implements messagelistener<integer, string> {\n    private int i;\n    private int count;\n\n    @override\n    public void onmessage(consumerrecord<integer, string> record) {\n\t/*\t system.out.println("*****接受到消息开始***********");\n\t\t system.out.println("整个对象:"+record);\n//\t\t system.out.println("key:"+record.key());\n//\t\t system.out.println("value:"+record.value());\n\t\t system.out.println("partition:"+record.partition());*/\n        try {\n            system.out.println("key:"+record.key()+"value:"+record.value());\n        }catch (exception e) {\n            e.printstacktrace();\n        }\n//        i++;\n//        if (i % 1000 == 0) {\n//            count++;\n//            system.out.println(i+"***接受到消息结束***"+count+"---"+record);\n//            i = 0;\n//        }\n\n    }\n\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"SpringBoot整合kafka",frontmatter:{title:"SpringBoot整合kafka",date:"2021-08-06T15:38:35.000Z",permalink:"/pages/fd92ef/",categories:["后端","消息队列"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/60.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/02.SpringBoot%E6%95%B4%E5%90%88kafka.html",relativePath:"01.后端/60.消息队列/02.SpringBoot整合kafka.md",key:"v-1528edda",path:"/pages/fd92ef/",headers:[{level:2,title:"一.前戏",slug:"一-前戏",normalizedTitle:"一.前戏",charIndex:126},{level:2,title:"二.简单生产者消费者",slug:"二-简单生产者消费者",normalizedTitle:"二.简单生产者消费者",charIndex:6372},{level:3,title:"1.简单生产者",slug:"_1-简单生产者",normalizedTitle:"1.简单生产者",charIndex:6387},{level:3,title:"2.简单消费者",slug:"_2-简单消费者",normalizedTitle:"2.简单消费者",charIndex:7074},{level:2,title:"三.生产者",slug:"三-生产者",normalizedTitle:"三.生产者",charIndex:7678},{level:3,title:"1.带回调的生产者",slug:"_1-带回调的生产者",normalizedTitle:"1.带回调的生产者",charIndex:7688},{level:3,title:"2.自定义分区规则",slug:"_2-自定义分区规则",normalizedTitle:"2.自定义分区规则",charIndex:8960},{level:3,title:"3.生产者kafka事务提交",slug:"_3-生产者kafka事务提交",normalizedTitle:"3.生产者kafka事务提交",charIndex:10221},{level:2,title:"四.消费者",slug:"四-消费者",normalizedTitle:"四.消费者",charIndex:11838},{level:3,title:"1.指定topic、partition、offset消费",slug:"_1-指定topic、partition、offset消费",normalizedTitle:"1.指定topic、partition、offset消费",charIndex:11848},{level:3,title:"2.批量消费",slug:"_2-批量消费",normalizedTitle:"2.批量消费",charIndex:12962},{level:3,title:"3.ConsumerAwareListenerErrorHandler 异常处理器",slug:"_3-consumerawarelistenererrorhandler-异常处理器",normalizedTitle:"3.consumerawarelistenererrorhandler 异常处理器",charIndex:13519},{level:3,title:"4.消息过滤器",slug:"_4-消息过滤器",normalizedTitle:"4.消息过滤器",charIndex:14576},{level:3,title:"5.消息转发",slug:"_5-消息转发",normalizedTitle:"5.消息转发",charIndex:16280},{level:3,title:"6.定时启动、停止监听器",slug:"_6-定时启动、停止监听器",normalizedTitle:"6.定时启动、停止监听器",charIndex:16798}],headersStr:"一.前戏 二.简单生产者消费者 1.简单生产者 2.简单消费者 三.生产者 1.带回调的生产者 2.自定义分区规则 3.生产者kafka事务提交 四.消费者 1.指定topic、partition、offset消费 2.批量消费 3.ConsumerAwareListenerErrorHandler 异常处理器 4.消息过滤器 5.消息转发 6.定时启动、停止监听器",content:'# SpringBoot集成kafka全面实战\n\n参考：地址\n\n本文是SpringBoot+Kafka的实战讲解，如果对kafka的架构原理还不了解的读者，建议先看一下《大白话kafka架构原理》、《秒懂kafka HA（高可用）》两篇文章。\n\n\n# 一.前戏\n\n1、在项目中连接kafka，因为是外网，首先要开放kafka配置文件中的如下配置（其中IP为公网IP），\n\nadvertised.listeners=PLAINTEXT://112.126.74.249:9092\n也可以配置\nlisteners=PLAINTEXT://112.126.74.249:9092\n\n\n1\n2\n3\n\n\n2.在开始前我们先创建两个topic：topic1、topic2，其分区和副本数都设置为2，用来测试，\n\n[root@iZ2zegzlkedbo3e64vkbefZ ~]#  cd /usr/local/kafka-cluster/kafka1/bin/\n[root@iZ2zegzlkedbo3e64vkbefZ bin]# ./kafka-topics.sh --create --zookeeper 172.17.80.219:2181 --replication-factor 2 --partitions 2 --topic topic1\nCreated topic topic1.\n[root@iZ2zegzlkedbo3e64vkbefZ bin]# ./kafka-topics.sh --create --zookeeper 172.17.80.219:2181 --replication-factor 2 --partitions 2 --topic topic2\nCreated topic topic2.\n\n\n1\n2\n3\n4\n5\n\n\n当然我们也可以不手动创建topic，在执行代码kafkaTemplate.send("topic1", normalMessage)发送消息时，kafka会帮我们自动完成topic的创建工作，但这种情况下创建的topic默认**只有一个分区，分区也没有副本。**所以，我们可以在项目中新建一个配置类专门用来初始化topic，如下:\n\n@Configuration\npublic class KafkaInitialConfiguration {\n    // 创建一个名为testtopic的Topic并设置分区数为8，分区副本数为2\n    @Bean\n    public NewTopic initialTopic() {\n        return new NewTopic("testtopic",8, (short) 2 );\n    }\n    \n     // 如果要修改分区数，只需修改配置值重启项目即可\n    // 修改分区数并不会导致数据的丢失，但是分区数只能增大不能减小 更新有问题，请去命令行操作\n    @Bean\n    public NewTopic updateTopic() {\n        return new NewTopic("testtopic",10, (short) 2 );\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n3.新建Springboot项目\n\n 1. 引入pom依赖\n\n<dependency>\n    <groupId>org.springframework.kafka</groupId>\n    <artifactId>spring-kafka</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n\n\n 2. application.propertise配置（本文用到的配置项这里全列了出来）\n    \n    application.properties：文件\n    \n    ###########【Kafka集群】###########\n    spring.kafka.bootstrap-servers=112.126.74.249:9092,112.126.74.249:9093\n    ###########【初始化生产者配置】###########\n    # 重试次数\n    spring.kafka.producer.retries=0\n    # 应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)\n    spring.kafka.producer.acks=1\n    # 批量大小\n    spring.kafka.producer.batch-size=16384\n    # 提交延时\n    spring.kafka.producer.properties.linger.ms=0\n    # 当生产端积累的消息达到batch-size或接收到消息linger.ms后,生产者就会将消息提交给kafka\n    # linger.ms为0表示每接收到一条消息就提交给kafka,这时候batch-size其实就没用了\n    \n    # 生产端缓冲区大小\n    spring.kafka.producer.buffer-memory = 33554432\n    # Kafka提供的序列化和反序列化类\n    spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer\n    spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer\n    # 自定义分区器\n    # spring.kafka.producer.properties.partitioner.class=com.felix.kafka.producer.CustomizePartitioner\n    \n    ###########【初始化消费者配置】###########\n    # 默认的消费组ID\n    spring.kafka.consumer.properties.group.id=defaultConsumerGroup\n    # 是否自动提交offset\n    spring.kafka.consumer.enable-auto-commit=true\n    # 提交offset延时(接收到消息后多久提交offset)\n    spring.kafka.consumer.auto.commit.interval.ms=1000\n    # 当kafka中没有初始offset或offset超出范围时将自动重置offset\n    # earliest:重置为分区中最小的offset;\n    # latest:重置为分区中最新的offset(消费分区中新产生的数据);\n    # none:只要有一个分区不存在已提交的offset,就抛出异常;\n    spring.kafka.consumer.auto-offset-reset=latest\n    # 消费会话超时时间(超过这个时间consumer没有发送心跳,就会触发rebalance操作)\n    spring.kafka.consumer.properties.session.timeout.ms=120000\n    # 消费请求超时时间\n    spring.kafka.consumer.properties.request.timeout.ms=180000\n    # Kafka提供的序列化和反序列化类\n    spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer\n    spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer\n    # 消费端监听的topic不存在时，项目启动会报错(关掉)\n    spring.kafka.listener.missing-topics-fatal=false\n    # 设置批量消费\n    # spring.kafka.listener.type=batch\n    # 批量消费每次最多消费多少条消息\n    # spring.kafka.consumer.max-poll-records=50\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    \n    \n    yml文件\n    \n    spring:\n      application:\n        name: SpringBoot_kafka\n      #【Kafka集群】\n      kafka:\n        bootstrap-servers: 192.168.188.128:9092,192.168.188.128:9093\n        # [kafka生产者配置]\n        producer:\n          retries: 0  #重试次数\n          acks: 1 #应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)\n          batch-size: 16384 #生产者批量发送大小\n          #提交延时 当生产端积累的消息达到batch-size或接收到消息linger.ms后,生产者就会将消息提交给kafka\n          ## linger.ms为0表示每接收到一条消息就提交给kafka,这时候batch-size其实就没用了\n          properties:\n            linger:\n              ms: 0\n            #自定义分区器\n    #        partitioner:\n    #          class: com.felix.kafka.producer.CustomizePartitioner\n          # 生产端缓冲区大小\n          buffer-memory: 33554432\n          key-serializer: org.apache.kafka.common.serialization.StringSerializer\n          value-serializer: org.apache.kafka.common.serialization.StringSerializer\n    \n        # [kafka消费者配置]\n        consumer:\n          properties:\n            #默认的消费组ID\n            group:\n              id: defaultConsumerGroup\n            session:\n              timeout:\n                ms: 120000 # 消费会话超时时间(超过这个时间consumer没有发送心跳,就会触发rebalance操作)\n            request:\n              timeout:\n                ms: 180000 # 消费请求超时时间\n          enable-auto-commit: true #是否自动提交offset\n          auto-commit-interval: 1000 #提交offset延时(接收到消息后多久提交offset)\n          # 当kafka中没有初始offset或offset超出范围时将自动重置offset\n          # earliest:重置为分区中最小的offset;\n          # latest:重置为分区中最新的offset(消费分区中新产生的数据);\n          # none:只要有一个分区不存在已提交的offset,就抛出异常;\n          auto-offset-reset: latest\n          #序列化\n          key-deserializer: org.apache.kafka.common.serialization.StringDeserializer\n          value-deserializer: org.apache.kafka.common.serialization.StringDeserializer\n    #      max-poll-records: 50 # 批量消费每次最多消费多少条消息\n        listener:\n          missing-topics-fatal: false  # 消费端监听的topic不存在时，项目启动会报错(关掉)\n    #      type: batch  # 设置批量消费  配合max-poll-records使用\n    \n    server:\n      port: 80\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    \n\n\n# 二.简单生产者消费者\n\n\n# 1.简单生产者\n\npackage com.wcy.controller;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.kafka.core.KafkaTemplate;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class KafkaController {\n    @Autowired\n    public KafkaTemplate<String,Object> kafkaTemplate;\n\n    @GetMapping("kafka/normal/{message}")\n    public void sendMessage1(@PathVariable("message") String normalMessage){\n        kafkaTemplate.send("topic1",normalMessage);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 2.简单消费者\n\n监听器用@KafkaListener注解，topics表示监听的topic，支持同时监听多个，用英文逗号分隔\n\npackage com.wcy.consumer;\n\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.springframework.kafka.annotation.KafkaListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class KafkaConsumer {\n    //订阅主题topic1\n    @KafkaListener(topics = {"topic1"})\n    public void onMessage1(ConsumerRecord<?, ?> record){\n        // 消费的哪个topic、partition的消息,打印出消息内容\n        System.out.println("简单消费："+record.topic()+"-"+record.partition()+"-"+record.value());\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 三.生产者\n\n\n# 1.带回调的生产者\n\n    /**\n     * 带回调的发送消息\n     * @param message\n     */\n    @GetMapping("kafka/callbackOne/{message}")\n    public void sendMessage2(@PathVariable("message") String message){\n        for (int i = 0; i < 100; i++) {\n            kafkaTemplate.send("topic1",message).addCallback(new ListenableFutureCallback<SendResult<String, Object>>() {\n                //发送失败\n                @Override\n                public void onFailure(Throwable throwable) {\n                    System.out.println(throwable.getMessage());\n                }\n                //发送成功\n                @Override\n                public void onSuccess(SendResult<String, Object> stringObjectSendResult) {\n                    RecordMetadata metadata = stringObjectSendResult.getRecordMetadata();\n                    long offset = metadata.offset();//发送成功后的偏移量\n                    ProducerRecord<String, Object> record = stringObjectSendResult.getProducerRecord();\n                    String topic = record.topic();//主题\n                    Integer partition = record.partition();//分区\n                    System.out.println("发送消息成功:" + topic + "-" + partition + "-" + offset);\n                }\n            });\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 2.自定义分区规则\n\n我们知道，kafka中每个topic被划分为多个分区，那么生产者将消息发送到topic时，具体追加到哪个分区呢？这就是所谓的分区策略，Kafka 为我们提供了默认的分区策略，同时它也支持自定义分区策略。其路由机制为：\n\n① 若发送消息时指定了分区（即自定义分区策略），则直接将消息append到指定分区；\n\n② 若发送消息时未指定 patition，但指定了 key（kafka允许为每条消息设置一个key），则对key值进行hash计算，根据计算结果路由到指定分区，这种情况下可以保证同一个 Key 的所有消息都进入到相同的分区；\n\n③ patition 和 key 都未指定，则使用kafka默认的分区策略，轮询选出一个 patition；\n\n※ 我们来自定义一个分区策略，将消息发送到我们指定的partition，首先新建一个分区器类实现Partitioner接口，重写方法，其中partition方法的返回值就表示将消息发送到几号分区：\n\npackage com.wcy.partitioner;\n\nimport org.apache.kafka.clients.producer.Partitioner;\nimport org.apache.kafka.common.Cluster;\n\nimport java.util.Map;\n\n/**\n * 自定义分区\n */\npublic class CustomizePartitioner implements Partitioner {\n    @Override\n    public int partition(String s, Object o, byte[] bytes, Object o1, byte[] bytes1, Cluster cluster) {\n        // 自定义分区规则(这里假设全部发到0号分区)\n        // ......\n        return 0;\n    }\n\n    @Override\n    public void close() {\n\n    }\n\n    @Override\n    public void configure(Map<String, ?> map) {\n\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n生产者配置自定义分区的类路径\n\n#自定义分区器\nspring:\n\tkafka:        \n        producer:\n            properties:\n                partitioner:\n                  class: com.wcy.partitioner.CustomizePartitioner\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.生产者kafka事务提交\n\n注意：一旦使用事务提交后，那么所有的消息都需要事务提交\n\n> 注意：一旦开启事务，那么后续的消息都必须放到事务中，否则会报错；\n> \n> java.lang.IllegalStateException: No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation, start a transaction with @Transactional before invoking the template method, run in a transaction started by a listener container when consuming a record\n\n# 1.添加支持事务的配置\n\n 1. retries：必须大于0\n 2. acks：必须为-1或all\n 3. transaction-id-prefix：开启事务，开启事务会默认开启幂等性\n\nspring:\n  application:\n    name: SpringBoot_kafka\n  #【Kafka集群】\n  kafka:\n    producer:\n      retries: 2  #重试次数\n      acks: -1 #应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)\n      #开启事务  retries>0  acks=-1 必须\n      transaction-id-prefix: tx-\n    consumer:\n      isolation-level: read_committed # 读取已提交的消息\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 2.使用kafkaTemplate内置的事务操作\n\n    /**\n     * 带事务发送消息\n     */\n    @GetMapping("/kafka/transaction")\n    public void sendMessage3(){\n        // 声明事务：后面报错消息不会发出去\n        kafkaTemplate.executeInTransaction(operations -> {\n            for (int i = 0; i < 10; i++) {\n                operations.send("topic1","事务提交数据测试");\n                if(i ==4){\n                    int b=10/0;// 模拟产生异常代码\n                }\n            }\n            return true;// 返回true，表示发送成功\n        });\n\n        // 不声明事务：后面报错但前面消息已经发送成功了\n//        for (int i = 0; i < 10; i++) {\n//            kafkaTemplate.send("topic1","test executeInTransaction");\n//            if(i==4){\n//                int b=10/0;\n//            }\n//        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 四.消费者\n\n\n# 1.指定topic、partition、offset消费\n\n前面我们在监听消费topic1的时候，监听的是topic1上所有的消息，如果我们想指定topic、指定partition、指定offset来消费呢？也很简单，@KafkaListener注解已全部为我们提供\n\n/**\n * @Title 指定topic、partition、offset消费\n * @Description 同时监听topic1和topic2，监听topic1的0号分区、topic2的 "0号和1号" 分区，指向1号分区的offset初始值为8\n * @Author long.yuan\n * @Date 2020/3/22 13:38\n * @Param [record]\n * @return void\n **/\n@KafkaListener(id = "consumer1",groupId = "felix-group",topicPartitions = {\n        @TopicPartition(topic = "topic1", partitions = { "0" }),\n        @TopicPartition(topic = "topic2", partitions = "0", partitionOffsets = @PartitionOffset(partition = "1", initialOffset = "8"))\n})\npublic void onMessage2(ConsumerRecord<?, ?> record) {\n    System.out.println("topic:"+record.topic()+"|partition:"+record.partition()+"|offset:"+record.offset()+"|value:"+record.value());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n属性解释：\n\n① id：消费者ID；\n\n② groupId：消费组ID；\n\n③ topics：监听的topic，可监听多个；\n\n④ topicPartitions：可配置更加详细的监听信息，可指定topic、parition、offset监听。\n\n上面onMessage2监听的含义：监听topic1的0号分区，同时监听topic2的0号分区和topic2的1号分区里面offset从8开始的消息，每次重启都会从8开始，注意：会重复消费\n\n注意：topics和topicPartitions不能同时使用；\n\n\n# 2.批量消费\n\n> 设置了批量消费，订阅了同一个主题都需要使用List<ConsumerRecord>来监听\n\n1.设置application.prpertise开启批量消费即可\n\n# 设置批量消费\nspring.kafka.listener.type=batch\n# 批量消费每次最多消费多少条消息\nspring.kafka.consumer.max-poll-records=50\n\n\n1\n2\n3\n4\n\n\n2.接收消息时用List来接收，监听代码如下\n\n@KafkaListener(id = "consumer2",groupId = "felix-group", topics = "topic1")\npublic void onMessage3(List<ConsumerRecord<?, ?>> records) {\n    System.out.println(">>>批量消费一次，records.size()="+records.size());\n    for (ConsumerRecord<?, ?> record : records) {\n        System.out.println(record.value());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.ConsumerAwareListenerErrorHandler 异常处理器\n\n通过异常处理器，我们可以处理consumer在消费时发生的异常。\n\n新建一个 ConsumerAwareListenerErrorHandler 类型的异常处理方法，用@Bean注入，BeanName默认就是方法名，然后我们将这个异常处理器的BeanName放到@KafkaListener注解的errorHandler属性里面，当监听抛出异常的时候，则会自动调用异常处理器\n\n// 新建一个异常处理器，用@Bean注入\n@Bean\npublic ConsumerAwareListenerErrorHandler consumerAwareErrorHandler() {\n    return (message, exception, consumer) -> {\n        System.out.println("消费异常："+message.getPayload());\n        return null;\n    };\n}\n​\n// 将这个异常处理器的BeanName放到@KafkaListener注解的errorHandler属性里面\n@KafkaListener(topics = {"topic1"},errorHandler = "consumerAwareErrorHandler")\npublic void onMessage4(ConsumerRecord<?, ?> record) throws Exception {\n    throw new Exception("简单消费-模拟异常");\n}\n​\n// 批量消费也一样，异常处理器的message.getPayload()也可以拿到各条消息的信息\n@KafkaListener(topics = "topic1",errorHandler="consumerAwareErrorHandler")\npublic void onMessage5(List<ConsumerRecord<?, ?>> records) throws Exception {\n    System.out.println("批量消费一次...");\n    throw new Exception("批量消费-模拟异常");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4.消息过滤器\n\n消息过滤器可以在消息抵达consumer之前被拦截，在实际应用中，我们可以根据自己的业务逻辑，筛选出需要的信息再交由KafkaListener处理，不需要的消息则过滤掉。\n\n配置消息过滤只需要为 监听器工厂 配置一个RecordFilterStrategy（消息过滤策略），返回true的时候消息将会被抛弃，返回false时，消息能正常抵达监听容器。\n\n# 1.创建消费过滤器\n\n> 只允许消息是偶数的通过\n\npackage com.wcy.config;\n\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;\nimport org.springframework.kafka.core.ConsumerFactory;\n\n/**\n * 项目启动创建主题 可以指定分区大小、副本大小\n */\n@Configuration\npublic class KafkaInitialConfiguration {\n    @Autowired\n    ConsumerFactory consumerFactory;\n\n    // 消息过滤器\n    @Bean\n    public ConcurrentKafkaListenerContainerFactory filterContainerFactory() {\n        ConcurrentKafkaListenerContainerFactory factory = new ConcurrentKafkaListenerContainerFactory();\n        factory.setConsumerFactory(consumerFactory);\n        // 被过滤的消息将被丢弃\n        factory.setAckDiscarded(true);\n        // 消息过滤策略\n        factory.setRecordFilterStrategy(consumerRecord -> {\n            if (Integer.parseInt(consumerRecord.value().toString()) % 2 == 0) {\n                return false;\n            }\n            //返回true消息则被过滤\n            return true;\n        });\n        return factory;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n# 2.设置消费者过滤监听器\n\n    // 消息过滤监听\n    @KafkaListener(topics = {"topic1"},containerFactory = "filterContainerFactory")\n    public void onMessage6(ConsumerRecord<?, ?> record) {\n        System.out.println(record.value());\n    }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5.消息转发\n\n在实际开发中，我们可能有这样的需求，应用A从TopicA获取到消息，经过处理后转发到TopicB，再由应用B监听处理消息，即一个应用处理完成后将该消息转发至其他应用，完成消息的转发。\n\n在SpringBoot集成Kafka实现消息的转发也很简单，只需要通过一个@SendTo注解，被注解方法的return值即转发的消息内容，如下\n\n/**\n * @Title 消息转发\n * @Description 从topic1接收到的消息经过处理后转发到topic2\n * @Author long.yuan\n * @Date 2020/3/23 22:15\n * @Param [record]\n * @return void\n **/\n@KafkaListener(topics = {"topic1"})\n@SendTo("topic2")\npublic String onMessage7(ConsumerRecord<?, ?> record) {\n    return record.value()+"-forward message";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 6.定时启动、停止监听器\n\n默认情况下，当消费者项目启动的时候，监听器就开始工作，监听消费发送到指定topic的消息，那如果我们不想让监听器立即工作，想让它在我们指定的时间点开始工作，或者在我们指定的时间点停止工作，该怎么处理呢——使用KafkaListenerEndpointRegistry，下面我们就来实现：\n\n① 禁止监听器自启动；\n\n② 创建两个定时任务，一个用来在指定时间点启动定时器，另一个在指定时间点停止定时器；\n\n新建一个定时任务类，用注解@EnableScheduling声明，KafkaListenerEndpointRegistry 在SpringIO中已经被注册为Bean，直接注入，设置禁止KafkaListener自启动\n\npackage com.wcy.consumer;\n\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.kafka.annotation.KafkaListener;\nimport org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;\nimport org.springframework.kafka.config.KafkaListenerEndpointRegistry;\nimport org.springframework.kafka.core.ConsumerFactory;\nimport org.springframework.scheduling.annotation.EnableScheduling;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\n@EnableScheduling\n@Component\npublic class CronTimer {\n\n    /**\n     * @KafkaListener注解所标注的方法并不会在IOC容器中被注册为Bean，\n     * 而是会被注册在KafkaListenerEndpointRegistry中，\n     * 而KafkaListenerEndpointRegistry在SpringIOC中已经被注册为Bean\n     **/\n    @Autowired\n    private KafkaListenerEndpointRegistry registry;\n\n    @Autowired\n    private ConsumerFactory consumerFactory;\n\n    // 监听器容器工厂(设置禁止KafkaListener自启动)\n    @Bean\n    public ConcurrentKafkaListenerContainerFactory delayContainerFactory() {\n        ConcurrentKafkaListenerContainerFactory container = new ConcurrentKafkaListenerContainerFactory();\n        container.setConsumerFactory(consumerFactory);\n        //禁止KafkaListener自启动\n        container.setAutoStartup(false);\n        return container;\n    }\n\n    // 监听器\n    @KafkaListener(id="timingConsumer",topics = "topic1",containerFactory = "delayContainerFactory")\n    public void onMessage1(ConsumerRecord<?, ?> record){\n        System.out.println("消费成功："+record.topic()+"-"+record.partition()+"-"+record.value());\n    }\n\n    // 定时启动监听器\n    @Scheduled(cron = "0 44 15 * * ? ")\n    public void startListener() {\n        System.out.println("启动监听器...");\n        // "timingConsumer"是@KafkaListener注解后面设置的监听器ID,标识这个监听器\n        if (!registry.getListenerContainer("timingConsumer").isRunning()) {\n            registry.getListenerContainer("timingConsumer").start();\n        }\n        //registry.getListenerContainer("timingConsumer").resume();\n    }\n\n    // 定时停止监听器\n    @Scheduled(cron = "0 45 15 * * ? ")\n    public void shutDownListener() {\n        System.out.println("关闭监听器...");\n        registry.getListenerContainer("timingConsumer").pause();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n',normalizedContent:'# springboot集成kafka全面实战\n\n参考：地址\n\n本文是springboot+kafka的实战讲解，如果对kafka的架构原理还不了解的读者，建议先看一下《大白话kafka架构原理》、《秒懂kafka ha（高可用）》两篇文章。\n\n\n# 一.前戏\n\n1、在项目中连接kafka，因为是外网，首先要开放kafka配置文件中的如下配置（其中ip为公网ip），\n\nadvertised.listeners=plaintext://112.126.74.249:9092\n也可以配置\nlisteners=plaintext://112.126.74.249:9092\n\n\n1\n2\n3\n\n\n2.在开始前我们先创建两个topic：topic1、topic2，其分区和副本数都设置为2，用来测试，\n\n[root@iz2zegzlkedbo3e64vkbefz ~]#  cd /usr/local/kafka-cluster/kafka1/bin/\n[root@iz2zegzlkedbo3e64vkbefz bin]# ./kafka-topics.sh --create --zookeeper 172.17.80.219:2181 --replication-factor 2 --partitions 2 --topic topic1\ncreated topic topic1.\n[root@iz2zegzlkedbo3e64vkbefz bin]# ./kafka-topics.sh --create --zookeeper 172.17.80.219:2181 --replication-factor 2 --partitions 2 --topic topic2\ncreated topic topic2.\n\n\n1\n2\n3\n4\n5\n\n\n当然我们也可以不手动创建topic，在执行代码kafkatemplate.send("topic1", normalmessage)发送消息时，kafka会帮我们自动完成topic的创建工作，但这种情况下创建的topic默认**只有一个分区，分区也没有副本。**所以，我们可以在项目中新建一个配置类专门用来初始化topic，如下:\n\n@configuration\npublic class kafkainitialconfiguration {\n    // 创建一个名为testtopic的topic并设置分区数为8，分区副本数为2\n    @bean\n    public newtopic initialtopic() {\n        return new newtopic("testtopic",8, (short) 2 );\n    }\n    \n     // 如果要修改分区数，只需修改配置值重启项目即可\n    // 修改分区数并不会导致数据的丢失，但是分区数只能增大不能减小 更新有问题，请去命令行操作\n    @bean\n    public newtopic updatetopic() {\n        return new newtopic("testtopic",10, (short) 2 );\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n3.新建springboot项目\n\n 1. 引入pom依赖\n\n<dependency>\n    <groupid>org.springframework.kafka</groupid>\n    <artifactid>spring-kafka</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n\n\n 2. application.propertise配置（本文用到的配置项这里全列了出来）\n    \n    application.properties：文件\n    \n    ###########【kafka集群】###########\n    spring.kafka.bootstrap-servers=112.126.74.249:9092,112.126.74.249:9093\n    ###########【初始化生产者配置】###########\n    # 重试次数\n    spring.kafka.producer.retries=0\n    # 应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)\n    spring.kafka.producer.acks=1\n    # 批量大小\n    spring.kafka.producer.batch-size=16384\n    # 提交延时\n    spring.kafka.producer.properties.linger.ms=0\n    # 当生产端积累的消息达到batch-size或接收到消息linger.ms后,生产者就会将消息提交给kafka\n    # linger.ms为0表示每接收到一条消息就提交给kafka,这时候batch-size其实就没用了\n    \n    # 生产端缓冲区大小\n    spring.kafka.producer.buffer-memory = 33554432\n    # kafka提供的序列化和反序列化类\n    spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.stringserializer\n    spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.stringserializer\n    # 自定义分区器\n    # spring.kafka.producer.properties.partitioner.class=com.felix.kafka.producer.customizepartitioner\n    \n    ###########【初始化消费者配置】###########\n    # 默认的消费组id\n    spring.kafka.consumer.properties.group.id=defaultconsumergroup\n    # 是否自动提交offset\n    spring.kafka.consumer.enable-auto-commit=true\n    # 提交offset延时(接收到消息后多久提交offset)\n    spring.kafka.consumer.auto.commit.interval.ms=1000\n    # 当kafka中没有初始offset或offset超出范围时将自动重置offset\n    # earliest:重置为分区中最小的offset;\n    # latest:重置为分区中最新的offset(消费分区中新产生的数据);\n    # none:只要有一个分区不存在已提交的offset,就抛出异常;\n    spring.kafka.consumer.auto-offset-reset=latest\n    # 消费会话超时时间(超过这个时间consumer没有发送心跳,就会触发rebalance操作)\n    spring.kafka.consumer.properties.session.timeout.ms=120000\n    # 消费请求超时时间\n    spring.kafka.consumer.properties.request.timeout.ms=180000\n    # kafka提供的序列化和反序列化类\n    spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.stringdeserializer\n    spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.stringdeserializer\n    # 消费端监听的topic不存在时，项目启动会报错(关掉)\n    spring.kafka.listener.missing-topics-fatal=false\n    # 设置批量消费\n    # spring.kafka.listener.type=batch\n    # 批量消费每次最多消费多少条消息\n    # spring.kafka.consumer.max-poll-records=50\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    \n    \n    yml文件\n    \n    spring:\n      application:\n        name: springboot_kafka\n      #【kafka集群】\n      kafka:\n        bootstrap-servers: 192.168.188.128:9092,192.168.188.128:9093\n        # [kafka生产者配置]\n        producer:\n          retries: 0  #重试次数\n          acks: 1 #应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)\n          batch-size: 16384 #生产者批量发送大小\n          #提交延时 当生产端积累的消息达到batch-size或接收到消息linger.ms后,生产者就会将消息提交给kafka\n          ## linger.ms为0表示每接收到一条消息就提交给kafka,这时候batch-size其实就没用了\n          properties:\n            linger:\n              ms: 0\n            #自定义分区器\n    #        partitioner:\n    #          class: com.felix.kafka.producer.customizepartitioner\n          # 生产端缓冲区大小\n          buffer-memory: 33554432\n          key-serializer: org.apache.kafka.common.serialization.stringserializer\n          value-serializer: org.apache.kafka.common.serialization.stringserializer\n    \n        # [kafka消费者配置]\n        consumer:\n          properties:\n            #默认的消费组id\n            group:\n              id: defaultconsumergroup\n            session:\n              timeout:\n                ms: 120000 # 消费会话超时时间(超过这个时间consumer没有发送心跳,就会触发rebalance操作)\n            request:\n              timeout:\n                ms: 180000 # 消费请求超时时间\n          enable-auto-commit: true #是否自动提交offset\n          auto-commit-interval: 1000 #提交offset延时(接收到消息后多久提交offset)\n          # 当kafka中没有初始offset或offset超出范围时将自动重置offset\n          # earliest:重置为分区中最小的offset;\n          # latest:重置为分区中最新的offset(消费分区中新产生的数据);\n          # none:只要有一个分区不存在已提交的offset,就抛出异常;\n          auto-offset-reset: latest\n          #序列化\n          key-deserializer: org.apache.kafka.common.serialization.stringdeserializer\n          value-deserializer: org.apache.kafka.common.serialization.stringdeserializer\n    #      max-poll-records: 50 # 批量消费每次最多消费多少条消息\n        listener:\n          missing-topics-fatal: false  # 消费端监听的topic不存在时，项目启动会报错(关掉)\n    #      type: batch  # 设置批量消费  配合max-poll-records使用\n    \n    server:\n      port: 80\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    \n\n\n# 二.简单生产者消费者\n\n\n# 1.简单生产者\n\npackage com.wcy.controller;\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.kafka.core.kafkatemplate;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.pathvariable;\nimport org.springframework.web.bind.annotation.restcontroller;\n\n@restcontroller\npublic class kafkacontroller {\n    @autowired\n    public kafkatemplate<string,object> kafkatemplate;\n\n    @getmapping("kafka/normal/{message}")\n    public void sendmessage1(@pathvariable("message") string normalmessage){\n        kafkatemplate.send("topic1",normalmessage);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 2.简单消费者\n\n监听器用@kafkalistener注解，topics表示监听的topic，支持同时监听多个，用英文逗号分隔\n\npackage com.wcy.consumer;\n\nimport org.apache.kafka.clients.consumer.consumerrecord;\nimport org.springframework.kafka.annotation.kafkalistener;\nimport org.springframework.stereotype.component;\n\n@component\npublic class kafkaconsumer {\n    //订阅主题topic1\n    @kafkalistener(topics = {"topic1"})\n    public void onmessage1(consumerrecord<?, ?> record){\n        // 消费的哪个topic、partition的消息,打印出消息内容\n        system.out.println("简单消费："+record.topic()+"-"+record.partition()+"-"+record.value());\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 三.生产者\n\n\n# 1.带回调的生产者\n\n    /**\n     * 带回调的发送消息\n     * @param message\n     */\n    @getmapping("kafka/callbackone/{message}")\n    public void sendmessage2(@pathvariable("message") string message){\n        for (int i = 0; i < 100; i++) {\n            kafkatemplate.send("topic1",message).addcallback(new listenablefuturecallback<sendresult<string, object>>() {\n                //发送失败\n                @override\n                public void onfailure(throwable throwable) {\n                    system.out.println(throwable.getmessage());\n                }\n                //发送成功\n                @override\n                public void onsuccess(sendresult<string, object> stringobjectsendresult) {\n                    recordmetadata metadata = stringobjectsendresult.getrecordmetadata();\n                    long offset = metadata.offset();//发送成功后的偏移量\n                    producerrecord<string, object> record = stringobjectsendresult.getproducerrecord();\n                    string topic = record.topic();//主题\n                    integer partition = record.partition();//分区\n                    system.out.println("发送消息成功:" + topic + "-" + partition + "-" + offset);\n                }\n            });\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 2.自定义分区规则\n\n我们知道，kafka中每个topic被划分为多个分区，那么生产者将消息发送到topic时，具体追加到哪个分区呢？这就是所谓的分区策略，kafka 为我们提供了默认的分区策略，同时它也支持自定义分区策略。其路由机制为：\n\n① 若发送消息时指定了分区（即自定义分区策略），则直接将消息append到指定分区；\n\n② 若发送消息时未指定 patition，但指定了 key（kafka允许为每条消息设置一个key），则对key值进行hash计算，根据计算结果路由到指定分区，这种情况下可以保证同一个 key 的所有消息都进入到相同的分区；\n\n③ patition 和 key 都未指定，则使用kafka默认的分区策略，轮询选出一个 patition；\n\n※ 我们来自定义一个分区策略，将消息发送到我们指定的partition，首先新建一个分区器类实现partitioner接口，重写方法，其中partition方法的返回值就表示将消息发送到几号分区：\n\npackage com.wcy.partitioner;\n\nimport org.apache.kafka.clients.producer.partitioner;\nimport org.apache.kafka.common.cluster;\n\nimport java.util.map;\n\n/**\n * 自定义分区\n */\npublic class customizepartitioner implements partitioner {\n    @override\n    public int partition(string s, object o, byte[] bytes, object o1, byte[] bytes1, cluster cluster) {\n        // 自定义分区规则(这里假设全部发到0号分区)\n        // ......\n        return 0;\n    }\n\n    @override\n    public void close() {\n\n    }\n\n    @override\n    public void configure(map<string, ?> map) {\n\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n生产者配置自定义分区的类路径\n\n#自定义分区器\nspring:\n\tkafka:        \n        producer:\n            properties:\n                partitioner:\n                  class: com.wcy.partitioner.customizepartitioner\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.生产者kafka事务提交\n\n注意：一旦使用事务提交后，那么所有的消息都需要事务提交\n\n> 注意：一旦开启事务，那么后续的消息都必须放到事务中，否则会报错；\n> \n> java.lang.illegalstateexception: no transaction is in process; possible solutions: run the template operation within the scope of a template.executeintransaction() operation, start a transaction with @transactional before invoking the template method, run in a transaction started by a listener container when consuming a record\n\n# 1.添加支持事务的配置\n\n 1. retries：必须大于0\n 2. acks：必须为-1或all\n 3. transaction-id-prefix：开启事务，开启事务会默认开启幂等性\n\nspring:\n  application:\n    name: springboot_kafka\n  #【kafka集群】\n  kafka:\n    producer:\n      retries: 2  #重试次数\n      acks: -1 #应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)\n      #开启事务  retries>0  acks=-1 必须\n      transaction-id-prefix: tx-\n    consumer:\n      isolation-level: read_committed # 读取已提交的消息\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 2.使用kafkatemplate内置的事务操作\n\n    /**\n     * 带事务发送消息\n     */\n    @getmapping("/kafka/transaction")\n    public void sendmessage3(){\n        // 声明事务：后面报错消息不会发出去\n        kafkatemplate.executeintransaction(operations -> {\n            for (int i = 0; i < 10; i++) {\n                operations.send("topic1","事务提交数据测试");\n                if(i ==4){\n                    int b=10/0;// 模拟产生异常代码\n                }\n            }\n            return true;// 返回true，表示发送成功\n        });\n\n        // 不声明事务：后面报错但前面消息已经发送成功了\n//        for (int i = 0; i < 10; i++) {\n//            kafkatemplate.send("topic1","test executeintransaction");\n//            if(i==4){\n//                int b=10/0;\n//            }\n//        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 四.消费者\n\n\n# 1.指定topic、partition、offset消费\n\n前面我们在监听消费topic1的时候，监听的是topic1上所有的消息，如果我们想指定topic、指定partition、指定offset来消费呢？也很简单，@kafkalistener注解已全部为我们提供\n\n/**\n * @title 指定topic、partition、offset消费\n * @description 同时监听topic1和topic2，监听topic1的0号分区、topic2的 "0号和1号" 分区，指向1号分区的offset初始值为8\n * @author long.yuan\n * @date 2020/3/22 13:38\n * @param [record]\n * @return void\n **/\n@kafkalistener(id = "consumer1",groupid = "felix-group",topicpartitions = {\n        @topicpartition(topic = "topic1", partitions = { "0" }),\n        @topicpartition(topic = "topic2", partitions = "0", partitionoffsets = @partitionoffset(partition = "1", initialoffset = "8"))\n})\npublic void onmessage2(consumerrecord<?, ?> record) {\n    system.out.println("topic:"+record.topic()+"|partition:"+record.partition()+"|offset:"+record.offset()+"|value:"+record.value());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n属性解释：\n\n① id：消费者id；\n\n② groupid：消费组id；\n\n③ topics：监听的topic，可监听多个；\n\n④ topicpartitions：可配置更加详细的监听信息，可指定topic、parition、offset监听。\n\n上面onmessage2监听的含义：监听topic1的0号分区，同时监听topic2的0号分区和topic2的1号分区里面offset从8开始的消息，每次重启都会从8开始，注意：会重复消费\n\n注意：topics和topicpartitions不能同时使用；\n\n\n# 2.批量消费\n\n> 设置了批量消费，订阅了同一个主题都需要使用list<consumerrecord>来监听\n\n1.设置application.prpertise开启批量消费即可\n\n# 设置批量消费\nspring.kafka.listener.type=batch\n# 批量消费每次最多消费多少条消息\nspring.kafka.consumer.max-poll-records=50\n\n\n1\n2\n3\n4\n\n\n2.接收消息时用list来接收，监听代码如下\n\n@kafkalistener(id = "consumer2",groupid = "felix-group", topics = "topic1")\npublic void onmessage3(list<consumerrecord<?, ?>> records) {\n    system.out.println(">>>批量消费一次，records.size()="+records.size());\n    for (consumerrecord<?, ?> record : records) {\n        system.out.println(record.value());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.consumerawarelistenererrorhandler 异常处理器\n\n通过异常处理器，我们可以处理consumer在消费时发生的异常。\n\n新建一个 consumerawarelistenererrorhandler 类型的异常处理方法，用@bean注入，beanname默认就是方法名，然后我们将这个异常处理器的beanname放到@kafkalistener注解的errorhandler属性里面，当监听抛出异常的时候，则会自动调用异常处理器\n\n// 新建一个异常处理器，用@bean注入\n@bean\npublic consumerawarelistenererrorhandler consumerawareerrorhandler() {\n    return (message, exception, consumer) -> {\n        system.out.println("消费异常："+message.getpayload());\n        return null;\n    };\n}\n​\n// 将这个异常处理器的beanname放到@kafkalistener注解的errorhandler属性里面\n@kafkalistener(topics = {"topic1"},errorhandler = "consumerawareerrorhandler")\npublic void onmessage4(consumerrecord<?, ?> record) throws exception {\n    throw new exception("简单消费-模拟异常");\n}\n​\n// 批量消费也一样，异常处理器的message.getpayload()也可以拿到各条消息的信息\n@kafkalistener(topics = "topic1",errorhandler="consumerawareerrorhandler")\npublic void onmessage5(list<consumerrecord<?, ?>> records) throws exception {\n    system.out.println("批量消费一次...");\n    throw new exception("批量消费-模拟异常");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4.消息过滤器\n\n消息过滤器可以在消息抵达consumer之前被拦截，在实际应用中，我们可以根据自己的业务逻辑，筛选出需要的信息再交由kafkalistener处理，不需要的消息则过滤掉。\n\n配置消息过滤只需要为 监听器工厂 配置一个recordfilterstrategy（消息过滤策略），返回true的时候消息将会被抛弃，返回false时，消息能正常抵达监听容器。\n\n# 1.创建消费过滤器\n\n> 只允许消息是偶数的通过\n\npackage com.wcy.config;\n\nimport org.apache.kafka.clients.admin.newtopic;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.kafka.config.concurrentkafkalistenercontainerfactory;\nimport org.springframework.kafka.core.consumerfactory;\n\n/**\n * 项目启动创建主题 可以指定分区大小、副本大小\n */\n@configuration\npublic class kafkainitialconfiguration {\n    @autowired\n    consumerfactory consumerfactory;\n\n    // 消息过滤器\n    @bean\n    public concurrentkafkalistenercontainerfactory filtercontainerfactory() {\n        concurrentkafkalistenercontainerfactory factory = new concurrentkafkalistenercontainerfactory();\n        factory.setconsumerfactory(consumerfactory);\n        // 被过滤的消息将被丢弃\n        factory.setackdiscarded(true);\n        // 消息过滤策略\n        factory.setrecordfilterstrategy(consumerrecord -> {\n            if (integer.parseint(consumerrecord.value().tostring()) % 2 == 0) {\n                return false;\n            }\n            //返回true消息则被过滤\n            return true;\n        });\n        return factory;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n# 2.设置消费者过滤监听器\n\n    // 消息过滤监听\n    @kafkalistener(topics = {"topic1"},containerfactory = "filtercontainerfactory")\n    public void onmessage6(consumerrecord<?, ?> record) {\n        system.out.println(record.value());\n    }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5.消息转发\n\n在实际开发中，我们可能有这样的需求，应用a从topica获取到消息，经过处理后转发到topicb，再由应用b监听处理消息，即一个应用处理完成后将该消息转发至其他应用，完成消息的转发。\n\n在springboot集成kafka实现消息的转发也很简单，只需要通过一个@sendto注解，被注解方法的return值即转发的消息内容，如下\n\n/**\n * @title 消息转发\n * @description 从topic1接收到的消息经过处理后转发到topic2\n * @author long.yuan\n * @date 2020/3/23 22:15\n * @param [record]\n * @return void\n **/\n@kafkalistener(topics = {"topic1"})\n@sendto("topic2")\npublic string onmessage7(consumerrecord<?, ?> record) {\n    return record.value()+"-forward message";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 6.定时启动、停止监听器\n\n默认情况下，当消费者项目启动的时候，监听器就开始工作，监听消费发送到指定topic的消息，那如果我们不想让监听器立即工作，想让它在我们指定的时间点开始工作，或者在我们指定的时间点停止工作，该怎么处理呢——使用kafkalistenerendpointregistry，下面我们就来实现：\n\n① 禁止监听器自启动；\n\n② 创建两个定时任务，一个用来在指定时间点启动定时器，另一个在指定时间点停止定时器；\n\n新建一个定时任务类，用注解@enablescheduling声明，kafkalistenerendpointregistry 在springio中已经被注册为bean，直接注入，设置禁止kafkalistener自启动\n\npackage com.wcy.consumer;\n\nimport org.apache.kafka.clients.consumer.consumerrecord;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.kafka.annotation.kafkalistener;\nimport org.springframework.kafka.config.concurrentkafkalistenercontainerfactory;\nimport org.springframework.kafka.config.kafkalistenerendpointregistry;\nimport org.springframework.kafka.core.consumerfactory;\nimport org.springframework.scheduling.annotation.enablescheduling;\nimport org.springframework.scheduling.annotation.scheduled;\nimport org.springframework.stereotype.component;\n\n@enablescheduling\n@component\npublic class crontimer {\n\n    /**\n     * @kafkalistener注解所标注的方法并不会在ioc容器中被注册为bean，\n     * 而是会被注册在kafkalistenerendpointregistry中，\n     * 而kafkalistenerendpointregistry在springioc中已经被注册为bean\n     **/\n    @autowired\n    private kafkalistenerendpointregistry registry;\n\n    @autowired\n    private consumerfactory consumerfactory;\n\n    // 监听器容器工厂(设置禁止kafkalistener自启动)\n    @bean\n    public concurrentkafkalistenercontainerfactory delaycontainerfactory() {\n        concurrentkafkalistenercontainerfactory container = new concurrentkafkalistenercontainerfactory();\n        container.setconsumerfactory(consumerfactory);\n        //禁止kafkalistener自启动\n        container.setautostartup(false);\n        return container;\n    }\n\n    // 监听器\n    @kafkalistener(id="timingconsumer",topics = "topic1",containerfactory = "delaycontainerfactory")\n    public void onmessage1(consumerrecord<?, ?> record){\n        system.out.println("消费成功："+record.topic()+"-"+record.partition()+"-"+record.value());\n    }\n\n    // 定时启动监听器\n    @scheduled(cron = "0 44 15 * * ? ")\n    public void startlistener() {\n        system.out.println("启动监听器...");\n        // "timingconsumer"是@kafkalistener注解后面设置的监听器id,标识这个监听器\n        if (!registry.getlistenercontainer("timingconsumer").isrunning()) {\n            registry.getlistenercontainer("timingconsumer").start();\n        }\n        //registry.getlistenercontainer("timingconsumer").resume();\n    }\n\n    // 定时停止监听器\n    @scheduled(cron = "0 45 15 * * ? ")\n    public void shutdownlistener() {\n        system.out.println("关闭监听器...");\n        registry.getlistenercontainer("timingconsumer").pause();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"模式一：同域同后端",frontmatter:{title:"模式一：同域同后端",date:"2021-12-09T17:26:41.000Z",permalink:"/pages/bd0628/",categories:["后端","Sa-Token","单点登录"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/61.Sa-Token/00.%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/01.%E6%A8%A1%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%90%8C%E5%9F%9F%E5%90%8C%E5%90%8E%E7%AB%AF.html",relativePath:"01.后端/61.Sa-Token/00.单点登录/01.模式一：同域同后端.md",key:"v-25d3e376",path:"/pages/bd0628/",headers:[{level:2,title:"1.解决思路？",slug:"_1-解决思路",normalizedTitle:"1.解决思路？",charIndex:91},{level:2,title:"2.准备工作",slug:"_2-准备工作",normalizedTitle:"2.准备工作",charIndex:474},{level:2,title:"3.指定Cookie的作用域",slug:"_3-指定cookie的作用域",normalizedTitle:"3.指定cookie的作用域",charIndex:738},{level:2,title:"4.搭建Client端项目",slug:"_4-搭建client端项目",normalizedTitle:"4.搭建client端项目",charIndex:1043},{level:3,title:"1.创建项目，导入依赖",slug:"_1-创建项目-导入依赖",normalizedTitle:"1.创建项目，导入依赖",charIndex:1135},{level:3,title:"2.添加控制器",slug:"_2-添加控制器",normalizedTitle:"2.添加控制器",charIndex:1973},{level:3,title:"3.配置文件",slug:"_3-配置文件",normalizedTitle:"3.配置文件",charIndex:2997},{level:3,title:"4.启动类",slug:"_4-启动类",normalizedTitle:"4.启动类",charIndex:3616},{level:3,title:"5.访问测试",slug:"_5-访问测试",normalizedTitle:"5.访问测试",charIndex:3925}],headersStr:"1.解决思路？ 2.准备工作 3.指定Cookie的作用域 4.搭建Client端项目 1.创建项目，导入依赖 2.添加控制器 3.配置文件 4.启动类 5.访问测试",content:'# SSO模式一 共享Cookie同步会话\n\n> 如果我们的多个系统可以做到：前端同域、后端同Redis，那么便可以使用 [共享Cookie同步会话] 的方式做到单点登录。\n\n\n# 1.解决思路？\n\n首先我们分析一下多个系统之间，为什么无法同步登录状态？\n\n 1. 前端的 Token 无法在多个系统下共享。\n 2. 后端的 Session 无法在多个系统间共享。\n\n所以单点登录第一招，就是对症下药：\n\n 1. 使用 共享Cookie 来解决 Token 共享问题。\n 2. 使用 Redis 来解决 Session 共享问题。\n\n所谓共享Cookie，就是主域名Cookie在二级域名下的共享，举个例子：写在父域名stp.com下的Cookie，在s1.stp.com、s2.stp.com等子域名都是可以共享访问的。\n\n而共享Redis，并不需要我们把所有项目的数据都放在同一个Redis中，Sa-Token提供了 [权限缓存与业务缓存分离] 的解决方案，详情戳：Alone独立Redis插件。\n\nOK，所有理论就绪，下面开始实战：\n\n\n# 2.准备工作\n\n首先修改hosts文件(C:\\windows\\system32\\drivers\\etc\\hosts)，添加以下IP映射，方便我们进行测试：\n\n127.0.0.1 sso.wcy.com\n127.0.0.1 s1.wcy.com\n127.0.0.1 s2.wcy.com\n127.0.0.1 s3.wcy.com\n\n\n1\n2\n3\n4\n\n\n其中：sso.wcy.com为统一认证中心地址，当用户在其它 Client 端发起登录请求时，均将其重定向至认证中心，待到登录成功之后再原路返回到 Client 端。\n\n\n# 3.指定Cookie的作用域\n\n在sso.wcy.com访问服务器，其Cookie也只能写入到sso.wcy.com下，为了将Cookie写入到其父级域名wcy.com下，我们需要更改 SSO-Server 端的 yml 配置：\n\nsa-token:\n    cookie:\n        # 配置Cookie作用域 \n        domain: wcy.com\n\n\n1\n2\n3\n4\n\n\n这个配置原本是被注释掉的，现在将其打开。另外我们格外需要注意： 在SSO模式一测试完毕之后，一定要将这个配置再次注释掉，因为模式一与模式二三使用不同的授权流程，这行配置会影响到我们模式二和模式三的正常运行。\n\n\n# 4.搭建Client端项目\n\n> 搭建示例在官方仓库的 /sa-token-demo/sa-token-demo-sso1-client/，如遇到难点可结合源码进行测试学习。\n\n\n# 1.创建项目，导入依赖\n\n新建项目 sa-token-demo-sso1-client，并添加以下依赖：\n\n\x3c!-- Sa-Token 权限认证, 在线文档：http://sa-token.dev33.cn/ --\x3e\n<dependency>\n    <groupId>cn.dev33</groupId>\n    <artifactId>sa-token-spring-boot-starter</artifactId>\n    <version>${sa-token-version}</version>\n</dependency>\n\n\x3c!-- Sa-Token 整合redis (使用jackson序列化方式) --\x3e\n<dependency>\n    <groupId>cn.dev33</groupId>\n    <artifactId>sa-token-dao-redis-jackson</artifactId>\n    <version>${sa-token-version}</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n</dependency>\n\n\x3c!-- Sa-Token插件：权限缓存与业务缓存分离 --\x3e\n<dependency>\n    <groupId>cn.dev33</groupId>\n    <artifactId>sa-token-alone-redis</artifactId>\n    <version>${sa-token-version}</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.添加控制器\n\n/**\n * Sa-Token-SSO Client端 Controller \n * @author kong\n */\n@RestController\npublic class SsoClientController {\n\n    // SSO-Client端：首页 \n    @RequestMapping("/")\n    public String index() {\n        String authUrl = SaManager.getConfig().getSso().getAuthUrl();\n        String solUrl = SaManager.getConfig().getSso().getSloUrl();\n        String str = "<h2>Sa-Token SSO-Client 应用端</h2>" + \n                    "<p>当前会话是否登录：" + StpUtil.isLogin() + "</p>" + \n                    "<p><a href=\\"javascript:location.href=\'" + authUrl + "?mode=simple&redirect=\' + encodeURIComponent(location.href);\\">登录</a> " + \n                    "<a href=\\"javascript:location.href=\'" + solUrl + "?back=\' + encodeURIComponent(location.href);\\">注销</a> </p>";\n        return str;\n    }\n\n    // 全局异常拦截 \n    @ExceptionHandler\n    public SaResult handlerException(Exception e) {\n        e.printStackTrace(); \n        return SaResult.error(e.getMessage());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 3.配置文件\n\n# 端口\nserver:\n    port: 9001\n\n# sa-token配置 \nsa-token: \n    # SSO-相关配置\n    sso: \n        # SSO-Server端-单点登录授权地址 \n        auth-url: http://sso.wcy.com:9000/sso/auth\n        # SSO-Server端-单点注销地址\n        slo-url: http://sso.wcy.com:9000/sso/logout\n\n    # 配置Sa-Token单独使用的Redis连接 （此处需要和SSO-Server端连接同一个Redis）\n    alone-redis: \n        # Redis数据库索引\n        database: 1\n        # Redis服务器地址\n        host: 127.0.0.1\n        # Redis服务器连接端口\n        port: 6379\n        # Redis服务器连接密码（默认为空）\n        password: \n        # 连接超时时间\n        timeout: 10s\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 4.启动类\n\n/**\n * SSO模式一，Client端 Demo \n */\n@SpringBootApplication\npublic class SaSsoClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SaSsoClientApplication.class, args);\n        System.out.println("\\nSa-Token SSO模式一 Client端启动成功");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 5.访问测试\n\n启动项目，依次访问三个应用端：\n\n * http://s1.wcy.com:9001/\n * http://s2.wcy.com:9001/\n * http://s3.wcy.com:9001/\n\n均返回：\n\n\n\n然后点击登录，被重定向至SSO认证中心：\n\n最后刷新发现都已经登陆成功\n\n如上，我们使用简单的步骤实现了同域下的单点登录，聪明如你😏，马上想到了这种模式有着一个不小的限制：\n\n> 所有子系统的域名，必须同属一个父级域名\n\n如果我们的子系统在完全不同的域名下，我们又该怎么完成单点登录功能呢？\n\n且往下看，SSO模式二：URL重定向传播会话',normalizedContent:'# sso模式一 共享cookie同步会话\n\n> 如果我们的多个系统可以做到：前端同域、后端同redis，那么便可以使用 [共享cookie同步会话] 的方式做到单点登录。\n\n\n# 1.解决思路？\n\n首先我们分析一下多个系统之间，为什么无法同步登录状态？\n\n 1. 前端的 token 无法在多个系统下共享。\n 2. 后端的 session 无法在多个系统间共享。\n\n所以单点登录第一招，就是对症下药：\n\n 1. 使用 共享cookie 来解决 token 共享问题。\n 2. 使用 redis 来解决 session 共享问题。\n\n所谓共享cookie，就是主域名cookie在二级域名下的共享，举个例子：写在父域名stp.com下的cookie，在s1.stp.com、s2.stp.com等子域名都是可以共享访问的。\n\n而共享redis，并不需要我们把所有项目的数据都放在同一个redis中，sa-token提供了 [权限缓存与业务缓存分离] 的解决方案，详情戳：alone独立redis插件。\n\nok，所有理论就绪，下面开始实战：\n\n\n# 2.准备工作\n\n首先修改hosts文件(c:\\windows\\system32\\drivers\\etc\\hosts)，添加以下ip映射，方便我们进行测试：\n\n127.0.0.1 sso.wcy.com\n127.0.0.1 s1.wcy.com\n127.0.0.1 s2.wcy.com\n127.0.0.1 s3.wcy.com\n\n\n1\n2\n3\n4\n\n\n其中：sso.wcy.com为统一认证中心地址，当用户在其它 client 端发起登录请求时，均将其重定向至认证中心，待到登录成功之后再原路返回到 client 端。\n\n\n# 3.指定cookie的作用域\n\n在sso.wcy.com访问服务器，其cookie也只能写入到sso.wcy.com下，为了将cookie写入到其父级域名wcy.com下，我们需要更改 sso-server 端的 yml 配置：\n\nsa-token:\n    cookie:\n        # 配置cookie作用域 \n        domain: wcy.com\n\n\n1\n2\n3\n4\n\n\n这个配置原本是被注释掉的，现在将其打开。另外我们格外需要注意： 在sso模式一测试完毕之后，一定要将这个配置再次注释掉，因为模式一与模式二三使用不同的授权流程，这行配置会影响到我们模式二和模式三的正常运行。\n\n\n# 4.搭建client端项目\n\n> 搭建示例在官方仓库的 /sa-token-demo/sa-token-demo-sso1-client/，如遇到难点可结合源码进行测试学习。\n\n\n# 1.创建项目，导入依赖\n\n新建项目 sa-token-demo-sso1-client，并添加以下依赖：\n\n\x3c!-- sa-token 权限认证, 在线文档：http://sa-token.dev33.cn/ --\x3e\n<dependency>\n    <groupid>cn.dev33</groupid>\n    <artifactid>sa-token-spring-boot-starter</artifactid>\n    <version>${sa-token-version}</version>\n</dependency>\n\n\x3c!-- sa-token 整合redis (使用jackson序列化方式) --\x3e\n<dependency>\n    <groupid>cn.dev33</groupid>\n    <artifactid>sa-token-dao-redis-jackson</artifactid>\n    <version>${sa-token-version}</version>\n</dependency>\n<dependency>\n    <groupid>org.apache.commons</groupid>\n    <artifactid>commons-pool2</artifactid>\n</dependency>\n\n\x3c!-- sa-token插件：权限缓存与业务缓存分离 --\x3e\n<dependency>\n    <groupid>cn.dev33</groupid>\n    <artifactid>sa-token-alone-redis</artifactid>\n    <version>${sa-token-version}</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.添加控制器\n\n/**\n * sa-token-sso client端 controller \n * @author kong\n */\n@restcontroller\npublic class ssoclientcontroller {\n\n    // sso-client端：首页 \n    @requestmapping("/")\n    public string index() {\n        string authurl = samanager.getconfig().getsso().getauthurl();\n        string solurl = samanager.getconfig().getsso().getslourl();\n        string str = "<h2>sa-token sso-client 应用端</h2>" + \n                    "<p>当前会话是否登录：" + stputil.islogin() + "</p>" + \n                    "<p><a href=\\"javascript:location.href=\'" + authurl + "?mode=simple&redirect=\' + encodeuricomponent(location.href);\\">登录</a> " + \n                    "<a href=\\"javascript:location.href=\'" + solurl + "?back=\' + encodeuricomponent(location.href);\\">注销</a> </p>";\n        return str;\n    }\n\n    // 全局异常拦截 \n    @exceptionhandler\n    public saresult handlerexception(exception e) {\n        e.printstacktrace(); \n        return saresult.error(e.getmessage());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 3.配置文件\n\n# 端口\nserver:\n    port: 9001\n\n# sa-token配置 \nsa-token: \n    # sso-相关配置\n    sso: \n        # sso-server端-单点登录授权地址 \n        auth-url: http://sso.wcy.com:9000/sso/auth\n        # sso-server端-单点注销地址\n        slo-url: http://sso.wcy.com:9000/sso/logout\n\n    # 配置sa-token单独使用的redis连接 （此处需要和sso-server端连接同一个redis）\n    alone-redis: \n        # redis数据库索引\n        database: 1\n        # redis服务器地址\n        host: 127.0.0.1\n        # redis服务器连接端口\n        port: 6379\n        # redis服务器连接密码（默认为空）\n        password: \n        # 连接超时时间\n        timeout: 10s\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 4.启动类\n\n/**\n * sso模式一，client端 demo \n */\n@springbootapplication\npublic class sassoclientapplication {\n    public static void main(string[] args) {\n        springapplication.run(sassoclientapplication.class, args);\n        system.out.println("\\nsa-token sso模式一 client端启动成功");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 5.访问测试\n\n启动项目，依次访问三个应用端：\n\n * http://s1.wcy.com:9001/\n * http://s2.wcy.com:9001/\n * http://s3.wcy.com:9001/\n\n均返回：\n\n\n\n然后点击登录，被重定向至sso认证中心：\n\n最后刷新发现都已经登陆成功\n\n如上，我们使用简单的步骤实现了同域下的单点登录，聪明如你😏，马上想到了这种模式有着一个不小的限制：\n\n> 所有子系统的域名，必须同属一个父级域名\n\n如果我们的子系统在完全不同的域名下，我们又该怎么完成单点登录功能呢？\n\n且往下看，sso模式二：url重定向传播会话',charsets:{cjk:!0}},{title:"JS通用方法",frontmatter:{title:"JS通用方法",date:"2021-07-09T15:02:45.000Z",permalink:"/pages/1f749b/",categories:["前端","JS"],tags:[null]},regularPath:"/02.%E5%89%8D%E7%AB%AF/00.JS/00.JS%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95.html",relativePath:"02.前端/00.JS/00.JS通用方法.md",key:"v-003925aa",path:"/pages/1f749b/",headersStr:null,content:"# JS通用方法\n\n1.Map转Json\n\nfunction Map2Json(map) {\n    var str = \"{\";\n    map.forEach(function (value, key) {\n        str += '\"'+key+'\"'+':'+ '\"'+value+'\",';\n    })\n    str = str.substring(0,str.length-1)\n    str +=\"}\";\n    return str;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",normalizedContent:"# js通用方法\n\n1.map转json\n\nfunction map2json(map) {\n    var str = \"{\";\n    map.foreach(function (value, key) {\n        str += '\"'+key+'\"'+':'+ '\"'+value+'\",';\n    })\n    str = str.substring(0,str.length-1)\n    str +=\"}\";\n    return str;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"初识单点登录",frontmatter:{title:"初识单点登录",date:"2021-12-09T15:20:12.000Z",permalink:"/pages/59cf58/",categories:["后端","Sa-Token","单点登录"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/61.Sa-Token/00.%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/00.%E5%88%9D%E8%AF%86%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.html",relativePath:"01.后端/61.Sa-Token/00.单点登录/00.初识单点登录.md",key:"v-4174a582",path:"/pages/59cf58/",headers:[{level:2,title:"1.什么是单点登录？解决什么问题",slug:"_1-什么是单点登录-解决什么问题",normalizedTitle:"1.什么是单点登录？解决什么问题",charIndex:76},{level:2,title:"2.架构选型",slug:"_2-架构选型",normalizedTitle:"2.架构选型",charIndex:293},{level:2,title:"3.单点登录准备",slug:"_3-单点登录准备",normalizedTitle:"3.单点登录准备",charIndex:916},{level:3,title:"1.创建 SpringBoot 项目",slug:"_1-创建-springboot-项目",normalizedTitle:"1.创建 springboot 项目",charIndex:988},{level:3,title:"2.开放认证接口",slug:"_2-开放认证接口",normalizedTitle:"2.开放认证接口",charIndex:2150},{level:3,title:"3.yml配置",slug:"_3-yml配置",normalizedTitle:"3.yml配置",charIndex:3851},{level:3,title:"4.启动类",slug:"_4-启动类",normalizedTitle:"4.启动类",charIndex:4894},{level:2,title:"4.单点登录API",slug:"_4-单点登录api",normalizedTitle:"4.单点登录api",charIndex:5538},{level:3,title:"1.单点登录授权地址",slug:"_1-单点登录授权地址",normalizedTitle:"1.单点登录授权地址",charIndex:5758},{level:3,title:"2.RestAPI 登录接口",slug:"_2-restapi-登录接口",normalizedTitle:"2.restapi 登录接口",charIndex:6114},{level:3,title:"3.Ticket 校验接口",slug:"_3-ticket-校验接口",normalizedTitle:"3.ticket 校验接口",charIndex:6395},{level:3,title:"4.单点注销接口",slug:"_4-单点注销接口",normalizedTitle:"4.单点注销接口",charIndex:6703}],headersStr:"1.什么是单点登录？解决什么问题 2.架构选型 3.单点登录准备 1.创建 SpringBoot 项目 2.开放认证接口 3.yml配置 4.启动类 4.单点登录API 1.单点登录授权地址 2.RestAPI 登录接口 3.Ticket 校验接口 4.单点注销接口",content:'# Sa-Token-SSO 单点登录\n\n凡是稍微上点规模的系统，统一认证中心都是绕不过去的槛。而单点登录——便是我们搭建统一认证中心的关键。\n\n\n# 1.什么是单点登录？解决什么问题\n\n举个场景，假设我们的系统被切割为N个部分：商城、论坛、直播、社交…… 如果用户每访问一个模块都要登录一次，那么用户将会疯掉， 为了优化用户体验，我们急需一套机制将这N个系统的认证授权互通共享，让用户在一个系统登录之后，便可以畅通无阻的访问其它所有系统。\n\n单点登录——就是为了解决这个问题而生！\n\n简而言之，单点登录可以做到：在多个互相信任的系统中，用户只需登录一次，就可以访问所有系统。\n\n\n# 2.架构选型\n\n对于单点登录，网上教程大多以CAS模式为主，其实对于不同的系统架构，实现单点登录的步骤也大为不同，Sa-Token 由简入难将其划分为三种模式：\n\n系统架构                 采用模式   简介               文档链接\n前端同域 + 后端同 Redis     模式一    共享 Cookie 同步会话   文档、示例\n前端不同域 + 后端同 Redis    模式二    URL重定向传播会话       文档、示例\n前端不同域 + 后端不同 Redis   模式三    Http请求获取会话       文档、示例\n\n 1. 前端同域：就是指多个系统可以部署在同一个主域名之下，比如：c1.domain.com、c2.domain.com、c3.domain.com。\n 2. 后端同Redis：就是指多个系统可以连接同一个Redis，其它的缓存数据中心亦可。PS：这里并不需要把所有项目的数据都放在同一个Redis中，Sa-Token提供了 [权限缓存与业务缓存分离] 的解决方案，详情戳：Alone独立Redis插件。\n 3. 如果既无法做到前端同域，也无法做到后端同Redis，那么只能走模式三，Http请求获取会话（Sa-Token对SSO提供了完整的封装，你只需要按照示例从文档上复制几段代码便可以轻松集成）。\n 4. 技术选型一定要根据系统架构对症下药，切不可胡乱选择。\n\n\n# 3.单点登录准备\n\n在开始SSO三种模式的对接之前，我们必须先搭建一个 SSO-Server 认证中心(用于所有的系统登录的统一入口)\n\n\n# 1.创建 SpringBoot 项目\n\nsa-token-demo-sso-server，引入依赖：\n\n\x3c!-- Sa-Token 权限认证, 在线文档：http://sa-token.dev33.cn/ --\x3e\n<dependency>\n    <groupId>cn.dev33</groupId>\n    <artifactId>sa-token-spring-boot-starter</artifactId>\n    <version>1.28.0</version>\n</dependency>\n\n\x3c!-- Sa-Token 整合 Redis (使用 jackson 序列化方式) --\x3e\n<dependency>\n    <groupId>cn.dev33</groupId>\n    <artifactId>sa-token-dao-redis-jackson</artifactId>\n    <version>1.28.0</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n</dependency>\n\n\x3c!-- 视图引擎（在前后端不分离模式下提供视图支持） --\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n\n\x3c!-- Http请求工具（在模式三的单点注销功能下用到，如不需要可以注释掉） --\x3e\n<dependency>\n     <groupId>com.ejlchina</groupId>\n     <artifactId>okhttps</artifactId>\n     <version>3.1.1</version>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n除了 sa-token-spring-boot-starter 以外，其它包都是可选的：\n\n * 在SSO模式三时 Redis 相关包是可选的\n * 在前后端分离模式下可以删除 thymeleaf 相关包\n * 在不需要SSO模式三单点注销的情况下可以删除 http 工具包\n\n建议先完整测试三种模式之后再对pom依赖进行酌情删减。\n\n\n# 2.开放认证接口\n\n/**\n * Sa-Token-SSO Server端 Controller \n */\n@RestController\npublic class SsoServerController {\n\n    /*\n     * SSO-Server端：处理所有SSO相关请求 (下面的章节我们会详细列出开放的接口) \n     */\n    @RequestMapping("/sso/*")\n    public Object ssoRequest() {\n        return SaSsoHandle.serverRequest();\n    }\n\n    /**\n     * 配置SSO相关参数 \n     */\n    @Autowired\n    private void configSso(SaTokenConfig cfg) {\n        // 配置：未登录时返回的View \n        cfg.sso.setNotLoginView(() -> {\n            String msg = "当前会话在SSO-Server端尚未登录，请先访问"\n                    + "<a href=\'/sso/doLogin?name=sa&pwd=123456\' target=\'_blank\'> doLogin登录 </a>"\n                    + "进行登录之后，刷新页面开始授权";\n            return msg;\n        });\n\n        // 配置：登录处理函数 \n        cfg.sso.setDoLoginHandle((name, pwd) -> {\n            // 此处仅做模拟登录，真实环境应该查询数据进行登录 \n            if("sa".equals(name) && "123456".equals(pwd)) {\n                StpUtil.login(10001);\n                return SaResult.ok("登录成功！").setData(StpUtil.getTokenValue());\n            }\n            return SaResult.error("登录失败！");\n        });\n\n        // 配置 Http 请求处理器 （在模式三的单点注销功能下用到，如不需要可以注释掉） \n        cfg.sso.setSendHttp(url -> {\n            return OkHttps.sync(url).get().getBody().toString();\n        });\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n注：在setDoLoginHandle函数里如果要获取name, pwd以外的参数，可通过SaHolder.getRequest().getParam("xxx")来获取\n\n全局异常处理：\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    // 全局异常拦截 \n    @ExceptionHandler\n    public SaResult handlerException(Exception e) {\n        e.printStackTrace(); \n        return SaResult.error(e.getMessage());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.yml配置\n\n# 端口\nserver:\n    port: 9000\n\n# Sa-Token 配置\nsa-token: \n    # -------------- SSO-模式一相关配置  (非模式一不需要配置) \n    # cookie: \n        # 配置Cookie作用域 \n        # domain: stp.com \n\n    # ------- SSO-模式二相关配置 \n    sso: \n        # Ticket有效期 (单位: 秒)，默认五分钟 \n        ticket-timeout: 300\n        # 所有允许的授权回调地址\n        allow-url: "*"\n        # 是否打开单点注销功能\n        is-slo: true\n\n        # ------- SSO-模式三相关配置 （下面的配置在SSO模式三并且 is-slo=true 时打开） -------\n        # 是否打开模式三 \n        isHttp: true\n        # 接口调用秘钥（用于SSO模式三的单点注销功能）\n        secretkey: kQwIOrYvnXmSDkwEiFngrKidMcdrgKor\n        # ---- 除了以上配置项，你还需要为 Sa-Token 配置http请求处理器（文档有步骤说明） \n\nspring: \n    # Redis配置 （SSO模式一和模式二使用Redis来同步会话）\n    redis:\n        # Redis数据库索引（默认为0）\n        database: 1\n        # Redis服务器地址\n        host: 127.0.0.1\n        # Redis服务器连接端口\n        port: 6379\n        # Redis服务器连接密码（默认为空）\n        password: \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n注意点：allow-url为了方便测试配置为*，线上生产环境一定要配置为详细URL地址 （之后的章节我们会详细阐述此配置项）\n\n\n# 4.启动类\n\n@SpringBootApplication\npublic class SaSsoServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SaSsoServerApplication.class, args);\n        System.out.println("\\n------ Sa-Token-SSO 认证中心启动成功");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n5.访问统一授权地址：\n\n * http://localhost:9000/sso/auth\n\n可以看到这个页面目前非常简陋，这是因为我们以上的代码示例，主要目标是为了带大家从零搭建一个可用的SSO认证服务端，所以就对一些不太必要的步骤做了简化。\n\n大家可以下载运行一下官方仓库里的示例/sa-token-demo/sa-token-demo-sso-server/，里面有制作好的登录页面：\n\n默认账号密码为：sa / 123456，先别着急点击登录，因为我们还没有搭建对应的 Client 端项目， 真实项目中我们是不会直接从浏览器访问 /sso/auth 授权地址的，我们需要在 Client 端点击登录按钮重定向而来。\n\n现在我们先来看看除了 /sso/auth 统一授权地址，这个 SSO-Server 认证中心还开放了哪些API。\n\n\n# 4.单点登录API\n\n如果你仅仅使用 Sa-Token 搭建 SSO-Server 端，而 Client 端使用其它框架的话，那么下面的 API 列表将给你的对接步骤做一份参考。\n\n如果你在 Client 端也用到了 Sa-Token 框架，那么你可以选择跳过本小节，Sa-Token 对 Client 端也提供了相应的封装，你可以直接开始学习：SSO模式一 共享Cookie同步会话\n\n> 在未登录情况下，单点登录提供了四个接口\n\n\n# 1.单点登录授权地址\n\nhttp://{host}:{port}/sso/auth\n\n\n1\n\n\n接收参数：\n\n参数         是否必填   说明\nredirect   是      登录成功后的重定向地址，一般填写 location.href（从哪来回哪去）\nmode       否      授权模式，取值 [simple,\n                  ticket]，simple=登录后直接重定向，ticket=带着ticket参数重定向，默认值为ticket\n\n访问接口后有两种情况：\n\n * 情况一：当前会话在 SSO 认证中心未登录，会进入登录页开始登录。\n * 情况二：当前会话在 SSO 认证中心已登录，会被重定向至 redirect 地址，并携带 ticket 参数。\n\n\n# 2.RestAPI 登录接口\n\nhttp://{host}:{port}/sso/doLogin\n\n\n1\n\n\n接收参数：\n\n参数     是否必填   说明\nname   是      用户名\npwd    是      密码\n\n此接口属于 RestAPI (使用ajax访问)，会进入后端配置的 setDoLoginHandle 函数中，另外需要注意： 此接口并非只能携带 name、pwd 参数，因为你可以在 setDoLoginHandle 函数里通过 SaHolder.getRequest().getParam("xxx") 来获取其它参数。\n\n\n# 3.Ticket 校验接口\n\n此接口仅配置模式三 (isHttp=true) 时打开\n\nhttp://{host}:{port}/sso/checkTicket\n\n\n1\n\n\n接收参数：\n\n参数              是否必填   说明\nticket          是      在步骤 5.1 中授权重定向时的 ticket 参数\nssoLogoutCall   否      单点注销时的回调通知地址，只在SSO模式三单点注销时需要携带此参数\n\n返回值场景：\n\n * 返回空，代表校验失败。\n * 返回具体的 loginId，例如10001，代表校验成功，值为此 ticket 码代表的用户id。\n\n\n# 4.单点注销接口\n\nhttp://{host}:{port}/sso/logout         \n\n\n1\n\n\n接受参数：\n\n参数          是否必填   说明\nloginId     否      要注销的账号id\nsecretkey   否      接口通信秘钥\nback        否      注销成功后的重定向地址\n\n此接口有两种调用方式\n\n# 方式一：在 Client 的前端页面引导用户直接跳转，并带有 back 参数\n\n例如：http://{host}:{port}/sso/logout?back=xxx，代表用户注销成功后返回back地址\n\n# 方式二：在 Client 的后端通过 http 工具来调用\n\n例如：http://{host}:{port}/sso/logout?loginId={value}&secretkey={value}，代表注销 账号=loginId 的账号，返回json数据结果，形如：\n\n{\n    "code": 200,    // 200表示请求成功，非200标识请求失败\n    "msg": "单点注销成功",\n    "data": null\n}\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# sa-token-sso 单点登录\n\n凡是稍微上点规模的系统，统一认证中心都是绕不过去的槛。而单点登录——便是我们搭建统一认证中心的关键。\n\n\n# 1.什么是单点登录？解决什么问题\n\n举个场景，假设我们的系统被切割为n个部分：商城、论坛、直播、社交…… 如果用户每访问一个模块都要登录一次，那么用户将会疯掉， 为了优化用户体验，我们急需一套机制将这n个系统的认证授权互通共享，让用户在一个系统登录之后，便可以畅通无阻的访问其它所有系统。\n\n单点登录——就是为了解决这个问题而生！\n\n简而言之，单点登录可以做到：在多个互相信任的系统中，用户只需登录一次，就可以访问所有系统。\n\n\n# 2.架构选型\n\n对于单点登录，网上教程大多以cas模式为主，其实对于不同的系统架构，实现单点登录的步骤也大为不同，sa-token 由简入难将其划分为三种模式：\n\n系统架构                 采用模式   简介               文档链接\n前端同域 + 后端同 redis     模式一    共享 cookie 同步会话   文档、示例\n前端不同域 + 后端同 redis    模式二    url重定向传播会话       文档、示例\n前端不同域 + 后端不同 redis   模式三    http请求获取会话       文档、示例\n\n 1. 前端同域：就是指多个系统可以部署在同一个主域名之下，比如：c1.domain.com、c2.domain.com、c3.domain.com。\n 2. 后端同redis：就是指多个系统可以连接同一个redis，其它的缓存数据中心亦可。ps：这里并不需要把所有项目的数据都放在同一个redis中，sa-token提供了 [权限缓存与业务缓存分离] 的解决方案，详情戳：alone独立redis插件。\n 3. 如果既无法做到前端同域，也无法做到后端同redis，那么只能走模式三，http请求获取会话（sa-token对sso提供了完整的封装，你只需要按照示例从文档上复制几段代码便可以轻松集成）。\n 4. 技术选型一定要根据系统架构对症下药，切不可胡乱选择。\n\n\n# 3.单点登录准备\n\n在开始sso三种模式的对接之前，我们必须先搭建一个 sso-server 认证中心(用于所有的系统登录的统一入口)\n\n\n# 1.创建 springboot 项目\n\nsa-token-demo-sso-server，引入依赖：\n\n\x3c!-- sa-token 权限认证, 在线文档：http://sa-token.dev33.cn/ --\x3e\n<dependency>\n    <groupid>cn.dev33</groupid>\n    <artifactid>sa-token-spring-boot-starter</artifactid>\n    <version>1.28.0</version>\n</dependency>\n\n\x3c!-- sa-token 整合 redis (使用 jackson 序列化方式) --\x3e\n<dependency>\n    <groupid>cn.dev33</groupid>\n    <artifactid>sa-token-dao-redis-jackson</artifactid>\n    <version>1.28.0</version>\n</dependency>\n<dependency>\n    <groupid>org.apache.commons</groupid>\n    <artifactid>commons-pool2</artifactid>\n</dependency>\n\n\x3c!-- 视图引擎（在前后端不分离模式下提供视图支持） --\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-thymeleaf</artifactid>\n</dependency>\n\n\x3c!-- http请求工具（在模式三的单点注销功能下用到，如不需要可以注释掉） --\x3e\n<dependency>\n     <groupid>com.ejlchina</groupid>\n     <artifactid>okhttps</artifactid>\n     <version>3.1.1</version>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n除了 sa-token-spring-boot-starter 以外，其它包都是可选的：\n\n * 在sso模式三时 redis 相关包是可选的\n * 在前后端分离模式下可以删除 thymeleaf 相关包\n * 在不需要sso模式三单点注销的情况下可以删除 http 工具包\n\n建议先完整测试三种模式之后再对pom依赖进行酌情删减。\n\n\n# 2.开放认证接口\n\n/**\n * sa-token-sso server端 controller \n */\n@restcontroller\npublic class ssoservercontroller {\n\n    /*\n     * sso-server端：处理所有sso相关请求 (下面的章节我们会详细列出开放的接口) \n     */\n    @requestmapping("/sso/*")\n    public object ssorequest() {\n        return sassohandle.serverrequest();\n    }\n\n    /**\n     * 配置sso相关参数 \n     */\n    @autowired\n    private void configsso(satokenconfig cfg) {\n        // 配置：未登录时返回的view \n        cfg.sso.setnotloginview(() -> {\n            string msg = "当前会话在sso-server端尚未登录，请先访问"\n                    + "<a href=\'/sso/dologin?name=sa&pwd=123456\' target=\'_blank\'> dologin登录 </a>"\n                    + "进行登录之后，刷新页面开始授权";\n            return msg;\n        });\n\n        // 配置：登录处理函数 \n        cfg.sso.setdologinhandle((name, pwd) -> {\n            // 此处仅做模拟登录，真实环境应该查询数据进行登录 \n            if("sa".equals(name) && "123456".equals(pwd)) {\n                stputil.login(10001);\n                return saresult.ok("登录成功！").setdata(stputil.gettokenvalue());\n            }\n            return saresult.error("登录失败！");\n        });\n\n        // 配置 http 请求处理器 （在模式三的单点注销功能下用到，如不需要可以注释掉） \n        cfg.sso.setsendhttp(url -> {\n            return okhttps.sync(url).get().getbody().tostring();\n        });\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n注：在setdologinhandle函数里如果要获取name, pwd以外的参数，可通过saholder.getrequest().getparam("xxx")来获取\n\n全局异常处理：\n\n@restcontrolleradvice\npublic class globalexceptionhandler {\n    // 全局异常拦截 \n    @exceptionhandler\n    public saresult handlerexception(exception e) {\n        e.printstacktrace(); \n        return saresult.error(e.getmessage());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.yml配置\n\n# 端口\nserver:\n    port: 9000\n\n# sa-token 配置\nsa-token: \n    # -------------- sso-模式一相关配置  (非模式一不需要配置) \n    # cookie: \n        # 配置cookie作用域 \n        # domain: stp.com \n\n    # ------- sso-模式二相关配置 \n    sso: \n        # ticket有效期 (单位: 秒)，默认五分钟 \n        ticket-timeout: 300\n        # 所有允许的授权回调地址\n        allow-url: "*"\n        # 是否打开单点注销功能\n        is-slo: true\n\n        # ------- sso-模式三相关配置 （下面的配置在sso模式三并且 is-slo=true 时打开） -------\n        # 是否打开模式三 \n        ishttp: true\n        # 接口调用秘钥（用于sso模式三的单点注销功能）\n        secretkey: kqwioryvnxmsdkweifngrkidmcdrgkor\n        # ---- 除了以上配置项，你还需要为 sa-token 配置http请求处理器（文档有步骤说明） \n\nspring: \n    # redis配置 （sso模式一和模式二使用redis来同步会话）\n    redis:\n        # redis数据库索引（默认为0）\n        database: 1\n        # redis服务器地址\n        host: 127.0.0.1\n        # redis服务器连接端口\n        port: 6379\n        # redis服务器连接密码（默认为空）\n        password: \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n注意点：allow-url为了方便测试配置为*，线上生产环境一定要配置为详细url地址 （之后的章节我们会详细阐述此配置项）\n\n\n# 4.启动类\n\n@springbootapplication\npublic class sassoserverapplication {\n    public static void main(string[] args) {\n        springapplication.run(sassoserverapplication.class, args);\n        system.out.println("\\n------ sa-token-sso 认证中心启动成功");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n5.访问统一授权地址：\n\n * http://localhost:9000/sso/auth\n\n可以看到这个页面目前非常简陋，这是因为我们以上的代码示例，主要目标是为了带大家从零搭建一个可用的sso认证服务端，所以就对一些不太必要的步骤做了简化。\n\n大家可以下载运行一下官方仓库里的示例/sa-token-demo/sa-token-demo-sso-server/，里面有制作好的登录页面：\n\n默认账号密码为：sa / 123456，先别着急点击登录，因为我们还没有搭建对应的 client 端项目， 真实项目中我们是不会直接从浏览器访问 /sso/auth 授权地址的，我们需要在 client 端点击登录按钮重定向而来。\n\n现在我们先来看看除了 /sso/auth 统一授权地址，这个 sso-server 认证中心还开放了哪些api。\n\n\n# 4.单点登录api\n\n如果你仅仅使用 sa-token 搭建 sso-server 端，而 client 端使用其它框架的话，那么下面的 api 列表将给你的对接步骤做一份参考。\n\n如果你在 client 端也用到了 sa-token 框架，那么你可以选择跳过本小节，sa-token 对 client 端也提供了相应的封装，你可以直接开始学习：sso模式一 共享cookie同步会话\n\n> 在未登录情况下，单点登录提供了四个接口\n\n\n# 1.单点登录授权地址\n\nhttp://{host}:{port}/sso/auth\n\n\n1\n\n\n接收参数：\n\n参数         是否必填   说明\nredirect   是      登录成功后的重定向地址，一般填写 location.href（从哪来回哪去）\nmode       否      授权模式，取值 [simple,\n                  ticket]，simple=登录后直接重定向，ticket=带着ticket参数重定向，默认值为ticket\n\n访问接口后有两种情况：\n\n * 情况一：当前会话在 sso 认证中心未登录，会进入登录页开始登录。\n * 情况二：当前会话在 sso 认证中心已登录，会被重定向至 redirect 地址，并携带 ticket 参数。\n\n\n# 2.restapi 登录接口\n\nhttp://{host}:{port}/sso/dologin\n\n\n1\n\n\n接收参数：\n\n参数     是否必填   说明\nname   是      用户名\npwd    是      密码\n\n此接口属于 restapi (使用ajax访问)，会进入后端配置的 setdologinhandle 函数中，另外需要注意： 此接口并非只能携带 name、pwd 参数，因为你可以在 setdologinhandle 函数里通过 saholder.getrequest().getparam("xxx") 来获取其它参数。\n\n\n# 3.ticket 校验接口\n\n此接口仅配置模式三 (ishttp=true) 时打开\n\nhttp://{host}:{port}/sso/checkticket\n\n\n1\n\n\n接收参数：\n\n参数              是否必填   说明\nticket          是      在步骤 5.1 中授权重定向时的 ticket 参数\nssologoutcall   否      单点注销时的回调通知地址，只在sso模式三单点注销时需要携带此参数\n\n返回值场景：\n\n * 返回空，代表校验失败。\n * 返回具体的 loginid，例如10001，代表校验成功，值为此 ticket 码代表的用户id。\n\n\n# 4.单点注销接口\n\nhttp://{host}:{port}/sso/logout         \n\n\n1\n\n\n接受参数：\n\n参数          是否必填   说明\nloginid     否      要注销的账号id\nsecretkey   否      接口通信秘钥\nback        否      注销成功后的重定向地址\n\n此接口有两种调用方式\n\n# 方式一：在 client 的前端页面引导用户直接跳转，并带有 back 参数\n\n例如：http://{host}:{port}/sso/logout?back=xxx，代表用户注销成功后返回back地址\n\n# 方式二：在 client 的后端通过 http 工具来调用\n\n例如：http://{host}:{port}/sso/logout?loginid={value}&secretkey={value}，代表注销 账号=loginid 的账号，返回json数据结果，形如：\n\n{\n    "code": 200,    // 200表示请求成功，非200标识请求失败\n    "msg": "单点注销成功",\n    "data": null\n}\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0}},{title:"模式二：URL重定向传播会话",frontmatter:{title:"模式二：URL重定向传播会话",date:"2021-12-14T10:47:02.000Z",permalink:"/pages/658e4c/",categories:["后端","Sa-Token","单点登录"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/61.Sa-Token/00.%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/02.%E6%A8%A1%E5%BC%8F%E4%BA%8C%EF%BC%9AURL%E9%87%8D%E5%AE%9A%E5%90%91%E4%BC%A0%E6%92%AD%E4%BC%9A%E8%AF%9D.html",relativePath:"01.后端/61.Sa-Token/00.单点登录/02.模式二：URL重定向传播会话.md",key:"v-0473e648",path:"/pages/658e4c/",headers:[{level:2,title:"1、解题思路",slug:"_1、解题思路",normalizedTitle:"1、解题思路",charIndex:92},{level:2,title:"2、准备工作",slug:"_2、准备工作",normalizedTitle:"2、准备工作",charIndex:959},{level:3,title:"1.修改本地映射",slug:"_1-修改本地映射",normalizedTitle:"1.修改本地映射",charIndex:970},{level:3,title:"2.单点登录系统修改配置",slug:"_2-单点登录系统修改配置",normalizedTitle:"2.单点登录系统修改配置",charIndex:1181},{level:2,title:"3.搭建 Client 端项目",slug:"_3-搭建-client-端项目",normalizedTitle:"3.搭建 client 端项目",charIndex:1340},{level:3,title:"1.创建项目，导入依赖",slug:"_1-创建项目-导入依赖",normalizedTitle:"1.创建项目，导入依赖",charIndex:1433},{level:3,title:"2.创建 SSO-Client 端认证接口",slug:"_2-创建-sso-client-端认证接口",normalizedTitle:"2.创建 sso-client 端认证接口",charIndex:2243},{level:3,title:"3.配置SSO认证中心地址",slug:"_3-配置sso认证中心地址",normalizedTitle:"3.配置sso认证中心地址",charIndex:3411},{level:3,title:"4.启动类",slug:"_4-启动类",normalizedTitle:"4.启动类",charIndex:4029},{level:3,title:"5.测试访问",slug:"_5-测试访问",normalizedTitle:"5.测试访问",charIndex:4305}],headersStr:"1、解题思路 2、准备工作 1.修改本地映射 2.单点登录系统修改配置 3.搭建 Client 端项目 1.创建项目，导入依赖 2.创建 SSO-Client 端认证接口 3.配置SSO认证中心地址 4.启动类 5.测试访问",content:'# 模式二：URL重定向传播会话\n\n如果我们的多个系统：部署在不同的域名之下，但是后端可以连接同一个Redis，那么便可以使用 [URL重定向传播会话] 的方式做到单点登录。\n\n\n# 1、解题思路\n\n首先我们再次复习一下，多个系统之间为什么无法同步登录状态？\n\n 1. 前端的Token无法在多个系统下共享。\n 2. 后端的Session无法在多个系统间共享。\n\n关于第二点，我们已在 "SSO模式一" 章节中阐述，使用 Alone独立Redis插件 做到权限缓存直连 SSO-Redis 数据中心，在此不再赘述。\n\n而第一点，才是我们解决问题的关键所在，在跨域模式下，意味着 "共享Cookie方案" 的失效，我们必须采用一种新的方案来传递Token。\n\n 1. 用户在 子系统 点击 [登录] 按钮。\n 2. 用户跳转到子系统登录接口/sso/login，并携带back参数记录初始页面URL。\n    * 形如：http://{sso-client}/sso/login?back=xxx\n 3. 子系统检测到此用户尚未登录，再次将其重定向至SSO认证中心，并携带redirect参数记录子系统的登录页URL。\n    * 形如：http://{sso-server}/sso/auth?redirect=xxx?back=xxx\n 4. 用户进入了 SSO认证中心 的登录页面，开始登录。\n 5. 用户 输入账号密码 并 登录成功，SSO认证中心再次将用户重定向至子系统的登录接口/sso/login，并携带ticket码参数。\n    * 形如：http://{sso-client}/sso/login?back=xxx&ticket=xxxxxxxxx\n 6. 子系统根据 ticket码 从 SSO-Redis 中获取账号id，并在子系统登录此账号会话。\n 7. 子系统将用户再次重定向至最初始的 back 页面。\n\n整个过程，除了第四步用户在SSO认证中心登录时会被打断，其余过程均是自动化的，当用户在另一个子系统再次点击[登录]按钮，由于此用户在SSO认证中心已有会话存在， 所以第四步也将自动化，也就是单点登录的最终目的 —— 一次登录，处处通行。\n\n下面我们按照步骤依次完成上述过程：\n\n\n# 2、准备工作\n\n\n# 1.修改本地映射\n\n首先修改hosts文件(C:\\windows\\system32\\drivers\\etc\\hosts)，添加以下IP映射，方便我们进行测试：\n\n127.0.0.1 sa-sso-server.com\n127.0.0.1 sa-sso-client1.com\n127.0.0.1 sa-sso-client2.com\n127.0.0.1 sa-sso-client3.com\n\n\n1\n2\n3\n4\n\n\n\n# 2.单点登录系统修改配置\n\n在SSO模式一章节中我们打开了配置：\n\nsa-token: \n    cookie:\n        # 配置Cookie作用域\n        domain: stp.com\n\n\n\n1\n2\n3\n4\n5\n\n\n此为模式一专属配置，现在我们将其注释掉，并按照注释提示打开其他相应的注释\n\n\n# 3.搭建 Client 端项目\n\n> 搭建示例在官方仓库的 /sa-token-demo/sa-token-demo-sso2-client/，如遇到难点可结合源码进行测试学习\n\n\n# 1.创建项目，导入依赖\n\n创建一个 SpringBoot 项目 sa-token-demo-sso2-client，引入依赖：\n\n\x3c!-- Sa-Token 权限认证, 在线文档：http://sa-token.dev33.cn/ --\x3e\n<dependency>\n    <groupId>cn.dev33</groupId>\n    <artifactId>sa-token-spring-boot-starter</artifactId>\n    <version>1.28.0</version>\n</dependency>\n\n\x3c!-- Sa-Token 整合redis (使用jackson序列化方式) --\x3e\n<dependency>\n    <groupId>cn.dev33</groupId>\n    <artifactId>sa-token-dao-redis-jackson</artifactId>\n    <version>1.28.0</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n</dependency>\n\n\x3c!-- Sa-Token插件：权限缓存与业务缓存分离 --\x3e\n<dependency>\n    <groupId>cn.dev33</groupId>\n    <artifactId>sa-token-alone-redis</artifactId>\n    <version>1.28.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.创建 SSO-Client 端认证接口\n\n同 SSO-Server 一样，Sa-Token 为 SSO-Client 端所需代码也提供了完整的封装，你只需提供一个访问入口，接入 Sa-Token 的方法即可。\n\n\n/**\n * Sa-Token-SSO Client端 Controller \n */\n@RestController\npublic class SsoClientController {\n\n    // 首页 \n    @RequestMapping("/")\n    public String index() {\n        String str = "<h2>Sa-Token SSO-Client 应用端</h2>" + \n                    "<p>当前会话是否登录：" + StpUtil.isLogin() + "</p>" + \n                    "<p><a href=\\"javascript:location.href=\'/sso/login?back=\' + encodeURIComponent(location.href);\\">登录</a> " + \n                    "<a href=\'/sso/logout?back=self\'>注销</a></p>";\n        return str;\n    }\n\n    /*\n     * SSO-Client端：处理所有SSO相关请求 \n     *         http://{host}:{port}/sso/login          -- Client端登录地址，接受参数：back=登录后的跳转地址 \n     *         http://{host}:{port}/sso/logout         -- Client端单点注销地址（isSlo=true时打开），接受参数：back=注销后的跳转地址 \n     *         http://{host}:{port}/sso/logoutCall     -- Client端单点注销回调地址（isSlo=true时打开），此接口为框架回调，开发者无需关心\n     */\n    @RequestMapping("/sso/*")\n    public Object ssoRequest() {\n        return SaSsoHandle.clientRequest();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 3.配置SSO认证中心地址\n\n# 端口\nserver:\n    port: 9001\n\n# sa-token配置 \nsa-token: \n    # SSO-相关配置\n    sso: \n        # SSO-Server端 统一认证地址 \n        auth-url: http://sa-sso-server.com:9000/sso/auth\n        # 是否打开单点注销接口\n        is-slo: true\n\n    # 配置Sa-Token单独使用的Redis连接 （此处需要和SSO-Server端连接同一个Redis）\n    alone-redis: \n        # Redis数据库索引 (默认为0)\n        database: 1\n        # Redis服务器地址\n        host: 127.0.0.1\n        # Redis服务器连接端口\n        port: 6379\n        # Redis服务器连接密码（默认为空）\n        password: \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n注意点：sa-token.alone-redis 的配置需要和SSO-Server端连接同一个Redis（database也要一样）\n\n\n# 4.启动类\n\n@SpringBootApplication\npublic class SaSsoClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SaSsoClientApplication.class, args);\n        System.out.println("\\nSa-Token-SSO Client端启动成功");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n启动项目\n\n\n# 5.测试访问\n\n(1) 依次启动 SSO-Server 与 SSO-Client，然后从浏览器访问：http://sa-sso-client1.com:9001/\n\n(2) 首次打开，提示当前未登录，我们点击**登录** 按钮，页面会被重定向到登录中心\n\n(3) SSO-Server提示我们在认证中心尚未登录，我们点击 **doLogin登录**按钮进行模拟登录\n\n(4) SSO-Server认证中心登录成功，我们回到刚才的页面刷新页面\n\n(5) 页面被重定向至Client端首页，并提示登录成功，至此，Client1应用已单点登录成功！\n\n(6) 我们再次访问Client2：http://sa-sso-client2.com:9001/\n\n(7) 提示未登录，我们点击**登录**按钮，会直接提示登录成功\n\n(8) 同样的方式，我们打开Client3，也可以直接登录成功：http://sa-sso-client3.com:9001/\n\n至此，测试完毕！\n\n可以看出，除了在Client1端我们需要手动登录一次之外，在Client2端和Client3端都是可以无需再次认证，直接登录成功的。\n\n我们可以通过 F12控制台 Netword跟踪整个过程',normalizedContent:'# 模式二：url重定向传播会话\n\n如果我们的多个系统：部署在不同的域名之下，但是后端可以连接同一个redis，那么便可以使用 [url重定向传播会话] 的方式做到单点登录。\n\n\n# 1、解题思路\n\n首先我们再次复习一下，多个系统之间为什么无法同步登录状态？\n\n 1. 前端的token无法在多个系统下共享。\n 2. 后端的session无法在多个系统间共享。\n\n关于第二点，我们已在 "sso模式一" 章节中阐述，使用 alone独立redis插件 做到权限缓存直连 sso-redis 数据中心，在此不再赘述。\n\n而第一点，才是我们解决问题的关键所在，在跨域模式下，意味着 "共享cookie方案" 的失效，我们必须采用一种新的方案来传递token。\n\n 1. 用户在 子系统 点击 [登录] 按钮。\n 2. 用户跳转到子系统登录接口/sso/login，并携带back参数记录初始页面url。\n    * 形如：http://{sso-client}/sso/login?back=xxx\n 3. 子系统检测到此用户尚未登录，再次将其重定向至sso认证中心，并携带redirect参数记录子系统的登录页url。\n    * 形如：http://{sso-server}/sso/auth?redirect=xxx?back=xxx\n 4. 用户进入了 sso认证中心 的登录页面，开始登录。\n 5. 用户 输入账号密码 并 登录成功，sso认证中心再次将用户重定向至子系统的登录接口/sso/login，并携带ticket码参数。\n    * 形如：http://{sso-client}/sso/login?back=xxx&ticket=xxxxxxxxx\n 6. 子系统根据 ticket码 从 sso-redis 中获取账号id，并在子系统登录此账号会话。\n 7. 子系统将用户再次重定向至最初始的 back 页面。\n\n整个过程，除了第四步用户在sso认证中心登录时会被打断，其余过程均是自动化的，当用户在另一个子系统再次点击[登录]按钮，由于此用户在sso认证中心已有会话存在， 所以第四步也将自动化，也就是单点登录的最终目的 —— 一次登录，处处通行。\n\n下面我们按照步骤依次完成上述过程：\n\n\n# 2、准备工作\n\n\n# 1.修改本地映射\n\n首先修改hosts文件(c:\\windows\\system32\\drivers\\etc\\hosts)，添加以下ip映射，方便我们进行测试：\n\n127.0.0.1 sa-sso-server.com\n127.0.0.1 sa-sso-client1.com\n127.0.0.1 sa-sso-client2.com\n127.0.0.1 sa-sso-client3.com\n\n\n1\n2\n3\n4\n\n\n\n# 2.单点登录系统修改配置\n\n在sso模式一章节中我们打开了配置：\n\nsa-token: \n    cookie:\n        # 配置cookie作用域\n        domain: stp.com\n\n\n\n1\n2\n3\n4\n5\n\n\n此为模式一专属配置，现在我们将其注释掉，并按照注释提示打开其他相应的注释\n\n\n# 3.搭建 client 端项目\n\n> 搭建示例在官方仓库的 /sa-token-demo/sa-token-demo-sso2-client/，如遇到难点可结合源码进行测试学习\n\n\n# 1.创建项目，导入依赖\n\n创建一个 springboot 项目 sa-token-demo-sso2-client，引入依赖：\n\n\x3c!-- sa-token 权限认证, 在线文档：http://sa-token.dev33.cn/ --\x3e\n<dependency>\n    <groupid>cn.dev33</groupid>\n    <artifactid>sa-token-spring-boot-starter</artifactid>\n    <version>1.28.0</version>\n</dependency>\n\n\x3c!-- sa-token 整合redis (使用jackson序列化方式) --\x3e\n<dependency>\n    <groupid>cn.dev33</groupid>\n    <artifactid>sa-token-dao-redis-jackson</artifactid>\n    <version>1.28.0</version>\n</dependency>\n<dependency>\n    <groupid>org.apache.commons</groupid>\n    <artifactid>commons-pool2</artifactid>\n</dependency>\n\n\x3c!-- sa-token插件：权限缓存与业务缓存分离 --\x3e\n<dependency>\n    <groupid>cn.dev33</groupid>\n    <artifactid>sa-token-alone-redis</artifactid>\n    <version>1.28.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.创建 sso-client 端认证接口\n\n同 sso-server 一样，sa-token 为 sso-client 端所需代码也提供了完整的封装，你只需提供一个访问入口，接入 sa-token 的方法即可。\n\n\n/**\n * sa-token-sso client端 controller \n */\n@restcontroller\npublic class ssoclientcontroller {\n\n    // 首页 \n    @requestmapping("/")\n    public string index() {\n        string str = "<h2>sa-token sso-client 应用端</h2>" + \n                    "<p>当前会话是否登录：" + stputil.islogin() + "</p>" + \n                    "<p><a href=\\"javascript:location.href=\'/sso/login?back=\' + encodeuricomponent(location.href);\\">登录</a> " + \n                    "<a href=\'/sso/logout?back=self\'>注销</a></p>";\n        return str;\n    }\n\n    /*\n     * sso-client端：处理所有sso相关请求 \n     *         http://{host}:{port}/sso/login          -- client端登录地址，接受参数：back=登录后的跳转地址 \n     *         http://{host}:{port}/sso/logout         -- client端单点注销地址（isslo=true时打开），接受参数：back=注销后的跳转地址 \n     *         http://{host}:{port}/sso/logoutcall     -- client端单点注销回调地址（isslo=true时打开），此接口为框架回调，开发者无需关心\n     */\n    @requestmapping("/sso/*")\n    public object ssorequest() {\n        return sassohandle.clientrequest();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 3.配置sso认证中心地址\n\n# 端口\nserver:\n    port: 9001\n\n# sa-token配置 \nsa-token: \n    # sso-相关配置\n    sso: \n        # sso-server端 统一认证地址 \n        auth-url: http://sa-sso-server.com:9000/sso/auth\n        # 是否打开单点注销接口\n        is-slo: true\n\n    # 配置sa-token单独使用的redis连接 （此处需要和sso-server端连接同一个redis）\n    alone-redis: \n        # redis数据库索引 (默认为0)\n        database: 1\n        # redis服务器地址\n        host: 127.0.0.1\n        # redis服务器连接端口\n        port: 6379\n        # redis服务器连接密码（默认为空）\n        password: \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n注意点：sa-token.alone-redis 的配置需要和sso-server端连接同一个redis（database也要一样）\n\n\n# 4.启动类\n\n@springbootapplication\npublic class sassoclientapplication {\n    public static void main(string[] args) {\n        springapplication.run(sassoclientapplication.class, args);\n        system.out.println("\\nsa-token-sso client端启动成功");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n启动项目\n\n\n# 5.测试访问\n\n(1) 依次启动 sso-server 与 sso-client，然后从浏览器访问：http://sa-sso-client1.com:9001/\n\n(2) 首次打开，提示当前未登录，我们点击**登录** 按钮，页面会被重定向到登录中心\n\n(3) sso-server提示我们在认证中心尚未登录，我们点击 **dologin登录**按钮进行模拟登录\n\n(4) sso-server认证中心登录成功，我们回到刚才的页面刷新页面\n\n(5) 页面被重定向至client端首页，并提示登录成功，至此，client1应用已单点登录成功！\n\n(6) 我们再次访问client2：http://sa-sso-client2.com:9001/\n\n(7) 提示未登录，我们点击**登录**按钮，会直接提示登录成功\n\n(8) 同样的方式，我们打开client3，也可以直接登录成功：http://sa-sso-client3.com:9001/\n\n至此，测试完毕！\n\n可以看出，除了在client1端我们需要手动登录一次之外，在client2端和client3端都是可以无需再次认证，直接登录成功的。\n\n我们可以通过 f12控制台 netword跟踪整个过程',charsets:{cjk:!0}},{title:"java",frontmatter:{title:"java",date:"2021-07-09T14:58:45.000Z",permalink:"/pages/8632d0/",categories:["技术","面试笔记"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/01.java.html",relativePath:"03.技术/05.面试笔记/01.java.md",key:"v-a6b40bf6",path:"/pages/8632d0/",headers:[{level:2,title:"1.1. Map",slug:"_1-1-map",normalizedTitle:"1.1. map",charIndex:11},{level:3,title:"1.多线程操作hashMap会出现什么问题",slug:"_1-多线程操作hashmap会出现什么问题",normalizedTitle:"1.多线程操作hashmap会出现什么问题",charIndex:24},{level:2,title:"1.2.List",slug:"_1-2-list",normalizedTitle:"1.2.list",charIndex:352},{level:3,title:"1.Iterator与Iterable有什么区别",slug:"_1-iterator与iterable有什么区别",normalizedTitle:"1.iterator与iterable有什么区别",charIndex:365},{level:3,title:"1.判断一个Java对象是否存活",slug:"_1-判断一个java对象是否存活",normalizedTitle:"1.判断一个java对象是否存活",charIndex:517},{level:2,title:"1.常见的异常",slug:"_1-常见的异常",normalizedTitle:"1.常见的异常",charIndex:1316}],headersStr:"1.1. Map 1.多线程操作hashMap会出现什么问题 1.2.List 1.Iterator与Iterable有什么区别 1.判断一个Java对象是否存活 1.常见的异常",content:"# 一.集合\n\n\n# 1.1. Map\n\n\n# 1.多线程操作hashMap会出现什么问题\n\n参考：http://www.imooc.com/article/details/id/292265\n\n> 若当前线程此时获得ertry节点，但是被线程中断无法继续执行，此时线程二进入transfer函数，并把函数顺利执行，此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，因为并发transfer，所以两者都是扩容的同一个链表，当线程一执行到e.next = new table[i] 的时候，由于线程二之前数据迁移的原因导致此时new table[i] 上就有ertry存在，所以线程一执行的时候，会将next节点，设置为自己，导致自己互相使用next引用对方，因此产生链表，导致死循环。\n\n\n# 1.2.List\n\n\n# 1.Iterator与Iterable有什么区别\n\n * List、Set都实现了Collection接口，该接口实现了获取Iterator对象的方法\n * Iterator是一个接口，只有一个获得Iterable对象的方法\n * Iterable则是具体进行遍历的\n\n\n\n\n# 二.GC面试题\n\n\n# 1.判断一个Java对象是否存活\n\n在Java虚拟机中，判断对象是否存活有2种方法：\n\n 1. 引用计数法\n 2. 引用链法（可达性分析法）\n\n1.引用计数法：\n\n * 给 Java 对象添加一个引用计数器\n * 每当有一个地方引用它时，计数器 +1；引用失效则 -1；\n\n2.引用链法：\n\n含3个步骤：\n\n 1. 可达性分析\n    \n    寻找到所有未被引用的的对象，如下图:GCA对象有引用，GCB对象没有引用，则GC B为未被引用对象放入到即将回收的集合中。\n    \n    \n\n 2. 第一次标记 & 筛选\n    \n    所有未被引用的对象并不一定就判断死亡，还需要进行第一次标记；\n    \n    > a. 不筛选：继续留在 ”即将回收“的集合里，等待回收； b. 筛选：从 ”即将回收“的集合取出\n    \n    筛选的标准：该对象是否有必要执行 finalize()方法\n    \n    1. 若有必要执行（人为设置），则筛选出来，进入下一阶段（第二次标记 & 筛选）；\n    \n    2. 若没必要执行，判断该对象死亡，不筛选 并等待回收\n       \n       > 当对象无 finalize()方法 或 finalize()已被虚拟机调用过，则视为“没必要执行”\n\n 3. 第二次标记 & 筛选**（执行finalize方法）**\n    \n    该对象会被放到一个 F-Queue 队列中，并由 虚拟机自动建立、优先级低的Finalizer 线程去执行 队列中该对象的finalize()\n    \n    在执行finalize()过程中，若对象依然没与引用链上的GC Roots 直接关联 或 间接关联（即关联上与GC Roots 关联的对象），那么该对象将被判断死亡，不筛选（留在”即将回收“集合里） 并 等待回收\n\n\n# 三.常规\n\n\n# 1.常见的异常\n\n 1. NullPointException：空指针\n 2. 数组下标越界\n 3. 数组计算错误\n 4. java.util.ConcurrentModificationException并发操作异常\n 5. RejectedExecutorException：拒绝策略异常",normalizedContent:"# 一.集合\n\n\n# 1.1. map\n\n\n# 1.多线程操作hashmap会出现什么问题\n\n参考：http://www.imooc.com/article/details/id/292265\n\n> 若当前线程此时获得ertry节点，但是被线程中断无法继续执行，此时线程二进入transfer函数，并把函数顺利执行，此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，因为并发transfer，所以两者都是扩容的同一个链表，当线程一执行到e.next = new table[i] 的时候，由于线程二之前数据迁移的原因导致此时new table[i] 上就有ertry存在，所以线程一执行的时候，会将next节点，设置为自己，导致自己互相使用next引用对方，因此产生链表，导致死循环。\n\n\n# 1.2.list\n\n\n# 1.iterator与iterable有什么区别\n\n * list、set都实现了collection接口，该接口实现了获取iterator对象的方法\n * iterator是一个接口，只有一个获得iterable对象的方法\n * iterable则是具体进行遍历的\n\n\n\n\n# 二.gc面试题\n\n\n# 1.判断一个java对象是否存活\n\n在java虚拟机中，判断对象是否存活有2种方法：\n\n 1. 引用计数法\n 2. 引用链法（可达性分析法）\n\n1.引用计数法：\n\n * 给 java 对象添加一个引用计数器\n * 每当有一个地方引用它时，计数器 +1；引用失效则 -1；\n\n2.引用链法：\n\n含3个步骤：\n\n 1. 可达性分析\n    \n    寻找到所有未被引用的的对象，如下图:gca对象有引用，gcb对象没有引用，则gc b为未被引用对象放入到即将回收的集合中。\n    \n    \n\n 2. 第一次标记 & 筛选\n    \n    所有未被引用的对象并不一定就判断死亡，还需要进行第一次标记；\n    \n    > a. 不筛选：继续留在 ”即将回收“的集合里，等待回收； b. 筛选：从 ”即将回收“的集合取出\n    \n    筛选的标准：该对象是否有必要执行 finalize()方法\n    \n    1. 若有必要执行（人为设置），则筛选出来，进入下一阶段（第二次标记 & 筛选）；\n    \n    2. 若没必要执行，判断该对象死亡，不筛选 并等待回收\n       \n       > 当对象无 finalize()方法 或 finalize()已被虚拟机调用过，则视为“没必要执行”\n\n 3. 第二次标记 & 筛选**（执行finalize方法）**\n    \n    该对象会被放到一个 f-queue 队列中，并由 虚拟机自动建立、优先级低的finalizer 线程去执行 队列中该对象的finalize()\n    \n    在执行finalize()过程中，若对象依然没与引用链上的gc roots 直接关联 或 间接关联（即关联上与gc roots 关联的对象），那么该对象将被判断死亡，不筛选（留在”即将回收“集合里） 并 等待回收\n\n\n# 三.常规\n\n\n# 1.常见的异常\n\n 1. nullpointexception：空指针\n 2. 数组下标越界\n 3. 数组计算错误\n 4. java.util.concurrentmodificationexception并发操作异常\n 5. rejectedexecutorexception：拒绝策略异常",charsets:{cjk:!0},lastUpdated:"2021/10/19, 17:13:24"},{title:"操作系统",frontmatter:{title:"操作系统",date:"2021-07-09T14:58:45.000Z",permalink:"/pages/1dde6d/",categories:["技术","面试笔记"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html",relativePath:"03.技术/05.面试笔记/02.操作系统.md",key:"v-687be266",path:"/pages/1dde6d/",headers:[{level:2,title:"1.kill -9 和kill -15的区别",slug:"_1-kill-9-和kill-15的区别",normalizedTitle:"1.kill -9 和kill -15的区别",charIndex:2}],headersStr:"1.kill -9 和kill -15的区别",content:'# 1.kill -9 和kill -15的区别\n\n> HUP 1 终端断线\n> \n> INT 2 中断（同 Ctrl + C）\n> \n> QUIT 3 退出（同 Ctrl + \\）\n> \n> TERM 15 终止\n> \n> KILL 9 强制终止\n> \n> CONT 18 继续（与STOP相反， fg/bg命令）\n> \n> STOP 19 暂停（同 Ctrl + Z）\n\n比较常用的就是强制终止信号：9和终止信号：15，另外，中断信号：2其实就是我们前文提到的Ctrl + C结束前台进程。\n\n那么，kill -9 和 kill -15到底有什么区别呢？该如何选择呢？\n\n * kill 命令默认为kill -15，即终止，该操作只是通知对应的进程要进行"安全、干净的退出"，有可能会被阻塞或者其他问题导致无法成功，从而终止杀进程；\n * kill -15会进行其他的操作，比如java中关闭tomacat的连接、执行定时任务等等；\n * kill -9会直接强制终止，停止所有操作，直接终止应用，那么会造成脏数据、定时任务未执行完成等等。',normalizedContent:'# 1.kill -9 和kill -15的区别\n\n> hup 1 终端断线\n> \n> int 2 中断（同 ctrl + c）\n> \n> quit 3 退出（同 ctrl + \\）\n> \n> term 15 终止\n> \n> kill 9 强制终止\n> \n> cont 18 继续（与stop相反， fg/bg命令）\n> \n> stop 19 暂停（同 ctrl + z）\n\n比较常用的就是强制终止信号：9和终止信号：15，另外，中断信号：2其实就是我们前文提到的ctrl + c结束前台进程。\n\n那么，kill -9 和 kill -15到底有什么区别呢？该如何选择呢？\n\n * kill 命令默认为kill -15，即终止，该操作只是通知对应的进程要进行"安全、干净的退出"，有可能会被阻塞或者其他问题导致无法成功，从而终止杀进程；\n * kill -15会进行其他的操作，比如java中关闭tomacat的连接、执行定时任务等等；\n * kill -9会直接强制终止，停止所有操作，直接终止应用，那么会造成脏数据、定时任务未执行完成等等。',charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"Layui使用",frontmatter:{title:"Layui使用",date:"2021-07-09T15:02:45.000Z",permalink:"/pages/9ff38f/",categories:["前端","Layui"],tags:[null]},regularPath:"/02.%E5%89%8D%E7%AB%AF/01.Layui/00.Layui%E4%BD%BF%E7%94%A8.html",relativePath:"02.前端/01.Layui/00.Layui使用.md",key:"v-4edf1e42",path:"/pages/9ff38f/",headers:[{level:2,title:"1.弹框使用",slug:"_1-弹框使用",normalizedTitle:"1.弹框使用",charIndex:14}],headersStr:"1.弹框使用",content:'# Layui使用\n\n\n# 1.弹框使用\n\nlayer.msg("请填写问题内容！！！",{icon: 1});//成功\nlayer.msg("请填写问题内容！！！",{icon: 2});//失败\nlayer.msg("请填写问题内容！！！",{icon: 2});//警告\nlayer.msg("请填写问题内容！！！",{icon: 2});//加锁表情\nlayer.msg("请填写问题内容！！！",{icon: 2});//哭的脸\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# layui使用\n\n\n# 1.弹框使用\n\nlayer.msg("请填写问题内容！！！",{icon: 1});//成功\nlayer.msg("请填写问题内容！！！",{icon: 2});//失败\nlayer.msg("请填写问题内容！！！",{icon: 2});//警告\nlayer.msg("请填写问题内容！！！",{icon: 2});//加锁表情\nlayer.msg("请填写问题内容！！！",{icon: 2});//哭的脸\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"SpringBoot面试笔记",frontmatter:{title:"SpringBoot面试笔记",date:"2021-07-08T19:08:11.000Z",permalink:"/pages/1861bf/",categories:["面试笔记","SpringBoot"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/00.SpringBoot%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html",relativePath:"03.技术/05.面试笔记/00.SpringBoot面试笔记.md",key:"v-f1aa535c",path:"/pages/1861bf/",headers:[{level:2,title:"1.@Transactional的使用",slug:"_1-transactional的使用",normalizedTitle:"1.@transactional的使用",charIndex:17},{level:3,title:"1.@Transactional的易错点：",slug:"_1-transactional的易错点",normalizedTitle:"1.@transactional的易错点：",charIndex:41},{level:3,title:"2.@Transactional的使用",slug:"_2-transactional的使用",normalizedTitle:"2.@transactional的使用",charIndex:470},{level:2,title:"2.数据库隔离级别",slug:"_2-数据库隔离级别",normalizedTitle:"2.数据库隔离级别",charIndex:643}],headersStr:"1.@Transactional的使用 1.@Transactional的易错点： 2.@Transactional的使用 2.数据库隔离级别",content:"# SpringBoot\n\n\n# 1.@Transactional的使用\n\n\n# 1.@Transactional的易错点：\n\n 1. ransactional默认只会在RuntimeExcep**tion才会回滚数据，Exception不会回滚数据\n\n> 重点：Transactional默认只会在RuntimeException才会回滚数据，Exception不会回滚数据\n> \n> \n> \n> 解决办法：\n> \n> 方法一：指定回滚的异常，我直接就指定了Exception。也就是只要是Exception或者是Exception的子类，那么在此方法中，都会进行回滚。\n> \n> @Transactional(rollbackFor=Exception.class)\n> \n> \n> 1\n> \n> \n> 方法二:\n> \n> 使用try、catch的时候不要抛出Exception异常，而是抛出RuntimeException\n\n2.同一个类中的方法都注解了Transactional，是不会生效的。\n\n> 解决：放在另一个类中\n\n\n# 2.@Transactional的使用\n\n1.默认，如果当前方法有事务，就使用该事务\n@Transactional(propagation = Propagation.REQUIRES)\n2.另起一个事务\n@Transactional(propagation = Propagation.REQUIRES_NEW)\n\n\n1\n2\n3\n4\n\n\n\n# 2.数据库隔离级别\n\n 1. 事务的基本要素：\n    \n    * 原子性：要么成功，要么失败\n    * 一致性：修改前后，数据完整性要一致\n    * 隔离性：各个事务互不干扰\n    * 持久性：事务完成，保存到数据库中\n\n 2. 事务并发的问题：\n    \n    * 脏读：读到了事务没有提交的数据\n    * 不可重复读：两次相同查询，读到了不同的数据（针对于修改）\n    * 幻读：在读数据之后又进行了插入或删除；（针对于新增、删除）\n\n 3. 隔离级别：\n    \n    * 读未提交：读到了未提交的数据\n    * 读提交：只读提交后的数据\n    * 可重复度：同一个事务中，两次相同查询，另一个事务修改了数据，两次查询的结果是一样，不会读到修改后的数据。\n    * 串行化：有顺序的执行\n\n 4. Spirng中使用：spring中默认的事务隔离级别是根据数据库的默认隔离级别\n    \n    * mysql默认隔离级别：可重复度\n    * Oracle默认隔离级别：串行化\n    \n    例子一：使用默认的隔离级别（可重复度）：两次查询中，又一次修改，不会读取到修改的数据\n    \n        @Transactional\n        @Override\n        public void getShop(){\n            Shop shop1 = shopMapper.selectById(1);\n            System.out.println(shop1.getPrice());\n            Shop shop2 = shopMapper.selectById(1);\n            System.out.println(shop2.getPrice());\n        }\n        //在第一次查询后打断点，然后用Navicat修改数据，执行\n        输出：\n        600.0\n    \t600.0\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n    \n    例子二：修改为读提交隔离级别：读提交的数据，只要提交了就会读到\n    \n        @Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.READ_COMMITTED)\n        @Override\n        public void getShop(){\n            Shop shop1 = shopMapper.selectById(1);\n            System.out.println(shop1.getPrice());\n            Shop shop2 = shopMapper.selectById(1);\n            System.out.println(shop2.getPrice());\n        }\n        //在第一次查询后打断点，然后用Navicat修改数据，执行\n        输出：\n        600.0\n    \t60.0\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    ",normalizedContent:"# springboot\n\n\n# 1.@transactional的使用\n\n\n# 1.@transactional的易错点：\n\n 1. ransactional默认只会在runtimeexcep**tion才会回滚数据，exception不会回滚数据\n\n> 重点：transactional默认只会在runtimeexception才会回滚数据，exception不会回滚数据\n> \n> \n> \n> 解决办法：\n> \n> 方法一：指定回滚的异常，我直接就指定了exception。也就是只要是exception或者是exception的子类，那么在此方法中，都会进行回滚。\n> \n> @transactional(rollbackfor=exception.class)\n> \n> \n> 1\n> \n> \n> 方法二:\n> \n> 使用try、catch的时候不要抛出exception异常，而是抛出runtimeexception\n\n2.同一个类中的方法都注解了transactional，是不会生效的。\n\n> 解决：放在另一个类中\n\n\n# 2.@transactional的使用\n\n1.默认，如果当前方法有事务，就使用该事务\n@transactional(propagation = propagation.requires)\n2.另起一个事务\n@transactional(propagation = propagation.requires_new)\n\n\n1\n2\n3\n4\n\n\n\n# 2.数据库隔离级别\n\n 1. 事务的基本要素：\n    \n    * 原子性：要么成功，要么失败\n    * 一致性：修改前后，数据完整性要一致\n    * 隔离性：各个事务互不干扰\n    * 持久性：事务完成，保存到数据库中\n\n 2. 事务并发的问题：\n    \n    * 脏读：读到了事务没有提交的数据\n    * 不可重复读：两次相同查询，读到了不同的数据（针对于修改）\n    * 幻读：在读数据之后又进行了插入或删除；（针对于新增、删除）\n\n 3. 隔离级别：\n    \n    * 读未提交：读到了未提交的数据\n    * 读提交：只读提交后的数据\n    * 可重复度：同一个事务中，两次相同查询，另一个事务修改了数据，两次查询的结果是一样，不会读到修改后的数据。\n    * 串行化：有顺序的执行\n\n 4. spirng中使用：spring中默认的事务隔离级别是根据数据库的默认隔离级别\n    \n    * mysql默认隔离级别：可重复度\n    * oracle默认隔离级别：串行化\n    \n    例子一：使用默认的隔离级别（可重复度）：两次查询中，又一次修改，不会读取到修改的数据\n    \n        @transactional\n        @override\n        public void getshop(){\n            shop shop1 = shopmapper.selectbyid(1);\n            system.out.println(shop1.getprice());\n            shop shop2 = shopmapper.selectbyid(1);\n            system.out.println(shop2.getprice());\n        }\n        //在第一次查询后打断点，然后用navicat修改数据，执行\n        输出：\n        600.0\n    \t600.0\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n    \n    例子二：修改为读提交隔离级别：读提交的数据，只要提交了就会读到\n    \n        @transactional(propagation = propagation.required,isolation = isolation.read_committed)\n        @override\n        public void getshop(){\n            shop shop1 = shopmapper.selectbyid(1);\n            system.out.println(shop1.getprice());\n            shop shop2 = shopmapper.selectbyid(1);\n            system.out.println(shop2.getprice());\n        }\n        //在第一次查询后打断点，然后用navicat修改数据，执行\n        输出：\n        600.0\n    \t60.0\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    ",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"数据结构",frontmatter:{title:"数据结构",date:"2021-07-09T14:58:45.000Z",permalink:"/pages/18b13f/",categories:["技术","面试笔记"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/04.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",relativePath:"03.技术/05.面试笔记/04.数据结构.md",key:"v-fc837a0e",path:"/pages/18b13f/",headers:[{level:2,title:"1.树的遍历",slug:"_1-树的遍历",normalizedTitle:"1.树的遍历",charIndex:10},{level:3,title:"1.先序遍历（根左右)",slug:"_1-先序遍历-根左右",normalizedTitle:"1.先序遍历（根左右)",charIndex:21},{level:2,title:"2.链表",slug:"_2-链表",normalizedTitle:"2.链表",charIndex:584}],headersStr:"1.树的遍历 1.先序遍历（根左右) 2.链表",content:"# 一.树\n\n\n# 1.树的遍历\n\n\n# 1.先序遍历（根左右)\n\n//递归方法\npublic void recursivePreOrder(TreeNode p){\n    if (p == null) return;\n    System.out.println(p);\n    recursivePreOrder(p.left);\n    recursivePreOrder(p.right);\n}\n//非递归 可以把所有的根节点放入到栈中\npublic void iterativePreOrder(TreeNode p){\n   if (p == null) return;\n   Stack<TreeNode> stack = new Stack<TreeNode>();\n   stack.push(p);\n   while (!stack.empty()) {\n      p = stack.pop();\n      visit(p);\n      if (p.right != null) stack.push(p.right);\n      if (p.left != null) stack.push(p.left);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2.链表\n\n1.合并两个链表，并从小到大排序；\n\n思路：\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    ListNode result=new ListNode(-1);\n    ListNode temp=result;//定义temp，temp会一直往后面移动，如果直接使用result那么最后只有返回最后一个元素\n    while(l1!=null && l2!=null){\n        if(l1.val<=l2.val){\n            temp.next=l1;//temp的下一个为l1\n            l1=l1.next;//l1等于l1的下一个\n        }else{\n            temp.next=l2;//temp的下一个为l2\n            l2=l2.next;//l2等于l2的下一个\n        }\n        //需要把temp移动到下一个位置\n        temp=temp.next;\n    }\n    //判断最后还存在一个的情况\n    if(l1 == null){\n        temp.next=l2;\n    }else{\n        temp.next=l1;\n    }\n    return result.next;//排除第一个初始化的-1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",normalizedContent:"# 一.树\n\n\n# 1.树的遍历\n\n\n# 1.先序遍历（根左右)\n\n//递归方法\npublic void recursivepreorder(treenode p){\n    if (p == null) return;\n    system.out.println(p);\n    recursivepreorder(p.left);\n    recursivepreorder(p.right);\n}\n//非递归 可以把所有的根节点放入到栈中\npublic void iterativepreorder(treenode p){\n   if (p == null) return;\n   stack<treenode> stack = new stack<treenode>();\n   stack.push(p);\n   while (!stack.empty()) {\n      p = stack.pop();\n      visit(p);\n      if (p.right != null) stack.push(p.right);\n      if (p.left != null) stack.push(p.left);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2.链表\n\n1.合并两个链表，并从小到大排序；\n\n思路：\n\nclass listnode {\n    int val;\n    listnode next;\n    listnode() {}\n    listnode(int val) { this.val = val; }\n    listnode(int val, listnode next) { this.val = val; this.next = next; }\n}\n\npublic listnode mergetwolists(listnode l1, listnode l2) {\n    listnode result=new listnode(-1);\n    listnode temp=result;//定义temp，temp会一直往后面移动，如果直接使用result那么最后只有返回最后一个元素\n    while(l1!=null && l2!=null){\n        if(l1.val<=l2.val){\n            temp.next=l1;//temp的下一个为l1\n            l1=l1.next;//l1等于l1的下一个\n        }else{\n            temp.next=l2;//temp的下一个为l2\n            l2=l2.next;//l2等于l2的下一个\n        }\n        //需要把temp移动到下一个位置\n        temp=temp.next;\n    }\n    //判断最后还存在一个的情况\n    if(l1 == null){\n        temp.next=l2;\n    }else{\n        temp.next=l1;\n    }\n    return result.next;//排除第一个初始化的-1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"高频面试",frontmatter:{title:"高频面试",date:"2021-07-13T15:35:54.000Z",permalink:"/pages/b28288/",categories:["技术","面试笔记"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/03.%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95.html",relativePath:"03.技术/05.面试笔记/03.高频面试.md",key:"v-2e17fd90",path:"/pages/b28288/",headers:[{level:2,title:"一.java",slug:"一-java",normalizedTitle:"一.java",charIndex:12},{level:3,title:"1.GC回收机制",slug:"_1-gc回收机制",normalizedTitle:"1.gc回收机制",charIndex:23},{level:3,title:"2.如何判断对象是否死亡（两种方法）。",slug:"_2-如何判断对象是否死亡-两种方法-。",normalizedTitle:"2.如何判断对象是否死亡（两种方法）。",charIndex:721},{level:3,title:"3.如何判断一个常量是废弃常量",slug:"_3-如何判断一个常量是废弃常量",normalizedTitle:"3.如何判断一个常量是废弃常量",charIndex:909},{level:3,title:"4.如何判断一个类是无用的类",slug:"_4-如何判断一个类是无用的类",normalizedTitle:"4.如何判断一个类是无用的类",charIndex:1059},{level:3,title:"5.垃圾收集有哪些算法，各自的特点？",slug:"_5-垃圾收集有哪些算法-各自的特点",normalizedTitle:"5.垃圾收集有哪些算法，各自的特点？",charIndex:1201},{level:3,title:"6.常见的垃圾回收器有哪些？",slug:"_6-常见的垃圾回收器有哪些",normalizedTitle:"6.常见的垃圾回收器有哪些？",charIndex:1713},{level:3,title:"7.sleep和wait的区别",slug:"_7-sleep和wait的区别",normalizedTitle:"7.sleep和wait的区别",charIndex:3048},{level:3,title:"8.Synchronized的原理",slug:"_8-synchronized的原理",normalizedTitle:"8.synchronized的原理",charIndex:3258},{level:3,title:"9.volatile",slug:"_9-volatile",normalizedTitle:"9.volatile",charIndex:3604},{level:3,title:"10.常见的阻塞队列",slug:"_10-常见的阻塞队列",normalizedTitle:"10.常见的阻塞队列",charIndex:3708},{level:3,title:"11.GCRoot有哪些",slug:"_11-gcroot有哪些",normalizedTitle:"11.gcroot有哪些",charIndex:3937},{level:2,title:"二.数据结构",slug:"二-数据结构",normalizedTitle:"二.数据结构",charIndex:4075},{level:2,title:"三.网络",slug:"三-网络",normalizedTitle:"三.网络",charIndex:4128},{level:2,title:"四.操作系统",slug:"四-操作系统",normalizedTitle:"四.操作系统",charIndex:4179},{level:3,title:"1.进程与线程的区别：",slug:"_1-进程与线程的区别",normalizedTitle:"1.进程与线程的区别：",charIndex:4190},{level:3,title:"2.进程调度",slug:"_2-进程调度",normalizedTitle:"2.进程调度",charIndex:4734},{level:2,title:"五.Mysql",slug:"五-mysql",normalizedTitle:"五.mysql",charIndex:5430},{level:3,title:"1.聚集索引和非聚集索引",slug:"_1-聚集索引和非聚集索引",normalizedTitle:"1.聚集索引和非聚集索引",charIndex:5442},{level:3,title:"2.分页查找优化",slug:"_2-分页查找优化",normalizedTitle:"2.分页查找优化",charIndex:5869},{level:3,title:"3.为什么mysql索引要使用B+树，而不是B树，红黑树",slug:"_3-为什么mysql索引要使用b-树-而不是b树-红黑树",normalizedTitle:"3.为什么mysql索引要使用b+树，而不是b树，红黑树",charIndex:6226},{level:2,title:"六.redis",slug:"六-redis",normalizedTitle:"六.redis",charIndex:6707},{level:3,title:"1. redis为什么采用跳表而不是红黑树？？",slug:"_1-redis为什么采用跳表而不是红黑树",normalizedTitle:"1. redis为什么采用跳表而不是红黑树？？",charIndex:6719},{level:3,title:"2.Redis的淘汰策略",slug:"_2-redis的淘汰策略",normalizedTitle:"2.redis的淘汰策略",charIndex:7277}],headersStr:"一.java 1.GC回收机制 2.如何判断对象是否死亡（两种方法）。 3.如何判断一个常量是废弃常量 4.如何判断一个类是无用的类 5.垃圾收集有哪些算法，各自的特点？ 6.常见的垃圾回收器有哪些？ 7.sleep和wait的区别 8.Synchronized的原理 9.volatile 10.常见的阻塞队列 11.GCRoot有哪些 二.数据结构 三.网络 四.操作系统 1.进程与线程的区别： 2.进程调度 五.Mysql 1.聚集索引和非聚集索引 2.分页查找优化 3.为什么mysql索引要使用B+树，而不是B树，红黑树 六.redis 1. redis为什么采用跳表而不是红黑树？？ 2.Redis的淘汰策略",content:'# 高频面试题\n\n\n# 一.java\n\n\n# 1.GC回收机制\n\n年轻代（Young Generation）\n\n1.所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。\n\n2.新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。\n\n3.当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收\n\n4.新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)\n\n年老代（Old Generation）\n\n1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。\n\n2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。\n\n\n# 2.如何判断对象是否死亡（两种方法）。\n\n 1. 引用计数法：对象被引用一次就+1，引用失效就-1,若等于0则对象死亡。\n 2. 可达性分析：\n    1. 找出所有未被引用的对象，并放入到不可达集合中；\n    2. 筛选出所有的未执行finalisize()方法或已执行一次finalisize()的对象；\n    3. 若对象还是没用引用，则判断对象以及死亡。\n\n\n# 3.如何判断一个常量是废弃常量\n\n> 若常量没有被引用即是废弃常量。\n\n假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。\n\n\n# 4.如何判断一个类是无用的类\n\n类需要同时满足下面 3 个条件才能算是 “无用的类” ：\n\n 1. 类的实例已经被回收\n 2. 类的classLoader已经被回收\n 3. 类的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n\n# 5.垃圾收集有哪些算法，各自的特点？\n\n 1. 标记-清除：标记所有的不需要回收的对象，清除所有的未标记对象；\n    \n    缺点：空间利用率低\n    \n    \n\n 2. 标记-复制:标记所有的不需要回收对象，把内存空间分为两部分，清除回收对象，把不需要回收对象复制到另一边。\n    \n    \n\n 3. 标记-整理:标记所有的不需要回收对象，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n    \n    \n\n 4. 分代收集算法：（新生区(Eden、from 、to)、老生区)\n    \n    当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n    \n    比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n\n\n# 6.常见的垃圾回收器有哪些？\n\n 1. 串行(Serial)收集器：停止所有工作流程进行垃圾回收(单线程)\n\n 2. 并行收集器:停止所有工作流程进行垃圾回收(多线程)\n\n 3. CMS收集器:垃圾回收和用户线程同时进行；\n    \n    CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\n    \n    * 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；\n    * 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n    * 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\n    * 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\n    \n    从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：\n    \n    * 对 CPU 资源敏感；\n    * 无法处理浮动垃圾；\n    * 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\n\n 4. G1收集器：\n    \n    它具备以下特点：\n    \n    * 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。\n    * 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。\n    * 空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。\n    * 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。\n    \n    G1 收集器的运作大致分为以下几个步骤：\n    \n    * 初始标记\n    * 并发标记\n    * 最终标记\n    * 筛选回收\n    \n    G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\n\n\n# 7.sleep和wait的区别\n\n * sleep属于Thread类，wait属于Object类\n * sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态；线程不会释放对象锁。\n * 调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备。\n\n\n# 8.Synchronized的原理\n\njdk1.6之前：直接使用重量锁，需要借助操作系统，直接从用户态切换为内核态，耗资源\n\njdk1.6之后：\n\nSynchronized减重的过程，通常被称为锁膨胀或是锁升级的过程。 主要步骤是：\n\n * 先是通过偏向锁来获取锁，解决了虽然有同步但无竞争的场景下锁的消耗。\n   \n   若当前线程之前获得过锁，就会优先获取锁，内部维护了一个变量，每次获得锁+1\n\n * 再是通过对象头的Mark Word来实现的轻量级锁，通过**轻量级锁（CAS）**如果还有竞争，那么继续升级。\n\n * 升级为自旋锁，如果达到最大自旋次数了，那么就直接升级为重量级锁，所有未获取锁的线程都阻塞等待。\n   \n   当一个线程请求被锁住的对象，让该线程等待一会\n\n\n# 9.volatile\n\n 1. volatile的三大特效\n    * 可见性：一旦修改，另外的线程能马上得到新值\n    * 防止指令重排（顺序性）\n    * 不能保证原子性：要么成功，要么失败\n\n\n# 10.常见的阻塞队列\n\n 1. ArrayBlockingQueue： 底层维护了一个定长的数组（长度固定）；\n 2. LinkedBlockingQueue：底层链表，长度无限，默认为int的最大长度；\n 3. SynchrousQueue：只做中转，来一个阻塞，直到上一个执行完成；\n 4. PriorityBlockingQueue：优先级队列；\n 5. DelayQueue：延时队列，可以延迟执行，比如淘宝订单未支付，30分钟后取消订单；\n\n\n# 11.GCRoot有哪些\n\n 1. 虚拟机栈：栈中的本地变量引用的对象\n 2. native方法引用的对象：navate指在java平台使用C\n 3. 方法区中的静态变量和常量的引用\n\n----------------------------------------\n\n\n# 二.数据结构\n\n----------------------------------------\n\n\n# 三.网络\n\n----------------------------------------\n\n\n# 四.操作系统\n\n\n# 1.进程与线程的区别：\n\n看了一遍排在前面的答案，类似”**进程是资源分配的最小单位，线程是CPU调度的最小单位“**这样的回答感觉太抽象，都不太容易让人理解。\n\n做个简单的比喻：进程=火车，线程=车厢\n\n * 线程在进程下行进（单纯的车厢无法运行）\n * 一个进程可以包含多个线程（一辆火车可以有多个车厢）\n * 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）\n * 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）\n * 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）\n * 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）\n * 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）\n * 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"\n * 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”\n\n\n# 2.进程调度\n\n 1. 先来先服务调度算法：先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。\n 2. 短作业(进程)优先调度算法：短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。\n 3. 高优先权优先调度算法：为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。\n\n----------------------------------------\n\n\n# 五.Mysql\n\n\n# 1.聚集索引和非聚集索引\n\n聚集索引\n\n通常由主键表示，打个比方，一个表就像是我们以前用的新华字典，聚集索引就像是拼音目录，而每个字存放的页码就是我们的数据物理地址，我们如果要查询一个“哇”字，我们只需要查询“哇”字对应在新华字典拼音目录对应的页码，就可以查询到对应的“哇”字所在的位置，而拼音目录对应的A-Z的字顺序，和新华字典实际存储的字的顺序A-Z也是一样的，如果我们中文新出了一个字，拼音开头第一个是B，那么他插入的时候也要按照拼音目录顺序插入到A字的后面，\n\n非聚集（unclustered）索引。\n\n> 定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。\n\n其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致。\n\n\n# 2.分页查找优化\n\n 1. 分表、加索引\n 2. 在分页之前加条件，比如SELECT * FROM your_table WHERE pk>=1000 ORDER BY pk ASC LIMIT 0,20\n 3. 查询数据只查询主键数据，贼快\n 4. 如果我们也要查询所有列，有两种方法，一种是id>=的形式，另一种就是利用join，看下实际情况：\n\n> SELECT * FROM product WHERE ID > =(select id from product limit 866613, 1) limit 20\n\n> SELECT * FROM product a JOIN (select id from product limit 866613, 20) b ON a.ID = b.id\n\n\n# 3.为什么mysql索引要使用B+树，而不是B树，红黑树\n\n由于B树的所有节点都存储了数据，而B+树只有叶子节点存储数据，并且叶子节点还存储了下节点的指针，数据库中会存在范围查找，如果用B树那么只能每次一个一个的去查找；而B+树查找到后，通过指针可以找到区间内的数据。\n\n参考：https://www.cnblogs.com/leijiangtao/p/4662779.html\n\n树的深度决定了IO操作的次数\n\n 1. B树应用\n    \n    主要用于文件系统以及部分数据库索引（MongoDB） 而Mysql是用B+树的。\n\n 2. B+树\n\n> B+树的最大元素始终位于根节点当中。所有叶子节点包含了全量元素信息，并且每一个叶子节点都带有指向 下一个节点指针，形成了一个有序链表。\n\nB树和B+树的区别：\n\n1.单一节点存储更多的元素，使得查询的IO次数更少。\n\n2.所有查询都要查找到叶子节点，查询性能稳定。\n\n3.所有叶子节点形成有序链表，便于范围查询。\n\n----------------------------------------\n\n\n# 六.redis\n\n\n# 1. redis为什么采用跳表而不是红黑树？？\n\n> 在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。 从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。 查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。 从算法实现难度上来比较，skiplist比平衡树要简单得多。\n\n\n# 2.Redis的淘汰策略\n\n * noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。 大多数写命令都会导致占用更多的内存(有极少数会例外, 如 DEL )。\n * allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。\n * volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。\n * allkeys-random: 所有key通用; 随机删除一部分 key。\n * volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。\n * volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。',normalizedContent:'# 高频面试题\n\n\n# 一.java\n\n\n# 1.gc回收机制\n\n年轻代（young generation）\n\n1.所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。\n\n2.新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个eden区，两个 survivor区(一般而言)。大部分对象在eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。\n\n3.当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次full gc，也就是新生代、老年代都进行回收\n\n4.新生代发生的gc也叫做minor gc，minorgc发生频率比较高(不一定等eden区满了才触发)\n\n年老代（old generation）\n\n1.在年轻代中经历了n次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。\n\n2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发major gc即full gc，full gc发生频率比较低，老年代对象存活时间比较长，存活率标记高。\n\n\n# 2.如何判断对象是否死亡（两种方法）。\n\n 1. 引用计数法：对象被引用一次就+1，引用失效就-1,若等于0则对象死亡。\n 2. 可达性分析：\n    1. 找出所有未被引用的对象，并放入到不可达集合中；\n    2. 筛选出所有的未执行finalisize()方法或已执行一次finalisize()的对象；\n    3. 若对象还是没用引用，则判断对象以及死亡。\n\n\n# 3.如何判断一个常量是废弃常量\n\n> 若常量没有被引用即是废弃常量。\n\n假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 string 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。\n\n\n# 4.如何判断一个类是无用的类\n\n类需要同时满足下面 3 个条件才能算是 “无用的类” ：\n\n 1. 类的实例已经被回收\n 2. 类的classloader已经被回收\n 3. 类的java.lang.class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n\n# 5.垃圾收集有哪些算法，各自的特点？\n\n 1. 标记-清除：标记所有的不需要回收的对象，清除所有的未标记对象；\n    \n    缺点：空间利用率低\n    \n    \n\n 2. 标记-复制:标记所有的不需要回收对象，把内存空间分为两部分，清除回收对象，把不需要回收对象复制到另一边。\n    \n    \n\n 3. 标记-整理:标记所有的不需要回收对象，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n    \n    \n\n 4. 分代收集算法：（新生区(eden、from 、to)、老生区)\n    \n    当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n    \n    比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n\n\n# 6.常见的垃圾回收器有哪些？\n\n 1. 串行(serial)收集器：停止所有工作流程进行垃圾回收(单线程)\n\n 2. 并行收集器:停止所有工作流程进行垃圾回收(多线程)\n\n 3. cms收集器:垃圾回收和用户线程同时进行；\n    \n    cms 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\n    \n    * 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；\n    * 并发标记： 同时开启 gc 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 gc 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n    * 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\n    * 并发清除： 开启用户线程，同时 gc 线程开始对未标记的区域做清扫。\n    \n    从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：\n    \n    * 对 cpu 资源敏感；\n    * 无法处理浮动垃圾；\n    * 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\n\n 4. g1收集器：\n    \n    它具备以下特点：\n    \n    * 并行与并发：g1 能充分利用 cpu、多核环境下的硬件优势，使用多个 cpu（cpu 或者 cpu 核心）来缩短 stop-the-world 停顿时间。部分其他收集器原本需要停顿 java 线程执行的 gc 动作，g1 收集器仍然可以通过并发的方式让 java 程序继续执行。\n    * 分代收集：虽然 g1 可以不需要其他收集器配合就能独立管理整个 gc 堆，但是还是保留了分代的概念。\n    * 空间整合：与 cms 的“标记-清理”算法不同，g1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。\n    * 可预测的停顿：这是 g1 相对于 cms 的另一个大优势，降低停顿时间是 g1 和 cms 共同的关注点，但 g1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 m 毫秒的时间片段内。\n    \n    g1 收集器的运作大致分为以下几个步骤：\n    \n    * 初始标记\n    * 并发标记\n    * 最终标记\n    * 筛选回收\n    \n    g1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 region(这也就是它的名字 garbage-first 的由来) 。这种使用 region 划分内存空间以及有优先级的区域回收方式，保证了 g1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\n\n\n# 7.sleep和wait的区别\n\n * sleep属于thread类，wait属于object类\n * sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态；线程不会释放对象锁。\n * 调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备。\n\n\n# 8.synchronized的原理\n\njdk1.6之前：直接使用重量锁，需要借助操作系统，直接从用户态切换为内核态，耗资源\n\njdk1.6之后：\n\nsynchronized减重的过程，通常被称为锁膨胀或是锁升级的过程。 主要步骤是：\n\n * 先是通过偏向锁来获取锁，解决了虽然有同步但无竞争的场景下锁的消耗。\n   \n   若当前线程之前获得过锁，就会优先获取锁，内部维护了一个变量，每次获得锁+1\n\n * 再是通过对象头的mark word来实现的轻量级锁，通过**轻量级锁（cas）**如果还有竞争，那么继续升级。\n\n * 升级为自旋锁，如果达到最大自旋次数了，那么就直接升级为重量级锁，所有未获取锁的线程都阻塞等待。\n   \n   当一个线程请求被锁住的对象，让该线程等待一会\n\n\n# 9.volatile\n\n 1. volatile的三大特效\n    * 可见性：一旦修改，另外的线程能马上得到新值\n    * 防止指令重排（顺序性）\n    * 不能保证原子性：要么成功，要么失败\n\n\n# 10.常见的阻塞队列\n\n 1. arrayblockingqueue： 底层维护了一个定长的数组（长度固定）；\n 2. linkedblockingqueue：底层链表，长度无限，默认为int的最大长度；\n 3. synchrousqueue：只做中转，来一个阻塞，直到上一个执行完成；\n 4. priorityblockingqueue：优先级队列；\n 5. delayqueue：延时队列，可以延迟执行，比如淘宝订单未支付，30分钟后取消订单；\n\n\n# 11.gcroot有哪些\n\n 1. 虚拟机栈：栈中的本地变量引用的对象\n 2. native方法引用的对象：navate指在java平台使用c\n 3. 方法区中的静态变量和常量的引用\n\n----------------------------------------\n\n\n# 二.数据结构\n\n----------------------------------------\n\n\n# 三.网络\n\n----------------------------------------\n\n\n# 四.操作系统\n\n\n# 1.进程与线程的区别：\n\n看了一遍排在前面的答案，类似”**进程是资源分配的最小单位，线程是cpu调度的最小单位“**这样的回答感觉太抽象，都不太容易让人理解。\n\n做个简单的比喻：进程=火车，线程=车厢\n\n * 线程在进程下行进（单纯的车厢无法运行）\n * 一个进程可以包含多个线程（一辆火车可以有多个车厢）\n * 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）\n * 同一进程下不同线程间数据很易共享（a车厢换到b车厢很容易）\n * 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）\n * 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）\n * 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）\n * 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"\n * 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”\n\n\n# 2.进程调度\n\n 1. 先来先服务调度算法：先来先服务(fcfs)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用fcfs算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。\n 2. 短作业(进程)优先调度算法：短作业(进程)优先调度算法sj(p)f，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(sjf)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(spf)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。\n 3. 高优先权优先调度算法：为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(fpf)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。\n\n----------------------------------------\n\n\n# 五.mysql\n\n\n# 1.聚集索引和非聚集索引\n\n聚集索引\n\n通常由主键表示，打个比方，一个表就像是我们以前用的新华字典，聚集索引就像是拼音目录，而每个字存放的页码就是我们的数据物理地址，我们如果要查询一个“哇”字，我们只需要查询“哇”字对应在新华字典拼音目录对应的页码，就可以查询到对应的“哇”字所在的位置，而拼音目录对应的a-z的字顺序，和新华字典实际存储的字的顺序a-z也是一样的，如果我们中文新出了一个字，拼音开头第一个是b，那么他插入的时候也要按照拼音目录顺序插入到a字的后面，\n\n非聚集（unclustered）索引。\n\n> 定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。\n\n其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致。\n\n\n# 2.分页查找优化\n\n 1. 分表、加索引\n 2. 在分页之前加条件，比如select * from your_table where pk>=1000 order by pk asc limit 0,20\n 3. 查询数据只查询主键数据，贼快\n 4. 如果我们也要查询所有列，有两种方法，一种是id>=的形式，另一种就是利用join，看下实际情况：\n\n> select * from product where id > =(select id from product limit 866613, 1) limit 20\n\n> select * from product a join (select id from product limit 866613, 20) b on a.id = b.id\n\n\n# 3.为什么mysql索引要使用b+树，而不是b树，红黑树\n\n由于b树的所有节点都存储了数据，而b+树只有叶子节点存储数据，并且叶子节点还存储了下节点的指针，数据库中会存在范围查找，如果用b树那么只能每次一个一个的去查找；而b+树查找到后，通过指针可以找到区间内的数据。\n\n参考：https://www.cnblogs.com/leijiangtao/p/4662779.html\n\n树的深度决定了io操作的次数\n\n 1. b树应用\n    \n    主要用于文件系统以及部分数据库索引（mongodb） 而mysql是用b+树的。\n\n 2. b+树\n\n> b+树的最大元素始终位于根节点当中。所有叶子节点包含了全量元素信息，并且每一个叶子节点都带有指向 下一个节点指针，形成了一个有序链表。\n\nb树和b+树的区别：\n\n1.单一节点存储更多的元素，使得查询的io次数更少。\n\n2.所有查询都要查找到叶子节点，查询性能稳定。\n\n3.所有叶子节点形成有序链表，便于范围查询。\n\n----------------------------------------\n\n\n# 六.redis\n\n\n# 1. redis为什么采用跳表而不是红黑树？？\n\n> 在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。 从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。 查找单个key，skiplist和平衡树的时间复杂度都为o(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近o(1)，性能更高一些。所以我们平常使用的各种map或dictionary结构，大都是基于哈希表实现的。 从算法实现难度上来比较，skiplist比平衡树要简单得多。\n\n\n# 2.redis的淘汰策略\n\n * noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。 大多数写命令都会导致占用更多的内存(有极少数会例外, 如 del )。\n * allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,lru) 的 key。\n * volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,lru) 的 key。\n * allkeys-random: 所有key通用; 随机删除一部分 key。\n * volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。\n * volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,ttl) 短的key。',charsets:{cjk:!0},lastUpdated:"2021/07/13, 18:28:04"},{title:"记第一次腾讯面试（惨疼）",frontmatter:{title:"记第一次腾讯面试（惨疼）",date:"2021-07-09T15:00:17.000Z",permalink:"/pages/23b3cf/",categories:["技术","面试笔记","面试经历"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/80.%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/00.%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%EF%BC%88%E6%83%A8%E7%96%BC%EF%BC%89.html",relativePath:"03.技术/05.面试笔记/80.面试经历/00.记第一次腾讯面试（惨疼）.md",key:"v-29898959",path:"/pages/23b3cf/",headers:[{level:2,title:"1.10  7   3L的三杯水，如何倒出两杯5L的水（核心怎么倒出1L的水)",slug:"_1-10-7-3l的三杯水-如何倒出两杯5l的水-核心怎么倒出1l的水",normalizedTitle:"1.10  7   3l的三杯水，如何倒出两杯5l的水（核心怎么倒出1l的水)",charIndex:null}],headersStr:"1.10  7   3L的三杯水，如何倒出两杯5L的水（核心怎么倒出1L的水)",content:"# 记第一次腾讯面试（惨疼）\n\n\n# 1.10 7 3L的三杯水，如何倒出两杯5L的水（核心怎么倒出1L的水)\n\n>  1. 7L倒满，倒入3L水，此时依次为0 4 3\n>  2. 3L水倒掉，4L水倒入3L的杯子，此时依次为0 1 3\n>  3. 此时已经有1L的水，3L水倒掉，1L放入3L的杯子，4L水倒满，再倒入10L的杯子，把1L的水倒入10L的杯子，此时依次为5 0 0\n\n二分查找",normalizedContent:"# 记第一次腾讯面试（惨疼）\n\n\n# 1.10 7 3l的三杯水，如何倒出两杯5l的水（核心怎么倒出1l的水)\n\n>  1. 7l倒满，倒入3l水，此时依次为0 4 3\n>  2. 3l水倒掉，4l水倒入3l的杯子，此时依次为0 1 3\n>  3. 此时已经有1l的水，3l水倒掉，1l放入3l的杯子，4l水倒满，再倒入10l的杯子，把1l的水倒入10l的杯子，此时依次为5 0 0\n\n二分查找",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"记第二次腾讯面试",frontmatter:{title:"记第二次腾讯面试",date:"2021-07-09T15:00:17.000Z",permalink:"/pages/d67e98/",categories:["技术","面试笔记","面试经历"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/80.%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/01.%E8%AE%B0%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95.html",relativePath:"03.技术/05.面试笔记/80.面试经历/01.记第二次腾讯面试.md",key:"v-1a7cf4bc",path:"/pages/d67e98/",headers:[{level:2,title:"1.消息队列如何保证数据顺序性",slug:"_1-消息队列如何保证数据顺序性",normalizedTitle:"1.消息队列如何保证数据顺序性",charIndex:15}],headersStr:"1.消息队列如何保证数据顺序性",content:"# 记第二次腾讯面试\n\n\n# 1.消息队列如何保证数据顺序性\n\n> 比如：对用户信息进行更新操作，第一次修改名字为张三，第二次修改为李四，如何保证顺序写。\n\n情况一：若是多个消费者：可以通过一个队列对应一个消费者，把所有的消息放到一个队列里面\n\n情况二：若是一个消费者，又如何保证顺序写：一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队（通过时间存储），然后分发给底层不同的worker来处理",normalizedContent:"# 记第二次腾讯面试\n\n\n# 1.消息队列如何保证数据顺序性\n\n> 比如：对用户信息进行更新操作，第一次修改名字为张三，第二次修改为李四，如何保证顺序写。\n\n情况一：若是多个消费者：可以通过一个队列对应一个消费者，把所有的消息放到一个队列里面\n\n情况二：若是一个消费者，又如何保证顺序写：一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队（通过时间存储），然后分发给底层不同的worker来处理",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"腾讯面试题目",frontmatter:{title:"腾讯面试题目",date:"2021-07-09T14:58:45.000Z",permalink:"/pages/0f6bf1/",categories:["技术","面试笔记","面试经历"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/80.%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/02.%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE.html",relativePath:"03.技术/05.面试笔记/80.面试经历/02.腾讯面试题目.md",key:"v-4accbd96",path:"/pages/0f6bf1/",headersStr:null,content:"# 腾讯面试\n\n作者：想当offer收割机的猿儿 链接：https://www.nowcoder.com/discuss/607156?type=2&order=3&pos=7&page=1&channel=-1&source_id=discuss_tag_nctrack 来源：牛客网\n\n一面\n\n 1.  i++是原子的吗？为什么不是原子的？会出现什么情况？\n     \n     > 不是，由于java内存中变量赋值有三个过程，开辟内存空间、初始化、变量赋值；所有三个过程会出现顺序不同导致非原子操作。\n\n 2.  数组的特点？底层如何定位到数组中的元素？数组的内存空间是连续的吗？\n     \n     > 连续的空间，查找效率高；\n     > \n     > 确定数组在内存中的地址，数组长度确定，就能获取到数组的每个元素；\n     > \n     > 是；\n\n 3.  32位操作系统会为每个进程分配多大的内存空间？为什么能为每个进程分配那么多虚拟内存空间？地址空间是连续的吗？\n\n 4.  快速排序的时间复杂度是多少？最好情况和最坏情况出现在什么地方？为什么选取最后一个元素作为key值？\n     \n     > Nlog(N);通过首部、尾部指针，选取基数，大的在右边，小的在左边，知道首部、尾部指针相同，第一次匹配结束；\n     > \n     > 最好：只需要排序依次就完成，LogN；最坏：每次都需要排序，排序N词，就是冒泡排序了，NN\n     > \n     > 随机选取\n\n 5.  Hash的底层实现？链地址法解决冲突？为什么需要转化成红黑树？\n     \n     > 数组+链表\n     > \n     > 若链表过大，选择使用红黑树\n     > \n     > 红黑树是平衡二叉树，其查找效率为LogN，链表查找效率为N，若过长效率慢\n\n 6.  你编写程序的时候如何进行调试？如何快速定位到一个异常？\n\n 7.  如果你在运行程序的时候，突然卡住了，鼠标也动不了了，你如何排查异常？\n     \n     > 查进程还有线程状态，再看磁盘IO的情况，查CPU使用率，大概就这些我也不知道对不对\n\n 8.  TCP和UDP有什么区别？TCP如何实现可靠的数据传输？为什么有了TCP还需要UDP，能够保证传输的可靠性不是更好吗？TCP和UDP适用的场景？说一下使用UDP实现可靠数据传输的大体设计思路？\n\n 9.  TCP的快速重传机制？什么时候发生重传？重传哪些数据包？\n     \n     > TCP快速重传策略： 发送端发送带序号的报文，比如ACK1发送成功，接收端应答ACK1（代表发送成功）； 若发送端发送ACK2，接收端未接受到，那么接收端会发送三次ACK2,那么发送端就会重新发送ACK2; 并且不会影响其他报文发送，比如ACK1、ACK3、ACK4接收成功，那么重发ACK2后，接收端会发送ACK5，表示期望发送ACK5。\n\n 10. TCP的time_wait状态出现在什么时候？有什么作用？\n     \n     > TIME_WAIT应该是出现在TCP四次挥手，主动断开连接方收到被动断开连接方的FIN，发出ACK后所处的状态。作用有两个：\n     > \n     >  1. 防止旧连接的数据包。如果没有TIME_WAIT，断开连接后又建立了新的连接，如果旧的数据包在新的连接建立后到达，会造成数据错乱，TIME_WAIT可以保证旧的数据包超过报文的最大生存时间，会被丢弃。\n     >  2. 保证连接正确关闭。TIME_WAIT的作用是足够的时间以确保最后的ACK被被动关闭方接受。如果没有TIME_WAIT，ACK被被动关闭方接受，被动关闭方会一直处于LAST_ACK状态，如果此时发起一个新连接，会收到RST。如果有TIME_WAIT，被动断开方没有收到ACK，触发重传FIN报文，主动断开方收到后重新发送ACK。\n\n 11. TCP具有超时重传策略？如果一直超时怎么办？如何解决？\n\n 12. 线程之间如何进行通信？进程之间如何进行通信？匿名管道和命名管道的区别是什么？\n\n 13. 在网络通信当中，如何确认对方是否在线呢？\n\n 14. IO多路复用如何实现的？epoll相对于select有什么优点？epoll的垂直和水平触发方式？\n     \n     > I/O multiplexing 这里面的 multiplexing 指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态(对应空管塔里面的Fight progress strip槽)来同时管理多个I/O流.\n     \n     >  1. select:同时监听多个请求：最多1024\n     >  2. poll：每次来一次请求，就询问一次\n     >  3. epoll:为每一个请求增加标记，不用询问多次\n\n 15. 跳表的优点是什么？为什么不用红黑树？\n\n 16. 平常用MySQL用的哪个存储引擎？Innodb有什么优缺点？如何查看一条SQL指令的执行时间？\n\n 17. Linux基本指令有哪些？如何查看当前CPU的使用情况？（不懂）\n     \n     > top:查看CPU、内存情况\n     > \n     > Free：查看内存情况\n     > \n     > df:查看磁盘使用情况\n\n二面\n\n 1.  JVM运行时的内存布局是怎么样的？\n 2.  什么排序的时间复杂度可能为O（n）？桶排序和计数排序懂吗？\n 3.  平常一般都如何进行程序调试的？还会打断点？\n 4.  链表和数组的区别？底层寻址是如何完成的？\n 5.  TCP和UDP相关，很多问题\n 6.  用过Socket编程吗？进行Socket编程的具体步骤是怎么样的？\n 7.  同一个计算机上的应用能使用Socket进行通信吗？\n 8.  IO多路复用到底在实际应用当中解决了什么问题？给了一个场景\n 9.  解决过粘包问题吗？怎么拆包解包的？还有其它更多的解决方案吗？\n 10. HTTP 301状态码表示什么意思？还有什么其它的状态码？\n 11. 写过Web编程吗？怎么分派请求的？\n 12. 进程线程相关，通信如何进行？在代码中实现过吗？怎么用的？\n 13. 多进程和多线程？平常用哪个更多？用过多进程吗？\n 14. UDP最大包长多少？首部的字段和长度？为什么是1500字节呢？\n\n三面(主管面）\n\n 1.  Innodb和ms的区别？具体一点\n\n 2.  Innodb有什么优点？具体一点\n\n 3.  什么是时候用缓存？你有什么解决方案？\n\n 4.  为什么需要事务？事务有什么特点？你觉得事务最关键的地方在于什么？\n\n 5.  你知道索引和主键有什么区别吗？\n\n 6.  如果mysql数据库中的数据过多会产生什么问题？你会怎么办？\n\n 7.  redis和mysql有什么区别？redis数据只存在内存上吗？\n\n 8.  JVM垃圾收集策略是怎么样的？为什么有垃圾收集还会有内存泄漏问题？如何判断一个JVM进程是否发生了内存泄漏？\n     \n     https://blog.csdn.net/nlcexiyue/article/details/106708302\n     \n     > –linux的top命令 –JDK自带的工具jstat和jmap –JVM内存泄漏工具\n\n 9.  如何查看远程进程连接本地主机的一个端口号？写Linux命令\n\n 10. 介绍一下http协议，写过web应用吗？了解过sql注入吗？会有什么问题？如何防止？\n\n 11. Java里面，既然有了基本类型，为什么还需要包装类型呢？\n\n 12. 你说一下递归的优缺点吧，如何优化？如何进行剪枝搜索？\n\n 13. 给了一道多进程和多线程的场景题。这个场景下会出现什么问题？为什么会出现这样的问题？你会如何解决呢？\n\n 14. 给了一道场景题，我说用动态规划，写了个状态转移方程。",normalizedContent:"# 腾讯面试\n\n作者：想当offer收割机的猿儿 链接：https://www.nowcoder.com/discuss/607156?type=2&order=3&pos=7&page=1&channel=-1&source_id=discuss_tag_nctrack 来源：牛客网\n\n一面\n\n 1.  i++是原子的吗？为什么不是原子的？会出现什么情况？\n     \n     > 不是，由于java内存中变量赋值有三个过程，开辟内存空间、初始化、变量赋值；所有三个过程会出现顺序不同导致非原子操作。\n\n 2.  数组的特点？底层如何定位到数组中的元素？数组的内存空间是连续的吗？\n     \n     > 连续的空间，查找效率高；\n     > \n     > 确定数组在内存中的地址，数组长度确定，就能获取到数组的每个元素；\n     > \n     > 是；\n\n 3.  32位操作系统会为每个进程分配多大的内存空间？为什么能为每个进程分配那么多虚拟内存空间？地址空间是连续的吗？\n\n 4.  快速排序的时间复杂度是多少？最好情况和最坏情况出现在什么地方？为什么选取最后一个元素作为key值？\n     \n     > nlog(n);通过首部、尾部指针，选取基数，大的在右边，小的在左边，知道首部、尾部指针相同，第一次匹配结束；\n     > \n     > 最好：只需要排序依次就完成，logn；最坏：每次都需要排序，排序n词，就是冒泡排序了，nn\n     > \n     > 随机选取\n\n 5.  hash的底层实现？链地址法解决冲突？为什么需要转化成红黑树？\n     \n     > 数组+链表\n     > \n     > 若链表过大，选择使用红黑树\n     > \n     > 红黑树是平衡二叉树，其查找效率为logn，链表查找效率为n，若过长效率慢\n\n 6.  你编写程序的时候如何进行调试？如何快速定位到一个异常？\n\n 7.  如果你在运行程序的时候，突然卡住了，鼠标也动不了了，你如何排查异常？\n     \n     > 查进程还有线程状态，再看磁盘io的情况，查cpu使用率，大概就这些我也不知道对不对\n\n 8.  tcp和udp有什么区别？tcp如何实现可靠的数据传输？为什么有了tcp还需要udp，能够保证传输的可靠性不是更好吗？tcp和udp适用的场景？说一下使用udp实现可靠数据传输的大体设计思路？\n\n 9.  tcp的快速重传机制？什么时候发生重传？重传哪些数据包？\n     \n     > tcp快速重传策略： 发送端发送带序号的报文，比如ack1发送成功，接收端应答ack1（代表发送成功）； 若发送端发送ack2，接收端未接受到，那么接收端会发送三次ack2,那么发送端就会重新发送ack2; 并且不会影响其他报文发送，比如ack1、ack3、ack4接收成功，那么重发ack2后，接收端会发送ack5，表示期望发送ack5。\n\n 10. tcp的time_wait状态出现在什么时候？有什么作用？\n     \n     > time_wait应该是出现在tcp四次挥手，主动断开连接方收到被动断开连接方的fin，发出ack后所处的状态。作用有两个：\n     > \n     >  1. 防止旧连接的数据包。如果没有time_wait，断开连接后又建立了新的连接，如果旧的数据包在新的连接建立后到达，会造成数据错乱，time_wait可以保证旧的数据包超过报文的最大生存时间，会被丢弃。\n     >  2. 保证连接正确关闭。time_wait的作用是足够的时间以确保最后的ack被被动关闭方接受。如果没有time_wait，ack被被动关闭方接受，被动关闭方会一直处于last_ack状态，如果此时发起一个新连接，会收到rst。如果有time_wait，被动断开方没有收到ack，触发重传fin报文，主动断开方收到后重新发送ack。\n\n 11. tcp具有超时重传策略？如果一直超时怎么办？如何解决？\n\n 12. 线程之间如何进行通信？进程之间如何进行通信？匿名管道和命名管道的区别是什么？\n\n 13. 在网络通信当中，如何确认对方是否在线呢？\n\n 14. io多路复用如何实现的？epoll相对于select有什么优点？epoll的垂直和水平触发方式？\n     \n     > i/o multiplexing 这里面的 multiplexing 指的其实是在单个线程通过记录跟踪每一个sock(i/o流)的状态(对应空管塔里面的fight progress strip槽)来同时管理多个i/o流.\n     \n     >  1. select:同时监听多个请求：最多1024\n     >  2. poll：每次来一次请求，就询问一次\n     >  3. epoll:为每一个请求增加标记，不用询问多次\n\n 15. 跳表的优点是什么？为什么不用红黑树？\n\n 16. 平常用mysql用的哪个存储引擎？innodb有什么优缺点？如何查看一条sql指令的执行时间？\n\n 17. linux基本指令有哪些？如何查看当前cpu的使用情况？（不懂）\n     \n     > top:查看cpu、内存情况\n     > \n     > free：查看内存情况\n     > \n     > df:查看磁盘使用情况\n\n二面\n\n 1.  jvm运行时的内存布局是怎么样的？\n 2.  什么排序的时间复杂度可能为o（n）？桶排序和计数排序懂吗？\n 3.  平常一般都如何进行程序调试的？还会打断点？\n 4.  链表和数组的区别？底层寻址是如何完成的？\n 5.  tcp和udp相关，很多问题\n 6.  用过socket编程吗？进行socket编程的具体步骤是怎么样的？\n 7.  同一个计算机上的应用能使用socket进行通信吗？\n 8.  io多路复用到底在实际应用当中解决了什么问题？给了一个场景\n 9.  解决过粘包问题吗？怎么拆包解包的？还有其它更多的解决方案吗？\n 10. http 301状态码表示什么意思？还有什么其它的状态码？\n 11. 写过web编程吗？怎么分派请求的？\n 12. 进程线程相关，通信如何进行？在代码中实现过吗？怎么用的？\n 13. 多进程和多线程？平常用哪个更多？用过多进程吗？\n 14. udp最大包长多少？首部的字段和长度？为什么是1500字节呢？\n\n三面(主管面）\n\n 1.  innodb和ms的区别？具体一点\n\n 2.  innodb有什么优点？具体一点\n\n 3.  什么是时候用缓存？你有什么解决方案？\n\n 4.  为什么需要事务？事务有什么特点？你觉得事务最关键的地方在于什么？\n\n 5.  你知道索引和主键有什么区别吗？\n\n 6.  如果mysql数据库中的数据过多会产生什么问题？你会怎么办？\n\n 7.  redis和mysql有什么区别？redis数据只存在内存上吗？\n\n 8.  jvm垃圾收集策略是怎么样的？为什么有垃圾收集还会有内存泄漏问题？如何判断一个jvm进程是否发生了内存泄漏？\n     \n     https://blog.csdn.net/nlcexiyue/article/details/106708302\n     \n     > –linux的top命令 –jdk自带的工具jstat和jmap –jvm内存泄漏工具\n\n 9.  如何查看远程进程连接本地主机的一个端口号？写linux命令\n\n 10. 介绍一下http协议，写过web应用吗？了解过sql注入吗？会有什么问题？如何防止？\n\n 11. java里面，既然有了基本类型，为什么还需要包装类型呢？\n\n 12. 你说一下递归的优缺点吧，如何优化？如何进行剪枝搜索？\n\n 13. 给了一道多进程和多线程的场景题。这个场景下会出现什么问题？为什么会出现这样的问题？你会如何解决呢？\n\n 14. 给了一道场景题，我说用动态规划，写了个状态转移方程。",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"面试的准备",frontmatter:{title:"面试的准备",date:"2021-07-14T20:00:44.000Z",permalink:"/pages/88b3b7/",categories:["技术","面试笔记"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/20.%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87.html",relativePath:"03.技术/05.面试笔记/20.面试的准备.md",key:"v-822e42c2",path:"/pages/88b3b7/",headersStr:null,content:"# 面试之前的准备\n\n1、你项目中做了什么？\n\n2、项目的用户是谁，业务流程图、数据流程图、领域模型是什么样的？\n\n3、哪些是亮点，为什么是亮点，技术攻关还是架构或者功能设计\n\n4、为什么你要这样做？别的方法也可以啊，你的思考\n\n5、你这样做了你觉得有什么问题？解决了哪些问题？有没有新的问题？你怎么做决策的？\n\n6、你怎么让我觉得你牛逼有能力跟我共事而不是我给你以后擦屁股\n\n7、你这几年的长处在哪里？面试就是让你学会让面试官挖掘出你的擅长之后，然后镇住他，镇不住也要让他认为你比较不错\n\n8、学会给面试官埋雷，这个雷应该埋几个，应该埋在哪里，怎么让他去引爆，然后无线衍生\n\n9、市场上热点技术，你的整体思考在哪里。分布式仅仅是分布式，有没有别的深度思考，从设计或者上帝视角出发\n\n10、你的下一个目标是干什么? 很重要\n\n作者：洋锅demon https://www.bilibili.com/read/cv10669986 出处：bilibili",normalizedContent:"# 面试之前的准备\n\n1、你项目中做了什么？\n\n2、项目的用户是谁，业务流程图、数据流程图、领域模型是什么样的？\n\n3、哪些是亮点，为什么是亮点，技术攻关还是架构或者功能设计\n\n4、为什么你要这样做？别的方法也可以啊，你的思考\n\n5、你这样做了你觉得有什么问题？解决了哪些问题？有没有新的问题？你怎么做决策的？\n\n6、你怎么让我觉得你牛逼有能力跟我共事而不是我给你以后擦屁股\n\n7、你这几年的长处在哪里？面试就是让你学会让面试官挖掘出你的擅长之后，然后镇住他，镇不住也要让他认为你比较不错\n\n8、学会给面试官埋雷，这个雷应该埋几个，应该埋在哪里，怎么让他去引爆，然后无线衍生\n\n9、市场上热点技术，你的整体思考在哪里。分布式仅仅是分布式，有没有别的深度思考，从设计或者上帝视角出发\n\n10、你的下一个目标是干什么? 很重要\n\n作者：洋锅demon https://www.bilibili.com/read/cv10669986 出处：bilibili",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"奇安信笔试",frontmatter:{title:"奇安信笔试",date:"2021-07-09T14:59:59.000Z",permalink:"/pages/8b2440/",categories:["技术","面试笔记","面试经历"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/80.%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/03.%E5%A5%87%E5%AE%89%E4%BF%A1%E7%AC%94%E8%AF%95.html",relativePath:"03.技术/05.面试笔记/80.面试经历/03.奇安信笔试.md",key:"v-9bccd544",path:"/pages/8b2440/",headersStr:null,content:"# 奇安信笔试\n\n作者：竭鱼 链接：https://www.nowcoder.com/discuss/607490 来源：牛客网\n\n 1. 挑选奶牛： （动态规划)\n\n * 输入输出：接收表示奶牛吃草量和奶牛产奶量的两个数组，返回奶牛产奶最大桶数；\n * 条件：吃草多产奶少的奶牛会和吃草少产奶多的奶牛打架，要求奶牛不能打架，且挑选出来的奶牛产奶量最大；\n\n 2. 求图的最短路径；",normalizedContent:"# 奇安信笔试\n\n作者：竭鱼 链接：https://www.nowcoder.com/discuss/607490 来源：牛客网\n\n 1. 挑选奶牛： （动态规划)\n\n * 输入输出：接收表示奶牛吃草量和奶牛产奶量的两个数组，返回奶牛产奶最大桶数；\n * 条件：吃草多产奶少的奶牛会和吃草少产奶多的奶牛打架，要求奶牛不能打架，且挑选出来的奶牛产奶量最大；\n\n 2. 求图的最短路径；",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"Nginx",frontmatter:{title:"Nginx",date:"2021-07-08T19:11:03.000Z",permalink:"/pages/6edb2d/",categories:["工具使用"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01.Nginx.html",relativePath:"03.技术/06.工具使用/01.Nginx.md",key:"v-60ec441d",path:"/pages/6edb2d/",headers:[{level:2,title:"一.为什么学习Nginx",slug:"一-为什么学习nginx",normalizedTitle:"一.为什么学习nginx",charIndex:12},{level:2,title:"二.什么是Nginx？",slug:"二-什么是nginx",normalizedTitle:"二.什么是nginx？",charIndex:362},{level:2,title:"三.Nginx作用？",slug:"三-nginx作用",normalizedTitle:"三.nginx作用？",charIndex:843},{level:3,title:"1.反向代理：",slug:"_1-反向代理",normalizedTitle:"1.反向代理：",charIndex:858},{level:3,title:"2.负载均衡：",slug:"_2-负载均衡",normalizedTitle:"2.负载均衡：",charIndex:984},{level:3,title:"3.动静分离：",slug:"_3-动静分离",normalizedTitle:"3.动静分离：",charIndex:1181},{level:2,title:"四.Nginx的安装",slug:"四-nginx的安装",normalizedTitle:"四.nginx的安装",charIndex:1416},{level:3,title:"1.windows下安装",slug:"_1-windows下安装",normalizedTitle:"1.windows下安装",charIndex:1431},{level:3,title:"2.Linux下安装",slug:"_2-linux下安装",normalizedTitle:"2.linux下安装",charIndex:1750},{level:2,title:"Nginx常用命令",slug:"nginx常用命令",normalizedTitle:"nginx常用命令",charIndex:2661}],headersStr:"一.为什么学习Nginx 二.什么是Nginx？ 三.Nginx作用？ 1.反向代理： 2.负载均衡： 3.动静分离： 四.Nginx的安装 1.windows下安装 2.Linux下安装 Nginx常用命令",content:"# Nginx\n\n\n# 一.为什么学习Nginx\n\n项目刚刚上线的时候，并发量小，用户使用的少，所以在低并发的情况下，一个jar包启动应用就够了，然后内部tomcat返回内容给用户。\n\n\n\n但是慢慢的，使用我们平台的用户越来越多了，并发量慢慢增大了，这时候一台服务器满足不了我们的需求了。\n\n\n\n于是我们横向扩展，又增加了服务器。这个时候几个项目启动在不同的服务器上，用户要访问，就需要增加一个代理服务器了，通过代理服务器来帮我们转发和处理请求。\n\n\n\n我们希望这个代理服务器可以帮助我们接收用户的请求，然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的，用户并不知道是哪个服务器返回的结果，我们还希望他可以按照服务器的性能提供不同的权重选择。保证最佳体验！所以我们使用了Nginx。\n\n\n# 二.什么是Nginx？\n\nNginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的http://Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。\n\n其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。\n\nNginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。\n\nNginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。\n\n\n# 三.Nginx作用？\n\n\n# 1.反向代理：\n\n> Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。\n\n正向代理\n\n\n\n反向代理\n\n\n\n总结：\n\n正向不知前端，反向不知后端；即正向代理服务器不知哪个客户端访问，反向代理客户端不知访问的哪个服务器。\n\n\n# 2.负载均衡：\n\n> Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的。\n\n1.轮询\n\n\n\n2.加权轮询（推荐）\n\n\n\n3.iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。\n\n\n\n\n# 3.动静分离：\n\n> 动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。\n\n\n\n目前，通过使用Nginx大大提高了我们网站的响应速度，优化了用户体验，让网站的健壮性更上一层楼！\n\n\n# 四.Nginx的安装\n\n\n# 1.windows下安装\n\n下载地址：http://nginx.org/en/download.html\n\n启动：\n\n(1)直接双击nginx.exe，双击后一个黑色的弹窗一闪而过\n\n(2)打开cmd命令窗口，切换到nginx解压目录下，输入命令 nginx.exe ，回车即可\n\n关闭：\n\n如果使用cmd命令窗口启动nginx， 关闭cmd窗口是不能结束nginx进程的，可使用两种方法关闭nginx\n\n(1)输入nginx命令 nginx -s stop(快速停止nginx) 或 nginx -s quit(完整有序的停止nginx)\n\n(2)使用taskkill taskkill /f /t /im nginx.exe\n\n\n# 2.Linux下安装\n\n1、安装gcc\n\n安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：\n\nyum install gcc-c++\n\n\n1\n\n\n2、PCRE pcre-devel 安装\n\nPCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：\n\nyum install -y pcre pcre-devel\n\n\n1\n\n\n3、zlib 安装\n\nzlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。\n\nyum install -y zlib zlib-devel\n\n\n1\n\n\n4、OpenSSL 安装 OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。 nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。\n\nyum install -y openssl openssl-devel\n\n\n1\n\n\n5、下载安装包\n\n手动下载.tar.gz安装包，地址：https://nginx.org/en/download.html\n\n\n\n下载完毕上传到服务器上 /root\n\n6、解压\n\ntar -zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0\n\n\n1\n\n\n\n\n7、配置\n\n使用默认配置，在nginx根目录下执行\n\n./configure\nmake\nmake install\n\n\n1\n2\n3\n\n\n查找安装路径： whereis nginx\n\n\n\n\n# Nginx常用命令\n\ncd /usr/local/nginx/sbin/\n./nginx  启动\n./nginx -s stop  停止\n./nginx -s quit  安全退出\n./nginx -s reload  重新加载配置文件\nps aux|grep nginx  查看nginx进程\n\n\n1\n2\n3\n4\n5\n6\n\n\n启动成功访问 服务器ip:80\n\n\n\n注意：如何连接不上，检查阿里云安全组是否开放端口，或者服务器防火墙是否开放端口！ 相关命令：\n\n# 开启\nservice firewalld start\n# 重启\nservice firewalld restart\n# 关闭\nservice firewalld stop\n# 查看防火墙规则\nfirewall-cmd --list-all\n# 查询端口是否开放\nfirewall-cmd --query-port=8080/tcp\n# 开放80端口\nfirewall-cmd --permanent --add-port=80/tcp\n# 移除端口\nfirewall-cmd --permanent --remove-port=8080/tcp\n#重启防火墙(修改配置后要重启防火墙)\nfirewall-cmd --reload\n# 参数解释\n1、firwall-cmd：是Linux提供的操作firewall的一个工具；\n2、--permanent：表示设置为持久；\n3、--add-port：标识添加的端口；\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 演示\n\nupstream lb{    server 127.0.0.1:8080 weight=1;    server 127.0.0.1:8081 weight=1;}location / {    proxy_pass http://lb;}\n\n\n1\n\n\n配套的视频已经发布到B站，看前记得三连投币支持哦~\n\nhttps://links.jianshu.com/go?to=https%3A%2F%2Fnginx.org%2Fen%2Fdownload.html)",normalizedContent:"# nginx\n\n\n# 一.为什么学习nginx\n\n项目刚刚上线的时候，并发量小，用户使用的少，所以在低并发的情况下，一个jar包启动应用就够了，然后内部tomcat返回内容给用户。\n\n\n\n但是慢慢的，使用我们平台的用户越来越多了，并发量慢慢增大了，这时候一台服务器满足不了我们的需求了。\n\n\n\n于是我们横向扩展，又增加了服务器。这个时候几个项目启动在不同的服务器上，用户要访问，就需要增加一个代理服务器了，通过代理服务器来帮我们转发和处理请求。\n\n\n\n我们希望这个代理服务器可以帮助我们接收用户的请求，然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的，用户并不知道是哪个服务器返回的结果，我们还希望他可以按照服务器的性能提供不同的权重选择。保证最佳体验！所以我们使用了nginx。\n\n\n# 二.什么是nginx？\n\nnginx (engine x) 是一个高性能的http和反向代理web服务器，同时也提供了imap/pop3/smtp服务。nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的http://rambler.ru站点（俄文：рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。\n\n其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。\n\nnginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、bug非常少的服务。nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。\n\nnginx代码完全用c语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。\n\n\n# 三.nginx作用？\n\n\n# 1.反向代理：\n\n> http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。\n\n正向代理\n\n\n\n反向代理\n\n\n\n总结：\n\n正向不知前端，反向不知后端；即正向代理服务器不知哪个客户端访问，反向代理客户端不知访问的哪个服务器。\n\n\n# 2.负载均衡：\n\n> nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的。\n\n1.轮询\n\n\n\n2.加权轮询（推荐）\n\n\n\n3.iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。\n\n\n\n\n# 3.动静分离：\n\n> 动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。\n\n\n\n目前，通过使用nginx大大提高了我们网站的响应速度，优化了用户体验，让网站的健壮性更上一层楼！\n\n\n# 四.nginx的安装\n\n\n# 1.windows下安装\n\n下载地址：http://nginx.org/en/download.html\n\n启动：\n\n(1)直接双击nginx.exe，双击后一个黑色的弹窗一闪而过\n\n(2)打开cmd命令窗口，切换到nginx解压目录下，输入命令 nginx.exe ，回车即可\n\n关闭：\n\n如果使用cmd命令窗口启动nginx， 关闭cmd窗口是不能结束nginx进程的，可使用两种方法关闭nginx\n\n(1)输入nginx命令 nginx -s stop(快速停止nginx) 或 nginx -s quit(完整有序的停止nginx)\n\n(2)使用taskkill taskkill /f /t /im nginx.exe\n\n\n# 2.linux下安装\n\n1、安装gcc\n\n安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：\n\nyum install gcc-c++\n\n\n1\n\n\n2、pcre pcre-devel 安装\n\npcre(perl compatible regular expressions) 是一个perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：\n\nyum install -y pcre pcre-devel\n\n\n1\n\n\n3、zlib 安装\n\nzlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 centos 上安装 zlib 库。\n\nyum install -y zlib zlib-devel\n\n\n1\n\n\n4、openssl 安装 openssl 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 ssl 协议，并提供丰富的应用程序供测试或其它目的使用。 nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 centos 安装 openssl 库。\n\nyum install -y openssl openssl-devel\n\n\n1\n\n\n5、下载安装包\n\n手动下载.tar.gz安装包，地址：https://nginx.org/en/download.html\n\n\n\n下载完毕上传到服务器上 /root\n\n6、解压\n\ntar -zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0\n\n\n1\n\n\n\n\n7、配置\n\n使用默认配置，在nginx根目录下执行\n\n./configure\nmake\nmake install\n\n\n1\n2\n3\n\n\n查找安装路径： whereis nginx\n\n\n\n\n# nginx常用命令\n\ncd /usr/local/nginx/sbin/\n./nginx  启动\n./nginx -s stop  停止\n./nginx -s quit  安全退出\n./nginx -s reload  重新加载配置文件\nps aux|grep nginx  查看nginx进程\n\n\n1\n2\n3\n4\n5\n6\n\n\n启动成功访问 服务器ip:80\n\n\n\n注意：如何连接不上，检查阿里云安全组是否开放端口，或者服务器防火墙是否开放端口！ 相关命令：\n\n# 开启\nservice firewalld start\n# 重启\nservice firewalld restart\n# 关闭\nservice firewalld stop\n# 查看防火墙规则\nfirewall-cmd --list-all\n# 查询端口是否开放\nfirewall-cmd --query-port=8080/tcp\n# 开放80端口\nfirewall-cmd --permanent --add-port=80/tcp\n# 移除端口\nfirewall-cmd --permanent --remove-port=8080/tcp\n#重启防火墙(修改配置后要重启防火墙)\nfirewall-cmd --reload\n# 参数解释\n1、firwall-cmd：是linux提供的操作firewall的一个工具；\n2、--permanent：表示设置为持久；\n3、--add-port：标识添加的端口；\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 演示\n\nupstream lb{    server 127.0.0.1:8080 weight=1;    server 127.0.0.1:8081 weight=1;}location / {    proxy_pass http://lb;}\n\n\n1\n\n\n配套的视频已经发布到b站，看前记得三连投币支持哦~\n\nhttps://links.jianshu.com/go?to=https%3a%2f%2fnginx.org%2fen%2fdownload.html)",charsets:{cyrillic:!0,cjk:!0}},{title:"Git",frontmatter:{title:"Git",date:"2021-07-08T19:11:03.000Z",permalink:"/pages/e931bb/",categories:["工具使用"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/00.Git.html",relativePath:"03.技术/06.工具使用/00.Git.md",key:"v-35949522",path:"/pages/e931bb/",headers:[{level:2,title:"一.git基本操作",slug:"一-git基本操作",normalizedTitle:"一.git基本操作",charIndex:10},{level:2,title:"二.分支的使用",slug:"二-分支的使用",normalizedTitle:"二.分支的使用",charIndex:95},{level:2,title:"三.绑定远程库",slug:"三-绑定远程库",normalizedTitle:"三.绑定远程库",charIndex:340},{level:2,title:"四.解决冲突",slug:"四-解决冲突",normalizedTitle:"四.解决冲突",charIndex:450}],headersStr:"一.git基本操作 二.分支的使用 三.绑定远程库 四.解决冲突",content:"# Git\n\n\n# 一.git基本操作\n\n 1. 初始化：git init\n 2. 添加到暂存区：git add .\n 3. 提交到本地库：git commit -m '提交内容'\n\n\n# 二.分支的使用\n\n 1. 创建分支：git branch 《分支名》\n 2. 查看分支：git branch -v 《分支名》\n 3. 切换分支：git checkout 《分支名》\n 4. 一步完成创建和切换分支：git checkout -b 《分支名》\n 5. 合并分支：先切换到主分支git checkout master ；再git merge 《分支名》\n 6. 删除分支：先切换到主分支git checkout master ；再git branch -D《分支名》\n\n\n# 三.绑定远程库\n\ngit remote add origin git@github.com:lenve/test.git  --绑定远程库\ngit push origin master  --提交\n\n\n1\n2\n\n\n\n# 四.解决冲突\n\n 1. git pull origin master拉取\n 2. git push origin master推送，说明有文件冲突\n 3. 通过git status查看冲突文件，修改冲突文件\n 4. add 、commit 、push",normalizedContent:"# git\n\n\n# 一.git基本操作\n\n 1. 初始化：git init\n 2. 添加到暂存区：git add .\n 3. 提交到本地库：git commit -m '提交内容'\n\n\n# 二.分支的使用\n\n 1. 创建分支：git branch 《分支名》\n 2. 查看分支：git branch -v 《分支名》\n 3. 切换分支：git checkout 《分支名》\n 4. 一步完成创建和切换分支：git checkout -b 《分支名》\n 5. 合并分支：先切换到主分支git checkout master ；再git merge 《分支名》\n 6. 删除分支：先切换到主分支git checkout master ；再git branch -d《分支名》\n\n\n# 三.绑定远程库\n\ngit remote add origin git@github.com:lenve/test.git  --绑定远程库\ngit push origin master  --提交\n\n\n1\n2\n\n\n\n# 四.解决冲突\n\n 1. git pull origin master拉取\n 2. git push origin master推送，说明有文件冲突\n 3. 通过git status查看冲突文件，修改冲突文件\n 4. add 、commit 、push",charsets:{cjk:!0}},{title:"VScode的使用",frontmatter:{title:"VScode的使用",date:"2021-07-08T19:11:03.000Z",permalink:"/pages/1f82c9/",categories:["工具使用","VScode的使用"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01.%E5%89%8D%E7%AB%AF/00.VScode%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"03.技术/06.工具使用/01.前端/00.VScode的使用.md",key:"v-a72e87c4",path:"/pages/1f82c9/",headers:[{level:2,title:"一.安装常用npm",slug:"一-安装常用npm",normalizedTitle:"一.安装常用npm",charIndex:16},{level:2,title:"二.常用插件",slug:"二-常用插件",normalizedTitle:"二.常用插件",charIndex:80}],headersStr:"一.安装常用npm 二.常用插件",content:"# VScode的使用\n\n\n# 一.安装常用npm\n\nnpm install yarn -g\nnpm install eslint -g\n\n\n1\n2\n\n\n\n# 二.常用插件\n\n用友：\n\n1、npm(npm commands for VSCode) 2、npm(npm support for VS Code) 3、Chinese (Simplified) Language Pack for Visual Studio Code（汉化包） 4、Debugger for Chrome（在工具中启动调试模式） 5、Simple React Snippets(生成模块代码) 6、Auto Close Tag（自动关闭标签） 7、Auto Rename Tag(自动重命名标签) 8、Material Icon Theme（文件自有图标） 9、Prettier - Code formatter（格式化代码） 10、vscode fileheader(标题注释)\n\n汉得：\n\nBracket Pair Colorizer\t在软件内安装，用于找代码括号\nColor Picker\t在软件内安装，用于颜色选择\nESLint\t在软件内安装，用于语法检查\nGit History\t在软件内安装，用于查看Git提交历史记录\nGitLens\t在软件内安装，用于查看文件中最后修改人等\njshint\t在软件内安装，用于语法检查\nPath Intellisense\t在软件内安装，用于引用资源时进行路径提示\nVetur\t在软件内安装，用于Vue.js语法支持\nvscode-fileheader\t在软件内安装，用于自动添加文件头注释\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",normalizedContent:"# vscode的使用\n\n\n# 一.安装常用npm\n\nnpm install yarn -g\nnpm install eslint -g\n\n\n1\n2\n\n\n\n# 二.常用插件\n\n用友：\n\n1、npm(npm commands for vscode) 2、npm(npm support for vs code) 3、chinese (simplified) language pack for visual studio code（汉化包） 4、debugger for chrome（在工具中启动调试模式） 5、simple react snippets(生成模块代码) 6、auto close tag（自动关闭标签） 7、auto rename tag(自动重命名标签) 8、material icon theme（文件自有图标） 9、prettier - code formatter（格式化代码） 10、vscode fileheader(标题注释)\n\n汉得：\n\nbracket pair colorizer\t在软件内安装，用于找代码括号\ncolor picker\t在软件内安装，用于颜色选择\neslint\t在软件内安装，用于语法检查\ngit history\t在软件内安装，用于查看git提交历史记录\ngitlens\t在软件内安装，用于查看文件中最后修改人等\njshint\t在软件内安装，用于语法检查\npath intellisense\t在软件内安装，用于引用资源时进行路径提示\nvetur\t在软件内安装，用于vue.js语法支持\nvscode-fileheader\t在软件内安装，用于自动添加文件头注释\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"Idea的使用",frontmatter:{title:"Idea的使用",date:"2021-07-08T19:11:03.000Z",permalink:"/pages/fa218a/",categories:["工具使用","Idea的使用"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/02.Idea%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"03.技术/06.工具使用/02.Idea的使用.md",key:"v-6dc6a488",path:"/pages/fa218a/",headers:[{level:2,title:"一.idea的配置",slug:"一-idea的配置",normalizedTitle:"一.idea的配置",charIndex:14},{level:2,title:"二.快捷键",slug:"二-快捷键",normalizedTitle:"二.快捷键",charIndex:69}],headersStr:"一.idea的配置 二.快捷键",content:"# Idea的使用\n\n\n# 一.idea的配置\n\nhttps://www.bilibili.com/read/cv5707434\n\n\n# 二.快捷键\n\n 1. 查看接口的实现类：点击接口+Ctrl+H",normalizedContent:"# idea的使用\n\n\n# 一.idea的配置\n\nhttps://www.bilibili.com/read/cv5707434\n\n\n# 二.快捷键\n\n 1. 查看接口的实现类：点击接口+ctrl+h",charsets:{cjk:!0}},{title:"ES的使用",frontmatter:{title:"ES的使用",date:"2021-07-08T19:11:03.000Z",permalink:"/pages/1632a8/",categories:["工具使用","ES的使用"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03.ES%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"03.技术/06.工具使用/03.ES的使用.md",key:"v-3e5a7f98",path:"/pages/1632a8/",headers:[{level:2,title:"3.1.spring-boot-starter-data-elasticsearch方式",slug:"_3-1-spring-boot-starter-data-elasticsearch方式",normalizedTitle:"3.1.spring-boot-starter-data-elasticsearch方式",charIndex:1014}],headersStr:"3.1.spring-boot-starter-data-elasticsearch方式",content:'# elasticsearch\n\n\n# 一.安装\n\n个人的有道云笔记\n\n一定要注意版本\n\n\n\n一.docker中安装ES\n\n1.拉取镜像\n\ndocker pull elasticsearch:6.6.2\n\n2.设置ES_JAVA_OPTS内存使用限制启动服务\n\ndocker run -d -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS="-Xms512m -Xmx512m" -e "discovery.type=single-node" --name es elasticsearch:6.6.2\n\n3.访问：\n\nhttp://192.168.232.210:9200/\n\n4.设置ES跨域\n\ndocker exec -it es /bin/bash\n\ncd config\n\nls\n\nvi elasticsearch.yml\n\n#设置跨域\n\nhttp.cors.enabled: true\n\nhttp.cors.allow-origin: "*"\n\n5.重启ES\n\ndocker restart es\n\n二.本机安装谷歌浏览器****elasticsearch-head插件\n\n参考地址：\n\nhttps://blog.csdn.net/qq_33849593/article/details/109464339\n\n1.下载下方elasticsearch-head插件，解压，记住不要删除了\n\n![elasticsearch-head.7z](file:///D:\\个人\\网易云笔记\\2452952178@qq.com\\af33276a0ab04008aea6bc9a44682f56\\attachment.png)\n\n2.谷歌扩展程序=》点击“加载已解压的压缩程序”，选择该文件夹\n\n3.点击插件即可启动\n\n\n# 二.知识\n\n索引： 含有相同属性的文档（例如 一个索引待变消费者的数据，另一个索引代表产品的数据）\n\n类型： 索引可以定义一个或多个类型（相同字段的文档定为一个类型）\n\n文档： 文档是可以被索引的基本数据单位（比如 一个用户的基本信息，一篇文章的数据等）， 文档必须属于一个类型。\n\n索引通过名字来识别，英文字母小写且不含中画线\n\n索引相当于database 一个数据库。类型相当于table，一个表。 文档相当于一行记录\n\n\n# 三.SpringBoot使用ES\n\n\n# 3.1.spring-boot-starter-data-elasticsearch方式\n\n1.引入Pom文件，注意版本\n\n        \x3c!--springdata方式--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-elasticsearch</artifactId>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n\n\n2.springData的方式引入\n\n# Spring配置\nspring:\n  #springData elasticsearch的方式\n  data:\n    elasticsearch:\n      cluster-name: docker-cluster #默认为elasticsearch\n      cluster-nodes: 192.168.232.210:9300 #配置es节点信息，逗号分隔，如果没有指定，则启动ClientNode\n      properties:\n        path:\n          logs: ./elasticsearch/log #elasticsearch日志存储目录\n          data: ./elasticsearch/data #elasticsearch数据存储目录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n3.引入dao层\n\npublic interface PostRepository extends ElasticsearchRepository<CoursePost,Long> {\n}\n\n\n1\n2\n\n\n4.bean层\n\n 1. @Document：定义索引、类型、分片、副本\n 2. @Id：主键\n 3. @Field：\n    * @Field(type = FieldType.Text, analyzer = "ik_max_word")：使用IK分词器，会将文本做最细粒度的拆分，比如会将“中华人民共和国人民大会堂”拆分为“中华人民共和国、中华人民、中华、华人、人民共和国、人民、共和国、大会堂、大会、会堂等词语。\n    * @Field(type = FieldType.Text, analyzer = "ik_smart")：使用IK分词器，会做最粗粒度的拆分，比如会将“中华人民共和国人民大会堂”拆分为中华人民共和国、人民大会堂。\n    * @Field(type = FieldType.Keyword)\n\npackage com.wcy.project.my.course.domain;\n\nimport com.wcy.framework.aspectj.lang.annotation.Excel;\nimport com.wcy.framework.web.domain.BaseEntity;\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.elasticsearch.annotations.Document;\nimport org.springframework.data.elasticsearch.annotations.Field;\nimport org.springframework.data.elasticsearch.annotations.FieldType;\n\n/**\n * 线上答疑对象 my_course_post\n * \n * @author wcy\n * @date 2020-12-04\n */\n@Document(indexName = "post_index",type="post",shards = 5,replicas = 0)\npublic class CoursePost extends BaseEntity\n{\n    private static final long serialVersionUID = 1L;\n\n    /** 主键 */\n    @Id\n    private Long id;\n\n    /** 标题 */\n    @Excel(name = "标题")\n    @Field(type = FieldType.Text, analyzer = "ik_max_word")\n    private String title;\n\n    /** 不带html内容 */\n    @Field(type = FieldType.Text, analyzer = "ik_max_word")\n    @Excel(name = "内容")\n    private String content;\n\n    //html内容\n    private String htmlContent;\n\n\n    /** 是否置顶 */\n    @Excel(name = "是否置顶")\n    // 0：不置顶  1:置顶\n    @Field(type = FieldType.Keyword)\n    private String isTop;\n\n    /** 用户 */\n    private Long userId;\n\n    /** 房间号 */\n    private Long roomId;\n\n    /** 是否开放 */\n    @Excel(name = "是否开放")\n    @Field(type = FieldType.Keyword)\n    private String isOpen;\n\n    /** 点赞量 */\n    @Excel(name = "点赞量")\n    private Long voteUp;\n\n    /** 访问量 */\n    @Excel(name = "访问量")\n    private Long viewCount;\n\n    /** 是否精华 */\n    @Excel(name = "是否精华")\n    // 0:否 1:是\n    @Field(type = FieldType.Keyword)\n    private String recommend;\n\n    /** 0:文字 1:图片地址 */\n    @Excel(name = "0:未违规 1:违规")\n    @Field(type = FieldType.Keyword)\n    private String isViolations;\n\n    @Field(type = FieldType.Keyword)\n    private String spiderUrl;\n\n    public String getSpiderUrl() {\n        return spiderUrl;\n    }\n\n    public void setSpiderUrl(String spiderUrl) {\n        this.spiderUrl = spiderUrl;\n    }\n\n    public String getIsViolations() {\n        return isViolations;\n    }\n\n    public void setIsViolations(String isViolations) {\n        this.isViolations = isViolations;\n    }\n\n    public void setId(Long id)\n    {\n        this.id = id;\n    }\n\n    public Long getId()\n    {\n        return id;\n    }\n    public void setTitle(String title)\n    {\n        this.title = title;\n    }\n\n    public String getTitle()\n    {\n        return title;\n    }\n    public void setContent(String content)\n    {\n        this.content = content;\n    }\n\n    public String getContent()\n    {\n        return content;\n    }\n    public void setIsTop(String isTop)\n    {\n        this.isTop = isTop;\n    }\n\n    public String getIsTop()\n    {\n        return isTop;\n    }\n    public void setUserId(Long userId)\n    {\n        this.userId = userId;\n    }\n\n    public Long getUserId()\n    {\n        return userId;\n    }\n    public void setRoomId(Long roomId)\n    {\n        this.roomId = roomId;\n    }\n\n    public Long getRoomId()\n    {\n        return roomId;\n    }\n    public void setIsOpen(String isOpen)\n    {\n        this.isOpen = isOpen;\n    }\n\n    public String getIsOpen()\n    {\n        return isOpen;\n    }\n    public void setVoteUp(Long voteUp)\n    {\n        this.voteUp = voteUp;\n    }\n\n    public Long getVoteUp()\n    {\n        return voteUp;\n    }\n    public void setViewCount(Long viewCount)\n    {\n        this.viewCount = viewCount;\n    }\n\n    public Long getViewCount()\n    {\n        return viewCount;\n    }\n    public void setRecommend(String recommend)\n    {\n        this.recommend = recommend;\n    }\n\n    public String getRecommend()\n    {\n        return recommend;\n    }\n\n    @Override\n    public String toString() {\n        return "CoursePost{" +\n                "id=" + id +\n                ", title=\'" + title + \'\\\'\' +\n                ", content=\'" + content + \'\\\'\' +\n                ", htmlContent=\'" + htmlContent + \'\\\'\' +\n                ", isTop=\'" + isTop + \'\\\'\' +\n                ", userId=" + userId +\n                ", roomId=" + roomId +\n                ", isOpen=\'" + isOpen + \'\\\'\' +\n                ", voteUp=" + voteUp +\n                ", viewCount=" + viewCount +\n                ", recommend=\'" + recommend + \'\\\'\' +\n                ", isViolations=\'" + isViolations + \'\\\'\' +\n                \'}\';\n    }\n\n    public String getHtmlContent() {\n        return htmlContent;\n    }\n\n    public void setHtmlContent(String htmlContent) {\n        this.htmlContent = htmlContent;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n',normalizedContent:'# elasticsearch\n\n\n# 一.安装\n\n个人的有道云笔记\n\n一定要注意版本\n\n\n\n一.docker中安装es\n\n1.拉取镜像\n\ndocker pull elasticsearch:6.6.2\n\n2.设置es_java_opts内存使用限制启动服务\n\ndocker run -d -p 9200:9200 -p 9300:9300 -e es_java_opts="-xms512m -xmx512m" -e "discovery.type=single-node" --name es elasticsearch:6.6.2\n\n3.访问：\n\nhttp://192.168.232.210:9200/\n\n4.设置es跨域\n\ndocker exec -it es /bin/bash\n\ncd config\n\nls\n\nvi elasticsearch.yml\n\n#设置跨域\n\nhttp.cors.enabled: true\n\nhttp.cors.allow-origin: "*"\n\n5.重启es\n\ndocker restart es\n\n二.本机安装谷歌浏览器****elasticsearch-head插件\n\n参考地址：\n\nhttps://blog.csdn.net/qq_33849593/article/details/109464339\n\n1.下载下方elasticsearch-head插件，解压，记住不要删除了\n\n![elasticsearch-head.7z](file:///d:\\个人\\网易云笔记\\2452952178@qq.com\\af33276a0ab04008aea6bc9a44682f56\\attachment.png)\n\n2.谷歌扩展程序=》点击“加载已解压的压缩程序”，选择该文件夹\n\n3.点击插件即可启动\n\n\n# 二.知识\n\n索引： 含有相同属性的文档（例如 一个索引待变消费者的数据，另一个索引代表产品的数据）\n\n类型： 索引可以定义一个或多个类型（相同字段的文档定为一个类型）\n\n文档： 文档是可以被索引的基本数据单位（比如 一个用户的基本信息，一篇文章的数据等）， 文档必须属于一个类型。\n\n索引通过名字来识别，英文字母小写且不含中画线\n\n索引相当于database 一个数据库。类型相当于table，一个表。 文档相当于一行记录\n\n\n# 三.springboot使用es\n\n\n# 3.1.spring-boot-starter-data-elasticsearch方式\n\n1.引入pom文件，注意版本\n\n        \x3c!--springdata方式--\x3e\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-data-elasticsearch</artifactid>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n\n\n2.springdata的方式引入\n\n# spring配置\nspring:\n  #springdata elasticsearch的方式\n  data:\n    elasticsearch:\n      cluster-name: docker-cluster #默认为elasticsearch\n      cluster-nodes: 192.168.232.210:9300 #配置es节点信息，逗号分隔，如果没有指定，则启动clientnode\n      properties:\n        path:\n          logs: ./elasticsearch/log #elasticsearch日志存储目录\n          data: ./elasticsearch/data #elasticsearch数据存储目录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n3.引入dao层\n\npublic interface postrepository extends elasticsearchrepository<coursepost,long> {\n}\n\n\n1\n2\n\n\n4.bean层\n\n 1. @document：定义索引、类型、分片、副本\n 2. @id：主键\n 3. @field：\n    * @field(type = fieldtype.text, analyzer = "ik_max_word")：使用ik分词器，会将文本做最细粒度的拆分，比如会将“中华人民共和国人民大会堂”拆分为“中华人民共和国、中华人民、中华、华人、人民共和国、人民、共和国、大会堂、大会、会堂等词语。\n    * @field(type = fieldtype.text, analyzer = "ik_smart")：使用ik分词器，会做最粗粒度的拆分，比如会将“中华人民共和国人民大会堂”拆分为中华人民共和国、人民大会堂。\n    * @field(type = fieldtype.keyword)\n\npackage com.wcy.project.my.course.domain;\n\nimport com.wcy.framework.aspectj.lang.annotation.excel;\nimport com.wcy.framework.web.domain.baseentity;\nimport org.springframework.data.annotation.id;\nimport org.springframework.data.elasticsearch.annotations.document;\nimport org.springframework.data.elasticsearch.annotations.field;\nimport org.springframework.data.elasticsearch.annotations.fieldtype;\n\n/**\n * 线上答疑对象 my_course_post\n * \n * @author wcy\n * @date 2020-12-04\n */\n@document(indexname = "post_index",type="post",shards = 5,replicas = 0)\npublic class coursepost extends baseentity\n{\n    private static final long serialversionuid = 1l;\n\n    /** 主键 */\n    @id\n    private long id;\n\n    /** 标题 */\n    @excel(name = "标题")\n    @field(type = fieldtype.text, analyzer = "ik_max_word")\n    private string title;\n\n    /** 不带html内容 */\n    @field(type = fieldtype.text, analyzer = "ik_max_word")\n    @excel(name = "内容")\n    private string content;\n\n    //html内容\n    private string htmlcontent;\n\n\n    /** 是否置顶 */\n    @excel(name = "是否置顶")\n    // 0：不置顶  1:置顶\n    @field(type = fieldtype.keyword)\n    private string istop;\n\n    /** 用户 */\n    private long userid;\n\n    /** 房间号 */\n    private long roomid;\n\n    /** 是否开放 */\n    @excel(name = "是否开放")\n    @field(type = fieldtype.keyword)\n    private string isopen;\n\n    /** 点赞量 */\n    @excel(name = "点赞量")\n    private long voteup;\n\n    /** 访问量 */\n    @excel(name = "访问量")\n    private long viewcount;\n\n    /** 是否精华 */\n    @excel(name = "是否精华")\n    // 0:否 1:是\n    @field(type = fieldtype.keyword)\n    private string recommend;\n\n    /** 0:文字 1:图片地址 */\n    @excel(name = "0:未违规 1:违规")\n    @field(type = fieldtype.keyword)\n    private string isviolations;\n\n    @field(type = fieldtype.keyword)\n    private string spiderurl;\n\n    public string getspiderurl() {\n        return spiderurl;\n    }\n\n    public void setspiderurl(string spiderurl) {\n        this.spiderurl = spiderurl;\n    }\n\n    public string getisviolations() {\n        return isviolations;\n    }\n\n    public void setisviolations(string isviolations) {\n        this.isviolations = isviolations;\n    }\n\n    public void setid(long id)\n    {\n        this.id = id;\n    }\n\n    public long getid()\n    {\n        return id;\n    }\n    public void settitle(string title)\n    {\n        this.title = title;\n    }\n\n    public string gettitle()\n    {\n        return title;\n    }\n    public void setcontent(string content)\n    {\n        this.content = content;\n    }\n\n    public string getcontent()\n    {\n        return content;\n    }\n    public void setistop(string istop)\n    {\n        this.istop = istop;\n    }\n\n    public string getistop()\n    {\n        return istop;\n    }\n    public void setuserid(long userid)\n    {\n        this.userid = userid;\n    }\n\n    public long getuserid()\n    {\n        return userid;\n    }\n    public void setroomid(long roomid)\n    {\n        this.roomid = roomid;\n    }\n\n    public long getroomid()\n    {\n        return roomid;\n    }\n    public void setisopen(string isopen)\n    {\n        this.isopen = isopen;\n    }\n\n    public string getisopen()\n    {\n        return isopen;\n    }\n    public void setvoteup(long voteup)\n    {\n        this.voteup = voteup;\n    }\n\n    public long getvoteup()\n    {\n        return voteup;\n    }\n    public void setviewcount(long viewcount)\n    {\n        this.viewcount = viewcount;\n    }\n\n    public long getviewcount()\n    {\n        return viewcount;\n    }\n    public void setrecommend(string recommend)\n    {\n        this.recommend = recommend;\n    }\n\n    public string getrecommend()\n    {\n        return recommend;\n    }\n\n    @override\n    public string tostring() {\n        return "coursepost{" +\n                "id=" + id +\n                ", title=\'" + title + \'\\\'\' +\n                ", content=\'" + content + \'\\\'\' +\n                ", htmlcontent=\'" + htmlcontent + \'\\\'\' +\n                ", istop=\'" + istop + \'\\\'\' +\n                ", userid=" + userid +\n                ", roomid=" + roomid +\n                ", isopen=\'" + isopen + \'\\\'\' +\n                ", voteup=" + voteup +\n                ", viewcount=" + viewcount +\n                ", recommend=\'" + recommend + \'\\\'\' +\n                ", isviolations=\'" + isviolations + \'\\\'\' +\n                \'}\';\n    }\n\n    public string gethtmlcontent() {\n        return htmlcontent;\n    }\n\n    public void sethtmlcontent(string htmlcontent) {\n        this.htmlcontent = htmlcontent;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n',charsets:{cjk:!0}},{title:"PLSQL的使用",frontmatter:{title:"PLSQL的使用",date:"2021-07-12T09:38:23.000Z",permalink:"/pages/c7e33c/",categories:["技术","工具使用","后端"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/05.PLSQL%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"03.技术/06.工具使用/05.PLSQL的使用.md",key:"v-1741bda2",path:"/pages/c7e33c/",headersStr:null,content:'# PLSQL的使用\n\n 1. 下载PLsql、汉化、破解\n\n 2. 下载InstantClient文件，并配置\n    \n    * 在instantclient_12_2文件下创建NETWORK文件夹,在NETWORK下创建ADMIN文件夹,在ADMIN文件夹中创建tnsnames.ora文件,编辑内容如下,注意可配置多个监听,监听多个数据库实例\n      \n      > A =\n      > \n      > (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.6.10)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = NBA) ) )\n      > \n      > 其中A是可以自定义的名称,用来自己识别所连接到是哪个数据库,真正的数据库实例名是SERVICE_NAME = NBA中的NBA,第一个等号"="后面的是数据库连接串.\n\n 3. 配置环境变量\n    \n    * 1. 修改Path变量，在后面添加 D:\\instantclient_12_2 -------instantclient_12_2文件夹路径\n      \n      2. 变量名：TNS_ADMIN 变量值：D:\\instantclient_12_2\\NETWORK\\ADMIN------------tnsnames.ora所在目录\n      \n      3. 变量名: NLS_LANG 变量值:SIMPLIFIED CHINESE_CHINA.ZHS16GBK',normalizedContent:'# plsql的使用\n\n 1. 下载plsql、汉化、破解\n\n 2. 下载instantclient文件，并配置\n    \n    * 在instantclient_12_2文件下创建network文件夹,在network下创建admin文件夹,在admin文件夹中创建tnsnames.ora文件,编辑内容如下,注意可配置多个监听,监听多个数据库实例\n      \n      > a =\n      > \n      > (description = (address_list = (address = (protocol = tcp)(host = 192.168.6.10)(port = 1521)) ) (connect_data = (service_name = nba) ) )\n      > \n      > 其中a是可以自定义的名称,用来自己识别所连接到是哪个数据库,真正的数据库实例名是service_name = nba中的nba,第一个等号"="后面的是数据库连接串.\n\n 3. 配置环境变量\n    \n    * 1. 修改path变量，在后面添加 d:\\instantclient_12_2 -------instantclient_12_2文件夹路径\n      \n      2. 变量名：tns_admin 变量值：d:\\instantclient_12_2\\network\\admin------------tnsnames.ora所在目录\n      \n      3. 变量名: nls_lang 变量值:simplified chinese_china.zhs16gbk',charsets:{cjk:!0}},{title:"Docker基础 - 入门基础和Helloworld",frontmatter:{title:"Docker基础 - 入门基础和Helloworld",date:"2021-10-19T17:19:22.000Z",permalink:"/pages/910866/",categories:["技术","工具使用","后端","docker"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/10.docker/02.Docker%E5%9F%BA%E7%A1%80_%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E5%92%8CHelloworld.html",relativePath:"03.技术/06.工具使用/10.docker/02.Docker基础_入门基础和Helloworld.md",key:"v-a1218f50",path:"/pages/910866/",headers:[{level:2,title:"Docker 架构",slug:"docker-架构",normalizedTitle:"docker 架构",charIndex:188},{level:2,title:"Docker 安装",slug:"docker-安装",normalizedTitle:"docker 安装",charIndex:720},{level:3,title:"CentOS 版本要求",slug:"centos-版本要求",normalizedTitle:"centos 版本要求",charIndex:912},{level:3,title:"卸载老的Docker及依赖",slug:"卸载老的docker及依赖",normalizedTitle:"卸载老的docker及依赖",charIndex:993},{level:3,title:"安装一些依赖库",slug:"安装一些依赖库",normalizedTitle:"安装一些依赖库",charIndex:1469},{level:3,title:"安装Docker CE",slug:"安装docker-ce",normalizedTitle:"安装docker ce",charIndex:1787},{level:2,title:"仓库配置",slug:"仓库配置",normalizedTitle:"仓库配置",charIndex:2388},{level:2,title:"镜像查看和拉取",slug:"镜像查看和拉取",normalizedTitle:"镜像查看和拉取",charIndex:2995},{level:2,title:"容器实例-ubuntu实例",slug:"容器实例-ubuntu实例",normalizedTitle:"容器实例-ubuntu实例",charIndex:4567},{level:3,title:"从一个ubuntu的hello world说起",slug:"从一个ubuntu的hello-world说起",normalizedTitle:"从一个ubuntu的hello world说起",charIndex:4652},{level:3,title:"运行交互式的容器",slug:"运行交互式的容器",normalizedTitle:"运行交互式的容器",charIndex:5492},{level:3,title:"运行容器至后台模式",slug:"运行容器至后台模式",normalizedTitle:"运行容器至后台模式",charIndex:5886}],headersStr:"Docker 架构 Docker 安装 CentOS 版本要求 卸载老的Docker及依赖 安装一些依赖库 安装Docker CE 仓库配置 镜像查看和拉取 容器实例-ubuntu实例 从一个ubuntu的hello world说起 运行交互式的容器 运行容器至后台模式",content:'# Docker基础 - 入门基础和Helloworld\n\n> 在了解了虚拟化技术和Docker之后，让我们上手Docker，看看Docker是怎么工作的。这里会介绍CentOS环境下Docker的安装和配置，以及会给你展示两个实例，给你一个直观的理解。再啰嗦下，有条件的情况下直接看官网 (opens new window), 网上资料鱼龙混杂，版本也更新不及时。\n\n\n# Docker 架构\n\n> 理解如下的一些概念，你才知道安装什么\n\nDocker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。\n\n * Docker 客户端(Client) : Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.docker.com/develop/sdk/) 与 Docker 的守护进程通信。\n * Docker 主机(Host) ：一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。\n\nDocker 包括三个基本概念:\n\n * 镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。\n * 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n * 仓库（Repository）：仓库可看着一个代码控制中心，用来保存镜像。\n\n\n\n\n# Docker 安装\n\n> 从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE：Docker CE 即社区免费版；Docker EE 即企业版，强调安全，但需付费使用；按照官网上Docker Engine - Community包现在就是叫做Docker CE。这里将展示在CentOS上安装Docker。\n\n\n# CentOS 版本要求\n\n官网要求，使用CentOS7的稳定版本，同时：\n\n * 启用centos-extras\n * 推荐使用overlay2存储驱动\n\n\n# 卸载老的Docker及依赖\n\n> 为什么你可能还需要删除较低的Docker安装？因为较旧版本的Docker被称为docker或docker-engine（它是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure）\n\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 安装一些依赖库\n\n * yum-utils 提供 yum-config-manager 类库\n * device-mapper-persistent-data 和 lvm2 被devicemapper 存储驱动依赖\n\nsudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n\n\n1\n2\n3\n\n\n设置稳定版本的库\n\nsudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n\n\n1\n2\n3\n\n\n\n# 安装Docker CE\n\nyum install -y docker-ce\n\n\n1\n\n\n安装完之后启动\n\nsudo systemctl start docker\n\n\n1\n\n\n测试是否安装成功\n\n[root@pdai ~]# systemctl status docker\n● docker.service - Docker Application Container Engine\n   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)\n   Active: active (running) since Mon 2020-02-17 13:57:45 CST; 39s ago\n     Docs: https://docs.docker.com\n Main PID: 26029 (dockerd)\n    Tasks: 8\n   Memory: 36.9M\n   CGroup: /system.slice/docker.service\n           └─26029 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 仓库配置\n\n> Docker 安装好以后，我们就要开始为拉取镜像准备了；国内从 DockerHub 拉取镜像有时会特别慢，此时可以配置镜像加速器。\n\nDocker 官方和国内很多云服务商都提供了国内加速器服务，比如：\n\n * 阿里云的加速器：https://help.aliyun.com/document_detail/60750.html\n * 网易加速器：http://hub-mirror.c.163.com\n * Docker官方中国加速器：https://registry.docker-cn.com\n * ustc 的镜像：https://docker.mirrors.ustc.edu.cn\n * daocloud：https://www.daocloud.io/mirror#accelerator-doc（注册后使用）\n\n这里配置 Docker官方中国的加速器：\n\n对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）\n\n{"registry-mirrors":["https://registry.docker-cn.com"]}\n\n\n1\n\n\n之后重新启动服务\n\n$ sudo systemctl daemon-reload\n$ sudo systemctl restart docker\n\n\n1\n2\n\n\n\n# 镜像查看和拉取\n\n> 拉一个docker镜像试试吧？\n\n拉取hello world\n\n[root@pdai ~]# docker pull hello-world:latest\nlatest: Pulling from library/hello-world\n1b930d010525: Pull complete\nDigest: sha256:9572f7cdcee8591948c2963463447a53466950b3fc15a247fcad1917ca215a2f\nStatus: Downloaded newer image for hello-world:latest\ndocker.io/library/hello-world:latest\n\n\n1\n2\n3\n4\n5\n6\n\n\n看本地仓库是否有这个库\n\n[root@pdai ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nhello-world         latest              fce289e99eb9        13 months ago       1.84kB\n\n\n1\n2\n3\n\n\n运行这个镜像的实例，即容器\n\n[root@pdai ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 注意, 如果你在没有镜像的时候，直接docker run hello-world也是可以的；它会先检查本地是否有这个镜像，没有的话会先从指定仓库中拉取。\n\n\n# 容器实例-ubuntu实例\n\n> 上面我们跑了一个官方的Hello-world容器实例, 这里通过介绍运行ubuntu的实例来全面理解如何跑一个Docker实例\n\n\n# 从一个ubuntu的hello world说起\n\nDocker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序。这里同样是个Hello World，不同在于它是在容器内部运行的。\n\n[root@pdai ~]# docker run ubuntu:latest /bin/echo "Hello world"\nUnable to find image \'ubuntu:latest\' locally\nlatest: Pulling from library/ubuntu\n5c939e3a4d10: Pull complete\nc63719cdbe7a: Pull complete\n19a861ea6baf: Pull complete\n651c9d2d6c4f: Pull complete\nDigest: sha256:8d31dad0c58f552e890d68bbfb735588b6b820a46e459672d96e585871acc110\nStatus: Downloaded newer image for ubuntu:latest\nHello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们看下各个参数的含义：\n\n * docker: Docker 的二进制执行文件。\n * run: 与前面的 docker 组合来运行一个容器。\n * ubuntu:latest 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。\n * /bin/echo "Hello world": 在启动的容器里执行的命令\n\n以上命令完整的意思可以解释为：Docker 以 ubuntu 最新的（默认是latest) 镜像创建一个新容器，然后在容器里执行 bin/echo "Hello world"，然后输出结果。\n\n\n# 运行交互式的容器\n\n> 以上面例子，容器跑的是Ubuntu是一个系统实例，能否进入系统进行交互呢？\n\n我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现"对话"的能力：\n\n[root@pdai ~]# docker run -i -t ubuntu:latest\nroot@414bf796cbe4:/# echo \'hello world\'\nhello world\nroot@414bf796cbe4:/#\n\n\n1\n2\n3\n4\n\n\n各个参数解析：\n\n * -t: 在新容器内指定一个伪终端或终端。\n * -i: 允许你对容器内的标准输入 (STDIN) 进行交互。\n\n我们可以通过运行 exit 命令或者使用 CTRL+D 来退出容器\n\nroot@414bf796cbe4:/# exit\nexit\n[root@pdai ~]#\n\n\n1\n2\n3\n\n\n\n# 运行容器至后台模式\n\n> 我们先来看, 当我们跑完上面例子之后，我们看下后台是否有docker容器实例？\n\n显然没有任何容器实例\n\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n\n\n1\n2\n\n\n所以我们需要-d参数，来让容器实例在后台运行，比如：\n\n[root@pdai ~]# docker run -d ubuntu:latest /bin/sh -c "while true; do echo hello world; sleep 1; done"\n1a51d2f023c947f2be2d9a78eb863e854ca302c89bf354654c409e23e7dd25d7\n\n\n1\n2\n\n\n在输出中，我们没有看到期望的 "hello world"，而是一串长字符\n\n2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63\n\n\n1\n\n\n这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。\n\n首先，我们需要确认容器有在运行，可以通过 docker ps 来查看：\n\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES\n1a51d2f023c9        ubuntu:latest       "/bin/sh -c \'while t…"   About a minute ago   Up About a minute                       gifted_brown\n\n\n1\n2\n3\n\n\n输出详情介绍：\n\n * CONTAINER ID: 容器 ID。\n * IMAGE: 使用的镜像。\n * COMMAND: 启动容器时运行的命令。\n * CREATED: 容器的创建时间。\n * STATUS: 容器状态(状态有7种)。\n   * created（已创建）\n   * restarting（重启中）\n   * running（运行中）\n   * removing（迁移中）\n   * paused（暂停）\n   * exited（停止）\n   * dead（死亡）\n * PORTS: 容器的端口信息和使用的连接类型（tcp\\udp）。\n * NAMES: 自动分配的容器名称。\n\n我们通过docker logs 命令，查看指定容器内的标准输出:\n\n[root@pdai ~]# docker logs 1a51d2f023c9\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n最后我们看下，如何关闭后台实例\n\n[root@pdai ~]# docker stop 1a51d2f023c9\n1a51d2f023c9\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n[root@pdai ~]#\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# docker基础 - 入门基础和helloworld\n\n> 在了解了虚拟化技术和docker之后，让我们上手docker，看看docker是怎么工作的。这里会介绍centos环境下docker的安装和配置，以及会给你展示两个实例，给你一个直观的理解。再啰嗦下，有条件的情况下直接看官网 (opens new window), 网上资料鱼龙混杂，版本也更新不及时。\n\n\n# docker 架构\n\n> 理解如下的一些概念，你才知道安装什么\n\ndocker 使用客户端-服务器 (c/s) 架构模式，使用远程api来管理和创建docker容器。\n\n * docker 客户端(client) : docker 客户端通过命令行或者其他工具使用 docker sdk (https://docs.docker.com/develop/sdk/) 与 docker 的守护进程通信。\n * docker 主机(host) ：一个物理或者虚拟的机器用于执行 docker 守护进程和容器。\n\ndocker 包括三个基本概念:\n\n * 镜像（image）：docker 镜像（image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 ubuntu16.04 最小系统的 root 文件系统。\n * 容器（container）：镜像（image）和容器（container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n * 仓库（repository）：仓库可看着一个代码控制中心，用来保存镜像。\n\n\n\n\n# docker 安装\n\n> 从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: docker ce 和 docker ee：docker ce 即社区免费版；docker ee 即企业版，强调安全，但需付费使用；按照官网上docker engine - community包现在就是叫做docker ce。这里将展示在centos上安装docker。\n\n\n# centos 版本要求\n\n官网要求，使用centos7的稳定版本，同时：\n\n * 启用centos-extras\n * 推荐使用overlay2存储驱动\n\n\n# 卸载老的docker及依赖\n\n> 为什么你可能还需要删除较低的docker安装？因为较旧版本的docker被称为docker或docker-engine（它是一个简化docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装docker，比如virtualbox、 digital ocean、microsoft azure）\n\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 安装一些依赖库\n\n * yum-utils 提供 yum-config-manager 类库\n * device-mapper-persistent-data 和 lvm2 被devicemapper 存储驱动依赖\n\nsudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n\n\n1\n2\n3\n\n\n设置稳定版本的库\n\nsudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n\n\n1\n2\n3\n\n\n\n# 安装docker ce\n\nyum install -y docker-ce\n\n\n1\n\n\n安装完之后启动\n\nsudo systemctl start docker\n\n\n1\n\n\n测试是否安装成功\n\n[root@pdai ~]# systemctl status docker\n● docker.service - docker application container engine\n   loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)\n   active: active (running) since mon 2020-02-17 13:57:45 cst; 39s ago\n     docs: https://docs.docker.com\n main pid: 26029 (dockerd)\n    tasks: 8\n   memory: 36.9m\n   cgroup: /system.slice/docker.service\n           └─26029 /usr/bin/dockerd -h fd:// --containerd=/run/containerd/containerd\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 仓库配置\n\n> docker 安装好以后，我们就要开始为拉取镜像准备了；国内从 dockerhub 拉取镜像有时会特别慢，此时可以配置镜像加速器。\n\ndocker 官方和国内很多云服务商都提供了国内加速器服务，比如：\n\n * 阿里云的加速器：https://help.aliyun.com/document_detail/60750.html\n * 网易加速器：http://hub-mirror.c.163.com\n * docker官方中国加速器：https://registry.docker-cn.com\n * ustc 的镜像：https://docker.mirrors.ustc.edu.cn\n * daocloud：https://www.daocloud.io/mirror#accelerator-doc（注册后使用）\n\n这里配置 docker官方中国的加速器：\n\n对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）\n\n{"registry-mirrors":["https://registry.docker-cn.com"]}\n\n\n1\n\n\n之后重新启动服务\n\n$ sudo systemctl daemon-reload\n$ sudo systemctl restart docker\n\n\n1\n2\n\n\n\n# 镜像查看和拉取\n\n> 拉一个docker镜像试试吧？\n\n拉取hello world\n\n[root@pdai ~]# docker pull hello-world:latest\nlatest: pulling from library/hello-world\n1b930d010525: pull complete\ndigest: sha256:9572f7cdcee8591948c2963463447a53466950b3fc15a247fcad1917ca215a2f\nstatus: downloaded newer image for hello-world:latest\ndocker.io/library/hello-world:latest\n\n\n1\n2\n3\n4\n5\n6\n\n\n看本地仓库是否有这个库\n\n[root@pdai ~]# docker images\nrepository          tag                 image id            created             size\nhello-world         latest              fce289e99eb9        13 months ago       1.84kb\n\n\n1\n2\n3\n\n\n运行这个镜像的实例，即容器\n\n[root@pdai ~]# docker run hello-world\n\nhello from docker!\nthis message shows that your installation appears to be working correctly.\n\nto generate this message, docker took the following steps:\n 1. the docker client contacted the docker daemon.\n 2. the docker daemon pulled the "hello-world" image from the docker hub.\n    (amd64)\n 3. the docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. the docker daemon streamed that output to the docker client, which sent it\n    to your terminal.\n\nto try something more ambitious, you can run an ubuntu container with:\n $ docker run -it ubuntu bash\n\nshare images, automate workflows, and more with a free docker id:\n https://hub.docker.com/\n\nfor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 注意, 如果你在没有镜像的时候，直接docker run hello-world也是可以的；它会先检查本地是否有这个镜像，没有的话会先从指定仓库中拉取。\n\n\n# 容器实例-ubuntu实例\n\n> 上面我们跑了一个官方的hello-world容器实例, 这里通过介绍运行ubuntu的实例来全面理解如何跑一个docker实例\n\n\n# 从一个ubuntu的hello world说起\n\ndocker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序。这里同样是个hello world，不同在于它是在容器内部运行的。\n\n[root@pdai ~]# docker run ubuntu:latest /bin/echo "hello world"\nunable to find image \'ubuntu:latest\' locally\nlatest: pulling from library/ubuntu\n5c939e3a4d10: pull complete\nc63719cdbe7a: pull complete\n19a861ea6baf: pull complete\n651c9d2d6c4f: pull complete\ndigest: sha256:8d31dad0c58f552e890d68bbfb735588b6b820a46e459672d96e585871acc110\nstatus: downloaded newer image for ubuntu:latest\nhello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们看下各个参数的含义：\n\n * docker: docker 的二进制执行文件。\n * run: 与前面的 docker 组合来运行一个容器。\n * ubuntu:latest 指定要运行的镜像，docker 首先从本地主机上查找镜像是否存在，如果不存在，docker 就会从镜像仓库 docker hub 下载公共镜像。\n * /bin/echo "hello world": 在启动的容器里执行的命令\n\n以上命令完整的意思可以解释为：docker 以 ubuntu 最新的（默认是latest) 镜像创建一个新容器，然后在容器里执行 bin/echo "hello world"，然后输出结果。\n\n\n# 运行交互式的容器\n\n> 以上面例子，容器跑的是ubuntu是一个系统实例，能否进入系统进行交互呢？\n\n我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现"对话"的能力：\n\n[root@pdai ~]# docker run -i -t ubuntu:latest\nroot@414bf796cbe4:/# echo \'hello world\'\nhello world\nroot@414bf796cbe4:/#\n\n\n1\n2\n3\n4\n\n\n各个参数解析：\n\n * -t: 在新容器内指定一个伪终端或终端。\n * -i: 允许你对容器内的标准输入 (stdin) 进行交互。\n\n我们可以通过运行 exit 命令或者使用 ctrl+d 来退出容器\n\nroot@414bf796cbe4:/# exit\nexit\n[root@pdai ~]#\n\n\n1\n2\n3\n\n\n\n# 运行容器至后台模式\n\n> 我们先来看, 当我们跑完上面例子之后，我们看下后台是否有docker容器实例？\n\n显然没有任何容器实例\n\n[root@pdai ~]# docker ps\ncontainer id        image               command             created             status              ports               names\n\n\n1\n2\n\n\n所以我们需要-d参数，来让容器实例在后台运行，比如：\n\n[root@pdai ~]# docker run -d ubuntu:latest /bin/sh -c "while true; do echo hello world; sleep 1; done"\n1a51d2f023c947f2be2d9a78eb863e854ca302c89bf354654c409e23e7dd25d7\n\n\n1\n2\n\n\n在输出中，我们没有看到期望的 "hello world"，而是一串长字符\n\n2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63\n\n\n1\n\n\n这个长字符串叫做容器 id，对每个容器来说都是唯一的，我们可以通过容器 id 来查看对应的容器发生了什么。\n\n首先，我们需要确认容器有在运行，可以通过 docker ps 来查看：\n\n[root@pdai ~]# docker ps\ncontainer id        image               command                  created              status              ports               names\n1a51d2f023c9        ubuntu:latest       "/bin/sh -c \'while t…"   about a minute ago   up about a minute                       gifted_brown\n\n\n1\n2\n3\n\n\n输出详情介绍：\n\n * container id: 容器 id。\n * image: 使用的镜像。\n * command: 启动容器时运行的命令。\n * created: 容器的创建时间。\n * status: 容器状态(状态有7种)。\n   * created（已创建）\n   * restarting（重启中）\n   * running（运行中）\n   * removing（迁移中）\n   * paused（暂停）\n   * exited（停止）\n   * dead（死亡）\n * ports: 容器的端口信息和使用的连接类型（tcp\\udp）。\n * names: 自动分配的容器名称。\n\n我们通过docker logs 命令，查看指定容器内的标准输出:\n\n[root@pdai ~]# docker logs 1a51d2f023c9\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\nhello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n最后我们看下，如何关闭后台实例\n\n[root@pdai ~]# docker stop 1a51d2f023c9\n1a51d2f023c9\n[root@pdai ~]# docker ps\ncontainer id        image               command             created             status              ports               names\n[root@pdai ~]#\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0}},{title:"Typora的使用",frontmatter:{title:"Typora的使用",date:"2021-07-08T19:11:03.000Z",permalink:"/pages/e09ac3/",categories:["工具使用","Typora的使用"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/04.Typora%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"03.技术/06.工具使用/04.Typora的使用.md",key:"v-551fc23c",path:"/pages/e09ac3/",headers:[{level:2,title:"一.更换Vue主题",slug:"一-更换vue主题",normalizedTitle:"一.更换vue主题",charIndex:16}],headersStr:"一.更换Vue主题",content:"# Typora的使用\n\n\n# 一.更换Vue主题\n\n 1. 下载vue主题地址：https://theme.typora.io/theme/Vue",normalizedContent:"# typora的使用\n\n\n# 一.更换vue主题\n\n 1. 下载vue主题地址：https://theme.typora.io/theme/vue",charsets:{cjk:!0}},{title:"Docker - Overview",frontmatter:{title:"Docker - Overview",date:"2021-10-19T17:16:42.000Z",permalink:"/pages/96abfe/",categories:["技术","工具使用","后端","docker"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/10.docker/00.Docker_Overview.html",relativePath:"03.技术/06.工具使用/10.docker/00.Docker_Overview.md",key:"v-72bc6c96",path:"/pages/96abfe/",headers:[{level:2,title:"学习资源",slug:"学习资源",normalizedTitle:"学习资源",charIndex:68}],headersStr:"学习资源",content:"# Docker - Overview\n\n> 主机端口：docker容器端口\n> \n> 主机挂载文件：docker容器挂载文件\n\n\n# 学习资源\n\n> 最好的资源在官网! 最好的资源在官网! 最好的资源在官网!\n\nDocker 资源\n\n * Docker 官方主页: https://www.docker.com (opens new window)\n * Docker 官方博客: https://blog.docker.com/\n * Docker 官方文档: https://docs.docker.com/\n * Docker Store: https://store.docker.com\n * Docker Cloud: https://cloud.docker.com\n * Docker Hub: https://hub.docker.com\n * Docker 的源代码仓库: https://github.com/moby/moby\n * Docker 发布版本历史: https://docs.docker.com/release-notes/\n * Docker 常见问题: https://docs.docker.com/engine/faq/\n * Docker 远端应用 API: https://docs.docker.com/develop/sdk/\n\nDocker 国内镜像\n\n * 阿里云的加速器：https://help.aliyun.com/document_detail/60750.html\n * 网易加速器：http://hub-mirror.c.163.com\n * 官方中国加速器：https://registry.docker-cn.com\n * ustc 的镜像：https://docker.mirrors.ustc.edu.cn\n * daocloud：https://www.daocloud.io/mirror#accelerator-doc（注册后使用）",normalizedContent:"# docker - overview\n\n> 主机端口：docker容器端口\n> \n> 主机挂载文件：docker容器挂载文件\n\n\n# 学习资源\n\n> 最好的资源在官网! 最好的资源在官网! 最好的资源在官网!\n\ndocker 资源\n\n * docker 官方主页: https://www.docker.com (opens new window)\n * docker 官方博客: https://blog.docker.com/\n * docker 官方文档: https://docs.docker.com/\n * docker store: https://store.docker.com\n * docker cloud: https://cloud.docker.com\n * docker hub: https://hub.docker.com\n * docker 的源代码仓库: https://github.com/moby/moby\n * docker 发布版本历史: https://docs.docker.com/release-notes/\n * docker 常见问题: https://docs.docker.com/engine/faq/\n * docker 远端应用 api: https://docs.docker.com/develop/sdk/\n\ndocker 国内镜像\n\n * 阿里云的加速器：https://help.aliyun.com/document_detail/60750.html\n * 网易加速器：http://hub-mirror.c.163.com\n * 官方中国加速器：https://registry.docker-cn.com\n * ustc 的镜像：https://docker.mirrors.ustc.edu.cn\n * daocloud：https://www.daocloud.io/mirror#accelerator-doc（注册后使用）",charsets:{cjk:!0}},{title:"虚拟化技术",frontmatter:{title:"虚拟化技术",date:"2021-10-19T17:17:20.000Z",permalink:"/pages/1163f9/",categories:["技术","工具使用","后端","docker"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/10.docker/01.%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF.html",relativePath:"03.技术/06.工具使用/10.docker/01.虚拟化技术.md",key:"v-ba42e26c",path:"/pages/1163f9/",headers:[{level:2,title:"什么是虚拟化技术？",slug:"什么是虚拟化技术",normalizedTitle:"什么是虚拟化技术？",charIndex:270},{level:3,title:"什么是虚拟化",slug:"什么是虚拟化",normalizedTitle:"什么是虚拟化",charIndex:229},{level:3,title:"虚拟化技术分类",slug:"虚拟化技术分类",normalizedTitle:"虚拟化技术分类",charIndex:474},{level:3,title:"几种虚拟化技术",slug:"几种虚拟化技术",normalizedTitle:"几种虚拟化技术",charIndex:1908},{level:2,title:"Docker虚拟化",slug:"docker虚拟化",normalizedTitle:"docker虚拟化",charIndex:3352},{level:3,title:"什么是Docker？",slug:"什么是docker",normalizedTitle:"什么是docker？",charIndex:3366},{level:3,title:"Docker能干什么？",slug:"docker能干什么",normalizedTitle:"docker能干什么？",charIndex:3816},{level:2,title:"Docker和虚拟机的区别？",slug:"docker和虚拟机的区别",normalizedTitle:"docker和虚拟机的区别？",charIndex:5347},{level:3,title:"基本对比",slug:"基本对比",normalizedTitle:"基本对比",charIndex:5428},{level:3,title:"虚拟技术对比",slug:"虚拟技术对比",normalizedTitle:"虚拟技术对比",charIndex:6853},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:7447}],headersStr:"什么是虚拟化技术？ 什么是虚拟化 虚拟化技术分类 几种虚拟化技术 Docker虚拟化 什么是Docker？ Docker能干什么？ Docker和虚拟机的区别？ 基本对比 虚拟技术对比 参考文章",content:'# 虚拟化技术 - Docker Vs. 虚拟机\n\n> 人们为了提高系统及硬件资源的利用率而引入了虚拟化技术。虚拟化是一种资源管理技术，它可以各种实体资源抽像后再分隔，从而打破实体结构的限制，最大程度的提高资源的利用率。Docker属于软件虚拟化技术中的操作系统层虚拟化技术，它是基于LXC实现的一个应用容器引擎，Docker让开发者可以打包他们的应用及依赖环境到一个可移植的容器中，然后可以将这个容器快速部署开发、测试或生产环境中。了解本文从三个问题着手，什么是虚拟化技术，docker和虚拟机区别，docker可以用来做什么？\n\n\n# 什么是虚拟化技术？\n\n\n# 什么是虚拟化\n\n在计算机技术中，虚拟化（Virtualization）是一种资源管理技术。它是将计算机的各种实体资源，如：服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用更好的方式来利用这些资源。\n\n虚拟化的目的是为了在同一个主机上运行多个系统或应用，从而提高系统资源的利用率，并带来降低成本、方便管理和容错容灾等好处。\n\n\n# 虚拟化技术分类\n\n从实现形式来分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化。\n\n# 硬件虚拟化\n\n硬件虚拟化就是硬件物理平台本身提供了对特殊指令的截获和重定向的支持。支持虚拟化的硬件，也是一些基于硬件实现软件虚拟化技术的关键。在基于硬件实现软件虚拟化的技术中，在硬件是实现虚拟化的基础，硬件(主要是CPU)会为虚拟化软件提供支持，从而实现硬件资源的虚拟化。\n\n支持虚拟化的硬件有：\n\n * Intel-VT-(Intel Virtualization Technology)，Intel公司为解决纯软件虚拟化解决方案在可靠性、安全性和性能上的不足而引进的技术。它可以让一个CPU工作起来像多个CPU在并行运行，从而使得在一部电脑内同时运行多个操作系统成为可能\n * AMD-V-(AMD Virtualization)，是AMD公司的虚拟化技术。它是对x86处理器系统架构的一组硬件扩展和硬件辅助虚拟化技术，可以简化纯软件的虚拟化解决方案，改进VMM（虚拟机监视器）的设计，更充分地利用硬件资源，提高服务器和数据中心的虚拟化效率\n\n# 软件虚拟化\n\n软件虚拟化就是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。在软件虚拟化技术中，有些技术不需要硬件支持，如：QEMU；而有些软件虚拟化技术，则依赖硬件支持，如：VMware、KVM。\n\n对软件虚拟化进行细分，又可以分为以下几类：\n\n * 完全虚拟化：（Full Virtualization）虚拟机模拟完整的底层硬件环境和特权指令的执行过程，使客户机操作系统可以独立运行。支持完全虚拟化的软件有：Parallels Workstation、VirtualBox、Virtual Iron、Oracle VM、Virtual PC、Virtual Server、Hyper-V、VMware Workstation、QEMU等\n * 硬件辅助虚拟化：（Hardware-assisted Virtualization）是指通过硬件辅助支持模拟运行环境，使客户机操作系统可以独立运行，实现完全虚拟化的功能。支持硬件辅助虚拟化的软件有：Linux KVM、VMware Workstation、VMware Fusion、Virtual PC、Xen、VirtualBox、Parallels Workstation等\n * 部分虚拟化：（Partial Virtualization）只针对部分硬件资源进行虚拟化，虚拟机模拟部分底层硬件环境，特别是地址空间。这样的环境支持资源共享和线程独立，但是不允许建立独立的客户机操作系统。\n * 平行虚拟化：（Para-Virtualization）虚拟机不需要模拟硬件，而是将部分硬件接口以软件的形式提供给客户机操作系统。如：早期的Xen。\n * 操作系统层虚拟化：（OS-level virtualization）这种技术将操作系统内核虚拟化，可以允许使用者空间软件实例被分割成几个独立的单元，在内核中运行，而不是只有一个单一实例运行。这个软件实例，也被称为是一个容器（containers）、虚拟引擎（Virtualization engine）、虚拟专用服务器（virtual private servers）。每个容器的进程是独立的，对于使用者来说，就像是在使用自己的专用服务器。 Docker容器技术就是属于操作系统层虚拟化的范畴。\n\n\n# 几种虚拟化技术\n\n虚拟化是通过软件的方式模拟实体服务器，其初衷是为了解决“一种应用占用一台服务器”模式所带来的服务器数量剧增的问题，从而降低数据中心复杂度，简化管理难度。在虚拟化的发展过程中，出现过以下主要虚拟化技术或产品：\n\n * Xen - 由剑桥大学开发的，一款开源的虚拟机监视器。采用ICA协议，它通过一种叫做准虚拟化的技术来获取高性能，甚至在一些与传统虚拟技术极度不友好的架构上（如：x86），Xen也有极佳的表现。Xen属于半虚拟化的技术，所以其性能损失非常小。Xen没有指令翻译，其或者使用使能理解和翻译虚拟操作系统发出的未修改指令的CPU（即：完全虚拟化）；或者修改操作系统，使它发出的指令最优化，便于在虚拟化环境中执行（即：准虚拟化）。\n * KVM - KVM是一个Linux kernel模块，可以使用modprobe来加载KVM，加载后还需要通过其他工具创建虚拟机。KVM是一个全虚拟化的解决方案，但需要CPU支持虚拟化功能。相比Xen来说，KVM可以更加方便的整合进Linux内核，但它还需要其它虚拟化软件（如：QEMU）才能实现虚拟化功能。\n * LXC - 即：Linux Container，Linux容器，是一种轻量级的虚拟化的手段。它可以提供轻量级的虚拟化，以隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。容器会有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。\n * OpenVZ - 是SWsoft公司开发的开源软件，是该公司Virtuozzo软件的基础产品，是基于Linux平台的操作系统级服务器虚拟化解决方案。通过OpenVZ，可以在单个物理服务器上创建多个相互隔离的虚拟专用服务器(VPS)并以最大的效率共享硬件和管理资源。其上运行虚拟服务器被称为VPS（Virtual Private Serve），每个VPS的运行环境和独立服务器完全一致。OpenVZ基于Linux系统内核及作业系统提供操作系统级虚拟化，在虚拟化过程中资源消耗非常小，官方宣称约1-2%。\n * Hyper-V - 是微软件推出的一种虚拟化技术，可以采用半虚拟化或全虚拟的方式创建虚拟机。虽然它可以创建Windows或Linux操作系统，但其本身只能运行在Windows系统下，使用范围较为有限。\n * Oracle VM - Oracle推出的服务器虚拟化软件，基于开源的Xen技术，包括Oracle VM Server和Oracle VM Manager两部分。\n * VMWare - 是一家非常出名虚拟化软件公司，其产品涵盖服务器、桌面等各种虚拟化领域，如：VMware Workstation - 是一款桌面虚拟机软件，可以在一台实体机器上模拟完整的网络环境，并可运行多个Windows、DOS、Linux或Mac系统，是非常好的开发、测试、部署解决方案。从技术角度来说，VMware Workstation是一款完全虚拟化产品，可借助硬件辅助在不修改用户操作系统的情况下完整虚拟化操作系统。\n * VMware ESX Server - 是一款适用于任何系统环境的企业级的虚拟机软件，可以认为是VMware Server的升级版。相比VMware Workstation来说，其功能更加强大，可以用于构建高伸缩和高可靠企业级服务器，并可实现远程管理、高级资源管理控制等高级功能。\n\n\n# Docker虚拟化\n\n\n# 什么是Docker？\n\nDocker是一个开源的应用容器引擎，它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 Linux 发行版本的机器上。Docker基于LXC来实现类似VM的功能，可以在更有限的硬件资源上提供给用户更多的计算资源。与同VM等虚拟化的方式不同，LXC不属于全虚拟化、部分虚拟化或半虚拟化中的任何一个分类，而是一个操作系统级虚拟化。\n\nDocker是直接运行在宿主操作系统之上的一个容器，使用沙箱机制完全虚拟出一个完整的操作，容器之间不会有任何接口，从而让容器与宿主机之间、容器与容器之间隔离的更加彻底。每个容器会有自己的权限管理，独立的网络与存储栈，及自己的资源管理能，使同一台宿主机上可以友好的共存多个容器。\n\nDocker借助Linux的内核特性，如：控制组（Control Group）、命名空间（Namespace）等，并直接调用操作系统的系统调用接口。从而降低每个容器的系统开销，并实现降低容器复杂度、启动快、资源占用小等特征。\n\n\n# Docker能干什么？\n\n * 简化配置\n\n这是Docker公司宣传的Docker的主要使用场景。虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。\n\n * 代码流水线（Code Pipeline）管理\n\n前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。\n\n * 提高开发效率\n\n这就带来了一些额外的好处：Docker能提升开发者的开发效率。详细一点的例子，可以参考Aater在DevOpsDays Austin 2014大会或者是DockerCon上的演讲。\n\n不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想快速搭建开发环境。\n\n理想状态中，要达到第一个目标，我们需要将每一个服务都跑在独立的虚拟机中以便监控生产环境中服务的运行状态。然而，我们却不想每次都需要网络连接，每次重新编译的时候远程连接上去特别麻烦。这就是Docker做的特别好的地方，开发环境的机器通常内存比较小，之前使用虚拟的时候，我们经常需要为开发环境的机器加内存，而现在Docker可以轻易的让几十个服务在Docker中跑起来。\n\n * 隔离应用\n\n有很多种原因会让你选择在一个机器上运行不同的应用，比如之前提到的提高开发效率的场景等。\n\n我们经常需要考虑两点，一是因为要降低成本而进行服务器整合，二是将一个整体式的应用拆分成松耦合的单个服务（译者注：微服务架构）。如果你想了解为什么松耦合的应用这么重要，请参考Steve Yege的这篇论文，文中将Google和亚马逊做了比较。\n\n * 整合服务器 正如通过虚拟机来整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。\n * 调适能力\n\nDocker提供了很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多的功能，包括可以为容器设置检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。你可以在《Docker拯救世界》的文章中找到这一点的例证。\n\n * 多租户\n\n另外一个Docker有意思的使用场景是在多租户的应用中，它可以避免关键应用的重写。我们一个特别的关于这个场景的例子是为IoT（物联网）的应用开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间，也浪费金钱。\n\n使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。\n\n * 快速部署\n\n在虚拟机之前，引入新的硬件资源需要消耗几天的时间。Docker的虚拟化技术将这个时间降到了几分钟，Docker只是创建一个容器进程而无需启动操作系统，这个过程只需要秒级的时间。这正是Google和Facebook都看重的特性。\n\n你可以在数据中心创建销毁资源而无需担心重新启动带来的开销。通常数据中心的资源利用率只有30%，通过使用Docker并进行有效的资源分配可以提高资源的利用率。\n\n\n# Docker和虚拟机的区别？\n\n> 虚拟机Virtual Machine与容器化技术（代表Docker）都是虚拟化技术，两者的区别在于虚拟化的程度不同。\n\n\n# 基本对比\n\n\n\n * 虚拟机\n   * 基础设施（Infrastructure）。它可以是你的个人电脑，数据中心的服务器，或者是云主机。\n   * 主操作系统（Host Operating System）。你的个人电脑之上，运行的可能是MacOS，Windows或者某个Linux发行版。\n   * 虚拟机管理系统（Hypervisor）。利用Hypervisor，可以在主操作系统之上运行多个不同的从操作系统。类型1的Hypervisor有支持MacOS的HyperKit，支持Windows的Hyper-V以及支持Linux的KVM。类型2的Hypervisor有VirtualBox和VMWare。\n   * 操作系统（Guest Operating System）。假设你需要运行3个相互隔离的应用，则需要使用Hypervisor启动3个从操作系统，也就是3个虚拟机。这些虚拟机都非常大，也许有700MB，这就意味着它们将占用2.1GB的磁盘空间。更糟糕的是，它们还会消耗很多CPU和内存。\n   * 各种依赖。每一个从操作系统都需要安装许多依赖。如果你的的应用需要连接PostgreSQL的话，则需要安装libpq-dev；如果你使用Ruby的话，应该需要安装gems；如果使用其他编程语言，比如Python或者Node.js，都会需要安装对应的依赖库。\n * Docker容器\n   * 主操作系统（Host Operating System）。所有主流的Linux发行版都可以运行Docker。对于MacOS和Windows，也有一些办法"运行"Docker。\n   * Docker守护进程（Docker Daemon）。Docker守护进程取代了Hypervisor，它是运行在操作系统之上的后台进程，负责管理Docker容器。\n   * 各种依赖。对于Docker，应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的。\n   * 应用。应用的源代码与它的依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像。不同的应用运行在不同的Docker容器中，它们是相互隔离的。\n\n虚拟机是在物理资源层面实现的隔离，相对于虚拟机，Docker是你APP层面实现的隔离，并且省去了虚拟机操作系统（Guest OS）），从而节省了一部分的系统资源；Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源。\n\n虚拟机与容器docker的区别，在于vm多了一层guest OS，虚拟机的Hypervisor会对硬件资源也进行虚拟化，而容器Docker会直接使用宿主机的硬件资源。\n\n下面我们采用形象的比喻区分两者的隔离级别：\n\n * 服务器：比作一个大型的仓管基地，包含场地与零散的货物——相当于各种服务器资源。\n * 虚拟机技术：比作仓库，拥有独立的空间堆放各种货物或集装箱，仓库之间完全独立——仓库相当于各种系统，独立的应用系统和操作系统。\n * Docker：比作集装箱，操作各种货物的打包——将各种应用程序和他们所依赖的运行环境打包成标准的容器，容器之间隔离。\n\n\n# 虚拟技术对比\n\n * 隔离性\n\n在于隔离性上面，由于vm对操作系统也进行了虚拟化，隔离的更加彻底。而Docker共享宿主机的操作系统，隔离性较差。\n\n * 运行效率\n\n由于vm的隔离操作，导致生成虚拟机的速率大大低于容器Docker生成的速度，因为Docker直接利用宿主机的系统内核。比如openstack能够以10台/min的速度创建虚拟机，而docker可以做到在几秒钟之内创建大量容器，它们的启动速度是在数量级上的差距。\n\n因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在Hypervisor虚拟的CPU上的；另外一方面是由于计算程序本身的特性导致的差异。虚拟机虚拟的cpu架构不同于实际cpu架构，数值计算程序一般针对特定的cpu架构有一定的优化措施，虚拟化使这些措施作废，甚至起到反效果。\n\n * 资源利用率\n\n在资源利用率上虚拟机由于隔离更彻底，因此利用率也会相对较低。\n\n因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在Hypervisor虚拟的CPU上的；另外一方面是由于计算程序本身的特性导致的差异。虚拟机虚拟的cpu架构不同于实际cpu架构，数值计算程序一般针对特定的cpu架构有一定的优化措施，虚拟化使这些措施作废，甚至起到反效果。比如对于本次实验的平台，实际的CPU架构是2块物理CPU。\n\n\n# 参考文章\n\n * https://blog.csdn.net/steelren/article/details/78491923\n * https://www.cnblogs.com/jie-fang/p/10279629.html',normalizedContent:'# 虚拟化技术 - docker vs. 虚拟机\n\n> 人们为了提高系统及硬件资源的利用率而引入了虚拟化技术。虚拟化是一种资源管理技术，它可以各种实体资源抽像后再分隔，从而打破实体结构的限制，最大程度的提高资源的利用率。docker属于软件虚拟化技术中的操作系统层虚拟化技术，它是基于lxc实现的一个应用容器引擎，docker让开发者可以打包他们的应用及依赖环境到一个可移植的容器中，然后可以将这个容器快速部署开发、测试或生产环境中。了解本文从三个问题着手，什么是虚拟化技术，docker和虚拟机区别，docker可以用来做什么？\n\n\n# 什么是虚拟化技术？\n\n\n# 什么是虚拟化\n\n在计算机技术中，虚拟化（virtualization）是一种资源管理技术。它是将计算机的各种实体资源，如：服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用更好的方式来利用这些资源。\n\n虚拟化的目的是为了在同一个主机上运行多个系统或应用，从而提高系统资源的利用率，并带来降低成本、方便管理和容错容灾等好处。\n\n\n# 虚拟化技术分类\n\n从实现形式来分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化。\n\n# 硬件虚拟化\n\n硬件虚拟化就是硬件物理平台本身提供了对特殊指令的截获和重定向的支持。支持虚拟化的硬件，也是一些基于硬件实现软件虚拟化技术的关键。在基于硬件实现软件虚拟化的技术中，在硬件是实现虚拟化的基础，硬件(主要是cpu)会为虚拟化软件提供支持，从而实现硬件资源的虚拟化。\n\n支持虚拟化的硬件有：\n\n * intel-vt-(intel virtualization technology)，intel公司为解决纯软件虚拟化解决方案在可靠性、安全性和性能上的不足而引进的技术。它可以让一个cpu工作起来像多个cpu在并行运行，从而使得在一部电脑内同时运行多个操作系统成为可能\n * amd-v-(amd virtualization)，是amd公司的虚拟化技术。它是对x86处理器系统架构的一组硬件扩展和硬件辅助虚拟化技术，可以简化纯软件的虚拟化解决方案，改进vmm（虚拟机监视器）的设计，更充分地利用硬件资源，提高服务器和数据中心的虚拟化效率\n\n# 软件虚拟化\n\n软件虚拟化就是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。在软件虚拟化技术中，有些技术不需要硬件支持，如：qemu；而有些软件虚拟化技术，则依赖硬件支持，如：vmware、kvm。\n\n对软件虚拟化进行细分，又可以分为以下几类：\n\n * 完全虚拟化：（full virtualization）虚拟机模拟完整的底层硬件环境和特权指令的执行过程，使客户机操作系统可以独立运行。支持完全虚拟化的软件有：parallels workstation、virtualbox、virtual iron、oracle vm、virtual pc、virtual server、hyper-v、vmware workstation、qemu等\n * 硬件辅助虚拟化：（hardware-assisted virtualization）是指通过硬件辅助支持模拟运行环境，使客户机操作系统可以独立运行，实现完全虚拟化的功能。支持硬件辅助虚拟化的软件有：linux kvm、vmware workstation、vmware fusion、virtual pc、xen、virtualbox、parallels workstation等\n * 部分虚拟化：（partial virtualization）只针对部分硬件资源进行虚拟化，虚拟机模拟部分底层硬件环境，特别是地址空间。这样的环境支持资源共享和线程独立，但是不允许建立独立的客户机操作系统。\n * 平行虚拟化：（para-virtualization）虚拟机不需要模拟硬件，而是将部分硬件接口以软件的形式提供给客户机操作系统。如：早期的xen。\n * 操作系统层虚拟化：（os-level virtualization）这种技术将操作系统内核虚拟化，可以允许使用者空间软件实例被分割成几个独立的单元，在内核中运行，而不是只有一个单一实例运行。这个软件实例，也被称为是一个容器（containers）、虚拟引擎（virtualization engine）、虚拟专用服务器（virtual private servers）。每个容器的进程是独立的，对于使用者来说，就像是在使用自己的专用服务器。 docker容器技术就是属于操作系统层虚拟化的范畴。\n\n\n# 几种虚拟化技术\n\n虚拟化是通过软件的方式模拟实体服务器，其初衷是为了解决“一种应用占用一台服务器”模式所带来的服务器数量剧增的问题，从而降低数据中心复杂度，简化管理难度。在虚拟化的发展过程中，出现过以下主要虚拟化技术或产品：\n\n * xen - 由剑桥大学开发的，一款开源的虚拟机监视器。采用ica协议，它通过一种叫做准虚拟化的技术来获取高性能，甚至在一些与传统虚拟技术极度不友好的架构上（如：x86），xen也有极佳的表现。xen属于半虚拟化的技术，所以其性能损失非常小。xen没有指令翻译，其或者使用使能理解和翻译虚拟操作系统发出的未修改指令的cpu（即：完全虚拟化）；或者修改操作系统，使它发出的指令最优化，便于在虚拟化环境中执行（即：准虚拟化）。\n * kvm - kvm是一个linux kernel模块，可以使用modprobe来加载kvm，加载后还需要通过其他工具创建虚拟机。kvm是一个全虚拟化的解决方案，但需要cpu支持虚拟化功能。相比xen来说，kvm可以更加方便的整合进linux内核，但它还需要其它虚拟化软件（如：qemu）才能实现虚拟化功能。\n * lxc - 即：linux container，linux容器，是一种轻量级的虚拟化的手段。它可以提供轻量级的虚拟化，以隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。容器会有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。\n * openvz - 是swsoft公司开发的开源软件，是该公司virtuozzo软件的基础产品，是基于linux平台的操作系统级服务器虚拟化解决方案。通过openvz，可以在单个物理服务器上创建多个相互隔离的虚拟专用服务器(vps)并以最大的效率共享硬件和管理资源。其上运行虚拟服务器被称为vps（virtual private serve），每个vps的运行环境和独立服务器完全一致。openvz基于linux系统内核及作业系统提供操作系统级虚拟化，在虚拟化过程中资源消耗非常小，官方宣称约1-2%。\n * hyper-v - 是微软件推出的一种虚拟化技术，可以采用半虚拟化或全虚拟的方式创建虚拟机。虽然它可以创建windows或linux操作系统，但其本身只能运行在windows系统下，使用范围较为有限。\n * oracle vm - oracle推出的服务器虚拟化软件，基于开源的xen技术，包括oracle vm server和oracle vm manager两部分。\n * vmware - 是一家非常出名虚拟化软件公司，其产品涵盖服务器、桌面等各种虚拟化领域，如：vmware workstation - 是一款桌面虚拟机软件，可以在一台实体机器上模拟完整的网络环境，并可运行多个windows、dos、linux或mac系统，是非常好的开发、测试、部署解决方案。从技术角度来说，vmware workstation是一款完全虚拟化产品，可借助硬件辅助在不修改用户操作系统的情况下完整虚拟化操作系统。\n * vmware esx server - 是一款适用于任何系统环境的企业级的虚拟机软件，可以认为是vmware server的升级版。相比vmware workstation来说，其功能更加强大，可以用于构建高伸缩和高可靠企业级服务器，并可实现远程管理、高级资源管理控制等高级功能。\n\n\n# docker虚拟化\n\n\n# 什么是docker？\n\ndocker是一个开源的应用容器引擎，它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 linux 发行版本的机器上。docker基于lxc来实现类似vm的功能，可以在更有限的硬件资源上提供给用户更多的计算资源。与同vm等虚拟化的方式不同，lxc不属于全虚拟化、部分虚拟化或半虚拟化中的任何一个分类，而是一个操作系统级虚拟化。\n\ndocker是直接运行在宿主操作系统之上的一个容器，使用沙箱机制完全虚拟出一个完整的操作，容器之间不会有任何接口，从而让容器与宿主机之间、容器与容器之间隔离的更加彻底。每个容器会有自己的权限管理，独立的网络与存储栈，及自己的资源管理能，使同一台宿主机上可以友好的共存多个容器。\n\ndocker借助linux的内核特性，如：控制组（control group）、命名空间（namespace）等，并直接调用操作系统的系统调用接口。从而降低每个容器的系统开销，并实现降低容器复杂度、启动快、资源占用小等特征。\n\n\n# docker能干什么？\n\n * 简化配置\n\n这是docker公司宣传的docker的主要使用场景。虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。\n\n * 代码流水线（code pipeline）管理\n\n前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。\n\n * 提高开发效率\n\n这就带来了一些额外的好处：docker能提升开发者的开发效率。详细一点的例子，可以参考aater在devopsdays austin 2014大会或者是dockercon上的演讲。\n\n不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想快速搭建开发环境。\n\n理想状态中，要达到第一个目标，我们需要将每一个服务都跑在独立的虚拟机中以便监控生产环境中服务的运行状态。然而，我们却不想每次都需要网络连接，每次重新编译的时候远程连接上去特别麻烦。这就是docker做的特别好的地方，开发环境的机器通常内存比较小，之前使用虚拟的时候，我们经常需要为开发环境的机器加内存，而现在docker可以轻易的让几十个服务在docker中跑起来。\n\n * 隔离应用\n\n有很多种原因会让你选择在一个机器上运行不同的应用，比如之前提到的提高开发效率的场景等。\n\n我们经常需要考虑两点，一是因为要降低成本而进行服务器整合，二是将一个整体式的应用拆分成松耦合的单个服务（译者注：微服务架构）。如果你想了解为什么松耦合的应用这么重要，请参考steve yege的这篇论文，文中将google和亚马逊做了比较。\n\n * 整合服务器 正如通过虚拟机来整合多个应用，docker隔离应用的能力使得docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，docker可以比虚拟机提供更好的服务器整合解决方案。\n * 调适能力\n\ndocker提供了很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多的功能，包括可以为容器设置检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试bug。你可以在《docker拯救世界》的文章中找到这一点的例证。\n\n * 多租户\n\n另外一个docker有意思的使用场景是在多租户的应用中，它可以避免关键应用的重写。我们一个特别的关于这个场景的例子是为iot（物联网）的应用开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间，也浪费金钱。\n\n使用docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于docker环境的启动速度和其高效的diff命令。\n\n * 快速部署\n\n在虚拟机之前，引入新的硬件资源需要消耗几天的时间。docker的虚拟化技术将这个时间降到了几分钟，docker只是创建一个容器进程而无需启动操作系统，这个过程只需要秒级的时间。这正是google和facebook都看重的特性。\n\n你可以在数据中心创建销毁资源而无需担心重新启动带来的开销。通常数据中心的资源利用率只有30%，通过使用docker并进行有效的资源分配可以提高资源的利用率。\n\n\n# docker和虚拟机的区别？\n\n> 虚拟机virtual machine与容器化技术（代表docker）都是虚拟化技术，两者的区别在于虚拟化的程度不同。\n\n\n# 基本对比\n\n\n\n * 虚拟机\n   * 基础设施（infrastructure）。它可以是你的个人电脑，数据中心的服务器，或者是云主机。\n   * 主操作系统（host operating system）。你的个人电脑之上，运行的可能是macos，windows或者某个linux发行版。\n   * 虚拟机管理系统（hypervisor）。利用hypervisor，可以在主操作系统之上运行多个不同的从操作系统。类型1的hypervisor有支持macos的hyperkit，支持windows的hyper-v以及支持linux的kvm。类型2的hypervisor有virtualbox和vmware。\n   * 操作系统（guest operating system）。假设你需要运行3个相互隔离的应用，则需要使用hypervisor启动3个从操作系统，也就是3个虚拟机。这些虚拟机都非常大，也许有700mb，这就意味着它们将占用2.1gb的磁盘空间。更糟糕的是，它们还会消耗很多cpu和内存。\n   * 各种依赖。每一个从操作系统都需要安装许多依赖。如果你的的应用需要连接postgresql的话，则需要安装libpq-dev；如果你使用ruby的话，应该需要安装gems；如果使用其他编程语言，比如python或者node.js，都会需要安装对应的依赖库。\n * docker容器\n   * 主操作系统（host operating system）。所有主流的linux发行版都可以运行docker。对于macos和windows，也有一些办法"运行"docker。\n   * docker守护进程（docker daemon）。docker守护进程取代了hypervisor，它是运行在操作系统之上的后台进程，负责管理docker容器。\n   * 各种依赖。对于docker，应用的所有依赖都打包在docker镜像中，docker容器是基于docker镜像创建的。\n   * 应用。应用的源代码与它的依赖都打包在docker镜像中，不同的应用需要不同的docker镜像。不同的应用运行在不同的docker容器中，它们是相互隔离的。\n\n虚拟机是在物理资源层面实现的隔离，相对于虚拟机，docker是你app层面实现的隔离，并且省去了虚拟机操作系统（guest os）），从而节省了一部分的系统资源；docker守护进程可以直接与主操作系统进行通信，为各个docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，docker可以节省大量的磁盘空间以及其他系统资源。\n\n虚拟机与容器docker的区别，在于vm多了一层guest os，虚拟机的hypervisor会对硬件资源也进行虚拟化，而容器docker会直接使用宿主机的硬件资源。\n\n下面我们采用形象的比喻区分两者的隔离级别：\n\n * 服务器：比作一个大型的仓管基地，包含场地与零散的货物——相当于各种服务器资源。\n * 虚拟机技术：比作仓库，拥有独立的空间堆放各种货物或集装箱，仓库之间完全独立——仓库相当于各种系统，独立的应用系统和操作系统。\n * docker：比作集装箱，操作各种货物的打包——将各种应用程序和他们所依赖的运行环境打包成标准的容器，容器之间隔离。\n\n\n# 虚拟技术对比\n\n * 隔离性\n\n在于隔离性上面，由于vm对操作系统也进行了虚拟化，隔离的更加彻底。而docker共享宿主机的操作系统，隔离性较差。\n\n * 运行效率\n\n由于vm的隔离操作，导致生成虚拟机的速率大大低于容器docker生成的速度，因为docker直接利用宿主机的系统内核。比如openstack能够以10台/min的速度创建虚拟机，而docker可以做到在几秒钟之内创建大量容器，它们的启动速度是在数量级上的差距。\n\n因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在hypervisor虚拟的cpu上的；另外一方面是由于计算程序本身的特性导致的差异。虚拟机虚拟的cpu架构不同于实际cpu架构，数值计算程序一般针对特定的cpu架构有一定的优化措施，虚拟化使这些措施作废，甚至起到反效果。\n\n * 资源利用率\n\n在资源利用率上虚拟机由于隔离更彻底，因此利用率也会相对较低。\n\n因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在hypervisor虚拟的cpu上的；另外一方面是由于计算程序本身的特性导致的差异。虚拟机虚拟的cpu架构不同于实际cpu架构，数值计算程序一般针对特定的cpu架构有一定的优化措施，虚拟化使这些措施作废，甚至起到反效果。比如对于本次实验的平台，实际的cpu架构是2块物理cpu。\n\n\n# 参考文章\n\n * https://blog.csdn.net/steelren/article/details/78491923\n * https://www.cnblogs.com/jie-fang/p/10279629.html',charsets:{cjk:!0}},{title:"Docker基础 - 一个web应用实例",frontmatter:{title:"Docker基础 - 一个web应用实例",date:"2021-10-20T17:12:50.000Z",permalink:"/pages/fac510/",categories:["技术","工具使用","后端","docker"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/10.docker/04.Docker%E5%9F%BA%E7%A1%80_%E4%B8%80%E4%B8%AAweb%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B.html",relativePath:"03.技术/06.工具使用/10.docker/04.Docker基础_一个web应用实例.md",key:"v-4b00cd86",path:"/pages/fac510/",headers:[{level:2,title:"一个web 应用运行和访问",slug:"一个web-应用运行和访问",normalizedTitle:"一个web 应用运行和访问",charIndex:152},{level:3,title:"运行一个 web 应用",slug:"运行一个-web-应用",normalizedTitle:"运行一个 web 应用",charIndex:170},{level:3,title:"访问webapp",slug:"访问webapp",normalizedTitle:"访问webapp",charIndex:1758},{level:3,title:"设置自定义映射端口",slug:"设置自定义映射端口",normalizedTitle:"设置自定义映射端口",charIndex:2572},{level:2,title:"其它常用功能",slug:"其它常用功能",normalizedTitle:"其它常用功能",charIndex:3515},{level:3,title:"查看web 应用网络端口",slug:"查看web-应用网络端口",normalizedTitle:"查看web 应用网络端口",charIndex:3526},{level:3,title:"查看 WEB 应用程序日志",slug:"查看-web-应用程序日志",normalizedTitle:"查看 web 应用程序日志",charIndex:3878},{level:3,title:"查看WEB应用程序容器的进程",slug:"查看web应用程序容器的进程",normalizedTitle:"查看web应用程序容器的进程",charIndex:4289},{level:3,title:"检查 WEB 应用程序",slug:"检查-web-应用程序",normalizedTitle:"检查 web 应用程序",charIndex:4691},{level:3,title:"停止 WEB 应用容器",slug:"停止-web-应用容器",normalizedTitle:"停止 web 应用容器",charIndex:14554},{level:3,title:"重启WEB应用容器",slug:"重启web应用容器",normalizedTitle:"重启web应用容器",charIndex:14863},{level:3,title:"移除WEB应用容器",slug:"移除web应用容器",normalizedTitle:"移除web应用容器",charIndex:15204},{level:2,title:"与其它容器（DB容器）互联",slug:"与其它容器-db容器-互联",normalizedTitle:"与其它容器（db容器）互联",charIndex:15634},{level:3,title:"与数据库容器互联",slug:"与数据库容器互联",normalizedTitle:"与数据库容器互联",charIndex:15709},{level:3,title:"容器公开的连接信息",slug:"容器公开的连接信息",normalizedTitle:"容器公开的连接信息",charIndex:19496}],headersStr:"一个web 应用运行和访问 运行一个 web 应用 访问webapp 设置自定义映射端口 其它常用功能 查看web 应用网络端口 查看 WEB 应用程序日志 查看WEB应用程序容器的进程 检查 WEB 应用程序 停止 WEB 应用容器 重启WEB应用容器 移除WEB应用容器 与其它容器（DB容器）互联 与数据库容器互联 容器公开的连接信息",content:'# Docker基础 - 一个web应用实例\n\n> 通过上文我们已经基本了解了docker的结构（仓库，镜像，容器）以及跑docker应用了；本文将通过介绍一个web应用：向你展示如何进行主机与web容器之间的通信，这是web开发者常用的；第二，贯穿上文中内容, 且为我们后续讲解网络提供基础。\n\n\n# 一个web 应用运行和访问\n\n\n# 运行一个 web 应用\n\n> 我们只需要找一个webapp的镜像即可，无需自己再写个程序啥的。接下来让我们尝试使用 docker 构建一个 web 应用程序。\n\n这里找了一个training/webapp，它是将在docker容器中运行一个 Python Flask web应用。\n\n[root@pdai ~]# docker pull training/webapp\nUsing default tag: latest\nlatest: Pulling from training/webapp\nImage docker.io/training/webapp:latest uses outdated schema1 manifest format. Please upgrade to a schema2 image for better future compatibility. More information at https://docs.docker.com/registry/spec/deprecated-schema-v1/\ne190868d63f8: Pull complete\n909cd34c6fd7: Pull complete\n0b9bfabab7c1: Pull complete\na3ed95caeb02: Pull complete\n10bbbc0fc0ff: Pull complete\nfca59b508e9f: Pull complete\ne7ae2541b15b: Pull complete\n9dd97ef58ce9: Pull complete\na4c1b0cb7af7: Pull complete\nDigest: sha256:06e9c1983bd6d5db5fba376ccd63bfa529e8d02f23d5079b8f74a616308fb11d\nStatus: Downloaded newer image for training/webapp:latest\ndocker.io/training/webapp:latest\n[root@pdai ~]# docker images | grep webapp\ntraining/webapp     latest              6fae60ef3446        4 years ago         349MB\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n紧接着，我们启动这个webapp\n\n[root@pdai ~]# docker run -d -P training/webapp python app.py\nec3eb9ae218494d5aa5902c1ca4435733567b5e81319f02e5d2509d45cbc25da\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES\nec3eb9ae2184        training/webapp     "python app.py"     18 seconds ago      Up 17 seconds       0.0.0.0:32768->5000/tcp   gifted_agnesi\n\n\n1\n2\n3\n4\n5\n\n\n参数说明:\n\n * -d:让容器在后台运行。\n * -P:将容器内部使用的网络端口映射到我们使用的主机上。\n\n\n# 访问webapp\n\n> 我们注意看上述PORTS部分为0.0.0.0:32769->5000/tcp\n\nDocker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32768 上。\n\n * 从主机上看，它应该暴露了端口32768\n\n所以我们来验证下：\n\n[root@pdai ~]# netstat | grep 32768\n[root@pdai ~]# netstat -nltp | grep 32768\ntcp6       0      0 :::32768                :::*                    LISTEN      2227/docker-proxy\n[root@pdai ~]# curl localhost:32768\nHello world!\n\n\n1\n2\n3\n4\n5\n\n\n这意味着，你浏览器你可以输入localhost:32768访问这个页面。\n\n * 从容器内部看，它应该有一个端口5000\n\n我们再进容器验证下：\n\n[root@pdai ~]# docker exec -it ec3eb9ae2184 /bin/bash\nroot@ec3eb9ae2184:/opt/webapp# netstat -nltp\nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 0.0.0.0:5000            0.0.0.0:*               LISTEN      1/python\n\n\n1\n2\n3\n4\n5\n\n\n所以我们的理解是对的。\n\n\n# 设置自定义映射端口\n\n> 我们发现，通过 -P参数映射到主机上的端口是随机，能否自定义端口呢？\n\n我们可以通过 -p 参数来设置不一样的端口；为了对比，我们再起一个容器实例：\n\n[root@pdai ~]# docker run -d -p 5001:5000 training/webapp python app.py\n5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES\n5da3588d5bc4        training/webapp     "python app.py"     33 seconds ago      Up 31 seconds       0.0.0.0:5001->5000/tcp    hopeful_bardeen\nec3eb9ae2184        training/webapp     "python app.py"     22 minutes ago      Up 22 minutes       0.0.0.0:32768->5000/tcp   gifted_agnesi\n[root@pdai ~]# netstat -nltp | grep 5001\ntcp6       0      0 :::5001                 :::*                    LISTEN      2591/docker-proxy\n[root@pdai ~]# curl localhost:5001\nHello world!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n所以你看到跑了两个内部端口都是5000的web实例，新的容器内部的 5000 端口映射到我们本地主机的 5001 端口上。\n\n\n# 其它常用功能\n\n\n# 查看web 应用网络端口\n\n> 通过 docker ps 命令可以查看到容器的端口映射，docker 还提供了另一个快捷方式 docker port，使用 docker port 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。\n\n上面我们创建的 web 应用容器 ID 为 5da3588d5bc4 名字为 hopeful_bardeen。\n\n我可以这样查看容器端口的映射情况：\n\n[root@pdai ~]# docker port 5da3588d5bc4\n5000/tcp -> 0.0.0.0:5001\n[root@pdai ~]# docker port hopeful_bardeen\n5000/tcp -> 0.0.0.0:5001\n\n\n1\n2\n3\n4\n\n\n\n# 查看 WEB 应用程序日志\n\n> docker logs [ID或者名字] 可以查看容器内部的标准输出。\n\n[root@pdai ~]# docker port hopeful_bardeen\n5000/tcp -> 0.0.0.0:5001\n[root@pdai ~]# docker logs -f hopeful_bardeen\n * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)\n172.17.0.1 - - [18/Feb/2020 09:08:31] "GET / HTTP/1.1" 200 -\n^C\n\n\n1\n2\n3\n4\n5\n6\n\n\n参数说明：\n\n * -f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。\n\n从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。\n\n\n# 查看WEB应用程序容器的进程\n\n我们还可以使用 docker top 来查看容器内部运行的进程\n\n[root@pdai ~]# docker top hopeful_bardeen\nUID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD\nroot                2614                2597                0                   17:07               ?                   00:00:00            python app.py\n\n\n1\n2\n3\n\n\n\n# 检查 WEB 应用程序\n\n使用 docker inspect 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。\n\n[root@pdai ~]# docker inspect hopeful_bardeen\n[\n    {\n        "Id": "5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a",\n        "Created": "2020-02-18T09:07:32.827193286Z",\n        "Path": "python",\n        "Args": [\n            "app.py"\n        ],\n        "State": {\n            "Status": "running",\n            "Running": true,\n            "Paused": false,\n            "Restarting": false,\n            "OOMKilled": false,\n            "Dead": false,\n            "Pid": 2614,\n            "ExitCode": 0,\n            "Error": "",\n            "StartedAt": "2020-02-18T09:07:33.374368448Z",\n            "FinishedAt": "0001-01-01T00:00:00Z"\n        },\n        "Image": "sha256:6fae60ef344644649a39240b94d73b8ba9c67f898ede85cf8e947a887b3e6557",\n        "ResolvConfPath": "/var/lib/docker/containers/5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a/resolv.conf",\n        "HostnamePath": "/var/lib/docker/containers/5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a/hostname",\n        "HostsPath": "/var/lib/docker/containers/5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a/hosts",\n        "LogPath": "/var/lib/docker/containers/5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a/5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a-json.log",\n        "Name": "/hopeful_bardeen",\n        "RestartCount": 0,\n        "Driver": "overlay2",\n        "Platform": "linux",\n        "MountLabel": "",\n        "ProcessLabel": "",\n        "AppArmorProfile": "",\n        "ExecIDs": null,\n        "HostConfig": {\n            "Binds": null,\n            "ContainerIDFile": "",\n            "LogConfig": {\n                "Type": "json-file",\n                "Config": {}\n            },\n            "NetworkMode": "default",\n            "PortBindings": {\n                "5000/tcp": [\n                    {\n                        "HostIp": "",\n                        "HostPort": "5001"\n                    }\n                ]\n            },\n            "RestartPolicy": {\n                "Name": "no",\n                "MaximumRetryCount": 0\n            },\n            "AutoRemove": false,\n            "VolumeDriver": "",\n            "VolumesFrom": null,\n            "CapAdd": null,\n            "CapDrop": null,\n            "Capabilities": null,\n            "Dns": [],\n            "DnsOptions": [],\n            "DnsSearch": [],\n            "ExtraHosts": null,\n            "GroupAdd": null,\n            "IpcMode": "private",\n            "Cgroup": "",\n            "Links": null,\n            "OomScoreAdj": 0,\n            "PidMode": "",\n            "Privileged": false,\n            "PublishAllPorts": false,\n            "ReadonlyRootfs": false,\n            "SecurityOpt": null,\n            "UTSMode": "",\n            "UsernsMode": "",\n            "ShmSize": 67108864,\n            "Runtime": "runc",\n            "ConsoleSize": [\n                0,\n                0\n            ],\n            "Isolation": "",\n            "CpuShares": 0,\n            "Memory": 0,\n            "NanoCpus": 0,\n            "CgroupParent": "",\n            "BlkioWeight": 0,\n            "BlkioWeightDevice": [],\n            "BlkioDeviceReadBps": null,\n            "BlkioDeviceWriteBps": null,\n            "BlkioDeviceReadIOps": null,\n            "BlkioDeviceWriteIOps": null,\n            "CpuPeriod": 0,\n            "CpuQuota": 0,\n            "CpuRealtimePeriod": 0,\n            "CpuRealtimeRuntime": 0,\n            "CpusetCpus": "",\n            "CpusetMems": "",\n            "Devices": [],\n            "DeviceCgroupRules": null,\n            "DeviceRequests": null,\n            "KernelMemory": 0,\n            "KernelMemoryTCP": 0,\n            "MemoryReservation": 0,\n            "MemorySwap": 0,\n            "MemorySwappiness": null,\n            "OomKillDisable": false,\n            "PidsLimit": null,\n            "Ulimits": null,\n            "CpuCount": 0,\n            "CpuPercent": 0,\n            "IOMaximumIOps": 0,\n            "IOMaximumBandwidth": 0,\n            "MaskedPaths": [\n                "/proc/asound",\n                "/proc/acpi",\n                "/proc/kcore",\n                "/proc/keys",\n                "/proc/latency_stats",\n                "/proc/timer_list",\n                "/proc/timer_stats",\n                "/proc/sched_debug",\n                "/proc/scsi",\n                "/sys/firmware"\n            ],\n            "ReadonlyPaths": [\n                "/proc/bus",\n                "/proc/fs",\n                "/proc/irq",\n                "/proc/sys",\n                "/proc/sysrq-trigger"\n            ]\n        },\n        "GraphDriver": {\n            "Data": {\n                "LowerDir": "/var/lib/docker/overlay2/c6594e5b70feca02eb4b90ac75aba711f36378d5cb9853ffca1ec92f9d0c3e14-init/diff:/var/lib/docker/overlay2/d4690a06236a3857a2a51ab84c61992e50ea3e1a613f4793334916604ea0dfa0/diff:/var/lib/docker/overlay2/c45d0215cd2076174f38fea5003c3ff11a5ba2df2141d9d069f4bf32dac9a22a/diff:/var/lib/docker/overlay2/1cf63068912234a1f4c861f58f155423c87193c6e438948db493687d4da4f0a0/diff:/var/lib/docker/overlay2/55e4ecb04b1ff8d048bc75bb8698c782c813d45caa6f0d82ac6c49adec24bead/diff:/var/lib/docker/overlay2/27fa0dc314b851b8d2f0386d230a725f57117f9f1ccdb49ca27f5ad424cb4a90/diff:/var/lib/docker/overlay2/65a5a082188d9e0b9aaf09c2e9c3b3f8141f74c781996680dfaca63d81672cdf/diff:/var/lib/docker/overlay2/658a33c92cf114ee4cbc10f117207a0c813e39a908acc014fbce1783a28bc654/diff:/var/lib/docker/overlay2/e5b5c9e0abc43ff2750dcd33decc65d90d733b18f2626b91c500d803d7fe189b/diff:/var/lib/docker/overlay2/0b5181e429a89f6ab291e090b972e11718e4f63158ed60af1fce18095d0352a6/diff:/var/lib/docker/overlay2/f7c0405739bb58fdfa9af402a72507b78bc2a48b0d74356dad59495906b6e0e5/diff:/var/lib/docker/overlay2/073c45ae4a6ff27950a1dd969a675d3dcdc18392bb205ddde5913fcc10a751ef/diff:/var/lib/docker/overlay2/f92534844c8cc5b950ea36369b8e4a7dd7f7749e73483908e5d129bf5c26442f/diff:/var/lib/docker/overlay2/477378381d03c4b347d7b9224c4c9023b5dfbfde32022c7eb8af32e7a01b88b2/diff",\n                "MergedDir": "/var/lib/docker/overlay2/c6594e5b70feca02eb4b90ac75aba711f36378d5cb9853ffca1ec92f9d0c3e14/merged",\n                "UpperDir": "/var/lib/docker/overlay2/c6594e5b70feca02eb4b90ac75aba711f36378d5cb9853ffca1ec92f9d0c3e14/diff",\n                "WorkDir": "/var/lib/docker/overlay2/c6594e5b70feca02eb4b90ac75aba711f36378d5cb9853ffca1ec92f9d0c3e14/work"\n            },\n            "Name": "overlay2"\n        },\n        "Mounts": [],\n        "Config": {\n            "Hostname": "5da3588d5bc4",\n            "Domainname": "",\n            "User": "",\n            "AttachStdin": false,\n            "AttachStdout": false,\n            "AttachStderr": false,\n            "ExposedPorts": {\n                "5000/tcp": {}\n            },\n            "Tty": false,\n            "OpenStdin": false,\n            "StdinOnce": false,\n            "Env": [\n                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"\n            ],\n            "Cmd": [\n                "python",\n                "app.py"\n            ],\n            "Image": "training/webapp",\n            "Volumes": null,\n            "WorkingDir": "/opt/webapp",\n            "Entrypoint": null,\n            "OnBuild": null,\n            "Labels": {}\n        },\n        "NetworkSettings": {\n            "Bridge": "",\n            "SandboxID": "66e1f111a5d7acca71f0e9e24516a6945bca428f55ac1eab1576c99bde16190c",\n            "HairpinMode": false,\n            "LinkLocalIPv6Address": "",\n            "LinkLocalIPv6PrefixLen": 0,\n            "Ports": {\n                "5000/tcp": [\n                    {\n                        "HostIp": "0.0.0.0",\n                        "HostPort": "5001"\n                    }\n                ]\n            },\n            "SandboxKey": "/var/run/docker/netns/66e1f111a5d7",\n            "SecondaryIPAddresses": null,\n            "SecondaryIPv6Addresses": null,\n            "EndpointID": "794d5e97cd3bbb62c8a7a850f125404d174ecc45df4e704dbee403b1be7a2835",\n            "Gateway": "172.17.0.1",\n            "GlobalIPv6Address": "",\n            "GlobalIPv6PrefixLen": 0,\n            "IPAddress": "172.17.0.3",\n            "IPPrefixLen": 16,\n            "IPv6Gateway": "",\n            "MacAddress": "02:42:ac:11:00:03",\n            "Networks": {\n                "bridge": {\n                    "IPAMConfig": null,\n                    "Links": null,\n                    "Aliases": null,\n                    "NetworkID": "b8c5abdb0becacfa1bfa1d72e2e663fb0157b62a9b8bee37e2607211722713cc",\n                    "EndpointID": "794d5e97cd3bbb62c8a7a850f125404d174ecc45df4e704dbee403b1be7a2835",\n                    "Gateway": "172.17.0.1",\n                    "IPAddress": "172.17.0.3",\n                    "IPPrefixLen": 16,\n                    "IPv6Gateway": "",\n                    "GlobalIPv6Address": "",\n                    "GlobalIPv6PrefixLen": 0,\n                    "MacAddress": "02:42:ac:11:00:03",\n                    "DriverOpts": null\n                }\n            }\n        }\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n\n\n\n# 停止 WEB 应用容器\n\n再复习下docker的停止\n\n[root@pdai ~]# docker stop hopeful_bardeen\nhopeful_bardeen\n[root@pdai ~]# docker ps -a | grep \'hopeful_bardeen\'\n5da3588d5bc4        training/webapp      "python app.py"      13 minutes ago      Exited (137) 12 seconds ago                             hopeful_bardeen\n\n\n1\n2\n3\n4\n\n\n\n# 重启WEB应用容器\n\n已经停止的容器，我们可以使用命令 docker start 或者docker restart 来启动。\n\n[root@pdai ~]# docker restart hopeful_bardeen\nhopeful_bardeen\n[root@pdai ~]# docker ps -a | grep hopeful_bardeen\n5da3588d5bc4        training/webapp      "python app.py"      14 minutes ago      Up 10 seconds            0.0.0.0:5001->5000/tcp    hopeful_bardeen\n\n\n1\n2\n3\n4\n\n\n\n# 移除WEB应用容器\n\n我们可以使用 docker rm 命令来删除不需要的容器\n\n我们上文也讲过，如果是启动着的docker实例，需要加-f，强制（force）删除。\n\n[root@pdai ~]# docker ps -a | grep hopeful_bardeen\n5da3588d5bc4        training/webapp      "python app.py"      14 minutes ago      Up 10 seconds            0.0.0.0:5001->5000/tcp    hopeful_bardeen\n[root@pdai ~]# docker rm -f hopeful_bardeen\nhopeful_bardeen\n[root@pdai ~]# docker ps -a | grep hopeful_bardeen\n[root@pdai ~]#\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 与其它容器（DB容器）互联\n\n> 上述是一个web单一容器通过端口映射，可以通过主机端口访问容器；那么如果需要访问数据库，就涉及到容器互联。\n\n\n# 与数据库容器互联\n\n * 先停止上述的web容器, 且清理所有不用的容器\n\n[root@pdai ~]# docker ps -a\nCONTAINER ID        IMAGE                COMMAND              CREATED             STATUS                    PORTS                     NAMES\nec3eb9ae2184        training/webapp      "python app.py"      18 hours ago        Up 18 hours               0.0.0.0:32768->5000/tcp   gifted_agnesi\n11de9755a084        pdai/ubuntu:v2.0.2   "/bin/bash"          24 hours ago        Exited (0) 24 hours ago                             pdai-ubuntu-202\n57bd797570b6        pdai/ubuntu:v2.0.2   "--name pdai-test"   24 hours ago        Created                                             sharp_brahmagupta\n[root@pdai ~]# docker stop ec3eb9ae2184\nec3eb9ae2184\n[root@pdai ~]# docker ps -a\nCONTAINER ID        IMAGE                COMMAND              CREATED             STATUS                        PORTS               NAMES\nec3eb9ae2184        training/webapp      "python app.py"      18 hours ago        Exited (137) 29 seconds ago                       gifted_agnesi\n11de9755a084        pdai/ubuntu:v2.0.2   "/bin/bash"          24 hours ago        Exited (0) 24 hours ago                           pdai-ubuntu-202\n57bd797570b6        pdai/ubuntu:v2.0.2   "--name pdai-test"   24 hours ago        Created                                           sharp_brahmagupta\n[root@pdai ~]# docker container prune\nWARNING! This will remove all stopped containers.\nAre you sure you want to continue? [y/N] y\nDeleted Containers:\nec3eb9ae218494d5aa5902c1ca4435733567b5e81319f02e5d2509d45cbc25da\n11de9755a08402d963d263a559a7daf48f4a2188398f258641240b5eb50fbc89\n57bd797570b68b6587b16809889e6e8f710ec7a934229aa6391add02f758e036\n\nTotal reclaimed space: 89B\n[root@pdai ~]#\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 创建一个新的数据库容器。\n\n[root@pdai ~]# docker run -d --name db training/postgres\nUnable to find image \'training/postgres:latest\' locally\nlatest: Pulling from training/postgres\nImage docker.io/training/postgres:latest uses outdated schema1 manifest format. Please upgrade to a schema2 image for better future compatibility. More information at https://docs.docker.com/registry/spec/deprecated-schema-v1/\na3ed95caeb02: Pull complete\n6e71c809542e: Pull complete\n2978d9af87ba: Pull complete\ne1bca35b062f: Pull complete\n500b6decf741: Pull complete\n74b14ef2151f: Pull complete\n7afd5ed3826e: Pull complete\n3c69bb244f5e: Pull complete\nd86f9ec5aedf: Pull complete\n010fabf20157: Pull complete\nDigest: sha256:a945dc6dcfbc8d009c3d972931608344b76c2870ce796da00a827bd50791907e\nStatus: Downloaded newer image for training/postgres:latest\nd992e3c761e00649eb436b88c737adc54093b76119af0fb7878596b523f743ca\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES\nd992e3c761e0        training/postgres   "su postgres -c \'/us…"   9 seconds ago       Up 7 seconds        5432/tcp            db\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * db 容器和 web 容器建立互联关系\n\n[root@pdai ~]# docker run -d -p 5001:5000 --name web --link db:db training/webapp python app.py\n1cbc9aeba2a8a826d460ecb49de17ddf8ac336e150c752a3c762fd38a3e15254\n[root@pdai ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES\n1cbc9aeba2a8        training/webapp     "python app.py"          5 seconds ago       Up 4 seconds        0.0.0.0:5001->5000/tcp   web\nd992e3c761e0        training/postgres   "su postgres -c \'/us…"   7 minutes ago       Up 7 minutes        5432/tcp                 db\n\n\n1\n2\n3\n4\n5\n6\n\n\n--link 参数的格式为 --link name:alias，其中 name 是要链接的容器的名称，alias 是这个连接的别名。\n\n> Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机上。在启动 db 容器的时候并没有使用 -p 和 -P 标记，从而避免了暴露数据库端口到外部网络上。\n\n\n# 容器公开的连接信息\n\nDocker 通过 2 种方式为容器公开连接信息：\n\n * 环境变量\n * 更新 /etc/hosts 文件\n\n# 环境变量\n\n使用 env 命令来查看 web 容器的环境变量\n\n[root@pdai ~]# docker exec -it web /bin/bash\nroot@1cbc9aeba2a8:/opt/webapp# env\nHOSTNAME=1cbc9aeba2a8\nDB_NAME=/web/db\nDB_PORT_5432_TCP_ADDR=172.17.0.2\nDB_PORT=tcp://172.17.0.2:5432\nDB_PORT_5432_TCP=tcp://172.17.0.2:5432\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nPWD=/opt/webapp\nDB_PORT_5432_TCP_PORT=5432\nSHLVL=1\nHOME=/root\nDB_PORT_5432_TCP_PROTO=tcp\nDB_ENV_PG_VERSION=9.3\n_=/usr/bin/env\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n其中 DB_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。\n\n# hosts 文件\n\n除了环境变量，Docker 还添加 host 信息到父容器的 /etc/hosts 的文件。下面是父容器 web 的 hosts 文件\n\nroot@1cbc9aeba2a8:/opt/webapp# cat /etc/hosts\n127.0.0.1       localhost\n::1     localhost ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n172.17.0.2      db d992e3c761e0\n172.17.0.3      1cbc9aeba2a8\nroot@1cbc9aeba2a8:/opt/webapp#\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这里有 2 个 hosts:\n\n * 第一个, 172.17.0.2 db d992e3c761e0 表示 db 容器的 ip, ID和Name\n * 第二个，172.17.0.3 1cbc9aeba2a8 表示 web 容器的 ip, ID\n\n可以在 web 容器中安装 ping 命令来测试跟db容器的连通。\n\nroot@1cbc9aeba2a8:/opt/webapp# apt-get install -yqq inetutils-ping\n(Reading database ... 18233 files and directories currently installed.)\nRemoving ubuntu-minimal (1.325) ...\nRemoving iputils-ping (3:20121221-4ubuntu1.1) ...\nSelecting previously unselected package inetutils-ping.\n(Reading database ... 18221 files and directories currently installed.)\nPreparing to unpack .../inetutils-ping_2%3a1.9.2-1_amd64.deb ...\nUnpacking inetutils-ping (2:1.9.2-1) ...\nSetting up inetutils-ping (2:1.9.2-1) ...\nroot@1cbc9aeba2a8:/opt/webapp# ping db\nPING db (172.17.0.2): 56 data bytes\n64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.110 ms\n64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.092 ms\n64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.094 ms\n64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.104 ms\n64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.111 ms\n64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.093 ms\n64 bytes from 172.17.0.2: icmp_seq=6 ttl=64 time=0.095 ms\n^C--- db ping statistics ---\n7 packets transmitted, 7 packets received, 0% packet loss\nround-trip min/avg/max/stddev = 0.092/0.100/0.111/0.000 ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n用 ping 来测试db容器，它会解析成 172.17.0.2。\n\n当然，你还可以ping db容器的ID或者内部IP, 结果是一样的。\n\nroot@1cbc9aeba2a8:/opt/webapp# ping -t 4 d992e3c761e0\nping: unsupported packet type: 4\nroot@1cbc9aeba2a8:/opt/webapp# ping d992e3c761e0\nPING db (172.17.0.2): 56 data bytes\n64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.089 ms\n64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.093 ms\n^C--- db ping statistics ---\n2 packets transmitted, 2 packets received, 0% packet loss\nround-trip min/avg/max/stddev = 0.089/0.091/0.093/0.000 ms\nroot@1cbc9aeba2a8:/opt/webapp# ping 172.17.0.2\nPING 172.17.0.2 (172.17.0.2): 56 data bytes\n64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.094 ms\n64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.103 ms\n^C--- 172.17.0.2 ping statistics ---\n2 packets transmitted, 2 packets received, 0% packet loss\nround-trip min/avg/max/stddev = 0.094/0.099/0.103/0.000 ms\nroot@1cbc9aeba2a8:/opt/webapp#\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。',normalizedContent:'# docker基础 - 一个web应用实例\n\n> 通过上文我们已经基本了解了docker的结构（仓库，镜像，容器）以及跑docker应用了；本文将通过介绍一个web应用：向你展示如何进行主机与web容器之间的通信，这是web开发者常用的；第二，贯穿上文中内容, 且为我们后续讲解网络提供基础。\n\n\n# 一个web 应用运行和访问\n\n\n# 运行一个 web 应用\n\n> 我们只需要找一个webapp的镜像即可，无需自己再写个程序啥的。接下来让我们尝试使用 docker 构建一个 web 应用程序。\n\n这里找了一个training/webapp，它是将在docker容器中运行一个 python flask web应用。\n\n[root@pdai ~]# docker pull training/webapp\nusing default tag: latest\nlatest: pulling from training/webapp\nimage docker.io/training/webapp:latest uses outdated schema1 manifest format. please upgrade to a schema2 image for better future compatibility. more information at https://docs.docker.com/registry/spec/deprecated-schema-v1/\ne190868d63f8: pull complete\n909cd34c6fd7: pull complete\n0b9bfabab7c1: pull complete\na3ed95caeb02: pull complete\n10bbbc0fc0ff: pull complete\nfca59b508e9f: pull complete\ne7ae2541b15b: pull complete\n9dd97ef58ce9: pull complete\na4c1b0cb7af7: pull complete\ndigest: sha256:06e9c1983bd6d5db5fba376ccd63bfa529e8d02f23d5079b8f74a616308fb11d\nstatus: downloaded newer image for training/webapp:latest\ndocker.io/training/webapp:latest\n[root@pdai ~]# docker images | grep webapp\ntraining/webapp     latest              6fae60ef3446        4 years ago         349mb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n紧接着，我们启动这个webapp\n\n[root@pdai ~]# docker run -d -p training/webapp python app.py\nec3eb9ae218494d5aa5902c1ca4435733567b5e81319f02e5d2509d45cbc25da\n[root@pdai ~]# docker ps\ncontainer id        image               command             created             status              ports                     names\nec3eb9ae2184        training/webapp     "python app.py"     18 seconds ago      up 17 seconds       0.0.0.0:32768->5000/tcp   gifted_agnesi\n\n\n1\n2\n3\n4\n5\n\n\n参数说明:\n\n * -d:让容器在后台运行。\n * -p:将容器内部使用的网络端口映射到我们使用的主机上。\n\n\n# 访问webapp\n\n> 我们注意看上述ports部分为0.0.0.0:32769->5000/tcp\n\ndocker 开放了 5000 端口（默认 python flask 端口）映射到主机端口 32768 上。\n\n * 从主机上看，它应该暴露了端口32768\n\n所以我们来验证下：\n\n[root@pdai ~]# netstat | grep 32768\n[root@pdai ~]# netstat -nltp | grep 32768\ntcp6       0      0 :::32768                :::*                    listen      2227/docker-proxy\n[root@pdai ~]# curl localhost:32768\nhello world!\n\n\n1\n2\n3\n4\n5\n\n\n这意味着，你浏览器你可以输入localhost:32768访问这个页面。\n\n * 从容器内部看，它应该有一个端口5000\n\n我们再进容器验证下：\n\n[root@pdai ~]# docker exec -it ec3eb9ae2184 /bin/bash\nroot@ec3eb9ae2184:/opt/webapp# netstat -nltp\nactive internet connections (only servers)\nproto recv-q send-q local address           foreign address         state       pid/program name\ntcp        0      0 0.0.0.0:5000            0.0.0.0:*               listen      1/python\n\n\n1\n2\n3\n4\n5\n\n\n所以我们的理解是对的。\n\n\n# 设置自定义映射端口\n\n> 我们发现，通过 -p参数映射到主机上的端口是随机，能否自定义端口呢？\n\n我们可以通过 -p 参数来设置不一样的端口；为了对比，我们再起一个容器实例：\n\n[root@pdai ~]# docker run -d -p 5001:5000 training/webapp python app.py\n5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a\n[root@pdai ~]# docker ps\ncontainer id        image               command             created             status              ports                     names\n5da3588d5bc4        training/webapp     "python app.py"     33 seconds ago      up 31 seconds       0.0.0.0:5001->5000/tcp    hopeful_bardeen\nec3eb9ae2184        training/webapp     "python app.py"     22 minutes ago      up 22 minutes       0.0.0.0:32768->5000/tcp   gifted_agnesi\n[root@pdai ~]# netstat -nltp | grep 5001\ntcp6       0      0 :::5001                 :::*                    listen      2591/docker-proxy\n[root@pdai ~]# curl localhost:5001\nhello world!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n所以你看到跑了两个内部端口都是5000的web实例，新的容器内部的 5000 端口映射到我们本地主机的 5001 端口上。\n\n\n# 其它常用功能\n\n\n# 查看web 应用网络端口\n\n> 通过 docker ps 命令可以查看到容器的端口映射，docker 还提供了另一个快捷方式 docker port，使用 docker port 可以查看指定 （id 或者名字）容器的某个确定端口映射到宿主机的端口号。\n\n上面我们创建的 web 应用容器 id 为 5da3588d5bc4 名字为 hopeful_bardeen。\n\n我可以这样查看容器端口的映射情况：\n\n[root@pdai ~]# docker port 5da3588d5bc4\n5000/tcp -> 0.0.0.0:5001\n[root@pdai ~]# docker port hopeful_bardeen\n5000/tcp -> 0.0.0.0:5001\n\n\n1\n2\n3\n4\n\n\n\n# 查看 web 应用程序日志\n\n> docker logs [id或者名字] 可以查看容器内部的标准输出。\n\n[root@pdai ~]# docker port hopeful_bardeen\n5000/tcp -> 0.0.0.0:5001\n[root@pdai ~]# docker logs -f hopeful_bardeen\n * running on http://0.0.0.0:5000/ (press ctrl+c to quit)\n172.17.0.1 - - [18/feb/2020 09:08:31] "get / http/1.1" 200 -\n^c\n\n\n1\n2\n3\n4\n5\n6\n\n\n参数说明：\n\n * -f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。\n\n从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。\n\n\n# 查看web应用程序容器的进程\n\n我们还可以使用 docker top 来查看容器内部运行的进程\n\n[root@pdai ~]# docker top hopeful_bardeen\nuid                 pid                 ppid                c                   stime               tty                 time                cmd\nroot                2614                2597                0                   17:07               ?                   00:00:00            python app.py\n\n\n1\n2\n3\n\n\n\n# 检查 web 应用程序\n\n使用 docker inspect 来查看 docker 的底层信息。它会返回一个 json 文件记录着 docker 容器的配置和状态信息。\n\n[root@pdai ~]# docker inspect hopeful_bardeen\n[\n    {\n        "id": "5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a",\n        "created": "2020-02-18t09:07:32.827193286z",\n        "path": "python",\n        "args": [\n            "app.py"\n        ],\n        "state": {\n            "status": "running",\n            "running": true,\n            "paused": false,\n            "restarting": false,\n            "oomkilled": false,\n            "dead": false,\n            "pid": 2614,\n            "exitcode": 0,\n            "error": "",\n            "startedat": "2020-02-18t09:07:33.374368448z",\n            "finishedat": "0001-01-01t00:00:00z"\n        },\n        "image": "sha256:6fae60ef344644649a39240b94d73b8ba9c67f898ede85cf8e947a887b3e6557",\n        "resolvconfpath": "/var/lib/docker/containers/5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a/resolv.conf",\n        "hostnamepath": "/var/lib/docker/containers/5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a/hostname",\n        "hostspath": "/var/lib/docker/containers/5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a/hosts",\n        "logpath": "/var/lib/docker/containers/5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a/5da3588d5bc43a9ed3aa61fb87f98220c9719d2879b616404d443aaae6cee77a-json.log",\n        "name": "/hopeful_bardeen",\n        "restartcount": 0,\n        "driver": "overlay2",\n        "platform": "linux",\n        "mountlabel": "",\n        "processlabel": "",\n        "apparmorprofile": "",\n        "execids": null,\n        "hostconfig": {\n            "binds": null,\n            "containeridfile": "",\n            "logconfig": {\n                "type": "json-file",\n                "config": {}\n            },\n            "networkmode": "default",\n            "portbindings": {\n                "5000/tcp": [\n                    {\n                        "hostip": "",\n                        "hostport": "5001"\n                    }\n                ]\n            },\n            "restartpolicy": {\n                "name": "no",\n                "maximumretrycount": 0\n            },\n            "autoremove": false,\n            "volumedriver": "",\n            "volumesfrom": null,\n            "capadd": null,\n            "capdrop": null,\n            "capabilities": null,\n            "dns": [],\n            "dnsoptions": [],\n            "dnssearch": [],\n            "extrahosts": null,\n            "groupadd": null,\n            "ipcmode": "private",\n            "cgroup": "",\n            "links": null,\n            "oomscoreadj": 0,\n            "pidmode": "",\n            "privileged": false,\n            "publishallports": false,\n            "readonlyrootfs": false,\n            "securityopt": null,\n            "utsmode": "",\n            "usernsmode": "",\n            "shmsize": 67108864,\n            "runtime": "runc",\n            "consolesize": [\n                0,\n                0\n            ],\n            "isolation": "",\n            "cpushares": 0,\n            "memory": 0,\n            "nanocpus": 0,\n            "cgroupparent": "",\n            "blkioweight": 0,\n            "blkioweightdevice": [],\n            "blkiodevicereadbps": null,\n            "blkiodevicewritebps": null,\n            "blkiodevicereadiops": null,\n            "blkiodevicewriteiops": null,\n            "cpuperiod": 0,\n            "cpuquota": 0,\n            "cpurealtimeperiod": 0,\n            "cpurealtimeruntime": 0,\n            "cpusetcpus": "",\n            "cpusetmems": "",\n            "devices": [],\n            "devicecgrouprules": null,\n            "devicerequests": null,\n            "kernelmemory": 0,\n            "kernelmemorytcp": 0,\n            "memoryreservation": 0,\n            "memoryswap": 0,\n            "memoryswappiness": null,\n            "oomkilldisable": false,\n            "pidslimit": null,\n            "ulimits": null,\n            "cpucount": 0,\n            "cpupercent": 0,\n            "iomaximumiops": 0,\n            "iomaximumbandwidth": 0,\n            "maskedpaths": [\n                "/proc/asound",\n                "/proc/acpi",\n                "/proc/kcore",\n                "/proc/keys",\n                "/proc/latency_stats",\n                "/proc/timer_list",\n                "/proc/timer_stats",\n                "/proc/sched_debug",\n                "/proc/scsi",\n                "/sys/firmware"\n            ],\n            "readonlypaths": [\n                "/proc/bus",\n                "/proc/fs",\n                "/proc/irq",\n                "/proc/sys",\n                "/proc/sysrq-trigger"\n            ]\n        },\n        "graphdriver": {\n            "data": {\n                "lowerdir": "/var/lib/docker/overlay2/c6594e5b70feca02eb4b90ac75aba711f36378d5cb9853ffca1ec92f9d0c3e14-init/diff:/var/lib/docker/overlay2/d4690a06236a3857a2a51ab84c61992e50ea3e1a613f4793334916604ea0dfa0/diff:/var/lib/docker/overlay2/c45d0215cd2076174f38fea5003c3ff11a5ba2df2141d9d069f4bf32dac9a22a/diff:/var/lib/docker/overlay2/1cf63068912234a1f4c861f58f155423c87193c6e438948db493687d4da4f0a0/diff:/var/lib/docker/overlay2/55e4ecb04b1ff8d048bc75bb8698c782c813d45caa6f0d82ac6c49adec24bead/diff:/var/lib/docker/overlay2/27fa0dc314b851b8d2f0386d230a725f57117f9f1ccdb49ca27f5ad424cb4a90/diff:/var/lib/docker/overlay2/65a5a082188d9e0b9aaf09c2e9c3b3f8141f74c781996680dfaca63d81672cdf/diff:/var/lib/docker/overlay2/658a33c92cf114ee4cbc10f117207a0c813e39a908acc014fbce1783a28bc654/diff:/var/lib/docker/overlay2/e5b5c9e0abc43ff2750dcd33decc65d90d733b18f2626b91c500d803d7fe189b/diff:/var/lib/docker/overlay2/0b5181e429a89f6ab291e090b972e11718e4f63158ed60af1fce18095d0352a6/diff:/var/lib/docker/overlay2/f7c0405739bb58fdfa9af402a72507b78bc2a48b0d74356dad59495906b6e0e5/diff:/var/lib/docker/overlay2/073c45ae4a6ff27950a1dd969a675d3dcdc18392bb205ddde5913fcc10a751ef/diff:/var/lib/docker/overlay2/f92534844c8cc5b950ea36369b8e4a7dd7f7749e73483908e5d129bf5c26442f/diff:/var/lib/docker/overlay2/477378381d03c4b347d7b9224c4c9023b5dfbfde32022c7eb8af32e7a01b88b2/diff",\n                "mergeddir": "/var/lib/docker/overlay2/c6594e5b70feca02eb4b90ac75aba711f36378d5cb9853ffca1ec92f9d0c3e14/merged",\n                "upperdir": "/var/lib/docker/overlay2/c6594e5b70feca02eb4b90ac75aba711f36378d5cb9853ffca1ec92f9d0c3e14/diff",\n                "workdir": "/var/lib/docker/overlay2/c6594e5b70feca02eb4b90ac75aba711f36378d5cb9853ffca1ec92f9d0c3e14/work"\n            },\n            "name": "overlay2"\n        },\n        "mounts": [],\n        "config": {\n            "hostname": "5da3588d5bc4",\n            "domainname": "",\n            "user": "",\n            "attachstdin": false,\n            "attachstdout": false,\n            "attachstderr": false,\n            "exposedports": {\n                "5000/tcp": {}\n            },\n            "tty": false,\n            "openstdin": false,\n            "stdinonce": false,\n            "env": [\n                "path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"\n            ],\n            "cmd": [\n                "python",\n                "app.py"\n            ],\n            "image": "training/webapp",\n            "volumes": null,\n            "workingdir": "/opt/webapp",\n            "entrypoint": null,\n            "onbuild": null,\n            "labels": {}\n        },\n        "networksettings": {\n            "bridge": "",\n            "sandboxid": "66e1f111a5d7acca71f0e9e24516a6945bca428f55ac1eab1576c99bde16190c",\n            "hairpinmode": false,\n            "linklocalipv6address": "",\n            "linklocalipv6prefixlen": 0,\n            "ports": {\n                "5000/tcp": [\n                    {\n                        "hostip": "0.0.0.0",\n                        "hostport": "5001"\n                    }\n                ]\n            },\n            "sandboxkey": "/var/run/docker/netns/66e1f111a5d7",\n            "secondaryipaddresses": null,\n            "secondaryipv6addresses": null,\n            "endpointid": "794d5e97cd3bbb62c8a7a850f125404d174ecc45df4e704dbee403b1be7a2835",\n            "gateway": "172.17.0.1",\n            "globalipv6address": "",\n            "globalipv6prefixlen": 0,\n            "ipaddress": "172.17.0.3",\n            "ipprefixlen": 16,\n            "ipv6gateway": "",\n            "macaddress": "02:42:ac:11:00:03",\n            "networks": {\n                "bridge": {\n                    "ipamconfig": null,\n                    "links": null,\n                    "aliases": null,\n                    "networkid": "b8c5abdb0becacfa1bfa1d72e2e663fb0157b62a9b8bee37e2607211722713cc",\n                    "endpointid": "794d5e97cd3bbb62c8a7a850f125404d174ecc45df4e704dbee403b1be7a2835",\n                    "gateway": "172.17.0.1",\n                    "ipaddress": "172.17.0.3",\n                    "ipprefixlen": 16,\n                    "ipv6gateway": "",\n                    "globalipv6address": "",\n                    "globalipv6prefixlen": 0,\n                    "macaddress": "02:42:ac:11:00:03",\n                    "driveropts": null\n                }\n            }\n        }\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n\n\n\n# 停止 web 应用容器\n\n再复习下docker的停止\n\n[root@pdai ~]# docker stop hopeful_bardeen\nhopeful_bardeen\n[root@pdai ~]# docker ps -a | grep \'hopeful_bardeen\'\n5da3588d5bc4        training/webapp      "python app.py"      13 minutes ago      exited (137) 12 seconds ago                             hopeful_bardeen\n\n\n1\n2\n3\n4\n\n\n\n# 重启web应用容器\n\n已经停止的容器，我们可以使用命令 docker start 或者docker restart 来启动。\n\n[root@pdai ~]# docker restart hopeful_bardeen\nhopeful_bardeen\n[root@pdai ~]# docker ps -a | grep hopeful_bardeen\n5da3588d5bc4        training/webapp      "python app.py"      14 minutes ago      up 10 seconds            0.0.0.0:5001->5000/tcp    hopeful_bardeen\n\n\n1\n2\n3\n4\n\n\n\n# 移除web应用容器\n\n我们可以使用 docker rm 命令来删除不需要的容器\n\n我们上文也讲过，如果是启动着的docker实例，需要加-f，强制（force）删除。\n\n[root@pdai ~]# docker ps -a | grep hopeful_bardeen\n5da3588d5bc4        training/webapp      "python app.py"      14 minutes ago      up 10 seconds            0.0.0.0:5001->5000/tcp    hopeful_bardeen\n[root@pdai ~]# docker rm -f hopeful_bardeen\nhopeful_bardeen\n[root@pdai ~]# docker ps -a | grep hopeful_bardeen\n[root@pdai ~]#\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 与其它容器（db容器）互联\n\n> 上述是一个web单一容器通过端口映射，可以通过主机端口访问容器；那么如果需要访问数据库，就涉及到容器互联。\n\n\n# 与数据库容器互联\n\n * 先停止上述的web容器, 且清理所有不用的容器\n\n[root@pdai ~]# docker ps -a\ncontainer id        image                command              created             status                    ports                     names\nec3eb9ae2184        training/webapp      "python app.py"      18 hours ago        up 18 hours               0.0.0.0:32768->5000/tcp   gifted_agnesi\n11de9755a084        pdai/ubuntu:v2.0.2   "/bin/bash"          24 hours ago        exited (0) 24 hours ago                             pdai-ubuntu-202\n57bd797570b6        pdai/ubuntu:v2.0.2   "--name pdai-test"   24 hours ago        created                                             sharp_brahmagupta\n[root@pdai ~]# docker stop ec3eb9ae2184\nec3eb9ae2184\n[root@pdai ~]# docker ps -a\ncontainer id        image                command              created             status                        ports               names\nec3eb9ae2184        training/webapp      "python app.py"      18 hours ago        exited (137) 29 seconds ago                       gifted_agnesi\n11de9755a084        pdai/ubuntu:v2.0.2   "/bin/bash"          24 hours ago        exited (0) 24 hours ago                           pdai-ubuntu-202\n57bd797570b6        pdai/ubuntu:v2.0.2   "--name pdai-test"   24 hours ago        created                                           sharp_brahmagupta\n[root@pdai ~]# docker container prune\nwarning! this will remove all stopped containers.\nare you sure you want to continue? [y/n] y\ndeleted containers:\nec3eb9ae218494d5aa5902c1ca4435733567b5e81319f02e5d2509d45cbc25da\n11de9755a08402d963d263a559a7daf48f4a2188398f258641240b5eb50fbc89\n57bd797570b68b6587b16809889e6e8f710ec7a934229aa6391add02f758e036\n\ntotal reclaimed space: 89b\n[root@pdai ~]#\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 创建一个新的数据库容器。\n\n[root@pdai ~]# docker run -d --name db training/postgres\nunable to find image \'training/postgres:latest\' locally\nlatest: pulling from training/postgres\nimage docker.io/training/postgres:latest uses outdated schema1 manifest format. please upgrade to a schema2 image for better future compatibility. more information at https://docs.docker.com/registry/spec/deprecated-schema-v1/\na3ed95caeb02: pull complete\n6e71c809542e: pull complete\n2978d9af87ba: pull complete\ne1bca35b062f: pull complete\n500b6decf741: pull complete\n74b14ef2151f: pull complete\n7afd5ed3826e: pull complete\n3c69bb244f5e: pull complete\nd86f9ec5aedf: pull complete\n010fabf20157: pull complete\ndigest: sha256:a945dc6dcfbc8d009c3d972931608344b76c2870ce796da00a827bd50791907e\nstatus: downloaded newer image for training/postgres:latest\nd992e3c761e00649eb436b88c737adc54093b76119af0fb7878596b523f743ca\n[root@pdai ~]# docker ps\ncontainer id        image               command                  created             status              ports               names\nd992e3c761e0        training/postgres   "su postgres -c \'/us…"   9 seconds ago       up 7 seconds        5432/tcp            db\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * db 容器和 web 容器建立互联关系\n\n[root@pdai ~]# docker run -d -p 5001:5000 --name web --link db:db training/webapp python app.py\n1cbc9aeba2a8a826d460ecb49de17ddf8ac336e150c752a3c762fd38a3e15254\n[root@pdai ~]# docker ps -a\ncontainer id        image               command                  created             status              ports                    names\n1cbc9aeba2a8        training/webapp     "python app.py"          5 seconds ago       up 4 seconds        0.0.0.0:5001->5000/tcp   web\nd992e3c761e0        training/postgres   "su postgres -c \'/us…"   7 minutes ago       up 7 minutes        5432/tcp                 db\n\n\n1\n2\n3\n4\n5\n6\n\n\n--link 参数的格式为 --link name:alias，其中 name 是要链接的容器的名称，alias 是这个连接的别名。\n\n> docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机上。在启动 db 容器的时候并没有使用 -p 和 -p 标记，从而避免了暴露数据库端口到外部网络上。\n\n\n# 容器公开的连接信息\n\ndocker 通过 2 种方式为容器公开连接信息：\n\n * 环境变量\n * 更新 /etc/hosts 文件\n\n# 环境变量\n\n使用 env 命令来查看 web 容器的环境变量\n\n[root@pdai ~]# docker exec -it web /bin/bash\nroot@1cbc9aeba2a8:/opt/webapp# env\nhostname=1cbc9aeba2a8\ndb_name=/web/db\ndb_port_5432_tcp_addr=172.17.0.2\ndb_port=tcp://172.17.0.2:5432\ndb_port_5432_tcp=tcp://172.17.0.2:5432\npath=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\npwd=/opt/webapp\ndb_port_5432_tcp_port=5432\nshlvl=1\nhome=/root\ndb_port_5432_tcp_proto=tcp\ndb_env_pg_version=9.3\n_=/usr/bin/env\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n其中 db_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。\n\n# hosts 文件\n\n除了环境变量，docker 还添加 host 信息到父容器的 /etc/hosts 的文件。下面是父容器 web 的 hosts 文件\n\nroot@1cbc9aeba2a8:/opt/webapp# cat /etc/hosts\n127.0.0.1       localhost\n::1     localhost ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n172.17.0.2      db d992e3c761e0\n172.17.0.3      1cbc9aeba2a8\nroot@1cbc9aeba2a8:/opt/webapp#\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这里有 2 个 hosts:\n\n * 第一个, 172.17.0.2 db d992e3c761e0 表示 db 容器的 ip, id和name\n * 第二个，172.17.0.3 1cbc9aeba2a8 表示 web 容器的 ip, id\n\n可以在 web 容器中安装 ping 命令来测试跟db容器的连通。\n\nroot@1cbc9aeba2a8:/opt/webapp# apt-get install -yqq inetutils-ping\n(reading database ... 18233 files and directories currently installed.)\nremoving ubuntu-minimal (1.325) ...\nremoving iputils-ping (3:20121221-4ubuntu1.1) ...\nselecting previously unselected package inetutils-ping.\n(reading database ... 18221 files and directories currently installed.)\npreparing to unpack .../inetutils-ping_2%3a1.9.2-1_amd64.deb ...\nunpacking inetutils-ping (2:1.9.2-1) ...\nsetting up inetutils-ping (2:1.9.2-1) ...\nroot@1cbc9aeba2a8:/opt/webapp# ping db\nping db (172.17.0.2): 56 data bytes\n64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.110 ms\n64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.092 ms\n64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.094 ms\n64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.104 ms\n64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.111 ms\n64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.093 ms\n64 bytes from 172.17.0.2: icmp_seq=6 ttl=64 time=0.095 ms\n^c--- db ping statistics ---\n7 packets transmitted, 7 packets received, 0% packet loss\nround-trip min/avg/max/stddev = 0.092/0.100/0.111/0.000 ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n用 ping 来测试db容器，它会解析成 172.17.0.2。\n\n当然，你还可以ping db容器的id或者内部ip, 结果是一样的。\n\nroot@1cbc9aeba2a8:/opt/webapp# ping -t 4 d992e3c761e0\nping: unsupported packet type: 4\nroot@1cbc9aeba2a8:/opt/webapp# ping d992e3c761e0\nping db (172.17.0.2): 56 data bytes\n64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.089 ms\n64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.093 ms\n^c--- db ping statistics ---\n2 packets transmitted, 2 packets received, 0% packet loss\nround-trip min/avg/max/stddev = 0.089/0.091/0.093/0.000 ms\nroot@1cbc9aeba2a8:/opt/webapp# ping 172.17.0.2\nping 172.17.0.2 (172.17.0.2): 56 data bytes\n64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.094 ms\n64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.103 ms\n^c--- 172.17.0.2 ping statistics ---\n2 packets transmitted, 2 packets received, 0% packet loss\nround-trip min/avg/max/stddev = 0.094/0.099/0.103/0.000 ms\nroot@1cbc9aeba2a8:/opt/webapp#\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。',charsets:{cjk:!0}},{title:"Dockerfile 指令详解",frontmatter:{title:"Dockerfile 指令详解",date:"2021-12-08T15:16:18.000Z",permalink:"/pages/4cbf7b/",categories:["技术","工具使用","后端","docker"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/10.docker/98.Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3.html",relativePath:"03.技术/06.工具使用/10.docker/98.Dockerfile指令详解.md",key:"v-60f033c1",path:"/pages/4cbf7b/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"构建镜像",frontmatter:{title:"构建镜像",date:"2021-12-08T11:27:35.000Z",permalink:"/pages/4cf767/",categories:["技术","工具使用","后端","docker"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/10.docker/99.%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F.html",relativePath:"03.技术/06.工具使用/10.docker/99.构建镜像.md",key:"v-6e5d990a",path:"/pages/4cf767/",headers:[{level:2,title:"一.使用commit构建镜像（不推荐）",slug:"一-使用commit构建镜像-不推荐",normalizedTitle:"一.使用commit构建镜像（不推荐）",charIndex:2},{level:3,title:"1.拉取nginx镜像",slug:"_1-拉取nginx镜像",normalizedTitle:"1.拉取nginx镜像",charIndex:26},{level:3,title:"2.访问浏览器",slug:"_2-访问浏览器",normalizedTitle:"2.访问浏览器",charIndex:94},{level:3,title:"3.访问终端",slug:"_3-访问终端",normalizedTitle:"3.访问终端",charIndex:324},{level:3,title:"4.构建镜像",slug:"_4-构建镜像",normalizedTitle:"4.构建镜像",charIndex:464},{level:3,title:"5.查看镜像",slug:"_5-查看镜像",normalizedTitle:"5.查看镜像",charIndex:626},{level:3,title:"慎用 docker commit",slug:"慎用-docker-commit",normalizedTitle:"慎用 docker commit",charIndex:906},{level:2,title:"二.使用 Dockerfile 定制镜像",slug:"二-使用-dockerfile-定制镜像",normalizedTitle:"二.使用 dockerfile 定制镜像",charIndex:1488},{level:3,title:"1.FROM 指定基础镜像",slug:"_1-from-指定基础镜像",normalizedTitle:"1.from 指定基础镜像",charIndex:1815},{level:3,title:"2.执行命令",slug:"_2-执行命令",normalizedTitle:"2.执行命令",charIndex:2945},{level:3,title:"3.构建镜像",slug:"_3-构建镜像",normalizedTitle:"3.构建镜像",charIndex:5089},{level:3,title:"4.镜像构建上下文（Context）",slug:"_4-镜像构建上下文-context",normalizedTitle:"4.镜像构建上下文（context）",charIndex:5851},{level:3,title:"5.其它 docker build 的用法",slug:"_5-其它-docker-build-的用法",normalizedTitle:"5.其它 docker build 的用法",charIndex:8279}],headersStr:"一.使用commit构建镜像（不推荐） 1.拉取nginx镜像 2.访问浏览器 3.访问终端 4.构建镜像 5.查看镜像 慎用 docker commit 二.使用 Dockerfile 定制镜像 1.FROM 指定基础镜像 2.执行命令 3.构建镜像 4.镜像构建上下文（Context） 5.其它 docker build 的用法",content:'# 一.使用commit构建镜像（不推荐）\n\n\n# 1.拉取nginx镜像\n\ndocker run --name webserver -d -p 80:80 nginx\n\n\n1\n\n\n\n# 2.访问浏览器\n\n如果是在本机运行的 Docker，那么可以直接访问：http://localhost ，如果是在虚拟机、云服务器上安装的 Docker，则需要将 localhost 换为虚拟机地址或者实际云服务器地址。\n\n直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。\n\n\n1\n2\n3\n\n\n现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 docker exec 命令进入容器，修改其内容。\n\n\n# 3.访问终端\n\ndocker exec -it webserver bash\n\n\n1\n\n\n用 <h1>Hello, Docker!</h1> 覆盖了 /usr/share/nginx/html/index.html 的内容。\n\n再查看浏览器就可以看到内容已经发生了变化。\n\n\n# 4.构建镜像\n\ndocker commit --author "wcy" --message "修改了默认网页" webserver nginx:v2\n\n\n1\n\n\n其中 --author 是指定修改的作者，而 --message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。\n\n\n# 5.查看镜像\n\ndocker images\n\n\n1\n\n\n新的镜像定制好后，我们可以来运行这个镜像。\n\n启动新的镜像\n\ndocker run --name web2 -d -p 81:80 nginx:v2\n\n\n1\n\n\n这里我们命名为新的服务为 web2，并且映射到 81 端口。访问 http://localhost:81 看到结果，其内容应该和之前修改后的 webserver 一样。\n\n至此，我们第一次完成了定制镜像，使用的是 docker commit 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。\n\n\n# 慎用 docker commit\n\n使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。\n\n首先，如果仔细观察之前的 docker diff webserver 的结果，你会发现除了真正想要修改的 /usr/share/nginx/html/index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。\n\n此外，使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。\n\n而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。\n\n\n# 二.使用 Dockerfile 定制镜像\n\n>  1. 编写Dockerfile 文件\n>  2. 执行build命令：docker build -t nginx:v3 .\n\n在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：\n\n$ mkdir mynginx\n$ cd mynginx\n$ touch Dockerfile\n\n\n1\n2\n3\n\n\n其内容为：\n\nFROM nginx\nRUN echo \'<h1>Hello, Docker!</h1>\' > /usr/share/nginx/html/index.html\n\n\n1\n2\n\n\n这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。\n\n\n# 1.FROM 指定基础镜像\n\n所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。\n\n在 Docker Hub (opens new window)上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx (opens new window)、redis (opens new window)、mongo (opens new window)、mysql (opens new window)、httpd (opens new window)、php (opens new window)、tomcat (opens new window)等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node (opens new window)、openjdk (opens new window)、python (opens new window)、ruby (opens new window)、golang (opens new window)等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。\n\n如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu (opens new window)、debian (opens new window)、centos (opens new window)、fedora (opens new window)、alpine (opens new window)等，这些操作系统的软件库为我们提供了更广阔的扩展空间。\n\n除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。\n\nFROM scratch\n...\n\n\n1\n2\n\n\n如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。\n\n不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 (opens new window)开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。\n\n\n# 2.执行命令\n\nRUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：\n\n * shell 格式：RUN <命令>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。\n   \n   RUN echo \'<h1>Hello, Docker!</h1>\' > /usr/share/nginx/html/index.html\n   \n   \n   1\n   \n\n * exec 格式：RUN ["可执行文件", "参数1", "参数2"]，这更像是函数调用中的格式。\n\n既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：\n\nFROM debian:stretch\n\nRUN apt-get update\nRUN apt-get install -y gcc libc6-dev make wget\nRUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"\nRUN mkdir -p /usr/src/redis\nRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1\nRUN make -C /usr/src/redis\nRUN make -C /usr/src/redis install\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。\n\n而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。\n\nUnion FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。\n\n上面的 Dockerfile 正确的写法应该是这样：\n\nFROM debian:stretch\n\nRUN set -x; buildDeps=\'gcc libc6-dev make wget\' \\\n    && apt-get update \\\n    && apt-get install -y $buildDeps \\\n    && wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \\\n    && mkdir -p /usr/src/redis \\\n    && tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\\n    && make -C /usr/src/redis \\\n    && make -C /usr/src/redis install \\\n    && rm -rf /var/lib/apt/lists/* \\\n    && rm redis.tar.gz \\\n    && rm -r /usr/src/redis \\\n    && apt-get purge -y --auto-remove $buildDeps\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 && 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。\n\n并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。\n\n此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。\n\n很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。\n\n\n# 3.构建镜像\n\n好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。\n\n在 Dockerfile 文件所在目录执行：（注意有一个点）\n\n$ docker build -t nginx:v3 .\nSending build context to Docker daemon 2.048 kB\nStep 1 : FROM nginx\n ---\x3e e43d811ce2f4\nStep 2 : RUN echo \'<h1>Hello, Docker!</h1>\' > /usr/share/nginx/html/index.html\n ---\x3e Running in 9cdc27646c7b\n ---\x3e 44aa4490ce2c\nRemoving intermediate container 9cdc27646c7b\nSuccessfully built 44aa4490ce2c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。\n\n这里我们使用了 docker build 命令进行镜像构建。其格式为：\n\ndocker build [选项] <上下文路径/URL/->\n\n\n1\n\n\n在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。\n\n\n# 4.镜像构建上下文（Context）\n\n如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。那么什么是上下文呢？\n\n首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API (opens new window)，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。\n\n当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？\n\n这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。\n\n如果在 Dockerfile 中这么写：\n\nCOPY ./package.json /app/\n\n\n1\n\n\n这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。\n\n因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。\n\n现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。\n\n如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：\n\n这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。\n\n因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。\n\n现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。\n\n如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：\n\n$ docker build -t nginx:v3 .\nSending build context to Docker daemon 2.048 kB\n...\n\n\n1\n2\n3\n\n\n理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。\n\n一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。\n\n那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。\n\n这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。\n\n当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。\n\n\n# 5.其它 docker build 的用法\n\n# 1.git仓库的dockerfile文件进行构建\n\n或许你已经注意到了，docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建：\n\n# $env:DOCKER_BUILDKIT=0\n# export DOCKER_BUILDKIT=0\n\n$ docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world\n\nStep 1/3 : FROM scratch\n ---\x3e\nStep 2/3 : COPY hello /\n ---\x3e ac779757d46e\nStep 3/3 : CMD ["/hello"]\n ---\x3e Running in d2a513a760ed\nRemoving intermediate container d2a513a760ed\n ---\x3e 038ad4142d2b\nSuccessfully built 038ad4142d2b\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这行命令指定了构建所需的 Git repo，并且指定分支为 master，构建目录为 /amd64/hello-world/，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。\n\n# 2.用给定的 tar 压缩包构建\n\n$ docker build http://server/context.tar.gz\n\n\n1\n\n\n如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。\n\n# 3.从标准输入中读取 Dockerfile 进行构建\n\ndocker build - < Dockerfile\n\n\n1\n\n\n或\n\ncat Dockerfile | docker build -\n\n\n1\n\n\n如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。\n\n# 4.从标准输入中读取上下文压缩包进行构建\n\n$ docker build - < context.tar.gz\n\n\n1\n\n\n如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。',normalizedContent:'# 一.使用commit构建镜像（不推荐）\n\n\n# 1.拉取nginx镜像\n\ndocker run --name webserver -d -p 80:80 nginx\n\n\n1\n\n\n\n# 2.访问浏览器\n\n如果是在本机运行的 docker，那么可以直接访问：http://localhost ，如果是在虚拟机、云服务器上安装的 docker，则需要将 localhost 换为虚拟机地址或者实际云服务器地址。\n\n直接用浏览器访问的话，我们会看到默认的 nginx 欢迎页面。\n\n\n1\n2\n3\n\n\n现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 docker 的文字，我们可以使用 docker exec 命令进入容器，修改其内容。\n\n\n# 3.访问终端\n\ndocker exec -it webserver bash\n\n\n1\n\n\n用 <h1>hello, docker!</h1> 覆盖了 /usr/share/nginx/html/index.html 的内容。\n\n再查看浏览器就可以看到内容已经发生了变化。\n\n\n# 4.构建镜像\n\ndocker commit --author "wcy" --message "修改了默认网页" webserver nginx:v2\n\n\n1\n\n\n其中 --author 是指定修改的作者，而 --message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。\n\n\n# 5.查看镜像\n\ndocker images\n\n\n1\n\n\n新的镜像定制好后，我们可以来运行这个镜像。\n\n启动新的镜像\n\ndocker run --name web2 -d -p 81:80 nginx:v2\n\n\n1\n\n\n这里我们命名为新的服务为 web2，并且映射到 81 端口。访问 http://localhost:81 看到结果，其内容应该和之前修改后的 webserver 一样。\n\n至此，我们第一次完成了定制镜像，使用的是 docker commit 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。\n\n\n# 慎用 docker commit\n\n使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。\n\n首先，如果仔细观察之前的 docker diff webserver 的结果，你会发现除了真正想要修改的 /usr/share/nginx/html/index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。\n\n此外，使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。\n\n而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。\n\n\n# 二.使用 dockerfile 定制镜像\n\n>  1. 编写dockerfile 文件\n>  2. 执行build命令：docker build -t nginx:v3 .\n\n在一个空白目录中，建立一个文本文件，并命名为 dockerfile：\n\n$ mkdir mynginx\n$ cd mynginx\n$ touch dockerfile\n\n\n1\n2\n3\n\n\n其内容为：\n\nfrom nginx\nrun echo \'<h1>hello, docker!</h1>\' > /usr/share/nginx/html/index.html\n\n\n1\n2\n\n\n这个 dockerfile 很简单，一共就两行。涉及到了两条指令，from 和 run。\n\n\n# 1.from 指定基础镜像\n\n所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 from 就是指定 基础镜像，因此一个 dockerfile 中 from 是必备的指令，并且必须是第一条指令。\n\n在 docker hub (opens new window)上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx (opens new window)、redis (opens new window)、mongo (opens new window)、mysql (opens new window)、httpd (opens new window)、php (opens new window)、tomcat (opens new window)等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node (opens new window)、openjdk (opens new window)、python (opens new window)、ruby (opens new window)、golang (opens new window)等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。\n\n如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu (opens new window)、debian (opens new window)、centos (opens new window)、fedora (opens new window)、alpine (opens new window)等，这些操作系统的软件库为我们提供了更广阔的扩展空间。\n\n除了选择现有镜像为基础镜像外，docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。\n\nfrom scratch\n...\n\n\n1\n2\n\n\n如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。\n\n不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 from scratch 会让镜像体积更加小巧。使用 go 语言 (opens new window)开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 go 是特别适合容器微服务架构的语言的原因之一。\n\n\n# 2.执行命令\n\nrun 指令是用来执行命令行命令的。由于命令行的强大能力，run 指令在定制镜像时是最常用的指令之一。其格式有两种：\n\n * shell 格式：run <命令>，就像直接在命令行中输入的命令一样。刚才写的 dockerfile 中的 run 指令就是这种格式。\n   \n   run echo \'<h1>hello, docker!</h1>\' > /usr/share/nginx/html/index.html\n   \n   \n   1\n   \n\n * exec 格式：run ["可执行文件", "参数1", "参数2"]，这更像是函数调用中的格式。\n\n既然 run 就像 shell 脚本一样可以执行命令，那么我们是否就可以像 shell 脚本一样把每个命令对应一个 run 呢？比如这样：\n\nfrom debian:stretch\n\nrun apt-get update\nrun apt-get install -y gcc libc6-dev make wget\nrun wget -o redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"\nrun mkdir -p /usr/src/redis\nrun tar -xzf redis.tar.gz -c /usr/src/redis --strip-components=1\nrun make -c /usr/src/redis\nrun make -c /usr/src/redis install\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n之前说过，dockerfile 中每一个指令都会建立一层，run 也不例外。每一个 run 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。\n\n而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 docker 的人常犯的一个错误。\n\nunion fs 是有最大层数限制的，比如 aufs，曾经是最大不得超过 42 层，现在是不得超过 127 层。\n\n上面的 dockerfile 正确的写法应该是这样：\n\nfrom debian:stretch\n\nrun set -x; builddeps=\'gcc libc6-dev make wget\' \\\n    && apt-get update \\\n    && apt-get install -y $builddeps \\\n    && wget -o redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \\\n    && mkdir -p /usr/src/redis \\\n    && tar -xzf redis.tar.gz -c /usr/src/redis --strip-components=1 \\\n    && make -c /usr/src/redis \\\n    && make -c /usr/src/redis install \\\n    && rm -rf /var/lib/apt/lists/* \\\n    && rm redis.tar.gz \\\n    && rm -r /usr/src/redis \\\n    && apt-get purge -y --auto-remove $builddeps\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 run 一一对应不同的命令，而是仅仅使用一个 run 指令，并使用 && 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 dockerfile 的时候，要经常提醒自己，这并不是在写 shell 脚本，而是在定义每一层该如何构建。\n\n并且，这里为了格式化还进行了换行。dockerfile 支持 shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。\n\n此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。\n\n很多人初学 docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。\n\n\n# 3.构建镜像\n\n好了，让我们再回到之前定制的 nginx 镜像的 dockerfile 来。现在我们明白了这个 dockerfile 的内容，那么让我们来构建这个镜像吧。\n\n在 dockerfile 文件所在目录执行：（注意有一个点）\n\n$ docker build -t nginx:v3 .\nsending build context to docker daemon 2.048 kb\nstep 1 : from nginx\n ---\x3e e43d811ce2f4\nstep 2 : run echo \'<h1>hello, docker!</h1>\' > /usr/share/nginx/html/index.html\n ---\x3e running in 9cdc27646c7b\n ---\x3e 44aa4490ce2c\nremoving intermediate container 9cdc27646c7b\nsuccessfully built 44aa4490ce2c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 step 2 中，如同我们之前所说的那样，run 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。\n\n这里我们使用了 docker build 命令进行镜像构建。其格式为：\n\ndocker build [选项] <上下文路径/url/->\n\n\n1\n\n\n在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。\n\n\n# 4.镜像构建上下文（context）\n\n如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。那么什么是上下文呢？\n\n首先我们要理解 docker build 的工作原理。docker 在运行时分为 docker 引擎（也就是服务端守护进程）和客户端工具。docker 的引擎提供了一组 rest api，被称为 docker remote api (opens new window)，而如 docker 命令这样的客户端工具，则是通过这组 api 与 docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（docker 引擎）完成。也因为这种 c/s 设计，让我们操作远程服务器的 docker 引擎变得轻而易举。\n\n当我们进行镜像构建的时候，并非所有定制都会通过 run 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 copy 指令、add 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？\n\n这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 docker 引擎。这样 docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。\n\n如果在 dockerfile 中这么写：\n\ncopy ./package.json /app/\n\n\n1\n\n\n这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。\n\n因此，copy 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 copy ../package.json /app 或者 copy /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。\n\n现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 docker 引擎以帮助构建镜像。\n\n如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：\n\n这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。\n\n因此，copy 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 copy ../package.json /app 或者 copy /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。\n\n现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 docker 引擎以帮助构建镜像。\n\n如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：\n\n$ docker build -t nginx:v3 .\nsending build context to docker daemon 2.048 kb\n...\n\n\n1\n2\n3\n\n\n理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 copy /opt/xxxx /app 不工作后，于是干脆将 dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 gb 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。\n\n一般来说，应该会将 dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 docker 引擎的。\n\n那么为什么会有人误以为 . 是指定 dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 dockerfile 的话，会将上下文目录下的名为 dockerfile 的文件作为 dockerfile。\n\n这只是默认行为，实际上 dockerfile 的文件名并不要求必须为 dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../dockerfile.php 参数指定某个文件作为 dockerfile。\n\n当然，一般大家习惯性的会使用默认的文件名 dockerfile，以及会将其置于镜像构建上下文目录中。\n\n\n# 5.其它 docker build 的用法\n\n# 1.git仓库的dockerfile文件进行构建\n\n或许你已经注意到了，docker build 还支持从 url 构建，比如可以直接从 git repo 中构建：\n\n# $env:docker_buildkit=0\n# export docker_buildkit=0\n\n$ docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world\n\nstep 1/3 : from scratch\n ---\x3e\nstep 2/3 : copy hello /\n ---\x3e ac779757d46e\nstep 3/3 : cmd ["/hello"]\n ---\x3e running in d2a513a760ed\nremoving intermediate container d2a513a760ed\n ---\x3e 038ad4142d2b\nsuccessfully built 038ad4142d2b\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这行命令指定了构建所需的 git repo，并且指定分支为 master，构建目录为 /amd64/hello-world/，然后 docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。\n\n# 2.用给定的 tar 压缩包构建\n\n$ docker build http://server/context.tar.gz\n\n\n1\n\n\n如果所给出的 url 不是个 git repo，而是个 tar 压缩包，那么 docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。\n\n# 3.从标准输入中读取 dockerfile 进行构建\n\ndocker build - < dockerfile\n\n\n1\n\n\n或\n\ncat dockerfile | docker build -\n\n\n1\n\n\n如果标准输入传入的是文本文件，则将其视为 dockerfile，并开始构建。这种形式由于直接从标准输入中读取 dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 copy 进镜像之类的事情。\n\n# 4.从标准输入中读取上下文压缩包进行构建\n\n$ docker build - < context.tar.gz\n\n\n1\n\n\n如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。',charsets:{cjk:!0}},{title:"Docker基础 - 仓库，镜像，容器详解",frontmatter:{title:"Docker基础 - 仓库，镜像，容器详解",date:"2021-10-19T17:24:40.000Z",permalink:"/pages/3c17ac/",categories:["技术","工具使用","后端","docker"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/10.docker/03.Docker%E5%9F%BA%E7%A1%80_%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3.html",relativePath:"03.技术/06.工具使用/10.docker/03.Docker基础_仓库镜像容器详解.md",key:"v-6c0dd964",path:"/pages/3c17ac/",headers:[{level:2,title:"仓库，镜像，容器的关系",slug:"仓库-镜像-容器的关系",normalizedTitle:"仓库，镜像，容器的关系",charIndex:89},{level:2,title:"Docker 镜像",slug:"docker-镜像",normalizedTitle:"docker 镜像",charIndex:130},{level:3,title:"镜像列表",slug:"镜像列表",normalizedTitle:"镜像列表",charIndex:257},{level:3,title:"查找镜像",slug:"查找镜像",normalizedTitle:"查找镜像",charIndex:814},{level:3,title:"拉取镜像",slug:"拉取镜像",normalizedTitle:"拉取镜像",charIndex:4102},{level:3,title:"删除镜像",slug:"删除镜像",normalizedTitle:"删除镜像",charIndex:5155},{level:3,title:"更新镜像",slug:"更新镜像",normalizedTitle:"更新镜像",charIndex:8112},{level:3,title:"生成镜像",slug:"生成镜像",normalizedTitle:"生成镜像",charIndex:10716},{level:3,title:"镜像标签",slug:"镜像标签",normalizedTitle:"镜像标签",charIndex:13663},{level:3,title:"镜像导出和导入",slug:"镜像导出和导入",normalizedTitle:"镜像导出和导入",charIndex:14494},{level:2,title:"Docker 容器",slug:"docker-容器",normalizedTitle:"docker 容器",charIndex:15132},{level:3,title:"容器启动",slug:"容器启动",normalizedTitle:"容器启动",charIndex:15180},{level:3,title:"容器查看",slug:"容器查看",normalizedTitle:"容器查看",charIndex:15476},{level:3,title:"容器再启动",slug:"容器再启动",normalizedTitle:"容器再启动",charIndex:16586},{level:3,title:"容器停止和重启",slug:"容器停止和重启",normalizedTitle:"容器停止和重启",charIndex:17036},{level:3,title:"后台模式与进入",slug:"后台模式与进入",normalizedTitle:"后台模式与进入",charIndex:18425},{level:3,title:"容器导出和导入",slug:"容器导出和导入",normalizedTitle:"容器导出和导入",charIndex:19867},{level:3,title:"强制停止容器",slug:"强制停止容器",normalizedTitle:"强制停止容器",charIndex:21229},{level:3,title:"清理停止的容器",slug:"清理停止的容器",normalizedTitle:"清理停止的容器",charIndex:22558},{level:3,title:"容器别名及操作",slug:"容器别名及操作",normalizedTitle:"容器别名及操作",charIndex:24260},{level:3,title:"容器错误日志",slug:"容器错误日志",normalizedTitle:"容器错误日志",charIndex:25164},{level:2,title:"Docker 仓库",slug:"docker-仓库",normalizedTitle:"docker 仓库",charIndex:25683},{level:3,title:"公有仓库",slug:"公有仓库",normalizedTitle:"公有仓库",charIndex:25911}],headersStr:"仓库，镜像，容器的关系 Docker 镜像 镜像列表 查找镜像 拉取镜像 删除镜像 更新镜像 生成镜像 镜像标签 镜像导出和导入 Docker 容器 容器启动 容器查看 容器再启动 容器停止和重启 后台模式与进入 容器导出和导入 强制停止容器 清理停止的容器 容器别名及操作 容器错误日志 Docker 仓库 公有仓库",content:'# Docker基础 - 仓库，镜像，容器详解\n\n> 本文将从仓库，镜像，容器三个方面讲解常用的docker命令和使用等，对于开发而言这块使用的非常频繁，需要重点掌握。\n\n\n# 仓库，镜像，容器的关系\n\n> 仓库，镜像，容器的关系（这是官网的图）\n\n\n\n\n# Docker 镜像\n\n当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。\n\n下面我们来学 1、管理和使用本地 Docker 主机镜像 2、创建镜像\n\n\n# 镜像列表\n\n我们可以使用 docker images 来列出本地主机上的镜像\n\n[root@pdai ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB\nhello-world         latest              fce289e99eb9        13 months ago       1.84kB\n\n\n1\n2\n3\n4\n\n\n著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/devops/docker/docker-03-basic2.html\n\n各个选项说明:\n\n * REPOSITORY：表示镜像的仓库源\n * TAG：镜像的标签, 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本\n * IMAGE ID：镜像ID\n * CREATED：镜像创建时间\n * SIZE：镜像大小\n\n\n# 查找镜像\n\n> 以查找MySQL的镜像为例：\n\n * 通过Docker Hub 进行查找, 比如https://hub.docker.com/search?q=mysql&type=image\n\n\n\n * 使用 docker search 命令来搜索镜像\n\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n[root@pdai ~]# docker search mysql\nNAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\nmysql                             MySQL is a widely used, open-source relation…   9132                [OK]\nmariadb                           MariaDB is a community-developed fork of MyS…   3233                [OK]\nmysql/mysql-server                Optimized MySQL Server Docker images. Create…   676                                     [OK]\ncentos/mysql-57-centos7           MySQL 5.7 SQL database server                   68\nmysql/mysql-cluster               Experimental MySQL Cluster Docker images. Cr…   62\ncenturylink/mysql                 Image containing mysql. Optimized to be link…   61                                      [OK]\ndeitch/mysql-backup               REPLACED! Please use http://hub.docker.com/r…   41                                      [OK]\nbitnami/mysql                     Bitnami MySQL Docker Image                      35                                      [OK]\ntutum/mysql                       Base docker image to run a MySQL database se…   34\nschickling/mysql-backup-s3        Backup MySQL to S3 (supports periodic backup…   29                                      [OK]\nprom/mysqld-exporter                                                              26                                      [OK]\nlinuxserver/mysql                 A Mysql container, brought to you by LinuxSe…   24\ncentos/mysql-56-centos7           MySQL 5.6 SQL database server                   19\ncircleci/mysql                    MySQL is a widely used, open-source relation…   18\nmysql/mysql-router                MySQL Router provides transparent routing be…   14\narey/mysql-client                 Run a MySQL client from a docker container      13                                      [OK]\ndataback/mysql-backup             Back up mysql databases to... anywhere!         10\nopenshift/mysql-55-centos7        DEPRECATED: A Centos7 based MySQL v5.5 image…   6\nfradelg/mysql-cron-backup         MySQL/MariaDB database backup using cron tas…   5                                       [OK]\ngenschsa/mysql-employees          MySQL Employee Sample Database                  4                                       [OK]\ndevilbox/mysql                    Retagged MySQL, MariaDB and PerconaDB offici…   2\nansibleplaybookbundle/mysql-apb   An APB which deploys RHSCL MySQL                2                                       [OK]\njelastic/mysql                    An image of the MySQL database server mainta…   1\nmonasca/mysql-init                A minimal decoupled init container for mysql    0\nwiddpim/mysql-client              Dockerized MySQL Client (5.7) including Curl…   0                                       [OK]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n * NAME: 镜像仓库源的名称\n * DESCRIPTION: 镜像的描述\n * OFFICIAL: 是否 docker 官方发布\n * STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。\n * AUTOMATED: 自动构建。\n\n\n# 拉取镜像\n\n> 现在拉取搜索出的MySQL\n\n[root@pdai ~]# docker pull mysql\nUsing default tag: latest\nlatest: Pulling from library/mysql\n619014d83c02: Pull complete\n9ced578c3a5f: Pull complete\n731f6e13d8ea: Pull complete\n3c183de42679: Pull complete\n6de69b5c2f3c: Pull complete\n00f0a4086406: Pull complete\n84d93aea836d: Pull complete\nf18efbfd8d76: Pull complete\n012b302865d1: Pull complete\nfe16fd240f59: Pull complete\nca3e793e545e: Pull complete\n51d0f2cb2610: Pull complete\nDigest: sha256:6d0741319b6a2ae22c384a97f4bbee411b01e75f6284af0cce339fee83d7e314\nStatus: Downloaded newer image for mysql:latest\ndocker.io/library/mysql:latest\n[root@pdai ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nmysql               latest              791b6e40940c        2 weeks ago         465MB\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB\nhello-world         latest              fce289e99eb9        13 months ago       1.84kB\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 删除镜像\n\n> 是时候删除那个无聊的hello-world镜像了\n\n[root@pdai ~]# docker rmi hello-world\nError response from daemon: conflict: unable to remove repository reference "hello-world" (must force) - container c91b90b18884 is using its referenced image fce289e99eb9\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n\n\n1\n2\n3\n4\n\n\n发现报错了，这时候主要看两点：要么就是container实例存在，要么存在镜像依赖；\n\n[root@pdai ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES\n1a51d2f023c9        ubuntu:latest       "/bin/sh -c \'while t…"   2 hours ago         Exited (137) 2 hours ago                       gifted_brown\n414bf796cbe4        ubuntu:latest       "/bin/bash"              2 hours ago         Exited (0) 2 hours ago                         pedantic_galileo\n512061ebfa4c        ubuntu:latest       "/bin/bash"              2 hours ago         Exited (0) 2 hours ago                         wizardly_brown\naa5e9ae5e5db        ubuntu:latest       "/bin/echo \'Hello wo…"   2 hours ago         Exited (0) 2 hours ago                         affectionate_knuth\nc91b90b18884        hello-world         "/hello"                 3 hours ago         Exited (0) 3 hours ago                         admiring_pare\n[root@pdai ~]# docker image inspect --format=\'{{.RepoTags}} {{.Id}} {{.Parent}}\' $(docker image ls -q )\n[mysql:latest] sha256:791b6e40940cd550af522eb4ffe995226798204504fe495743445b900e417a51\n[ubuntu:latest] sha256:ccc6e87d482b79dd1645affd958479139486e47191dfe7a997c862d89cd8b4c0\n[hello-world:latest] sha256:fce289e99eb9bca977dae136fbe2a82b6b7d4c372474c9235adc1741675f587e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n显然，我们只要删除container即可：\n\n[root@pdai ~]# docker rm c91b90b18884\nc91b90b18884\n[root@pdai ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES\n1a51d2f023c9        ubuntu:latest       "/bin/sh -c \'while t…"   2 hours ago         Exited (137) 2 hours ago                       gifted_brown\n414bf796cbe4        ubuntu:latest       "/bin/bash"              2 hours ago         Exited (0) 2 hours ago                         pedantic_galileo\n512061ebfa4c        ubuntu:latest       "/bin/bash"              2 hours ago         Exited (0) 2 hours ago                         wizardly_brown\naa5e9ae5e5db        ubuntu:latest       "/bin/echo \'Hello wo…"   2 hours ago         Exited (0) 2 hours ago                         affectionate_knuth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n最后再来删除镜像吧\n\n[root@pdai ~]# docker rmi hello-world\nUntagged: hello-world:latest\nUntagged: hello-world@sha256:9572f7cdcee8591948c2963463447a53466950b3fc15a247fcad1917ca215a2f\nDeleted: sha256:fce289e99eb9bca977dae136fbe2a82b6b7d4c372474c9235adc1741675f587e\nDeleted: sha256:af0b15c8625bb1938f1d7b17081031f649fd14e6b233688eea3c5483994a66a3\n\n\n1\n2\n3\n4\n5\n\n\n\n# 更新镜像\n\n> 针对上述ubuntu的镜像，我们能否在里面安装一些软件，然后重新生成一个镜像呢？这就是更新重新commit出一个新的镜像。\n\n我们先跑一个ubuntu容器实例，同时在里面进行apt-get update更新\n\n[root@pdai ~]# docker run -it ubuntu:latest\nroot@0a1556ca3c27:/# apt-get update\nGet:1 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]\nGet:2 http://archive.ubuntu.com/ubuntu bionic InRelease [242 kB]\nGet:3 http://archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]\nGet:4 http://archive.ubuntu.com/ubuntu bionic-backports InRelease [74.6 kB]\nGet:5 http://security.ubuntu.com/ubuntu bionic-security/main amd64 Packages [817 kB]\nGet:6 http://archive.ubuntu.com/ubuntu bionic/main amd64 Packages [1344 kB]\nGet:7 http://archive.ubuntu.com/ubuntu bionic/multiverse amd64 Packages [186 kB]\nGet:8 http://archive.ubuntu.com/ubuntu bionic/restricted amd64 Packages [13.5 kB]\nGet:9 http://archive.ubuntu.com/ubuntu bionic/universe amd64 Packages [11.3 MB]\nGet:10 http://security.ubuntu.com/ubuntu bionic-security/restricted amd64 Packages [27.5 kB]\nGet:11 http://security.ubuntu.com/ubuntu bionic-security/multiverse amd64 Packages [7064 B]\nGet:12 http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages [818 kB]\nGet:13 http://archive.ubuntu.com/ubuntu bionic-updates/multiverse amd64 Packages [11.1 kB]\nGet:14 http://archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages [1345 kB]\nGet:15 http://archive.ubuntu.com/ubuntu bionic-updates/restricted amd64 Packages [41.2 kB]\nGet:16 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 Packages [1104 kB]\nGet:17 http://archive.ubuntu.com/ubuntu bionic-backports/universe amd64 Packages [4252 B]\nGet:18 http://archive.ubuntu.com/ubuntu bionic-backports/main amd64 Packages [2496 B]\nFetched 17.6 MB in 10s (1759 kB/s)\nReading package lists... Done\nroot@0a1556ca3c27:/# exit\nexit\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n此时 ID 为 0a1556ca3c27 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本：\n\n[root@pdai ~]# docker commit -m="update test" -a="pdai" 0a1556ca3c27  pdai/ubuntu:v1.0.1\nsha256:b51e9f5f98cdb5b95c34181148ed7029f0150618aa8cd0e916b10b6aea1bd4c9\n\n\n1\n2\n\n\n可以看到已经生成成功, 且镜像的大小不一样了：\n\n[root@pdai ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\npdai/ubuntu         v1.0.1              b51e9f5f98cd        5 seconds ago       92.1MB\nmysql               latest              791b6e40940c        2 weeks ago         465MB\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB\n\n\n1\n2\n3\n4\n5\n\n\n著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/devops/docker/docker-03-basic2.html\n\n\n# 生成镜像\n\n> 那如果是生成一个全新的镜像呢？我们使用命令 docker build ，通过创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。\n\n这里特意指定的Base镜像为上一步修改生成的pdai/ubuntu:v1.0.1\n\nFROM    pdai/ubuntu:v1.0.1\nMAINTAINER      pdai "www.pdai.tech"\n\nRUN     /bin/echo \'root:123456\' |chpasswd\nRUN     useradd pdai\nRUN     /bin/echo \'pdai:123456\' |chpasswd\nRUN     /bin/echo -e "LANG=\\"en_US.UTF-8\\"" >/etc/default/local\nEXPOSE  22\nEXPOSE  80\nCMD     /usr/sbin/sshd -D\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n稍微解释下：这一部分在开发中会用到比较多，所以单独一个章节详解：Docker基础 - dockerfile详解\n\n * 每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。\n * 第一条FROM，指定使用哪个镜像源\n * RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。\n * 我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。\n\n接下来生成镜像：\n\n[root@pdai docker-test]# docker build -t pdai/ubuntu:v2.0.1 .\nSending build context to Docker daemon  2.048kB\nStep 1/9 : FROM    pdai/ubuntu:v1.0.1\n ---\x3e b51e9f5f98cd\nStep 2/9 : MAINTAINER      pdai "www.pdai.tech"\n ---\x3e Running in af026ee229ea\nRemoving intermediate container af026ee229ea\n ---\x3e 0e961cb557c9\nStep 3/9 : RUN     /bin/echo \'root:123456\' |chpasswd\n ---\x3e Running in 96bd9c40c55e\nRemoving intermediate container 96bd9c40c55e\n ---\x3e 9e8549720043\nStep 4/9 : RUN     useradd pdai\n ---\x3e Running in 0117278f243c\nRemoving intermediate container 0117278f243c\n ---\x3e 87c478df56da\nStep 5/9 : RUN     /bin/echo \'pdai:123456\' |chpasswd\n ---\x3e Running in e0381eabe71a\nRemoving intermediate container e0381eabe71a\n ---\x3e 84fd07f978ae\nStep 6/9 : RUN     /bin/echo -e "LANG=\\"en_US.UTF-8\\"" >/etc/default/local\n ---\x3e Running in 8d0052d9921f\nRemoving intermediate container 8d0052d9921f\n ---\x3e 3ed0b248224c\nStep 7/9 : EXPOSE  22\n ---\x3e Running in 4b5d540567cd\nRemoving intermediate container 4b5d540567cd\n ---\x3e c0a72ad140dd\nStep 8/9 : EXPOSE  80\n ---\x3e Running in c9620707d038\nRemoving intermediate container c9620707d038\n ---\x3e df42b714ecc1\nStep 9/9 : CMD     /usr/sbin/sshd -D\n ---\x3e Running in e178826b43fe\nRemoving intermediate container e178826b43fe\n ---\x3e a733d5a264b5\nSuccessfully built a733d5a264b5\nSuccessfully tagged pdai/ubuntu:v2.0.1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n参数说明：\n\n * -t ：指定要创建的目标镜像名\n * . ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径\n\n使用docker images 查看创建的镜像已经在列表中存在,镜像ID为a733d5a264b5\n\n[root@pdai docker-test]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\npdai/ubuntu         v2.0.1              a733d5a264b5        5 minutes ago       92.5MB\npdai/ubuntu         v1.0.1              b51e9f5f98cd        15 hours ago        92.1MB\nmysql               latest              791b6e40940c        2 weeks ago         465MB\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们可以使用新的镜像来创建容器\n\n[root@pdai docker-test]# docker run -it pdai/ubuntu:v2.0.1 /bin/bash\nroot@f5332ebce695:/# id pdai\nuid=1000(pdai) gid=1000(pdai) groups=1000(pdai)\nroot@f5332ebce695:/# exit\nexit\n\n\n1\n2\n3\n4\n5\n\n\n从上面看到新镜像已经包含我们创建的用户 pdai。\n\n\n# 镜像标签\n\n> 设置镜像的Tag，类似于Git中tag？我们可以使用 docker tag 命令，为镜像添加一个新的标签\n\n[root@pdai ~]# docker tag a733d5a264b5 pdai/ubuntu:v3.0.1\n[root@pdai ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\npdai/ubuntu         v2.0.1              a733d5a264b5        9 minutes ago       92.5MB\npdai/ubuntu         v3.0.1              a733d5a264b5        9 minutes ago       92.5MB\npdai/ubuntu         v1.0.1              b51e9f5f98cd        15 hours ago        92.1MB\nmysql               latest              791b6e40940c        2 weeks ago         465MB\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意：\n\n * docker tag 镜像ID，这里是 a733d5a264b5 ,用户名称、镜像源名(repository name)和新的标签名(tag)。\n * 使用 docker images 命令可以看到，ID为a733d5a264b5的镜像多一个v3.0.1标签。\n\n\n# 镜像导出和导入\n\n> 区别于容器的导出和导入\n\n * 镜像导出\n\n[root@pdai ~]# docker images\ndockREPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE\npdai/ubuntu                  v2.0.2              57544a04cd1a        3 months ago        91.5MB\n[root@pdai ~]# docker save > pdai-ubuntu-v2.0.2.tar 57544a04cd1a\n[root@pdai ~]# ll | grep pdai-u\n-rw-rw-r-- 1 root root 93898240 Jun  4 09:06 pdai-ubuntu-v2.0.2.tar\n[root@pdai ~]#\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 镜像导入\n\ndocker load < pdai-ubuntu-v2.0.2.tar\n\n\n1\n\n\n其中-i或者<表示从文件输入。会成功导入镜像及相关元数据，包括tag信息\n\n> 可以依据具体使用场景来选择命令\n\n * 若是只想备份images，使用save、load即可\n * 若是在启动容器后，容器内容有变化，需要备份，则使用export、import\n\n\n# Docker 容器\n\n> 上面已经展示了部分容器的使用命令了，这里会在此基础上进行拓展\n\n\n# 容器启动\n\n首先我们是可以这样启动容器的：\n\n[root@pdai docker-test]# docker run -it pdai/ubuntu:v2.0.1 /bin/bash\nroot@f5332ebce695:/# id pdai\nuid=1000(pdai) gid=1000(pdai) groups=1000(pdai)\nroot@f5332ebce695:/# exit\nexit\n\n\n1\n2\n3\n4\n5\n\n * -it 可以连写的，表示 -i -t\n * -t: 在新容器内指定一个伪终端或终端。\n * -i: 允许你对容器内的标准输入 (STDIN) 进行交互\n\n\n# 容器查看\n\n * -a 表示 all，所有的\n\n[root@pdai ~]# docker ps -a\nCONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS                      PORTS               NAMES\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"              20 minutes ago      Exited (0) 20 minutes ago                       jolly_kepler\n0a1556ca3c27        ubuntu:latest        "/bin/bash"              16 hours ago        Exited (0) 16 hours ago                         stoic_hodgkin\n1a51d2f023c9        ubuntu:latest        "/bin/sh -c \'while t…"   18 hours ago        Exited (137) 18 hours ago                       gifted_brown\n414bf796cbe4        ubuntu:latest        "/bin/bash"              18 hours ago        Exited (0) 18 hours ago                         pedantic_galileo\n512061ebfa4c        ubuntu:latest        "/bin/bash"              18 hours ago        Exited (0) 18 hours ago                         wizardly_brown\naa5e9ae5e5db        ubuntu:latest        "/bin/echo \'Hello wo…"   18 hours ago        Exited (0) 18 hours ago                         affectionate_knuth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 容器再启动\n\n> 我们看到，刚才pdai/ubuntu:v2.0.1的实例f5332ebce695已经停止了Exited (0) 20 minutes ago，我们能否再启这个实例？\n\n[root@pdai ~]# docker start f5332ebce695\nf5332ebce695\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"         32 minutes ago      Up 4 seconds        22/tcp, 80/tcp      jolly_kepler\n\n\n1\n2\n3\n4\n5\n\n\n\n# 容器停止和重启\n\n> 我们将上述容器停止，再重启\n\n[root@pdai ~]# docker stop f5332ebce695\nf5332ebce695\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n[root@pdai ~]# docker restart f5332ebce695\nf5332ebce695\n[root@pdai ~]# docker ps -a\nCONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS                      PORTS               NAMES\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"              33 minutes ago      Up 2 seconds                22/tcp, 80/tcp      jolly_kepler\n0a1556ca3c27        ubuntu:latest        "/bin/bash"              16 hours ago        Exited (0) 16 hours ago                         stoic_hodgkin\n1a51d2f023c9        ubuntu:latest        "/bin/sh -c \'while t…"   18 hours ago        Exited (137) 18 hours ago                       gifted_brown\n414bf796cbe4        ubuntu:latest        "/bin/bash"              18 hours ago        Exited (0) 18 hours ago                         pedantic_galileo\n512061ebfa4c        ubuntu:latest        "/bin/bash"              18 hours ago        Exited (0) 18 hours ago                         wizardly_brown\naa5e9ae5e5db        ubuntu:latest        "/bin/echo \'Hello wo…"   19 hours ago        Exited (0) 19 hours ago                         affectionate_knuth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 后台模式与进入\n\n> 在使用 -d 参数时，容器启动后会进入后台, 如何进入容器呢？\n\n * 第一种：docker attach\n\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"         38 minutes ago      Up 2 seconds        22/tcp, 80/tcp      jolly_kepler\n[root@pdai ~]# docker attach f5332ebce695\nroot@f5332ebce695:/# echo \'pdai\'\npdai\nroot@f5332ebce695:/# exit\nexit\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n看到没，使用docker attach进入后，exit便容器也停止了。\n\n * 第二种：docker exec\n\n[root@pdai ~]# docker exec -it f5332ebce695 /bin/bash\nError response from daemon: Container f5332ebce69520fba353f035ccddd4bd42055fbd1e595f916ba7233e26476464 is not running\n[root@pdai ~]# docker restart f5332ebce695\nf5332ebce695\n[root@pdai ~]# docker exec -it f5332ebce695 /bin/bash\nroot@f5332ebce695:/# exit\nexit\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"         42 minutes ago      Up 8 seconds        22/tcp, 80/tcp      jolly_kepler\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意：\n\n * 我特意在容器停止状态下执行了docker exec，是让你看到docker exec是在容器启动状态下用的，且注意下错误信息；\n * 推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。\n\n\n# 容器导出和导入\n\n> 在生产环境中，很多时候是无法连接外网的，所以有时候需要用到容器的导入和导出。\n\n * 容器的导出\n\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"         42 minutes ago      Up 8 seconds        22/tcp, 80/tcp      jolly_kepler\n[root@pdai ~]# docker export f5332ebce695 > ubuntu-pdai-v2.tar\n[root@pdai ~]# ll\n-rw-rw-r-- 1 root root 93891072 Feb 18 09:42 ubuntu-pdai-v2.tar\n\n\n1\n2\n3\n4\n5\n6\n\n\n同时你可以发现，导出容器的时候，容器无需关闭。\n\n * 容器导入\n\n[root@pdai ~]# docker import ubuntu-pdai-v2.tar pdai/ubuntu:v2.0.2\nsha256:57544a04cd1ad330371ca9142184ff031dc2b6df70df177994477c08fe547b25\n[root@pdai ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\npdai/ubuntu         v2.0.2              57544a04cd1a        7 seconds ago       91.5MB\npdai/ubuntu         v2.0.1              a733d5a264b5        About an hour ago   92.5MB\npdai/ubuntu         v3.0.1              a733d5a264b5        About an hour ago   92.5MB\npdai/ubuntu         v1.0.1              b51e9f5f98cd        16 hours ago        92.1MB\nmysql               latest              791b6e40940c        2 weeks ago         465MB\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意看，SIZE可能是不一样的。\n\n\n# 强制停止容器\n\n> 能否强制删除一个正在运行的容器呢？\n\n显然，加上-f之后是允许的。\n\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"         About an hour ago   Up 24 minutes       22/tcp, 80/tcp      jolly_kepler\n[root@pdai ~]# docker rm -f f5332ebce695\nf5332ebce695\n[root@pdai ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES\n0a1556ca3c27        ubuntu:latest       "/bin/bash"              17 hours ago        Exited (0) 17 hours ago                         stoic_hodgkin\n1a51d2f023c9        ubuntu:latest       "/bin/sh -c \'while t…"   19 hours ago        Exited (137) 19 hours ago                       gifted_brown\n414bf796cbe4        ubuntu:latest       "/bin/bash"              19 hours ago        Exited (0) 19 hours ago                         pedantic_galileo\n512061ebfa4c        ubuntu:latest       "/bin/bash"              19 hours ago        Exited (0) 19 hours ago                         wizardly_brown\naa5e9ae5e5db        ubuntu:latest       "/bin/echo \'Hello wo…"   19 hours ago        Exited (0) 19 hours ago                         affectionate_knuth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 清理停止的容器\n\n> 我们看到上面还有好几个容器出于停止状态，能不能删除它们呢？\n\n[root@pdai ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES\n0a1556ca3c27        ubuntu:latest       "/bin/bash"              17 hours ago        Exited (0) 17 hours ago                         stoic_hodgkin\n1a51d2f023c9        ubuntu:latest       "/bin/sh -c \'while t…"   19 hours ago        Exited (137) 19 hours ago                       gifted_brown\n414bf796cbe4        ubuntu:latest       "/bin/bash"              19 hours ago        Exited (0) 19 hours ago                         pedantic_galileo\n512061ebfa4c        ubuntu:latest       "/bin/bash"              19 hours ago        Exited (0) 19 hours ago                         wizardly_brown\naa5e9ae5e5db        ubuntu:latest       "/bin/echo \'Hello wo…"   19 hours ago        Exited (0) 19 hours ago                         affectionate_knuth\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n清理停止的容器: docker container prune\n\n[root@pdai ~]# docker container prune\nWARNING! This will remove all stopped containers.\nAre you sure you want to continue? [y/N] y\nDeleted Containers:\n0a1556ca3c275cc692ecd6d19caed4c5be42578f81b3dfea52b24208790d160a\n1a51d2f023c947f2be2d9a78eb863e854ca302c89bf354654c409e23e7dd25d7\n414bf796cbe403e01b5414f2b6232c6a037af78deee4581f4935c94859b5164e\n512061ebfa4c340eb03833e54d77052e33fb62cd42ab7dd7e09bf0b02a761552\naa5e9ae5e5db1760bdb8c7ddb92e4293cd7b4736be7e97314f3ef44a71bf8930\n\nTotal reclaimed space: 27.93MB\n[root@pdai ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 容器别名及操作\n\n> 我们上述对容器的操作都是针对容器ID，这个ID是随机的，能否添加一个name对我们自己设置的name操作呢？\n\n[root@pdai ~]# docker run -itd --name pdai-ubuntu-202 pdai/ubuntu:v2.0.2 /bin/bash\n11de9755a08402d963d263a559a7daf48f4a2188398f258641240b5eb50fbc89\n[root@pdai ~]# docker ps\nCONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES\n11de9755a084        pdai/ubuntu:v2.0.2   "/bin/bash"         5 seconds ago       Up 4 seconds                            pdai-ubuntu-202\n[root@pdai ~]# docker stop pdai-ubuntu-202\npdai-ubuntu-202\n[root@pdai ~]# docker ps -a\nCONTAINER ID        IMAGE                COMMAND              CREATED              STATUS                     PORTS               NAMES\n11de9755a084        pdai/ubuntu:v2.0.2   "/bin/bash"          26 seconds ago       Exited (0) 4 seconds ago                       pdai-ubuntu-202   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 容器错误日志\n\n例：实时查看docker容器名为user-uat的最后10行日志\ndocker logs -f -t --tail 10 user-uat\n\n例：查看指定时间后的日志，只显示最后100行：\ndocker logs -f -t --since="2018-02-08" --tail=100 user-uat\n\n例：查看最近30分钟的日志:\ndocker logs --since 30m user-uat\n\n例：查看某时间之后的日志：\ndocker logs -t --since="2018-02-08T13:23:37" user-uat\n\n例：查看某时间段日志：\ndocker logs -t --since="2018-02-08T13:23:37" --until "2018-02-09T12:23:37" user-uat\n\n例：将错误日志写入文件：\ndocker logs -f -t --since="2018-02-18" user-uat | grep error >> logs_error.txt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Docker 仓库\n\n仓库（Repository）是集中存放镜像的地方，它和我们的Maven仓库是一样的。以下介绍一下 Docker Hub。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。\n\n * 可以采用共有的仓库，也可以自己搭建Docker Registry;\n * 如果之前有自己的Artifactory或者Nexus，它们同样可以支持Docker Registry功能;\n * 带界面的也可以使用Harbor等;\n\n\n# 公有仓库\n\n> 我们以官方的docker hub为例，进行注册和理解。很多人会说官方的速度极慢或者私有仓库上传慢，不试试你怎么知道呢？\n\n * 注册官方docker hub，最新的名字叫docker cloud\n\nhttps://hub.docker.com/ (opens new window)\n\n我注册的用户名是 realpdai\n\n * 本地登录刚才注册的账户\n\n[root@pdai ~]# docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don\'t have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: realpdai\nPassword:\nWARNING! Your password will be stored unencrypted in /root/.docker/config.json.\nConfigure a credential helper to remove this warning. See\nhttps://docs.docker.com/engine/reference/commandline/login/#credentials-store\n\nLogin Succeeded\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 镜像准备\n\n[root@pdai ~]# docker tag pdai/ubuntu:v2.0.2 realpdai/ubuntu:v2.0.2\n[root@pdai ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\npdai/ubuntu         v2.0.2              57544a04cd1a        4 hours ago         91.5MB\nrealpdai/ubuntu     v2.0.2              57544a04cd1a        4 hours ago         91.5MB\npdai/ubuntu         v2.0.1              a733d5a264b5        5 hours ago         92.5MB\npdai/ubuntu         v3.0.1              a733d5a264b5        5 hours ago         92.5MB\npdai/ubuntu         v1.0.1              b51e9f5f98cd        21 hours ago        92.1MB\nmysql               latest              791b6e40940c        2 weeks ago         465MB\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 推送至Docker Hub服务器\n\n[root@pdai ~]# docker push realpdai/ubuntu:v2.0.2\nThe push refers to repository [docker.io/realpdai/ubuntu]\n9a2c43cbe02a: Pushed\nv2.0.2: digest: sha256:4afd82dd05d0b4a340ae4f4129dcbd63136b5ec7ff92edf313108a41fb0947e0 size: 528\n\n\n1\n2\n3\n4\n\n\n从推送的速度来看，大概是1.5MB/s。\n\n * 服务器端查看\n   \n   ',normalizedContent:'# docker基础 - 仓库，镜像，容器详解\n\n> 本文将从仓库，镜像，容器三个方面讲解常用的docker命令和使用等，对于开发而言这块使用的非常频繁，需要重点掌握。\n\n\n# 仓库，镜像，容器的关系\n\n> 仓库，镜像，容器的关系（这是官网的图）\n\n\n\n\n# docker 镜像\n\n当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 docker hub 公共镜像源下载。\n\n下面我们来学 1、管理和使用本地 docker 主机镜像 2、创建镜像\n\n\n# 镜像列表\n\n我们可以使用 docker images 来列出本地主机上的镜像\n\n[root@pdai ~]# docker images\nrepository          tag                 image id            created             size\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2mb\nhello-world         latest              fce289e99eb9        13 months ago       1.84kb\n\n\n1\n2\n3\n4\n\n\n著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/devops/docker/docker-03-basic2.html\n\n各个选项说明:\n\n * repository：表示镜像的仓库源\n * tag：镜像的标签, 同一仓库源可以有多个 tag，代表这个仓库源的不同个版本\n * image id：镜像id\n * created：镜像创建时间\n * size：镜像大小\n\n\n# 查找镜像\n\n> 以查找mysql的镜像为例：\n\n * 通过docker hub 进行查找, 比如https://hub.docker.com/search?q=mysql&type=image\n\n\n\n * 使用 docker search 命令来搜索镜像\n\n[root@pdai ~]# docker ps\ncontainer id        image               command             created             status              ports               names\n[root@pdai ~]# docker search mysql\nname                              description                                     stars               official            automated\nmysql                             mysql is a widely used, open-source relation…   9132                [ok]\nmariadb                           mariadb is a community-developed fork of mys…   3233                [ok]\nmysql/mysql-server                optimized mysql server docker images. create…   676                                     [ok]\ncentos/mysql-57-centos7           mysql 5.7 sql database server                   68\nmysql/mysql-cluster               experimental mysql cluster docker images. cr…   62\ncenturylink/mysql                 image containing mysql. optimized to be link…   61                                      [ok]\ndeitch/mysql-backup               replaced! please use http://hub.docker.com/r…   41                                      [ok]\nbitnami/mysql                     bitnami mysql docker image                      35                                      [ok]\ntutum/mysql                       base docker image to run a mysql database se…   34\nschickling/mysql-backup-s3        backup mysql to s3 (supports periodic backup…   29                                      [ok]\nprom/mysqld-exporter                                                              26                                      [ok]\nlinuxserver/mysql                 a mysql container, brought to you by linuxse…   24\ncentos/mysql-56-centos7           mysql 5.6 sql database server                   19\ncircleci/mysql                    mysql is a widely used, open-source relation…   18\nmysql/mysql-router                mysql router provides transparent routing be…   14\narey/mysql-client                 run a mysql client from a docker container      13                                      [ok]\ndataback/mysql-backup             back up mysql databases to... anywhere!         10\nopenshift/mysql-55-centos7        deprecated: a centos7 based mysql v5.5 image…   6\nfradelg/mysql-cron-backup         mysql/mariadb database backup using cron tas…   5                                       [ok]\ngenschsa/mysql-employees          mysql employee sample database                  4                                       [ok]\ndevilbox/mysql                    retagged mysql, mariadb and perconadb offici…   2\nansibleplaybookbundle/mysql-apb   an apb which deploys rhscl mysql                2                                       [ok]\njelastic/mysql                    an image of the mysql database server mainta…   1\nmonasca/mysql-init                a minimal decoupled init container for mysql    0\nwiddpim/mysql-client              dockerized mysql client (5.7) including curl…   0                                       [ok]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n * name: 镜像仓库源的名称\n * description: 镜像的描述\n * official: 是否 docker 官方发布\n * stars: 类似 github 里面的 star，表示点赞、喜欢的意思。\n * automated: 自动构建。\n\n\n# 拉取镜像\n\n> 现在拉取搜索出的mysql\n\n[root@pdai ~]# docker pull mysql\nusing default tag: latest\nlatest: pulling from library/mysql\n619014d83c02: pull complete\n9ced578c3a5f: pull complete\n731f6e13d8ea: pull complete\n3c183de42679: pull complete\n6de69b5c2f3c: pull complete\n00f0a4086406: pull complete\n84d93aea836d: pull complete\nf18efbfd8d76: pull complete\n012b302865d1: pull complete\nfe16fd240f59: pull complete\nca3e793e545e: pull complete\n51d0f2cb2610: pull complete\ndigest: sha256:6d0741319b6a2ae22c384a97f4bbee411b01e75f6284af0cce339fee83d7e314\nstatus: downloaded newer image for mysql:latest\ndocker.io/library/mysql:latest\n[root@pdai ~]# docker images\nrepository          tag                 image id            created             size\nmysql               latest              791b6e40940c        2 weeks ago         465mb\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2mb\nhello-world         latest              fce289e99eb9        13 months ago       1.84kb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 删除镜像\n\n> 是时候删除那个无聊的hello-world镜像了\n\n[root@pdai ~]# docker rmi hello-world\nerror response from daemon: conflict: unable to remove repository reference "hello-world" (must force) - container c91b90b18884 is using its referenced image fce289e99eb9\n[root@pdai ~]# docker ps\ncontainer id        image               command             created             status              ports               names\n\n\n1\n2\n3\n4\n\n\n发现报错了，这时候主要看两点：要么就是container实例存在，要么存在镜像依赖；\n\n[root@pdai ~]# docker ps -a\ncontainer id        image               command                  created             status                     ports               names\n1a51d2f023c9        ubuntu:latest       "/bin/sh -c \'while t…"   2 hours ago         exited (137) 2 hours ago                       gifted_brown\n414bf796cbe4        ubuntu:latest       "/bin/bash"              2 hours ago         exited (0) 2 hours ago                         pedantic_galileo\n512061ebfa4c        ubuntu:latest       "/bin/bash"              2 hours ago         exited (0) 2 hours ago                         wizardly_brown\naa5e9ae5e5db        ubuntu:latest       "/bin/echo \'hello wo…"   2 hours ago         exited (0) 2 hours ago                         affectionate_knuth\nc91b90b18884        hello-world         "/hello"                 3 hours ago         exited (0) 3 hours ago                         admiring_pare\n[root@pdai ~]# docker image inspect --format=\'{{.repotags}} {{.id}} {{.parent}}\' $(docker image ls -q )\n[mysql:latest] sha256:791b6e40940cd550af522eb4ffe995226798204504fe495743445b900e417a51\n[ubuntu:latest] sha256:ccc6e87d482b79dd1645affd958479139486e47191dfe7a997c862d89cd8b4c0\n[hello-world:latest] sha256:fce289e99eb9bca977dae136fbe2a82b6b7d4c372474c9235adc1741675f587e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n显然，我们只要删除container即可：\n\n[root@pdai ~]# docker rm c91b90b18884\nc91b90b18884\n[root@pdai ~]# docker ps -a\ncontainer id        image               command                  created             status                     ports               names\n1a51d2f023c9        ubuntu:latest       "/bin/sh -c \'while t…"   2 hours ago         exited (137) 2 hours ago                       gifted_brown\n414bf796cbe4        ubuntu:latest       "/bin/bash"              2 hours ago         exited (0) 2 hours ago                         pedantic_galileo\n512061ebfa4c        ubuntu:latest       "/bin/bash"              2 hours ago         exited (0) 2 hours ago                         wizardly_brown\naa5e9ae5e5db        ubuntu:latest       "/bin/echo \'hello wo…"   2 hours ago         exited (0) 2 hours ago                         affectionate_knuth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n最后再来删除镜像吧\n\n[root@pdai ~]# docker rmi hello-world\nuntagged: hello-world:latest\nuntagged: hello-world@sha256:9572f7cdcee8591948c2963463447a53466950b3fc15a247fcad1917ca215a2f\ndeleted: sha256:fce289e99eb9bca977dae136fbe2a82b6b7d4c372474c9235adc1741675f587e\ndeleted: sha256:af0b15c8625bb1938f1d7b17081031f649fd14e6b233688eea3c5483994a66a3\n\n\n1\n2\n3\n4\n5\n\n\n\n# 更新镜像\n\n> 针对上述ubuntu的镜像，我们能否在里面安装一些软件，然后重新生成一个镜像呢？这就是更新重新commit出一个新的镜像。\n\n我们先跑一个ubuntu容器实例，同时在里面进行apt-get update更新\n\n[root@pdai ~]# docker run -it ubuntu:latest\nroot@0a1556ca3c27:/# apt-get update\nget:1 http://security.ubuntu.com/ubuntu bionic-security inrelease [88.7 kb]\nget:2 http://archive.ubuntu.com/ubuntu bionic inrelease [242 kb]\nget:3 http://archive.ubuntu.com/ubuntu bionic-updates inrelease [88.7 kb]\nget:4 http://archive.ubuntu.com/ubuntu bionic-backports inrelease [74.6 kb]\nget:5 http://security.ubuntu.com/ubuntu bionic-security/main amd64 packages [817 kb]\nget:6 http://archive.ubuntu.com/ubuntu bionic/main amd64 packages [1344 kb]\nget:7 http://archive.ubuntu.com/ubuntu bionic/multiverse amd64 packages [186 kb]\nget:8 http://archive.ubuntu.com/ubuntu bionic/restricted amd64 packages [13.5 kb]\nget:9 http://archive.ubuntu.com/ubuntu bionic/universe amd64 packages [11.3 mb]\nget:10 http://security.ubuntu.com/ubuntu bionic-security/restricted amd64 packages [27.5 kb]\nget:11 http://security.ubuntu.com/ubuntu bionic-security/multiverse amd64 packages [7064 b]\nget:12 http://security.ubuntu.com/ubuntu bionic-security/universe amd64 packages [818 kb]\nget:13 http://archive.ubuntu.com/ubuntu bionic-updates/multiverse amd64 packages [11.1 kb]\nget:14 http://archive.ubuntu.com/ubuntu bionic-updates/universe amd64 packages [1345 kb]\nget:15 http://archive.ubuntu.com/ubuntu bionic-updates/restricted amd64 packages [41.2 kb]\nget:16 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 packages [1104 kb]\nget:17 http://archive.ubuntu.com/ubuntu bionic-backports/universe amd64 packages [4252 b]\nget:18 http://archive.ubuntu.com/ubuntu bionic-backports/main amd64 packages [2496 b]\nfetched 17.6 mb in 10s (1759 kb/s)\nreading package lists... done\nroot@0a1556ca3c27:/# exit\nexit\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n此时 id 为 0a1556ca3c27 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本：\n\n[root@pdai ~]# docker commit -m="update test" -a="pdai" 0a1556ca3c27  pdai/ubuntu:v1.0.1\nsha256:b51e9f5f98cdb5b95c34181148ed7029f0150618aa8cd0e916b10b6aea1bd4c9\n\n\n1\n2\n\n\n可以看到已经生成成功, 且镜像的大小不一样了：\n\n[root@pdai ~]# docker images\nrepository          tag                 image id            created             size\npdai/ubuntu         v1.0.1              b51e9f5f98cd        5 seconds ago       92.1mb\nmysql               latest              791b6e40940c        2 weeks ago         465mb\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2mb\n\n\n1\n2\n3\n4\n5\n\n\n著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/devops/docker/docker-03-basic2.html\n\n\n# 生成镜像\n\n> 那如果是生成一个全新的镜像呢？我们使用命令 docker build ，通过创建一个 dockerfile 文件，其中包含一组指令来告诉 docker 如何构建我们的镜像。\n\n这里特意指定的base镜像为上一步修改生成的pdai/ubuntu:v1.0.1\n\nfrom    pdai/ubuntu:v1.0.1\nmaintainer      pdai "www.pdai.tech"\n\nrun     /bin/echo \'root:123456\' |chpasswd\nrun     useradd pdai\nrun     /bin/echo \'pdai:123456\' |chpasswd\nrun     /bin/echo -e "lang=\\"en_us.utf-8\\"" >/etc/default/local\nexpose  22\nexpose  80\ncmd     /usr/sbin/sshd -d\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n稍微解释下：这一部分在开发中会用到比较多，所以单独一个章节详解：docker基础 - dockerfile详解\n\n * 每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。\n * 第一条from，指定使用哪个镜像源\n * run 指令告诉docker 在镜像内执行命令，安装了什么。。。\n * 我们使用 dockerfile 文件，通过 docker build 命令来构建一个镜像。\n\n接下来生成镜像：\n\n[root@pdai docker-test]# docker build -t pdai/ubuntu:v2.0.1 .\nsending build context to docker daemon  2.048kb\nstep 1/9 : from    pdai/ubuntu:v1.0.1\n ---\x3e b51e9f5f98cd\nstep 2/9 : maintainer      pdai "www.pdai.tech"\n ---\x3e running in af026ee229ea\nremoving intermediate container af026ee229ea\n ---\x3e 0e961cb557c9\nstep 3/9 : run     /bin/echo \'root:123456\' |chpasswd\n ---\x3e running in 96bd9c40c55e\nremoving intermediate container 96bd9c40c55e\n ---\x3e 9e8549720043\nstep 4/9 : run     useradd pdai\n ---\x3e running in 0117278f243c\nremoving intermediate container 0117278f243c\n ---\x3e 87c478df56da\nstep 5/9 : run     /bin/echo \'pdai:123456\' |chpasswd\n ---\x3e running in e0381eabe71a\nremoving intermediate container e0381eabe71a\n ---\x3e 84fd07f978ae\nstep 6/9 : run     /bin/echo -e "lang=\\"en_us.utf-8\\"" >/etc/default/local\n ---\x3e running in 8d0052d9921f\nremoving intermediate container 8d0052d9921f\n ---\x3e 3ed0b248224c\nstep 7/9 : expose  22\n ---\x3e running in 4b5d540567cd\nremoving intermediate container 4b5d540567cd\n ---\x3e c0a72ad140dd\nstep 8/9 : expose  80\n ---\x3e running in c9620707d038\nremoving intermediate container c9620707d038\n ---\x3e df42b714ecc1\nstep 9/9 : cmd     /usr/sbin/sshd -d\n ---\x3e running in e178826b43fe\nremoving intermediate container e178826b43fe\n ---\x3e a733d5a264b5\nsuccessfully built a733d5a264b5\nsuccessfully tagged pdai/ubuntu:v2.0.1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n参数说明：\n\n * -t ：指定要创建的目标镜像名\n * . ：dockerfile 文件所在目录，可以指定dockerfile 的绝对路径\n\n使用docker images 查看创建的镜像已经在列表中存在,镜像id为a733d5a264b5\n\n[root@pdai docker-test]# docker images\nrepository          tag                 image id            created             size\npdai/ubuntu         v2.0.1              a733d5a264b5        5 minutes ago       92.5mb\npdai/ubuntu         v1.0.1              b51e9f5f98cd        15 hours ago        92.1mb\nmysql               latest              791b6e40940c        2 weeks ago         465mb\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2mb\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们可以使用新的镜像来创建容器\n\n[root@pdai docker-test]# docker run -it pdai/ubuntu:v2.0.1 /bin/bash\nroot@f5332ebce695:/# id pdai\nuid=1000(pdai) gid=1000(pdai) groups=1000(pdai)\nroot@f5332ebce695:/# exit\nexit\n\n\n1\n2\n3\n4\n5\n\n\n从上面看到新镜像已经包含我们创建的用户 pdai。\n\n\n# 镜像标签\n\n> 设置镜像的tag，类似于git中tag？我们可以使用 docker tag 命令，为镜像添加一个新的标签\n\n[root@pdai ~]# docker tag a733d5a264b5 pdai/ubuntu:v3.0.1\n[root@pdai ~]# docker images\nrepository          tag                 image id            created             size\npdai/ubuntu         v2.0.1              a733d5a264b5        9 minutes ago       92.5mb\npdai/ubuntu         v3.0.1              a733d5a264b5        9 minutes ago       92.5mb\npdai/ubuntu         v1.0.1              b51e9f5f98cd        15 hours ago        92.1mb\nmysql               latest              791b6e40940c        2 weeks ago         465mb\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2mb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意：\n\n * docker tag 镜像id，这里是 a733d5a264b5 ,用户名称、镜像源名(repository name)和新的标签名(tag)。\n * 使用 docker images 命令可以看到，id为a733d5a264b5的镜像多一个v3.0.1标签。\n\n\n# 镜像导出和导入\n\n> 区别于容器的导出和导入\n\n * 镜像导出\n\n[root@pdai ~]# docker images\ndockrepository                   tag                 image id            created             size\npdai/ubuntu                  v2.0.2              57544a04cd1a        3 months ago        91.5mb\n[root@pdai ~]# docker save > pdai-ubuntu-v2.0.2.tar 57544a04cd1a\n[root@pdai ~]# ll | grep pdai-u\n-rw-rw-r-- 1 root root 93898240 jun  4 09:06 pdai-ubuntu-v2.0.2.tar\n[root@pdai ~]#\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 镜像导入\n\ndocker load < pdai-ubuntu-v2.0.2.tar\n\n\n1\n\n\n其中-i或者<表示从文件输入。会成功导入镜像及相关元数据，包括tag信息\n\n> 可以依据具体使用场景来选择命令\n\n * 若是只想备份images，使用save、load即可\n * 若是在启动容器后，容器内容有变化，需要备份，则使用export、import\n\n\n# docker 容器\n\n> 上面已经展示了部分容器的使用命令了，这里会在此基础上进行拓展\n\n\n# 容器启动\n\n首先我们是可以这样启动容器的：\n\n[root@pdai docker-test]# docker run -it pdai/ubuntu:v2.0.1 /bin/bash\nroot@f5332ebce695:/# id pdai\nuid=1000(pdai) gid=1000(pdai) groups=1000(pdai)\nroot@f5332ebce695:/# exit\nexit\n\n\n1\n2\n3\n4\n5\n\n * -it 可以连写的，表示 -i -t\n * -t: 在新容器内指定一个伪终端或终端。\n * -i: 允许你对容器内的标准输入 (stdin) 进行交互\n\n\n# 容器查看\n\n * -a 表示 all，所有的\n\n[root@pdai ~]# docker ps -a\ncontainer id        image                command                  created             status                      ports               names\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"              20 minutes ago      exited (0) 20 minutes ago                       jolly_kepler\n0a1556ca3c27        ubuntu:latest        "/bin/bash"              16 hours ago        exited (0) 16 hours ago                         stoic_hodgkin\n1a51d2f023c9        ubuntu:latest        "/bin/sh -c \'while t…"   18 hours ago        exited (137) 18 hours ago                       gifted_brown\n414bf796cbe4        ubuntu:latest        "/bin/bash"              18 hours ago        exited (0) 18 hours ago                         pedantic_galileo\n512061ebfa4c        ubuntu:latest        "/bin/bash"              18 hours ago        exited (0) 18 hours ago                         wizardly_brown\naa5e9ae5e5db        ubuntu:latest        "/bin/echo \'hello wo…"   18 hours ago        exited (0) 18 hours ago                         affectionate_knuth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 容器再启动\n\n> 我们看到，刚才pdai/ubuntu:v2.0.1的实例f5332ebce695已经停止了exited (0) 20 minutes ago，我们能否再启这个实例？\n\n[root@pdai ~]# docker start f5332ebce695\nf5332ebce695\n[root@pdai ~]# docker ps\ncontainer id        image                command             created             status              ports               names\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"         32 minutes ago      up 4 seconds        22/tcp, 80/tcp      jolly_kepler\n\n\n1\n2\n3\n4\n5\n\n\n\n# 容器停止和重启\n\n> 我们将上述容器停止，再重启\n\n[root@pdai ~]# docker stop f5332ebce695\nf5332ebce695\n[root@pdai ~]# docker ps\ncontainer id        image               command             created             status              ports               names\n[root@pdai ~]# docker restart f5332ebce695\nf5332ebce695\n[root@pdai ~]# docker ps -a\ncontainer id        image                command                  created             status                      ports               names\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"              33 minutes ago      up 2 seconds                22/tcp, 80/tcp      jolly_kepler\n0a1556ca3c27        ubuntu:latest        "/bin/bash"              16 hours ago        exited (0) 16 hours ago                         stoic_hodgkin\n1a51d2f023c9        ubuntu:latest        "/bin/sh -c \'while t…"   18 hours ago        exited (137) 18 hours ago                       gifted_brown\n414bf796cbe4        ubuntu:latest        "/bin/bash"              18 hours ago        exited (0) 18 hours ago                         pedantic_galileo\n512061ebfa4c        ubuntu:latest        "/bin/bash"              18 hours ago        exited (0) 18 hours ago                         wizardly_brown\naa5e9ae5e5db        ubuntu:latest        "/bin/echo \'hello wo…"   19 hours ago        exited (0) 19 hours ago                         affectionate_knuth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 后台模式与进入\n\n> 在使用 -d 参数时，容器启动后会进入后台, 如何进入容器呢？\n\n * 第一种：docker attach\n\n[root@pdai ~]# docker ps\ncontainer id        image                command             created             status              ports               names\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"         38 minutes ago      up 2 seconds        22/tcp, 80/tcp      jolly_kepler\n[root@pdai ~]# docker attach f5332ebce695\nroot@f5332ebce695:/# echo \'pdai\'\npdai\nroot@f5332ebce695:/# exit\nexit\n[root@pdai ~]# docker ps\ncontainer id        image               command             created             status              ports               names\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n看到没，使用docker attach进入后，exit便容器也停止了。\n\n * 第二种：docker exec\n\n[root@pdai ~]# docker exec -it f5332ebce695 /bin/bash\nerror response from daemon: container f5332ebce69520fba353f035ccddd4bd42055fbd1e595f916ba7233e26476464 is not running\n[root@pdai ~]# docker restart f5332ebce695\nf5332ebce695\n[root@pdai ~]# docker exec -it f5332ebce695 /bin/bash\nroot@f5332ebce695:/# exit\nexit\n[root@pdai ~]# docker ps\ncontainer id        image                command             created             status              ports               names\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"         42 minutes ago      up 8 seconds        22/tcp, 80/tcp      jolly_kepler\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意：\n\n * 我特意在容器停止状态下执行了docker exec，是让你看到docker exec是在容器启动状态下用的，且注意下错误信息；\n * 推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。\n\n\n# 容器导出和导入\n\n> 在生产环境中，很多时候是无法连接外网的，所以有时候需要用到容器的导入和导出。\n\n * 容器的导出\n\n[root@pdai ~]# docker ps\ncontainer id        image                command             created             status              ports               names\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"         42 minutes ago      up 8 seconds        22/tcp, 80/tcp      jolly_kepler\n[root@pdai ~]# docker export f5332ebce695 > ubuntu-pdai-v2.tar\n[root@pdai ~]# ll\n-rw-rw-r-- 1 root root 93891072 feb 18 09:42 ubuntu-pdai-v2.tar\n\n\n1\n2\n3\n4\n5\n6\n\n\n同时你可以发现，导出容器的时候，容器无需关闭。\n\n * 容器导入\n\n[root@pdai ~]# docker import ubuntu-pdai-v2.tar pdai/ubuntu:v2.0.2\nsha256:57544a04cd1ad330371ca9142184ff031dc2b6df70df177994477c08fe547b25\n[root@pdai ~]# docker images\nrepository          tag                 image id            created             size\npdai/ubuntu         v2.0.2              57544a04cd1a        7 seconds ago       91.5mb\npdai/ubuntu         v2.0.1              a733d5a264b5        about an hour ago   92.5mb\npdai/ubuntu         v3.0.1              a733d5a264b5        about an hour ago   92.5mb\npdai/ubuntu         v1.0.1              b51e9f5f98cd        16 hours ago        92.1mb\nmysql               latest              791b6e40940c        2 weeks ago         465mb\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2mb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意看，size可能是不一样的。\n\n\n# 强制停止容器\n\n> 能否强制删除一个正在运行的容器呢？\n\n显然，加上-f之后是允许的。\n\n[root@pdai ~]# docker ps\ncontainer id        image                command             created             status              ports               names\nf5332ebce695        pdai/ubuntu:v2.0.1   "/bin/bash"         about an hour ago   up 24 minutes       22/tcp, 80/tcp      jolly_kepler\n[root@pdai ~]# docker rm -f f5332ebce695\nf5332ebce695\n[root@pdai ~]# docker ps -a\ncontainer id        image               command                  created             status                      ports               names\n0a1556ca3c27        ubuntu:latest       "/bin/bash"              17 hours ago        exited (0) 17 hours ago                         stoic_hodgkin\n1a51d2f023c9        ubuntu:latest       "/bin/sh -c \'while t…"   19 hours ago        exited (137) 19 hours ago                       gifted_brown\n414bf796cbe4        ubuntu:latest       "/bin/bash"              19 hours ago        exited (0) 19 hours ago                         pedantic_galileo\n512061ebfa4c        ubuntu:latest       "/bin/bash"              19 hours ago        exited (0) 19 hours ago                         wizardly_brown\naa5e9ae5e5db        ubuntu:latest       "/bin/echo \'hello wo…"   19 hours ago        exited (0) 19 hours ago                         affectionate_knuth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 清理停止的容器\n\n> 我们看到上面还有好几个容器出于停止状态，能不能删除它们呢？\n\n[root@pdai ~]# docker ps -a\ncontainer id        image               command                  created             status                      ports               names\n0a1556ca3c27        ubuntu:latest       "/bin/bash"              17 hours ago        exited (0) 17 hours ago                         stoic_hodgkin\n1a51d2f023c9        ubuntu:latest       "/bin/sh -c \'while t…"   19 hours ago        exited (137) 19 hours ago                       gifted_brown\n414bf796cbe4        ubuntu:latest       "/bin/bash"              19 hours ago        exited (0) 19 hours ago                         pedantic_galileo\n512061ebfa4c        ubuntu:latest       "/bin/bash"              19 hours ago        exited (0) 19 hours ago                         wizardly_brown\naa5e9ae5e5db        ubuntu:latest       "/bin/echo \'hello wo…"   19 hours ago        exited (0) 19 hours ago                         affectionate_knuth\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n清理停止的容器: docker container prune\n\n[root@pdai ~]# docker container prune\nwarning! this will remove all stopped containers.\nare you sure you want to continue? [y/n] y\ndeleted containers:\n0a1556ca3c275cc692ecd6d19caed4c5be42578f81b3dfea52b24208790d160a\n1a51d2f023c947f2be2d9a78eb863e854ca302c89bf354654c409e23e7dd25d7\n414bf796cbe403e01b5414f2b6232c6a037af78deee4581f4935c94859b5164e\n512061ebfa4c340eb03833e54d77052e33fb62cd42ab7dd7e09bf0b02a761552\naa5e9ae5e5db1760bdb8c7ddb92e4293cd7b4736be7e97314f3ef44a71bf8930\n\ntotal reclaimed space: 27.93mb\n[root@pdai ~]# docker ps -a\ncontainer id        image               command             created             status              ports               names\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 容器别名及操作\n\n> 我们上述对容器的操作都是针对容器id，这个id是随机的，能否添加一个name对我们自己设置的name操作呢？\n\n[root@pdai ~]# docker run -itd --name pdai-ubuntu-202 pdai/ubuntu:v2.0.2 /bin/bash\n11de9755a08402d963d263a559a7daf48f4a2188398f258641240b5eb50fbc89\n[root@pdai ~]# docker ps\ncontainer id        image                command             created             status              ports               names\n11de9755a084        pdai/ubuntu:v2.0.2   "/bin/bash"         5 seconds ago       up 4 seconds                            pdai-ubuntu-202\n[root@pdai ~]# docker stop pdai-ubuntu-202\npdai-ubuntu-202\n[root@pdai ~]# docker ps -a\ncontainer id        image                command              created              status                     ports               names\n11de9755a084        pdai/ubuntu:v2.0.2   "/bin/bash"          26 seconds ago       exited (0) 4 seconds ago                       pdai-ubuntu-202   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 容器错误日志\n\n例：实时查看docker容器名为user-uat的最后10行日志\ndocker logs -f -t --tail 10 user-uat\n\n例：查看指定时间后的日志，只显示最后100行：\ndocker logs -f -t --since="2018-02-08" --tail=100 user-uat\n\n例：查看最近30分钟的日志:\ndocker logs --since 30m user-uat\n\n例：查看某时间之后的日志：\ndocker logs -t --since="2018-02-08t13:23:37" user-uat\n\n例：查看某时间段日志：\ndocker logs -t --since="2018-02-08t13:23:37" --until "2018-02-09t12:23:37" user-uat\n\n例：将错误日志写入文件：\ndocker logs -f -t --since="2018-02-18" user-uat | grep error >> logs_error.txt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# docker 仓库\n\n仓库（repository）是集中存放镜像的地方，它和我们的maven仓库是一样的。以下介绍一下 docker hub。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。\n\n * 可以采用共有的仓库，也可以自己搭建docker registry;\n * 如果之前有自己的artifactory或者nexus，它们同样可以支持docker registry功能;\n * 带界面的也可以使用harbor等;\n\n\n# 公有仓库\n\n> 我们以官方的docker hub为例，进行注册和理解。很多人会说官方的速度极慢或者私有仓库上传慢，不试试你怎么知道呢？\n\n * 注册官方docker hub，最新的名字叫docker cloud\n\nhttps://hub.docker.com/ (opens new window)\n\n我注册的用户名是 realpdai\n\n * 本地登录刚才注册的账户\n\n[root@pdai ~]# docker login\nlogin with your docker id to push and pull images from docker hub. if you don\'t have a docker id, head over to https://hub.docker.com to create one.\nusername: realpdai\npassword:\nwarning! your password will be stored unencrypted in /root/.docker/config.json.\nconfigure a credential helper to remove this warning. see\nhttps://docs.docker.com/engine/reference/commandline/login/#credentials-store\n\nlogin succeeded\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 镜像准备\n\n[root@pdai ~]# docker tag pdai/ubuntu:v2.0.2 realpdai/ubuntu:v2.0.2\n[root@pdai ~]# docker images\nrepository          tag                 image id            created             size\npdai/ubuntu         v2.0.2              57544a04cd1a        4 hours ago         91.5mb\nrealpdai/ubuntu     v2.0.2              57544a04cd1a        4 hours ago         91.5mb\npdai/ubuntu         v2.0.1              a733d5a264b5        5 hours ago         92.5mb\npdai/ubuntu         v3.0.1              a733d5a264b5        5 hours ago         92.5mb\npdai/ubuntu         v1.0.1              b51e9f5f98cd        21 hours ago        92.1mb\nmysql               latest              791b6e40940c        2 weeks ago         465mb\nubuntu              latest              ccc6e87d482b        4 weeks ago         64.2mb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 推送至docker hub服务器\n\n[root@pdai ~]# docker push realpdai/ubuntu:v2.0.2\nthe push refers to repository [docker.io/realpdai/ubuntu]\n9a2c43cbe02a: pushed\nv2.0.2: digest: sha256:4afd82dd05d0b4a340ae4f4129dcbd63136b5ec7ff92edf313108a41fb0947e0 size: 528\n\n\n1\n2\n3\n4\n\n\n从推送的速度来看，大概是1.5mb/s。\n\n * 服务器端查看\n   \n   ',charsets:{cjk:!0}},{title:"docker搭建halo博客",frontmatter:{title:"docker搭建halo博客",date:"2021-07-09T14:55:29.000Z",permalink:"/pages/9fef0c/",categories:["技术","环境搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/00.docker%E6%90%AD%E5%BB%BAhalo%E5%8D%9A%E5%AE%A2.html",relativePath:"03.技术/07.环境搭建/00.docker搭建halo博客.md",key:"v-dce71a6e",path:"/pages/9fef0c/",headers:[{level:2,title:"一.使用mysql搭建",slug:"一-使用mysql搭建",normalizedTitle:"一.使用mysql搭建",charIndex:89},{level:2,title:"二.使用自带的H2Database搭建",slug:"二-使用自带的h2database搭建",normalizedTitle:"二.使用自带的h2database搭建",charIndex:1441}],headersStr:"一.使用mysql搭建 二.使用自带的H2Database搭建",content:"# docker搭建halo博客\n\n参考：https://blog.csdn.net/weixin_43909881/article/details/105186317\n\n\n# 一.使用mysql搭建\n\n1.下载文件到本地的linux环境\n\n# 下载配置文件到 /data/halo 目录\ncurl -o /data/halo/application.yaml --create-dirs https://dl.halo.run/config/application-template.yaml\n\n\n1\n2\n\n\n2.修改配置文件（可以不修改)\n\nvi /data/halo/application.yaml\n\n\n1\n\n\n3.下载下来的配置文件默认是使用H2 Database的，把它改成自己实际使用的，我用的是mysql，配置文件换成mysql，然后修改数据库url和用户名密码，其他的注释掉，端口用默认的8090，可根据自己需要修改，改完如下\n\nserver:\n  port: 8090\nspring:\n  datasource:\n    type: com.zaxxer.hikari.HikariDataSource\n    # H2 Database 配置，如果你需要使用 MySQL，请注释掉该配置并取消注释 MySQL 的配置。\n    #driver-class-name: org.h2.Driver\n    #url: jdbc:h2:file:~/.halo/db/halo\n    #username: admin\n    #password: 123456\n\n    # MySQL 配置，如果你需要使用 H2Database，请注释掉该配置并取消注释上方 H2Database 的配置。\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://xx.xx.xx.xx:3306/halodb?characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true\n    username: root\n    password: root\n    \n  # H2 Database 的控制台相关配置，如果你使用的是 MySQL ，请注释掉下方内容。\n#  h2:\n#    console:\n#      settings:\n#        web-allow-others: false\n#      path: /h2-console\n#      enabled: false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n4.下载docker镜像\n\nsudo docker pull ruibaby/halo\n\n\n1\n\n\n5.运行镜像\n\ndocker run --rm -it -d --name halo -p 8090:8090  --privileged=true -v /data/halo:/root/.halo ruibaby/halo\n\n\n1\n\n\n--rm：系统崩了会自动删除容器\n\n--privileged=true：给挂载文件权限\n\n\n# 二.使用自带的H2Database搭建\n\n经过测试，以及看官方文档，发现不修改配置文件才是最优解，即不使用自建mysql，而是使用内嵌的H2数据库，理由如下：\n\n * halo可实现数据备份，但自建mysql未来更换服务器，数据备份会比较麻烦，H2备份的话直接导入就可以了，mysql的话需要导出数据表，同时还得备份数据\n\n * 用内嵌的H2数据库的话，可以选择整站备份，然后在新服务器把导出的压缩文件解压，docker启动的时候挂载上备份的文件夹，启动后就跟原来的博客博客一模一样了，如下图\n   \n   \n\n * 由于我的mysql跑在docker中，占用内存较大（400m+…学生机…心疼），而且不太稳定，而H2对halo来说几乎没多大的内存开销（200m+），还不需要再跑个mysql他不香吗~\n\n# 下载配置文件到 /data/halo 目录\ncurl -o /data/halo/application.yaml --create-dirs https://dl.halo.run/config/application-template.yaml\nsudo docker pull ruibaby/halo\ndocker run --rm -it -d --name halo -p 8090:8090  --privileged=true -v /data/halo:/root/.halo ruibaby/halo\n\n\n1\n2\n3\n4\n",normalizedContent:"# docker搭建halo博客\n\n参考：https://blog.csdn.net/weixin_43909881/article/details/105186317\n\n\n# 一.使用mysql搭建\n\n1.下载文件到本地的linux环境\n\n# 下载配置文件到 /data/halo 目录\ncurl -o /data/halo/application.yaml --create-dirs https://dl.halo.run/config/application-template.yaml\n\n\n1\n2\n\n\n2.修改配置文件（可以不修改)\n\nvi /data/halo/application.yaml\n\n\n1\n\n\n3.下载下来的配置文件默认是使用h2 database的，把它改成自己实际使用的，我用的是mysql，配置文件换成mysql，然后修改数据库url和用户名密码，其他的注释掉，端口用默认的8090，可根据自己需要修改，改完如下\n\nserver:\n  port: 8090\nspring:\n  datasource:\n    type: com.zaxxer.hikari.hikaridatasource\n    # h2 database 配置，如果你需要使用 mysql，请注释掉该配置并取消注释 mysql 的配置。\n    #driver-class-name: org.h2.driver\n    #url: jdbc:h2:file:~/.halo/db/halo\n    #username: admin\n    #password: 123456\n\n    # mysql 配置，如果你需要使用 h2database，请注释掉该配置并取消注释上方 h2database 的配置。\n    driver-class-name: com.mysql.cj.jdbc.driver\n    url: jdbc:mysql://xx.xx.xx.xx:3306/halodb?characterencoding=utf8&usessl=false&servertimezone=asia/shanghai&allowpublickeyretrieval=true\n    username: root\n    password: root\n    \n  # h2 database 的控制台相关配置，如果你使用的是 mysql ，请注释掉下方内容。\n#  h2:\n#    console:\n#      settings:\n#        web-allow-others: false\n#      path: /h2-console\n#      enabled: false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n4.下载docker镜像\n\nsudo docker pull ruibaby/halo\n\n\n1\n\n\n5.运行镜像\n\ndocker run --rm -it -d --name halo -p 8090:8090  --privileged=true -v /data/halo:/root/.halo ruibaby/halo\n\n\n1\n\n\n--rm：系统崩了会自动删除容器\n\n--privileged=true：给挂载文件权限\n\n\n# 二.使用自带的h2database搭建\n\n经过测试，以及看官方文档，发现不修改配置文件才是最优解，即不使用自建mysql，而是使用内嵌的h2数据库，理由如下：\n\n * halo可实现数据备份，但自建mysql未来更换服务器，数据备份会比较麻烦，h2备份的话直接导入就可以了，mysql的话需要导出数据表，同时还得备份数据\n\n * 用内嵌的h2数据库的话，可以选择整站备份，然后在新服务器把导出的压缩文件解压，docker启动的时候挂载上备份的文件夹，启动后就跟原来的博客博客一模一样了，如下图\n   \n   \n\n * 由于我的mysql跑在docker中，占用内存较大（400m+…学生机…心疼），而且不太稳定，而h2对halo来说几乎没多大的内存开销（200m+），还不需要再跑个mysql他不香吗~\n\n# 下载配置文件到 /data/halo 目录\ncurl -o /data/halo/application.yaml --create-dirs https://dl.halo.run/config/application-template.yaml\nsudo docker pull ruibaby/halo\ndocker run --rm -it -d --name halo -p 8090:8090  --privileged=true -v /data/halo:/root/.halo ruibaby/halo\n\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"SpringBoot项目搭建成jar包",frontmatter:{title:"SpringBoot项目搭建成jar包",date:"2021-07-09T14:55:29.000Z",permalink:"/pages/5cc41b/",categories:["技术","环境搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/01.SpringBoot%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%88%90jar%E5%8C%85.html",relativePath:"03.技术/07.环境搭建/01.SpringBoot项目搭建成jar包.md",key:"v-82fe639c",path:"/pages/5cc41b/",headers:[{level:2,title:"1.直接打包成jar包",slug:"_1-直接打包成jar包",normalizedTitle:"1.直接打包成jar包",charIndex:26},{level:3,title:"1.命令运行：",slug:"_1-命令运行",normalizedTitle:"1.命令运行：",charIndex:179},{level:3,title:"2.脚本运行",slug:"_2-脚本运行",normalizedTitle:"2.脚本运行",charIndex:381}],headersStr:"1.直接打包成jar包 1.命令运行： 2.脚本运行",content:'# SpringBoot项目搭建成jar包\n\n\n# 1.直接打包成jar包\n\n把springboot项目通过idea或其他编程软件通过maven的package来获取jar包。\n\n此种方式jar会非常的大，如果需要改动一点，那么整个jar就需要重新打包。\n\nmvn clean package -Dmaven.test.skip=true\n\n\n1\n\n\n\n# 1.命令运行：\n\njava –jar ruoyi.jar\n\n\n1\n\n\nlinux关闭防火墙\n\n1、查看firewall服务状态\nsystemctl status firewalld\n# 开启\nservice firewalld start\n# 重启\nservice firewalld restart\n# 关闭\nservice firewalld stop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2.脚本运行\n\n 1. 把脚本放入到和jar同一级目录下面（在该目录下面启动)\n 2. chmod +x start.sh给脚本添加权限\n\n只需要修改AppName\n\n#!/bin/bash\n\nAppName=wcy.jar\n\n#JVM参数\nJVM_OPTS="-Dname=$AppName  -Duser.timezone=Asia/Shanghai -Xms512M -Xmx512M -XX:PermSize=256M -XX:MaxPermSize=512M -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDateStamps  -XX:+PrintGCDetails -XX:NewRatio=1 -XX:SurvivorRatio=30 -XX:+UseParallelGC -XX:+UseParallelOldGC"\nAPP_HOME=`pwd`\nLOG_PATH=$APP_HOME/logs/$AppName.log\n\nif [ "$1" = "" ];\nthen\n    echo -e "\\033[0;31m 未输入操作名 \\033[0m  \\033[0;34m {start|stop|restart|status} \\033[0m"\n    exit 1\nfi\n\nif [ "$AppName" = "" ];\nthen\n    echo -e "\\033[0;31m 未输入应用名 \\033[0m"\n    exit 1\nfi\n\nfunction start()\n{\n    PID=`ps -ef |grep java|grep $AppName|grep -v grep|awk \'{print $2}\'`\n\n\tif [ x"$PID" != x"" ]; then\n\t    echo "$AppName is running..."\n\telse\n\t\tnohup java -jar  $JVM_OPTS $AppName > /dev/null 2>&1 &\n\t\techo "Start $AppName success..."\n\tfi\n}\n\nfunction stop()\n{\n    echo "Stop $AppName"\n\t\n\tPID=""\n\tquery(){\n\t\tPID=`ps -ef |grep java|grep $AppName|grep -v grep|awk \'{print $2}\'`\n\t}\n\n\tquery\n\tif [ x"$PID" != x"" ]; then\n\t\tkill -TERM $PID\n\t\techo "$AppName (pid:$PID) exiting..."\n\t\twhile [ x"$PID" != x"" ]\n\t\tdo\n\t\t\tsleep 1\n\t\t\tquery\n\t\tdone\n\t\techo "$AppName exited."\n\telse\n\t\techo "$AppName already stopped."\n\tfi\n}\n\nfunction restart()\n{\n    stop\n    sleep 2\n    start\n}\n\nfunction status()\n{\n    PID=`ps -ef |grep java|grep $AppName|grep -v grep|wc -l`\n    if [ $PID != 0 ];then\n        echo "$AppName is running..."\n    else\n        echo "$AppName is not running..."\n    fi\n}\n\ncase $1 in\n    start)\n    start;;\n    stop)\n    stop;;\n    restart)\n    restart;;\n    status)\n    status;;\n    *)\n\nesac\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n命令运行：\n\n#启动环境\n./wcy.sh start\n#停止环境\n./wcy.sh stop\n#重新启动环境\n./wcy.sh restart\n#查看状态\n./wcy.sh status\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可能会出现的问题：\n\nbash: ./a.sh: /bin/bash^M: bad interpreter: No such file or directory\n\n解决：\n\n * 可以 yum -y install dos2unix\n * 然后 dos2unix start.sh\n * 重新运行脚本',normalizedContent:'# springboot项目搭建成jar包\n\n\n# 1.直接打包成jar包\n\n把springboot项目通过idea或其他编程软件通过maven的package来获取jar包。\n\n此种方式jar会非常的大，如果需要改动一点，那么整个jar就需要重新打包。\n\nmvn clean package -dmaven.test.skip=true\n\n\n1\n\n\n\n# 1.命令运行：\n\njava –jar ruoyi.jar\n\n\n1\n\n\nlinux关闭防火墙\n\n1、查看firewall服务状态\nsystemctl status firewalld\n# 开启\nservice firewalld start\n# 重启\nservice firewalld restart\n# 关闭\nservice firewalld stop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2.脚本运行\n\n 1. 把脚本放入到和jar同一级目录下面（在该目录下面启动)\n 2. chmod +x start.sh给脚本添加权限\n\n只需要修改appname\n\n#!/bin/bash\n\nappname=wcy.jar\n\n#jvm参数\njvm_opts="-dname=$appname  -duser.timezone=asia/shanghai -xms512m -xmx512m -xx:permsize=256m -xx:maxpermsize=512m -xx:+heapdumponoutofmemoryerror -xx:+printgcdatestamps  -xx:+printgcdetails -xx:newratio=1 -xx:survivorratio=30 -xx:+useparallelgc -xx:+useparalleloldgc"\napp_home=`pwd`\nlog_path=$app_home/logs/$appname.log\n\nif [ "$1" = "" ];\nthen\n    echo -e "\\033[0;31m 未输入操作名 \\033[0m  \\033[0;34m {start|stop|restart|status} \\033[0m"\n    exit 1\nfi\n\nif [ "$appname" = "" ];\nthen\n    echo -e "\\033[0;31m 未输入应用名 \\033[0m"\n    exit 1\nfi\n\nfunction start()\n{\n    pid=`ps -ef |grep java|grep $appname|grep -v grep|awk \'{print $2}\'`\n\n\tif [ x"$pid" != x"" ]; then\n\t    echo "$appname is running..."\n\telse\n\t\tnohup java -jar  $jvm_opts $appname > /dev/null 2>&1 &\n\t\techo "start $appname success..."\n\tfi\n}\n\nfunction stop()\n{\n    echo "stop $appname"\n\t\n\tpid=""\n\tquery(){\n\t\tpid=`ps -ef |grep java|grep $appname|grep -v grep|awk \'{print $2}\'`\n\t}\n\n\tquery\n\tif [ x"$pid" != x"" ]; then\n\t\tkill -term $pid\n\t\techo "$appname (pid:$pid) exiting..."\n\t\twhile [ x"$pid" != x"" ]\n\t\tdo\n\t\t\tsleep 1\n\t\t\tquery\n\t\tdone\n\t\techo "$appname exited."\n\telse\n\t\techo "$appname already stopped."\n\tfi\n}\n\nfunction restart()\n{\n    stop\n    sleep 2\n    start\n}\n\nfunction status()\n{\n    pid=`ps -ef |grep java|grep $appname|grep -v grep|wc -l`\n    if [ $pid != 0 ];then\n        echo "$appname is running..."\n    else\n        echo "$appname is not running..."\n    fi\n}\n\ncase $1 in\n    start)\n    start;;\n    stop)\n    stop;;\n    restart)\n    restart;;\n    status)\n    status;;\n    *)\n\nesac\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n命令运行：\n\n#启动环境\n./wcy.sh start\n#停止环境\n./wcy.sh stop\n#重新启动环境\n./wcy.sh restart\n#查看状态\n./wcy.sh status\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可能会出现的问题：\n\nbash: ./a.sh: /bin/bash^m: bad interpreter: no such file or directory\n\n解决：\n\n * 可以 yum -y install dos2unix\n * 然后 dos2unix start.sh\n * 重新运行脚本',charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"PLSQL的安装",frontmatter:{title:"PLSQL的安装",date:"2021-07-09T19:24:38.000Z",permalink:"/pages/2daf7d/",categories:["技术","环境搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/05.PLSQL%E7%9A%84%E5%AE%89%E8%A3%85.html",relativePath:"03.技术/07.环境搭建/05.PLSQL的安装.md",key:"v-d5e0168a",path:"/pages/2daf7d/",headersStr:null,content:"# 一.PLsql以及instantclient的安装\n\n1.自行下载PLsql、instantclient-basic-windows.x64-11.2.0.4.0\n\n2.配置环境变量\n\n配置环境变量\n\n1) 变量名：ORACLE_HOME  变量值：E:\\tool_01\\PLSQL Developer\\instantclient_11_2\n\n2) 变量名：TNS_ADMIN  变量值：E:\\tool_01\\PLSQL Developer\\instantclient_11_2\n\n3) 变量名：NLS_LANG   变量值：SIMPLIFIED CHINESE_CHINA.ZHS16GBK\n\n4) 修改Path变量，在后面添加 E:\\tool_01\\PLSQL Developer\\instantclient_11_2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",normalizedContent:"# 一.plsql以及instantclient的安装\n\n1.自行下载plsql、instantclient-basic-windows.x64-11.2.0.4.0\n\n2.配置环境变量\n\n配置环境变量\n\n1) 变量名：oracle_home  变量值：e:\\tool_01\\plsql developer\\instantclient_11_2\n\n2) 变量名：tns_admin  变量值：e:\\tool_01\\plsql developer\\instantclient_11_2\n\n3) 变量名：nls_lang   变量值：simplified chinese_china.zhs16gbk\n\n4) 修改path变量，在后面添加 e:\\tool_01\\plsql developer\\instantclient_11_2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 18:28:04"},{title:"windows安装jekyll步骤及问题",frontmatter:{title:"windows安装jekyll步骤及问题",date:"2021-07-09T14:55:29.000Z",permalink:"/pages/0a56c4/",categories:["技术","环境搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/03.windows%E5%AE%89%E8%A3%85jekyll%E6%AD%A5%E9%AA%A4%E5%8F%8A%E9%97%AE%E9%A2%98.html",relativePath:"03.技术/07.环境搭建/03.windows安装jekyll步骤及问题.md",key:"v-2f624b2e",path:"/pages/0a56c4/",headersStr:null,content:"# windows安装jekyll步骤及问题\n\n# 1.安装Ruby和DevKit\n\n下载地址：https://rubyinstaller.org/downloads/\n\n\n\n# 2.安装jekyll\n\ngem install jekyll\n\n\n1\n\n\n测试一下\n\njekyll --version\n\n\n1\n\n\n新建项目\n\njekyll new myblog\n\n\n1\n\n\n# 3.运行服务器\n\n进入myblog\n\ncd myblog\n\nmyblog>jekyll serve\n\n\n1\n2\n3\n",normalizedContent:"# windows安装jekyll步骤及问题\n\n# 1.安装ruby和devkit\n\n下载地址：https://rubyinstaller.org/downloads/\n\n\n\n# 2.安装jekyll\n\ngem install jekyll\n\n\n1\n\n\n测试一下\n\njekyll --version\n\n\n1\n\n\n新建项目\n\njekyll new myblog\n\n\n1\n\n\n# 3.运行服务器\n\n进入myblog\n\ncd myblog\n\nmyblog>jekyll serve\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"教你如何使用github+jsDelivr搭建免费图床 - 副本",frontmatter:{title:"教你如何使用github+jsDelivr搭建免费图床 - 副本",date:"2021-07-09T14:55:29.000Z",permalink:"/pages/63547b/",categories:["技术","环境搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/04.%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github+jsDelivr%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A%20-%20%E5%89%AF%E6%9C%AC.html",relativePath:"03.技术/07.环境搭建/04.教你如何使用github+jsDelivr搭建免费图床 - 副本.md",key:"v-4880eaba",path:"/pages/63547b/",headers:[{level:2,title:"方法一：通过图床地址搭建图床（推荐，简单方便）",slug:"方法一-通过图床地址搭建图床-推荐-简单方便",normalizedTitle:"方法一：通过图床地址搭建图床（推荐，简单方便）",charIndex:34},{level:2,title:"方法二：通过PicGo软件来搭建图床，配合Typora使用自动上传到github",slug:"方法二-通过picgo软件来搭建图床-配合typora使用自动上传到github",normalizedTitle:"方法二：通过picgo软件来搭建图床，配合typora使用自动上传到github",charIndex:227},{level:2,title:"使用gitee搭建图床，由于有时候github网络出现问题，可以用gitee做备份",slug:"使用gitee搭建图床-由于有时候github网络出现问题-可以用gitee做备份",normalizedTitle:"使用gitee搭建图床，由于有时候github网络出现问题，可以用gitee做备份",charIndex:570}],headersStr:"方法一：通过图床地址搭建图床（推荐，简单方便） 方法二：通过PicGo软件来搭建图床，配合Typora使用自动上传到github 使用gitee搭建图床，由于有时候github网络出现问题，可以用gitee做备份",content:"# 教你如何使用github+jsDelivr搭建免费图床\n\n\n# 方法一：通过图床地址搭建图床（推荐，简单方便）\n\n 1. 图床地址：https://picx.xpoet.cn/?#/management\n\n 2. 根据网址中的使用教程，创建一个github的空项目；创建github仓库\n\n 3. 再创建一个有 repo 权限的 GitHub Token；github Token\n\n 4. 在网页上进行配置，即可使用；\n    \n    \n\n\n# 方法二：通过PicGo软件来搭建图床，配合Typora使用自动上传到github\n\n同理：（下方两步与上方相同）\n\n 1. 根据网址中的使用教程，创建一个github的空项目；创建github仓库\n\n 2. 再创建一个有 repo 权限的 GitHub Token；github Token\n\n 3. 下载PicGo软件，百度很多\n\n 4. 配置下方\n    \n    * 仓库名和分支名就是上方的第一步创建的仓库\n    * Token就是上方第二步创建的Token\n    * 指定路径就是上传的地址\n    * 自定义域名：https://cdn.jsdelivr.net/gh/用户名/仓库名@分支名\n    \n    \n\n 5. typora配置\n    \n    \n\n\n# 使用gitee搭建图床，由于有时候github网络出现问题，可以用gitee做备份\n\n参考",normalizedContent:"# 教你如何使用github+jsdelivr搭建免费图床\n\n\n# 方法一：通过图床地址搭建图床（推荐，简单方便）\n\n 1. 图床地址：https://picx.xpoet.cn/?#/management\n\n 2. 根据网址中的使用教程，创建一个github的空项目；创建github仓库\n\n 3. 再创建一个有 repo 权限的 github token；github token\n\n 4. 在网页上进行配置，即可使用；\n    \n    \n\n\n# 方法二：通过picgo软件来搭建图床，配合typora使用自动上传到github\n\n同理：（下方两步与上方相同）\n\n 1. 根据网址中的使用教程，创建一个github的空项目；创建github仓库\n\n 2. 再创建一个有 repo 权限的 github token；github token\n\n 3. 下载picgo软件，百度很多\n\n 4. 配置下方\n    \n    * 仓库名和分支名就是上方的第一步创建的仓库\n    * token就是上方第二步创建的token\n    * 指定路径就是上传的地址\n    * 自定义域名：https://cdn.jsdelivr.net/gh/用户名/仓库名@分支名\n    \n    \n\n 5. typora配置\n    \n    \n\n\n# 使用gitee搭建图床，由于有时候github网络出现问题，可以用gitee做备份\n\n参考",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"docker安装rabbitmq",frontmatter:{title:"docker安装rabbitmq",date:"2021-08-24T10:40:43.000Z",permalink:"/pages/370eba/",categories:["技术","环境搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/06.docker%E5%AE%89%E8%A3%85rabbitmq.html",relativePath:"03.技术/07.环境搭建/06.docker安装rabbitmq.md",key:"v-31054822",path:"/pages/370eba/",headers:[{level:2,title:"docker安装rabbitmq",slug:"docker安装rabbitmq",normalizedTitle:"docker安装rabbitmq",charIndex:2},{level:3,title:"1.选择版本，带web管理",slug:"_1-选择版本-带web管理",normalizedTitle:"1.选择版本，带web管理",charIndex:23},{level:3,title:"2.运行rabbitmq",slug:"_2-运行rabbitmq",normalizedTitle:"2.运行rabbitmq",charIndex:93},{level:3,title:"3.安装插件",slug:"_3-安装插件",normalizedTitle:"3.安装插件",charIndex:232},{level:3,title:"4.访问地址",slug:"_4-访问地址",normalizedTitle:"4.访问地址",charIndex:339}],headersStr:"docker安装rabbitmq 1.选择版本，带web管理 2.运行rabbitmq 3.安装插件 4.访问地址",content:"# docker安装rabbitmq\n\n\n# 1.选择版本，带web管理\n\ndocker pull rabbitmq:3.7.14-management-alpine\n\n\n1\n\n\n\n# 2.运行rabbitmq\n\ndocker run -d --hostname my-rabbit --name my-rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.7.14-management-alpine\n\n\n1\n\n\n\n# 3.安装插件\n\ndocker ps \ndocker exec -it 镜像ID /bin/bash\nrabbitmq-plugins enable rabbitmq_management\n\n\n1\n2\n3\n\n\n\n# 4.访问地址\n\nhttp://ip:15672，这里的用户名和密码默认都是guest",normalizedContent:"# docker安装rabbitmq\n\n\n# 1.选择版本，带web管理\n\ndocker pull rabbitmq:3.7.14-management-alpine\n\n\n1\n\n\n\n# 2.运行rabbitmq\n\ndocker run -d --hostname my-rabbit --name my-rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.7.14-management-alpine\n\n\n1\n\n\n\n# 3.安装插件\n\ndocker ps \ndocker exec -it 镜像id /bin/bash\nrabbitmq-plugins enable rabbitmq_management\n\n\n1\n2\n3\n\n\n\n# 4.访问地址\n\nhttp://ip:15672，这里的用户名和密码默认都是guest",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"docker搭建minio云盘",frontmatter:{title:"docker搭建minio云盘",date:"2021-12-08T18:02:39.000Z",permalink:"/pages/f4bf6d/",categories:["技术","环境搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/07.docker%E6%90%AD%E5%BB%BAminio%E4%BA%91%E7%9B%98.html",relativePath:"03.技术/07.环境搭建/07.docker搭建minio云盘.md",key:"v-32b5c37d",path:"/pages/f4bf6d/",headers:[{level:2,title:"一.旧版安装",slug:"一-旧版安装",normalizedTitle:"一.旧版安装",charIndex:21},{level:3,title:"1.下载",slug:"_1-下载",normalizedTitle:"1.下载",charIndex:32},{level:3,title:"2.启动命令",slug:"_2-启动命令",normalizedTitle:"2.启动命令",charIndex:100},{level:2,title:"二.新版安装",slug:"二-新版安装",normalizedTitle:"二.新版安装",charIndex:360}],headersStr:"一.旧版安装 1.下载 2.启动命令 二.新版安装",content:'# docker搭建halo博客\n\n\n# 一.旧版安装\n\n\n# 1.下载\n\ndocker pull minio/minio:RELEASE.2021-06-17T00-10-46Z\n\n\n1\n\n\n\n# 2.启动命令\n\ndocker run -p 9000:9000 --name minio -d \\\n-e "MINIO_ROOT_USER=admin" \\\n-e "MINIO_ROOT_PASSWORD=admin2452952178" \\\n-v /data/minio/data:/data \\\n-v /data/minio/config:/root/.minio \\\nminio/minio:RELEASE.2021-06-17T00-10-46Z server /data\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 二.新版安装\n\n> 暂时未解决：下载文件损坏、分享链接问题\n\ndocker pull minio/minio\n\n\n1\n\n\n指定版本：\n\ndocker pull minio/minio:RELEASE.2021-11-24T23:19:33Z\n\n\n1\n\n\nVersion：2021-11-24T23:19:33Z\n\ndocker run \\\n--name minio \\\n-p 9000:9000  \\\n-p 9090:9090  \\\n-d --privileged=true \\\n-e "MINIO_ROOT_USER=admin" \\\n-e "MINIO_ROOT_PASSWORD=admin2452952178" \\\n-v /data/minio/data:/data \\\n-v /data/minio/config:/root/.minio \\\nminio/minio server  /data --console-address ":9090" --address ":9000"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 大约在0.6版，privileged被引入docker。 使用该参数，container内的root拥有真正的root权限。 否则，container内的root只是外部的一个普通用户权限。 privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。 甚至允许你在docker容器中启动docker容器。',normalizedContent:'# docker搭建halo博客\n\n\n# 一.旧版安装\n\n\n# 1.下载\n\ndocker pull minio/minio:release.2021-06-17t00-10-46z\n\n\n1\n\n\n\n# 2.启动命令\n\ndocker run -p 9000:9000 --name minio -d \\\n-e "minio_root_user=admin" \\\n-e "minio_root_password=admin2452952178" \\\n-v /data/minio/data:/data \\\n-v /data/minio/config:/root/.minio \\\nminio/minio:release.2021-06-17t00-10-46z server /data\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 二.新版安装\n\n> 暂时未解决：下载文件损坏、分享链接问题\n\ndocker pull minio/minio\n\n\n1\n\n\n指定版本：\n\ndocker pull minio/minio:release.2021-11-24t23:19:33z\n\n\n1\n\n\nversion：2021-11-24t23:19:33z\n\ndocker run \\\n--name minio \\\n-p 9000:9000  \\\n-p 9090:9090  \\\n-d --privileged=true \\\n-e "minio_root_user=admin" \\\n-e "minio_root_password=admin2452952178" \\\n-v /data/minio/data:/data \\\n-v /data/minio/config:/root/.minio \\\nminio/minio server  /data --console-address ":9090" --address ":9000"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 大约在0.6版，privileged被引入docker。 使用该参数，container内的root拥有真正的root权限。 否则，container内的root只是外部的一个普通用户权限。 privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。 甚至允许你在docker容器中启动docker容器。',charsets:{cjk:!0}},{title:"vdoing主题搭建",frontmatter:{title:"vdoing主题搭建",date:"2021-07-13T15:40:33.000Z",permalink:"/pages/9cfdf3/",categories:["技术","环境搭建","vuepress博客搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20.vuepress%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/02.vdoing%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA.html",relativePath:"03.技术/07.环境搭建/20.vuepress博客搭建/02.vdoing主题搭建.md",key:"v-1f7e1d2a",path:"/pages/9cfdf3/",headers:[{level:2,title:"1.必要了解的约定",slug:"_1-必要了解的约定",normalizedTitle:"1.必要了解的约定",charIndex:78},{level:3,title:"1.1.目录结构",slug:"_1-1-目录结构",normalizedTitle:"1.1.目录结构",charIndex:92},{level:3,title:"1.2.必要约定",slug:"_1-2-必要约定",normalizedTitle:"1.2.必要约定",charIndex:775},{level:2,title:"2.注意注意：",slug:"_2-注意注意",normalizedTitle:"2.注意注意：",charIndex:969}],headersStr:"1.必要了解的约定 1.1.目录结构 1.2.必要约定 2.注意注意：",content:"# 一.使用Vdoing主题\n\n> 官网：https://xugaoyi.github.io/vuepress-theme-vdoing-doc/\n\n\n# 1.必要了解的约定\n\n\n# 1.1.目录结构\n\n.\n├── .github   (可选，GitHub Actions所需文件)\n│   ├── workflows\n│   │   ├── baiduPush.yml (可选，百度定时自动推送)\n│   │   └── ci.yml (可选，自动部署)\n├── docs (必须，不要修改文件夹名称)\n│   ├── .vuepress （同官方，查看：https://vuepress.vuejs.org/zh/guide/directory-structure.html#目录结构）\n│   ├── @pages (可选，自动生成的文件夹，存放分类页、标签页、归档页)\n│   ├── _posts (可选，专门存放碎片化博客文章的文件夹)\n│   ├── <结构化目录>\n│   └── index.md (首页)\n├── theme-vdoing (可选，本地的vdoing主题)\n├── utils  (可选，vdoing主题使用的node工具)\n│   ├── modules\n│   ├── config.yml (可选，批量操作front matter配置)\n│   ├── editFrontmatter.js (可选，批量操作front matter工具)\n├── baiduPush.sh (可选，百度推送命令脚本)\n├── deploy.sh (可选，部署命令脚本)\n│\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 1.2.必要约定\n\n在运行开发服务npm run dev或打包npm run build时主题内部将会按照目录约定自动生成一个结构化的侧边栏、目录页、面包屑等数据。\n\n在源目录（一般是docs）文件夹中，除了.vuepress、@pages、_posts、index.md 或 README.md之外的文件夹将会为其生成对应的侧边栏。生成的顺序取自序号，标题取自文件（夹）名称。\n\n\n# 2.注意注意：\n\n> md文件中的图片一旦没法加载，那么打包会出现问题，切记切记",normalizedContent:"# 一.使用vdoing主题\n\n> 官网：https://xugaoyi.github.io/vuepress-theme-vdoing-doc/\n\n\n# 1.必要了解的约定\n\n\n# 1.1.目录结构\n\n.\n├── .github   (可选，github actions所需文件)\n│   ├── workflows\n│   │   ├── baidupush.yml (可选，百度定时自动推送)\n│   │   └── ci.yml (可选，自动部署)\n├── docs (必须，不要修改文件夹名称)\n│   ├── .vuepress （同官方，查看：https://vuepress.vuejs.org/zh/guide/directory-structure.html#目录结构）\n│   ├── @pages (可选，自动生成的文件夹，存放分类页、标签页、归档页)\n│   ├── _posts (可选，专门存放碎片化博客文章的文件夹)\n│   ├── <结构化目录>\n│   └── index.md (首页)\n├── theme-vdoing (可选，本地的vdoing主题)\n├── utils  (可选，vdoing主题使用的node工具)\n│   ├── modules\n│   ├── config.yml (可选，批量操作front matter配置)\n│   ├── editfrontmatter.js (可选，批量操作front matter工具)\n├── baidupush.sh (可选，百度推送命令脚本)\n├── deploy.sh (可选，部署命令脚本)\n│\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 1.2.必要约定\n\n在运行开发服务npm run dev或打包npm run build时主题内部将会按照目录约定自动生成一个结构化的侧边栏、目录页、面包屑等数据。\n\n在源目录（一般是docs）文件夹中，除了.vuepress、@pages、_posts、index.md 或 readme.md之外的文件夹将会为其生成对应的侧边栏。生成的顺序取自序号，标题取自文件（夹）名称。\n\n\n# 2.注意注意：\n\n> md文件中的图片一旦没法加载，那么打包会出现问题，切记切记",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"引入gitalk评论",frontmatter:{title:"引入gitalk评论",date:"2021-07-13T19:57:05.000Z",permalink:"/pages/7f54e3/",categories:["技术","环境搭建","vuepress博客搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20.vuepress%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/04.%E5%BC%95%E5%85%A5gitalk%E8%AF%84%E8%AE%BA.html",relativePath:"03.技术/07.环境搭建/20.vuepress博客搭建/04.引入gitalk评论.md",key:"v-aac523bc",path:"/pages/7f54e3/",headers:[{level:2,title:"1.下载插件",slug:"_1-下载插件",normalizedTitle:"1.下载插件",charIndex:2},{level:2,title:"1.申请github的clientId、clientSecret",slug:"_1-申请github的clientid、clientsecret",normalizedTitle:"1.申请github的clientid、clientsecret",charIndex:52}],headersStr:"1.下载插件 1.申请github的clientId、clientSecret",content:"# 1.下载插件\n\nnpm i vuepress-plugin-comment -D\n\n\n1\n\n\n\n# 1.申请github的clientId、clientSecret\n\n去https://vssue.js.org/zh/guide/github.html#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-oauth-app申请github的clientId、clientSecret\n\n\n\n> 复制 Client ID 和 Client Secret, 并设置 owner 和 repo。\n> \n> > Github repository 的 URL 模式为 https://github.com/${owner}/${repo}\n\n [\n    'vuepress-plugin-comment', // 评论\n    {\n      choosen: 'gitalk',\n      options: {\n        clientID: 'a6e1355287947096b88b',\n        clientSecret: 'f0e77d070fabfcd5af95bebb82b2d574d7248d71',\n        repo: 'myBlog', // GitHub 仓库\n        owner: 'wangchangyin', // GitHub仓库所有者\n        admin: ['wangchangyin'], // 对仓库有写权限的人\n        // distractionFreeMode: true,\n        pagerDirection: 'last', // 'first'正序 | 'last'倒序\n        id: '<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>', //  页面的唯一标识,长度不能超过50\n        title: '「评论」<%- frontmatter.title %>', // GitHub issue 的标题\n        labels: ['Gitalk', 'Comment'], // GitHub issue 的标签\n        body:\n          '页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>', // GitHub issue 的内容\n      },\n    },\n  ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",normalizedContent:"# 1.下载插件\n\nnpm i vuepress-plugin-comment -d\n\n\n1\n\n\n\n# 1.申请github的clientid、clientsecret\n\n去https://vssue.js.org/zh/guide/github.html#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e6%96%b0%e7%9a%84-oauth-app申请github的clientid、clientsecret\n\n\n\n> 复制 client id 和 client secret, 并设置 owner 和 repo。\n> \n> > github repository 的 url 模式为 https://github.com/${owner}/${repo}\n\n [\n    'vuepress-plugin-comment', // 评论\n    {\n      choosen: 'gitalk',\n      options: {\n        clientid: 'a6e1355287947096b88b',\n        clientsecret: 'f0e77d070fabfcd5af95bebb82b2d574d7248d71',\n        repo: 'myblog', // github 仓库\n        owner: 'wangchangyin', // github仓库所有者\n        admin: ['wangchangyin'], // 对仓库有写权限的人\n        // distractionfreemode: true,\n        pagerdirection: 'last', // 'first'正序 | 'last'倒序\n        id: '<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>', //  页面的唯一标识,长度不能超过50\n        title: '「评论」<%- frontmatter.title %>', // github issue 的标题\n        labels: ['gitalk', 'comment'], // github issue 的标签\n        body:\n          '页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>', // github issue 的内容\n      },\n    },\n  ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"引入meting音乐播放器",frontmatter:{title:"引入meting音乐播放器",date:"2021-07-14T11:08:59.000Z",permalink:"/pages/0bea88/",categories:["技术","环境搭建","vuepress博客搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20.vuepress%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/05.%E5%BC%95%E5%85%A5meting%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8.html",relativePath:"03.技术/07.环境搭建/20.vuepress博客搭建/05.引入meting音乐播放器.md",key:"v-37ac8ce7",path:"/pages/0bea88/",headers:[{level:2,title:"1.安装vuepress-plugin-meting",slug:"_1-安装vuepress-plugin-meting",normalizedTitle:"1.安装vuepress-plugin-meting",charIndex:74},{level:2,title:"2.导入插件",slug:"_2-导入插件",normalizedTitle:"2.导入插件",charIndex:143}],headersStr:"1.安装vuepress-plugin-meting 2.导入插件",content:'# 引入meting音乐播放器\n\n官网：https://github.com/moefyit/vuepress-plugin-meting\n\n\n# 1.安装vuepress-plugin-meting\n\nnpm i vuepress-plugin-meting -D\n\n\n1\n\n\n\n# 2.导入插件\n\n  //引入音乐播放器\n  [\n    "meting",\n    {\n      meting: {\n        server: "netease", // netease:网易云，tencent:qq音乐，xiami:虾米音乐 "kuwo" | "kugou" | "baidu"\n        type: "playlist",\n        mid: "37432514",\n      },\n      aplayer: {\n        autoplay: true,  //是否开启自动播放\n        mini: true,  //是否开启迷你模式\n        theme: \'#282c34\',\n        lrcType:3  //显示歌词  3 | 1 | 0（0：禁用 lrc 歌词，1：lrc 格式的字符串，3：lrc 文件 url）\n      },\n      mobile: {\n        cover: false,\n        lrc: false\n      }\n    }\n  ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',normalizedContent:'# 引入meting音乐播放器\n\n官网：https://github.com/moefyit/vuepress-plugin-meting\n\n\n# 1.安装vuepress-plugin-meting\n\nnpm i vuepress-plugin-meting -d\n\n\n1\n\n\n\n# 2.导入插件\n\n  //引入音乐播放器\n  [\n    "meting",\n    {\n      meting: {\n        server: "netease", // netease:网易云，tencent:qq音乐，xiami:虾米音乐 "kuwo" | "kugou" | "baidu"\n        type: "playlist",\n        mid: "37432514",\n      },\n      aplayer: {\n        autoplay: true,  //是否开启自动播放\n        mini: true,  //是否开启迷你模式\n        theme: \'#282c34\',\n        lrctype:3  //显示歌词  3 | 1 | 0（0：禁用 lrc 歌词，1：lrc 格式的字符串，3：lrc 文件 url）\n      },\n      mobile: {\n        cover: false,\n        lrc: false\n      }\n    }\n  ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"vuepress搭建个人博客",frontmatter:{title:"vuepress搭建个人博客",date:"2021-07-09T14:55:29.000Z",permalink:"/pages/555c24/",categories:["技术","环境搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20.vuepress%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/01.vuepress%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html",relativePath:"03.技术/07.环境搭建/20.vuepress博客搭建/01.vuepress搭建个人博客.md",key:"v-288e2030",path:"/pages/555c24/",headers:[{level:2,title:"1.目录结构",slug:"_1-目录结构",normalizedTitle:"1.目录结构",charIndex:99},{level:2,title:"1.路由配置",slug:"_1-路由配置",normalizedTitle:"1.路由配置",charIndex:1256},{level:3,title:"1.1.搭建vuepress环境",slug:"_1-1-搭建vuepress环境",normalizedTitle:"1.1.搭建vuepress环境",charIndex:1415},{level:2,title:"2.导航栏",slug:"_2-导航栏",normalizedTitle:"2.导航栏",charIndex:1494},{level:3,title:"2.1.增加导航栏logo",slug:"_2-1-增加导航栏logo",normalizedTitle:"2.1.增加导航栏logo",charIndex:1553},{level:3,title:"2.2.导航栏链接",slug:"_2-2-导航栏链接",normalizedTitle:"2.2.导航栏链接",charIndex:1710},{level:3,title:"2.3.下拉导航栏",slug:"_2-3-下拉导航栏",normalizedTitle:"2.3.下拉导航栏",charIndex:1991},{level:3,title:"2.4.某些页面禁用导航栏",slug:"_2-4-某些页面禁用导航栏",normalizedTitle:"2.4.某些页面禁用导航栏",charIndex:2781},{level:2,title:"3.侧边栏",slug:"_3-侧边栏",normalizedTitle:"3.侧边栏",charIndex:2874},{level:3,title:"3.1.默认自动开启侧边栏",slug:"_3-1-默认自动开启侧边栏",normalizedTitle:"3.1.默认自动开启侧边栏",charIndex:3056},{level:3,title:"3.2.配置某个页面的侧边栏",slug:"_3-2-配置某个页面的侧边栏",normalizedTitle:"3.2.配置某个页面的侧边栏",charIndex:3174},{level:2,title:"4.SEC（网站个人信息设置）",slug:"_4-sec-网站个人信息设置",normalizedTitle:"4.sec（网站个人信息设置）",charIndex:3953},{level:2,title:"5.开启博客内容更新时间",slug:"_5-开启博客内容更新时间",normalizedTitle:"5.开启博客内容更新时间",charIndex:4254},{level:2,title:"6.发布到gitee上",slug:"_6-发布到gitee上",normalizedTitle:"6.发布到gitee上",charIndex:4505},{level:3,title:"6.1.修改base",slug:"_6-1-修改base",normalizedTitle:"6.1.修改base",charIndex:4521},{level:3,title:"6.2.创建deploy.sh脚本",slug:"_6-2-创建deploy-sh脚本",normalizedTitle:"6.2.创建deploy.sh脚本",charIndex:4874},{level:3,title:"6.3.执行脚本即可",slug:"_6-3-执行脚本即可",normalizedTitle:"6.3.执行脚本即可",charIndex:5449},{level:2,title:"7.绑定域名",slug:"_7-绑定域名",normalizedTitle:"7.绑定域名",charIndex:5502},{level:3,title:"7.1.关闭base配置",slug:"_7-1-关闭base配置",normalizedTitle:"7.1.关闭base配置",charIndex:5513},{level:3,title:"7.2.域名解析",slug:"_7-2-域名解析",normalizedTitle:"7.2.域名解析",charIndex:5606},{level:3,title:"7.3.编辑后的静态文件推送到github上，并设置域名",slug:"_7-3-编辑后的静态文件推送到github上-并设置域名",normalizedTitle:"7.3.编辑后的静态文件推送到github上，并设置域名",charIndex:5621},{level:2,title:"8.启用PWA(离线访问等等)",slug:"_8-启用pwa-离线访问等等",normalizedTitle:"8.启用pwa(离线访问等等)",charIndex:6150},{level:3,title:"8.1.安装pwa插件",slug:"_8-1-安装pwa插件",normalizedTitle:"8.1.安装pwa插件",charIndex:6172},{level:3,title:"8.2.导入插件",slug:"_8-2-导入插件",normalizedTitle:"8.2.导入插件",charIndex:6230},{level:3,title:"8.3.导入manifest.json和icons",slug:"_8-3-导入manifest-json和icons",normalizedTitle:"8.3.导入manifest.json和icons",charIndex:6483},{level:3,title:"8.4.vuepress/config.js导入头文件meta",slug:"_8-4-vuepress-config-js导入头文件meta",normalizedTitle:"8.4.vuepress/config.js导入头文件meta",charIndex:6579},{level:2,title:"9.vssue评论",slug:"_9-vssue评论",normalizedTitle:"9.vssue评论",charIndex:7480},{level:3,title:"9.1.安装vssue",slug:"_9-1-安装vssue",normalizedTitle:"9.1.安装vssue",charIndex:7530},{level:3,title:"9.2.添加插件",slug:"_9-2-添加插件",normalizedTitle:"9.2.添加插件",charIndex:7665},{level:3,title:"9.3.对应页面加上html代码",slug:"_9-3-对应页面加上html代码",normalizedTitle:"9.3.对应页面加上html代码",charIndex:8306},{level:3,title:"9.4.不在每个MD文件中加入的方法",slug:"_9-4-不在每个md文件中加入的方法",normalizedTitle:"9.4.不在每个md文件中加入的方法",charIndex:8343},{level:2,title:"10.back-to-top滚动回顶部",slug:"_10-back-to-top滚动回顶部",normalizedTitle:"10.back-to-top滚动回顶部",charIndex:9038},{level:3,title:"10.1.安装插件",slug:"_10-1-安装插件",normalizedTitle:"10.1.安装插件",charIndex:9062},{level:3,title:"10.2.添加插件",slug:"_10-2-添加插件",normalizedTitle:"10.2.添加插件",charIndex:9124},{level:2,title:"11.google analytics谷歌分析（需翻墙）",slug:"_11-google-analytics谷歌分析-需翻墙",normalizedTitle:"11.google analytics谷歌分析（需翻墙）",charIndex:9206},{level:3,title:"11.1.安装插件",slug:"_11-1-安装插件",normalizedTitle:"11.1.安装插件",charIndex:9239},{level:3,title:"11.2.使用插件",slug:"_11-2-使用插件",normalizedTitle:"11.2.使用插件",charIndex:9305},{level:2,title:"12.配置文件分割（方便管理）",slug:"_12-配置文件分割-方便管理",normalizedTitle:"12.配置文件分割（方便管理）",charIndex:9549},{level:2,title:"13.隐藏配置文件的私密信息",slug:"_13-隐藏配置文件的私密信息",normalizedTitle:"13.隐藏配置文件的私密信息",charIndex:11122},{level:3,title:"13.1.添加文件.vuepress/config/Secret.js",slug:"_13-1-添加文件-vuepress-config-secret-js",normalizedTitle:"13.1.添加文件.vuepress/config/secret.js",charIndex:11171},{level:3,title:"13.2..vuepress/config/pluginsConfig.js修改内容",slug:"_13-2-vuepress-config-pluginsconfig-js修改内容",normalizedTitle:"13.2..vuepress/config/pluginsconfig.js修改内容",charIndex:11422},{level:3,title:"13.3..gitignore文件",slug:"_13-3-gitignore文件",normalizedTitle:"13.3..gitignore文件",charIndex:12677}],headersStr:"1.目录结构 1.路由配置 1.1.搭建vuepress环境 2.导航栏 2.1.增加导航栏logo 2.2.导航栏链接 2.3.下拉导航栏 2.4.某些页面禁用导航栏 3.侧边栏 3.1.默认自动开启侧边栏 3.2.配置某个页面的侧边栏 4.SEC（网站个人信息设置） 5.开启博客内容更新时间 6.发布到gitee上 6.1.修改base 6.2.创建deploy.sh脚本 6.3.执行脚本即可 7.绑定域名 7.1.关闭base配置 7.2.域名解析 7.3.编辑后的静态文件推送到github上，并设置域名 8.启用PWA(离线访问等等) 8.1.安装pwa插件 8.2.导入插件 8.3.导入manifest.json和icons 8.4.vuepress/config.js导入头文件meta 9.vssue评论 9.1.安装vssue 9.2.添加插件 9.3.对应页面加上html代码 9.4.不在每个MD文件中加入的方法 10.back-to-top滚动回顶部 10.1.安装插件 10.2.添加插件 11.google analytics谷歌分析（需翻墙） 11.1.安装插件 11.2.使用插件 12.配置文件分割（方便管理） 13.隐藏配置文件的私密信息 13.1.添加文件.vuepress/config/Secret.js 13.2..vuepress/config/pluginsConfig.js修改内容 13.3..gitignore文件",content:"# vuepress搭建个人博客\n\n推荐视频：https://www.bilibili.com/video/BV1vb411m7NY?p=19&spm_id_from=pageDriver\n\n\n# 1.目录结构\n\n.\n├── docs\n│   ├── .vuepress (可选的)\n│   │   ├── components (可选的)\n│   │   ├── theme (可选的)\n│   │   │   └── Layout.vue\n│   │   ├── public (可选的)\n│   │   ├── styles (可选的)\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n│   │   ├── templates (可选的, 谨慎配置)\n│   │   │   ├── dev.html\n│   │   │   └── ssr.html\n│   │   ├── config.js (可选的)\n│   │   └── enhanceApp.js (可选的)\n│   │ \n│   ├── README.md\n│   ├── guide\n│   │   └── README.md\n│   └── config.md\n│ \n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * docs/.vuepress: 用于存放全局的配置、组件、静态资源等。\n * docs/.vuepress/components: 该目录中的 Vue 组件将会被自动注册为全局组件。\n * docs/.vuepress/theme: 用于存放本地主题。\n * docs/.vuepress/styles: 用于存放样式相关的文件。\n * docs/.vuepress/styles/index.styl: 将会被自动应用的全局样式文件，会生成在最终的 CSS 文件结尾，具有比默认样式更高的优先级。\n * docs/.vuepress/styles/palette.styl: 用于重写默认颜色常量，或者设置新的 stylus 颜色常量。\n * docs/.vuepress/public: 静态资源目录。\n * docs/.vuepress/templates: 存储 HTML 模板文件。\n * docs/.vuepress/templates/dev.html: 用于开发环境的 HTML 模板文件。\n * docs/.vuepress/templates/ssr.html: 构建时基于 Vue SSR 的 HTML 模板文件。\n * docs/.vuepress/config.js: 配置文件的入口文件，也可以是 YML 或 toml。\n * docs/.vuepress/enhanceApp.js: 客户端应用的增强。\n\n\n# 1.路由配置\n\n默认在docs/文件下面，通过README.md来配置路由设置，记得后面有个/\n\n文件的相对路径            页面路由地址\n/README.md         /\n/guide/README.md   /guide/\n/config.md         /config.html\n\n\n# 1.1.搭建vuepress环境\n\nhttps://vuepress.vuejs.org/zh/guide/getting-started.html\n\n\n# 2.导航栏\n\n创建vuepress配置文件路径：/docs/docs/.vuepress/config.js\n\n\n# 2.1.增加导航栏logo\n\n图片位置默认为公共路径：\n\n * docs/.vuepress/public: 静态资源目录。\n\nmodule.exports = {\n  themeConfig: {\n    logo: '/assets/img/logo.png',\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.2.导航栏链接\n\nmodule.exports = {\n    themeConfig: {\n      logo: '/assets/img/hero.png',\n      nav: [\n        { text: 'Home', link: '/' },\n        { text: '关于我', link: '/about/' },\n        { text: 'External', link: 'https://google.com' },\n      ]\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.3.下拉导航栏\n\nmodule.exports = {\n    themeConfig: {\n      logo: '/assets/img/hero.png',\n      nav: [\n        { text: 'Home', link: '/' },\n        { text: '关于我', link: '/about/' },\n        { text: 'External', link: 'https://google.com' },\n        {\n          text: '后端',\n          items: [\n            { text: 'Spring Boot', items: \n              [\n                { text: '服务注册', link: '/regist/' },\n                { text: '服务调用', link: '/fegin/' }\n              ] \n            },\n            { text: 'Spring Cloud', items: \n              [\n                { text: '服务注册', link: '/regist' },\n                { text: '服务调用', link: '/fegin/' }\n              ] \n            }\n          ]\n        }\n      ]\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 2.4.某些页面禁用导航栏\n\n直接在md文件加上YAML front matter 来禁用某个指定页面的导航栏：\n\n---\nnavbar: false\n---\n\n\n1\n2\n3\n\n\n\n# 3.侧边栏\n\n> 默认情况下，侧边栏会自动地显示由当前页面的标题（headers）组成的链接，并按照页面本身的结构进行嵌套，你可以通过 themeConfig.sidebarDepth 来修改它的行为。默认的深度是 1，它将提取到 h2 的标题，设置成 0 将会禁用标题（headers）链接，同时，最大的深度为 2，它将同时提取 h2 和 h3 标题。\n\n\n# 3.1.默认自动开启侧边栏\n\nh2何h3标题自动开启侧边栏\n\nmodule.exports = {\n    themeConfig: {\n      sidebar: 'auto'\n    }\n  }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.2.配置某个页面的侧边栏\n\n新建页面路径：\n\n> .\n> ├─ README.md\n> ├─ contact.md\n> ├─ about.md\n> ├─ foo/\n> │  ├─ README.md\n> │  ├─ one.md\n> │  └─ two.md\n> └─ bar/\n>    ├─ README.md\n>    ├─ three.md\n>    └─ four.md\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n\n全局配置：\n\n      sidebar: {\n        '/foo/': [\n          '',     /* /foo/ */\n          'one',  /* /foo/one.html */\n          'two'   /* /foo/two.html */\n        ],\n  \n        '/bar/': [\n          '',      /* /bar/ */\n          'three', /* /bar/three.html */\n          'four'   /* /bar/four.html */\n        ],\n  \n        // fallback\n        '/': [\n          '',        /* / */\n          'contact', /* /contact.html */\n          'about'    /* /about.html */\n        ]\n      }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 4.SEC（网站个人信息设置）\n\nmodule.exports = {\n    title:'CY的博客',\n    description:'CY的博客,王长印,个人博客',\n    head: [\n      ['link', { rel: 'icon', href: '/favicon.ico' }],\n      ['meta', { name: 'Keywords', href: 'CY的博客,王长印,个人博客' }],\n      ['meta', { name: 'author', href: '王长印' }]\n    ]\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5.开启博客内容更新时间\n\n> 使用须知\n> \n> 由于 lastUpdated 是基于 git 的, 所以你只能在一个基于 git 的项目中启用它。此外，由于使用的时间戳来自 git commit，因此它将仅在给定页的第一次提交之后显示，并且仅在该页面后续提交更改时更新。\n\nmodule.exports = {\n  themeConfig: {\n    lastUpdated: 'Last Updated', // string | boolean\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 6.发布到gitee上\n\n\n# 6.1.修改base\n\n> 在 docs/.vuepress/config.js 中设置正确的 base。\n> \n> 如果你打算发布到 https://<USERNAME>.github.io/，则可以省略这一步，因为 base 默认即是 \"/\"。\n> \n> 如果你打算发布到 https://<USERNAME>.github.io/<REPO>/（也就是说你的仓库在 https://github.com/<USERNAME>/<REPO>），则将 base 设置为 \"/<REPO>/\"。\n\n根据github上面创建的仓库名定义，方便后续通过github pages访问\n\nmodule.exports = {\n    base:'/docs/',  //网站base\n}\n\n\n1\n2\n3\n\n\n\n# 6.2.创建deploy.sh脚本\n\n在你的项目中，创建一个如下的 deploy.sh 文件（请自行判断去掉高亮行的注释）:\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run docs:build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# 如果是发布到自定义域名\n# echo 'www.example.com' > CNAME\n\ngit init\ngit add -A\ngit commit -m 'deploy'\n\n# 如果发布到 https://<USERNAME>.github.io\n# git push -f git@github.com:<USERNAME>/<USERNAME>.github.io.git master\n\n# 如果发布到 https://<USERNAME>.github.io/<REPO>  修改为自己的github页面\ngit push -f git@github.com:wangchangyin/docs.git master:gh-pages\n\ncd -\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 6.3.执行脚本即可\n\n执行方式：\n\n 1. 双击deploy.sh\n 2. 在命令窗口执行脚本\n\n\n# 7.绑定域名\n\n\n# 7.1.关闭base配置\n\nmodule.exports = {\n    // base:'/docs/',  //网站base 填写了域名，不需要此配置\n}\n\n\n1\n2\n3\n\n\n\n# 7.2.域名解析\n\n\n\n\n# 7.3.编辑后的静态文件推送到github上，并设置域名\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run docs:build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# 如果是发布到自定义域名\necho 'temp.wangchangyin.xyz' > CNAME\n\ngit init\ngit add -A\ngit commit -m 'deploy'\n\n# 如果发布到 https://<USERNAME>.github.io\n# git push -f git@github.com:<USERNAME>/<USERNAME>.github.io.git master\n\n# 如果发布到 https://<USERNAME>.github.io/<REPO>\ngit push -f git@github.com:wangchangyin/docs.git master:gh-pages\n\ncd -\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 8.启用PWA(离线访问等等)\n\n\n\n\n# 8.1.安装pwa插件\n\nnpm install -D @vuepress/plugin-pwa\n\n\n1\n\n\n\n# 8.2.导入插件\n\n   plugins: [\n      [\n        '@vuepress/pwa', {\n            serviceWorker: true,\n            updatePopup: {\n              message: \"发现新内容可用\",\n              buttonText: \"刷新\"\n            }\n        }\n      ]\n    ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 8.3.导入manifest.json和icons\n\n生成manifest.json文件地址：需翻墙\n\nhttps://app-manifest.firebaseapp.com/\n\n\n\n\n# 8.4.vuepress/config.js导入头文件meta\n\n    head: [\n      ['link', { rel: 'icon', href: '/favicon.ico' }],//网页图片\n      ['meta', { name: 'Keywords', href: 'CY的博客,王长印,个人博客' }],\n      ['meta', { name: 'author', href: '王长印' }],\n      ['link', { rel: 'manifest', href: '/manifest.json' }],\n      ['meta', { name: 'theme-color', content: '#3eaf7c' }],\n      ['meta', { name: 'apple-mobile-web-app-capable', content: 'yes' }],\n      ['meta', { name: 'apple-mobile-web-app-status-bar-style', content: 'black' }],\n      ['link', { rel: 'apple-touch-icon', href: '/icons/apple-touch-icon-152x152.png' }],\n      ['link', { rel: 'mask-icon', href: '/icons/safari-pinned-tab.svg', color: '#3eaf7c' }],\n      ['meta', { name: 'msapplication-TileImage', content: '/icons/msapplication-icon-144x144.png' }],\n      ['meta', { name: 'msapplication-TileColor', content: '#000000' }]\n    ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 9.vssue评论\n\n> vssue官网：https://vssue.js.org/zh/\n\n\n# 9.1.安装vssue\n\nnpm install @vssue/vuepress-plugin-vssue\nnpm install @vssue/api-github-v3 或者npm install @vssue/api-github-v4\n\n\n1\n2\n\n\n\n\n\n# 9.2.添加插件\n\n去https://vssue.js.org/zh/guide/github.html#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-oauth-app申请github的clientId、clientSecret\n\n\n\n> 复制 Client ID 和 Client Secret, 并设置 owner 和 repo。\n> \n> > Github repository 的 URL 模式为 https://github.com/${owner}/${repo}\n\n      //设置vssue评论\n      '@vssue/vuepress-plugin-vssue': {\n          // 设置 `platform` 而不是 `api`\n          platform: 'github-v4',\n    \n          // 其他的 Vssue 配置\n          owner: 'wangchangyin',\n          repo: 'docs',\n          clientId: '55b623aafc4fbda41ebf',\n          clientSecret: '6af6c813a72b94fe3254dfd6b21b35ad4c07f24e',\n      },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 9.3.对应页面加上html代码\n\n<Vssue />\n\n\n1\n\n\n\n# 9.4.不在每个MD文件中加入的方法\n\n> 利用vuepress主题的继承的方式：参考\n> \n> https://vuepress.vuejs.org/zh/theme/inheritance.html#%E4%BD%BF%E7%94%A8\n\n 1. 新增文件.vuepress/theme/index.js，内容如下：\n    \n    // .vuepress/theme/index.js\n    module.exports = {\n      extend: '@vuepress/theme-default'\n    }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 获取vuepress源码：把下面两个文件夹里的内容放入到.vuepress/theme/里\n    \n    \n\n 3. 修改.vuepress/theme/layouts/Layout.vue文件\n    \n      <template #top>\n        <slot name=\"page-top\" />\n      </template>\n      <template #bottom>\n        \x3c!--添加评论模板--\x3e\n        <div class=\"theme-default-content content__default\">\n          <Vssue />\n        </div>\n        <slot name=\"page-bottom\" />\n      </template>\n    \n\n\n# 10.back-to-top滚动回顶部\n\n\n# 10.1.安装插件\n\nnpm install  @vuepress/plugin-back-to-top\n\n\n1\n\n\n\n# 10.2.添加插件\n\nmodule.exports = {\n  plugins: ['@vuepress/back-to-top']\n}\n\n\n1\n2\n3\n\n\n\n# 11.google analytics谷歌分析（需翻墙）\n\n\n# 11.1.安装插件\n\nnpm install @vuepress/plugin-google-analytics\n\n\n1\n\n\n\n# 11.2.使用插件\n\n      '@vuepress/back-to-top':true,\n      '@vuepress/google-analytics':\n      {\n        'ga': 'G-PNZM9E937P' // UA-00000000-0\n      }\n\n\n1\n2\n3\n4\n5\n\n\n> 去网页https://analytics.google.com/analytics/web/：\n> \n> 创建账号=》创建媒体=》跟网站创建分析=》获取Ga\n\n\n# 12.配置文件分割（方便管理）\n\n> 配置文件过于多，不便于管理，所以拆分\n\n把head配置提出来：创建文件/.vuepress/config/headConfig.js\n\nmodule.exports=[\n    ['link', { rel: 'icon', href: '/favicon.ico' }],//网页图片\n    ['meta', { name: 'Keywords', href: 'CY的博客,王长印,个人博客' }],\n    ['meta', { name: 'author', href: '王长印' }],\n    ['link', { rel: 'manifest', href: '/manifest.json' }],\n    ['meta', { name: 'theme-color', content: '#3eaf7c' }],\n    ['meta', { name: 'apple-mobile-web-app-capable', content: 'yes' }],\n    ['meta', { name: 'apple-mobile-web-app-status-bar-style', content: 'black' }],\n    ['link', { rel: 'apple-touch-icon', href: '/icons/apple-touch-icon-152x152.png' }],\n    ['link', { rel: 'mask-icon', href: '/icons/safari-pinned-tab.svg', color: '#3eaf7c' }],\n    ['meta', { name: 'msapplication-TileImage', content: '/icons/msapplication-icon-144x144.png' }],\n    ['meta', { name: 'msapplication-TileColor', content: '#000000' }]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nvuepress的配置：\n\n//引入配置文件\nconst headConfig=require(\"./config/headConfig\");\nconst pluginsConfig=require(\"./config/pluginsConfig\");\nconst navConfig=require(\"./config/navConfig\");\nconst sidebarConfig=require(\"./config/sidebarConfig\");\n\nmodule.exports = {\n    // base:'/docs/',  //网站base 填写了域名，不需要此配置\n    title:'CY的博客',\n    description:'CY的博客,王长印,个人博客',\n    head: headConfig,\n    themeConfig: {\n      logo: '/assets/img/hero.png',\n      lastUpdated: '更新时间', // string | boolean\n      nav: navConfig,\n      // sidebar: 'auto'\n      sidebar:sidebarConfig \n    },\n    plugins:pluginsConfig \n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 13.隐藏配置文件的私密信息\n\n> 利用.gitignore文件不上传到github上方\n\n\n# 13.1.添加文件.vuepress/config/Secret.js\n\nmodule.exports = {\n    clientId: '55b623aafc4fbda41ebf', //注册的Client ID\n    clientSecret: '6af6c813a72b94fe3254dfd6b21b35ad4c07f24e', //注册的Client Secret\n    'ga': 'G-PNZM9E937P' // UA-00000000-0\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 13.2..vuepress/config/pluginsConfig.js修改内容\n\nconst secret=require(\"./Secret\");//导入隐藏文件\nmodule.exports={\n    //时间格式化\n    '@vuepress/last-updated': // \"上次更新\"时间格式\n    {\n      transformer: (timestamp, lang) => {\n        const moment = require('moment') // https://momentjs.com/\n        return moment(timestamp).format('YYYY/MM/DD, hh:mm:ss');\n      }\n    },\n    //pwa离线访问\n    '@vuepress/pwa': {\n        serviceWorker: true,\n        updatePopup: {\n          message: \"发现新内容可用\",\n          buttonText: \"刷新\"\n        }\n    },\n    //设置vssue评论\n    '@vssue/vuepress-plugin-vssue': {\n        // 设置 `platform` 而不是 `api`\n        platform: 'github-v4', //v3的platform是github，v4的是github-v4\n  \n        // 其他的 Vssue 配置\n        owner: 'wangchangyin',//github账户名\n        repo: 'docs',//github一个项目的名称\n        clientId: secret.clientId,//注册的Client ID\n        clientSecret: secret.clientSecret,//注册的Client Secret\n        autoCreateIssue:true,// 自动创建评论，默认是false，最好开启，这样首次进入页面的时候就不用去点击创建评论的按钮了。\n        locale:'zh-CN' //语言\n    },\n    //back-to-top\n    '@vuepress/back-to-top':true,\n    '@vuepress/google-analytics':\n    {\n      'ga': secret.ga // UA-00000000-0\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 13.3..gitignore文件\n\n#隐藏密钥信息\nSecret.js\n\n\n1\n2\n\n\n> 下次clone文件一定保存Secret.js文件",normalizedContent:"# vuepress搭建个人博客\n\n推荐视频：https://www.bilibili.com/video/bv1vb411m7ny?p=19&spm_id_from=pagedriver\n\n\n# 1.目录结构\n\n.\n├── docs\n│   ├── .vuepress (可选的)\n│   │   ├── components (可选的)\n│   │   ├── theme (可选的)\n│   │   │   └── layout.vue\n│   │   ├── public (可选的)\n│   │   ├── styles (可选的)\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n│   │   ├── templates (可选的, 谨慎配置)\n│   │   │   ├── dev.html\n│   │   │   └── ssr.html\n│   │   ├── config.js (可选的)\n│   │   └── enhanceapp.js (可选的)\n│   │ \n│   ├── readme.md\n│   ├── guide\n│   │   └── readme.md\n│   └── config.md\n│ \n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * docs/.vuepress: 用于存放全局的配置、组件、静态资源等。\n * docs/.vuepress/components: 该目录中的 vue 组件将会被自动注册为全局组件。\n * docs/.vuepress/theme: 用于存放本地主题。\n * docs/.vuepress/styles: 用于存放样式相关的文件。\n * docs/.vuepress/styles/index.styl: 将会被自动应用的全局样式文件，会生成在最终的 css 文件结尾，具有比默认样式更高的优先级。\n * docs/.vuepress/styles/palette.styl: 用于重写默认颜色常量，或者设置新的 stylus 颜色常量。\n * docs/.vuepress/public: 静态资源目录。\n * docs/.vuepress/templates: 存储 html 模板文件。\n * docs/.vuepress/templates/dev.html: 用于开发环境的 html 模板文件。\n * docs/.vuepress/templates/ssr.html: 构建时基于 vue ssr 的 html 模板文件。\n * docs/.vuepress/config.js: 配置文件的入口文件，也可以是 yml 或 toml。\n * docs/.vuepress/enhanceapp.js: 客户端应用的增强。\n\n\n# 1.路由配置\n\n默认在docs/文件下面，通过readme.md来配置路由设置，记得后面有个/\n\n文件的相对路径            页面路由地址\n/readme.md         /\n/guide/readme.md   /guide/\n/config.md         /config.html\n\n\n# 1.1.搭建vuepress环境\n\nhttps://vuepress.vuejs.org/zh/guide/getting-started.html\n\n\n# 2.导航栏\n\n创建vuepress配置文件路径：/docs/docs/.vuepress/config.js\n\n\n# 2.1.增加导航栏logo\n\n图片位置默认为公共路径：\n\n * docs/.vuepress/public: 静态资源目录。\n\nmodule.exports = {\n  themeconfig: {\n    logo: '/assets/img/logo.png',\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.2.导航栏链接\n\nmodule.exports = {\n    themeconfig: {\n      logo: '/assets/img/hero.png',\n      nav: [\n        { text: 'home', link: '/' },\n        { text: '关于我', link: '/about/' },\n        { text: 'external', link: 'https://google.com' },\n      ]\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.3.下拉导航栏\n\nmodule.exports = {\n    themeconfig: {\n      logo: '/assets/img/hero.png',\n      nav: [\n        { text: 'home', link: '/' },\n        { text: '关于我', link: '/about/' },\n        { text: 'external', link: 'https://google.com' },\n        {\n          text: '后端',\n          items: [\n            { text: 'spring boot', items: \n              [\n                { text: '服务注册', link: '/regist/' },\n                { text: '服务调用', link: '/fegin/' }\n              ] \n            },\n            { text: 'spring cloud', items: \n              [\n                { text: '服务注册', link: '/regist' },\n                { text: '服务调用', link: '/fegin/' }\n              ] \n            }\n          ]\n        }\n      ]\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 2.4.某些页面禁用导航栏\n\n直接在md文件加上yaml front matter 来禁用某个指定页面的导航栏：\n\n---\nnavbar: false\n---\n\n\n1\n2\n3\n\n\n\n# 3.侧边栏\n\n> 默认情况下，侧边栏会自动地显示由当前页面的标题（headers）组成的链接，并按照页面本身的结构进行嵌套，你可以通过 themeconfig.sidebardepth 来修改它的行为。默认的深度是 1，它将提取到 h2 的标题，设置成 0 将会禁用标题（headers）链接，同时，最大的深度为 2，它将同时提取 h2 和 h3 标题。\n\n\n# 3.1.默认自动开启侧边栏\n\nh2何h3标题自动开启侧边栏\n\nmodule.exports = {\n    themeconfig: {\n      sidebar: 'auto'\n    }\n  }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.2.配置某个页面的侧边栏\n\n新建页面路径：\n\n> .\n> ├─ readme.md\n> ├─ contact.md\n> ├─ about.md\n> ├─ foo/\n> │  ├─ readme.md\n> │  ├─ one.md\n> │  └─ two.md\n> └─ bar/\n>    ├─ readme.md\n>    ├─ three.md\n>    └─ four.md\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n\n全局配置：\n\n      sidebar: {\n        '/foo/': [\n          '',     /* /foo/ */\n          'one',  /* /foo/one.html */\n          'two'   /* /foo/two.html */\n        ],\n  \n        '/bar/': [\n          '',      /* /bar/ */\n          'three', /* /bar/three.html */\n          'four'   /* /bar/four.html */\n        ],\n  \n        // fallback\n        '/': [\n          '',        /* / */\n          'contact', /* /contact.html */\n          'about'    /* /about.html */\n        ]\n      }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 4.sec（网站个人信息设置）\n\nmodule.exports = {\n    title:'cy的博客',\n    description:'cy的博客,王长印,个人博客',\n    head: [\n      ['link', { rel: 'icon', href: '/favicon.ico' }],\n      ['meta', { name: 'keywords', href: 'cy的博客,王长印,个人博客' }],\n      ['meta', { name: 'author', href: '王长印' }]\n    ]\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5.开启博客内容更新时间\n\n> 使用须知\n> \n> 由于 lastupdated 是基于 git 的, 所以你只能在一个基于 git 的项目中启用它。此外，由于使用的时间戳来自 git commit，因此它将仅在给定页的第一次提交之后显示，并且仅在该页面后续提交更改时更新。\n\nmodule.exports = {\n  themeconfig: {\n    lastupdated: 'last updated', // string | boolean\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 6.发布到gitee上\n\n\n# 6.1.修改base\n\n> 在 docs/.vuepress/config.js 中设置正确的 base。\n> \n> 如果你打算发布到 https://<username>.github.io/，则可以省略这一步，因为 base 默认即是 \"/\"。\n> \n> 如果你打算发布到 https://<username>.github.io/<repo>/（也就是说你的仓库在 https://github.com/<username>/<repo>），则将 base 设置为 \"/<repo>/\"。\n\n根据github上面创建的仓库名定义，方便后续通过github pages访问\n\nmodule.exports = {\n    base:'/docs/',  //网站base\n}\n\n\n1\n2\n3\n\n\n\n# 6.2.创建deploy.sh脚本\n\n在你的项目中，创建一个如下的 deploy.sh 文件（请自行判断去掉高亮行的注释）:\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run docs:build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# 如果是发布到自定义域名\n# echo 'www.example.com' > cname\n\ngit init\ngit add -a\ngit commit -m 'deploy'\n\n# 如果发布到 https://<username>.github.io\n# git push -f git@github.com:<username>/<username>.github.io.git master\n\n# 如果发布到 https://<username>.github.io/<repo>  修改为自己的github页面\ngit push -f git@github.com:wangchangyin/docs.git master:gh-pages\n\ncd -\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 6.3.执行脚本即可\n\n执行方式：\n\n 1. 双击deploy.sh\n 2. 在命令窗口执行脚本\n\n\n# 7.绑定域名\n\n\n# 7.1.关闭base配置\n\nmodule.exports = {\n    // base:'/docs/',  //网站base 填写了域名，不需要此配置\n}\n\n\n1\n2\n3\n\n\n\n# 7.2.域名解析\n\n\n\n\n# 7.3.编辑后的静态文件推送到github上，并设置域名\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run docs:build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# 如果是发布到自定义域名\necho 'temp.wangchangyin.xyz' > cname\n\ngit init\ngit add -a\ngit commit -m 'deploy'\n\n# 如果发布到 https://<username>.github.io\n# git push -f git@github.com:<username>/<username>.github.io.git master\n\n# 如果发布到 https://<username>.github.io/<repo>\ngit push -f git@github.com:wangchangyin/docs.git master:gh-pages\n\ncd -\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 8.启用pwa(离线访问等等)\n\n\n\n\n# 8.1.安装pwa插件\n\nnpm install -d @vuepress/plugin-pwa\n\n\n1\n\n\n\n# 8.2.导入插件\n\n   plugins: [\n      [\n        '@vuepress/pwa', {\n            serviceworker: true,\n            updatepopup: {\n              message: \"发现新内容可用\",\n              buttontext: \"刷新\"\n            }\n        }\n      ]\n    ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 8.3.导入manifest.json和icons\n\n生成manifest.json文件地址：需翻墙\n\nhttps://app-manifest.firebaseapp.com/\n\n\n\n\n# 8.4.vuepress/config.js导入头文件meta\n\n    head: [\n      ['link', { rel: 'icon', href: '/favicon.ico' }],//网页图片\n      ['meta', { name: 'keywords', href: 'cy的博客,王长印,个人博客' }],\n      ['meta', { name: 'author', href: '王长印' }],\n      ['link', { rel: 'manifest', href: '/manifest.json' }],\n      ['meta', { name: 'theme-color', content: '#3eaf7c' }],\n      ['meta', { name: 'apple-mobile-web-app-capable', content: 'yes' }],\n      ['meta', { name: 'apple-mobile-web-app-status-bar-style', content: 'black' }],\n      ['link', { rel: 'apple-touch-icon', href: '/icons/apple-touch-icon-152x152.png' }],\n      ['link', { rel: 'mask-icon', href: '/icons/safari-pinned-tab.svg', color: '#3eaf7c' }],\n      ['meta', { name: 'msapplication-tileimage', content: '/icons/msapplication-icon-144x144.png' }],\n      ['meta', { name: 'msapplication-tilecolor', content: '#000000' }]\n    ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 9.vssue评论\n\n> vssue官网：https://vssue.js.org/zh/\n\n\n# 9.1.安装vssue\n\nnpm install @vssue/vuepress-plugin-vssue\nnpm install @vssue/api-github-v3 或者npm install @vssue/api-github-v4\n\n\n1\n2\n\n\n\n\n\n# 9.2.添加插件\n\n去https://vssue.js.org/zh/guide/github.html#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e6%96%b0%e7%9a%84-oauth-app申请github的clientid、clientsecret\n\n\n\n> 复制 client id 和 client secret, 并设置 owner 和 repo。\n> \n> > github repository 的 url 模式为 https://github.com/${owner}/${repo}\n\n      //设置vssue评论\n      '@vssue/vuepress-plugin-vssue': {\n          // 设置 `platform` 而不是 `api`\n          platform: 'github-v4',\n    \n          // 其他的 vssue 配置\n          owner: 'wangchangyin',\n          repo: 'docs',\n          clientid: '55b623aafc4fbda41ebf',\n          clientsecret: '6af6c813a72b94fe3254dfd6b21b35ad4c07f24e',\n      },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 9.3.对应页面加上html代码\n\n<vssue />\n\n\n1\n\n\n\n# 9.4.不在每个md文件中加入的方法\n\n> 利用vuepress主题的继承的方式：参考\n> \n> https://vuepress.vuejs.org/zh/theme/inheritance.html#%e4%bd%bf%e7%94%a8\n\n 1. 新增文件.vuepress/theme/index.js，内容如下：\n    \n    // .vuepress/theme/index.js\n    module.exports = {\n      extend: '@vuepress/theme-default'\n    }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 获取vuepress源码：把下面两个文件夹里的内容放入到.vuepress/theme/里\n    \n    \n\n 3. 修改.vuepress/theme/layouts/layout.vue文件\n    \n      <template #top>\n        <slot name=\"page-top\" />\n      </template>\n      <template #bottom>\n        \x3c!--添加评论模板--\x3e\n        <div class=\"theme-default-content content__default\">\n          <vssue />\n        </div>\n        <slot name=\"page-bottom\" />\n      </template>\n    \n\n\n# 10.back-to-top滚动回顶部\n\n\n# 10.1.安装插件\n\nnpm install  @vuepress/plugin-back-to-top\n\n\n1\n\n\n\n# 10.2.添加插件\n\nmodule.exports = {\n  plugins: ['@vuepress/back-to-top']\n}\n\n\n1\n2\n3\n\n\n\n# 11.google analytics谷歌分析（需翻墙）\n\n\n# 11.1.安装插件\n\nnpm install @vuepress/plugin-google-analytics\n\n\n1\n\n\n\n# 11.2.使用插件\n\n      '@vuepress/back-to-top':true,\n      '@vuepress/google-analytics':\n      {\n        'ga': 'g-pnzm9e937p' // ua-00000000-0\n      }\n\n\n1\n2\n3\n4\n5\n\n\n> 去网页https://analytics.google.com/analytics/web/：\n> \n> 创建账号=》创建媒体=》跟网站创建分析=》获取ga\n\n\n# 12.配置文件分割（方便管理）\n\n> 配置文件过于多，不便于管理，所以拆分\n\n把head配置提出来：创建文件/.vuepress/config/headconfig.js\n\nmodule.exports=[\n    ['link', { rel: 'icon', href: '/favicon.ico' }],//网页图片\n    ['meta', { name: 'keywords', href: 'cy的博客,王长印,个人博客' }],\n    ['meta', { name: 'author', href: '王长印' }],\n    ['link', { rel: 'manifest', href: '/manifest.json' }],\n    ['meta', { name: 'theme-color', content: '#3eaf7c' }],\n    ['meta', { name: 'apple-mobile-web-app-capable', content: 'yes' }],\n    ['meta', { name: 'apple-mobile-web-app-status-bar-style', content: 'black' }],\n    ['link', { rel: 'apple-touch-icon', href: '/icons/apple-touch-icon-152x152.png' }],\n    ['link', { rel: 'mask-icon', href: '/icons/safari-pinned-tab.svg', color: '#3eaf7c' }],\n    ['meta', { name: 'msapplication-tileimage', content: '/icons/msapplication-icon-144x144.png' }],\n    ['meta', { name: 'msapplication-tilecolor', content: '#000000' }]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nvuepress的配置：\n\n//引入配置文件\nconst headconfig=require(\"./config/headconfig\");\nconst pluginsconfig=require(\"./config/pluginsconfig\");\nconst navconfig=require(\"./config/navconfig\");\nconst sidebarconfig=require(\"./config/sidebarconfig\");\n\nmodule.exports = {\n    // base:'/docs/',  //网站base 填写了域名，不需要此配置\n    title:'cy的博客',\n    description:'cy的博客,王长印,个人博客',\n    head: headconfig,\n    themeconfig: {\n      logo: '/assets/img/hero.png',\n      lastupdated: '更新时间', // string | boolean\n      nav: navconfig,\n      // sidebar: 'auto'\n      sidebar:sidebarconfig \n    },\n    plugins:pluginsconfig \n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 13.隐藏配置文件的私密信息\n\n> 利用.gitignore文件不上传到github上方\n\n\n# 13.1.添加文件.vuepress/config/secret.js\n\nmodule.exports = {\n    clientid: '55b623aafc4fbda41ebf', //注册的client id\n    clientsecret: '6af6c813a72b94fe3254dfd6b21b35ad4c07f24e', //注册的client secret\n    'ga': 'g-pnzm9e937p' // ua-00000000-0\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 13.2..vuepress/config/pluginsconfig.js修改内容\n\nconst secret=require(\"./secret\");//导入隐藏文件\nmodule.exports={\n    //时间格式化\n    '@vuepress/last-updated': // \"上次更新\"时间格式\n    {\n      transformer: (timestamp, lang) => {\n        const moment = require('moment') // https://momentjs.com/\n        return moment(timestamp).format('yyyy/mm/dd, hh:mm:ss');\n      }\n    },\n    //pwa离线访问\n    '@vuepress/pwa': {\n        serviceworker: true,\n        updatepopup: {\n          message: \"发现新内容可用\",\n          buttontext: \"刷新\"\n        }\n    },\n    //设置vssue评论\n    '@vssue/vuepress-plugin-vssue': {\n        // 设置 `platform` 而不是 `api`\n        platform: 'github-v4', //v3的platform是github，v4的是github-v4\n  \n        // 其他的 vssue 配置\n        owner: 'wangchangyin',//github账户名\n        repo: 'docs',//github一个项目的名称\n        clientid: secret.clientid,//注册的client id\n        clientsecret: secret.clientsecret,//注册的client secret\n        autocreateissue:true,// 自动创建评论，默认是false，最好开启，这样首次进入页面的时候就不用去点击创建评论的按钮了。\n        locale:'zh-cn' //语言\n    },\n    //back-to-top\n    '@vuepress/back-to-top':true,\n    '@vuepress/google-analytics':\n    {\n      'ga': secret.ga // ua-00000000-0\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 13.3..gitignore文件\n\n#隐藏密钥信息\nsecret.js\n\n\n1\n2\n\n\n> 下次clone文件一定保存secret.js文件",charsets:{cjk:!0},lastUpdated:"2021/07/13, 18:28:04"},{title:"引入全文搜索插件fulltext-sarch",frontmatter:{title:"引入全文搜索插件fulltext-sarch",date:"2021-07-13T19:37:05.000Z",permalink:"/pages/ae1444/",categories:["技术","环境搭建","vuepress博客搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20.vuepress%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/03.%E5%BC%95%E5%85%A5%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E6%8F%92%E4%BB%B6fulltext-sarch.html",relativePath:"03.技术/07.环境搭建/20.vuepress博客搭建/03.引入全文搜索插件fulltext-sarch.md",key:"v-7a20c888",path:"/pages/ae1444/",headers:[{level:2,title:"1.安装插件",slug:"_1-安装插件",normalizedTitle:"1.安装插件",charIndex:27},{level:2,title:"2.添加插件fulltext-search",slug:"_2-添加插件fulltext-search",normalizedTitle:"2.添加插件fulltext-search",charIndex:85},{level:2,title:"3.优化",slug:"_3-优化",normalizedTitle:"3.优化",charIndex:335},{level:3,title:"3.1.高亮",slug:"_3-1-高亮",normalizedTitle:"3.1.高亮",charIndex:344},{level:3,title:"3.2.修改快捷键",slug:"_3-2-修改快捷键",normalizedTitle:"3.2.修改快捷键",charIndex:527}],headersStr:"1.安装插件 2.添加插件fulltext-search 3.优化 3.1.高亮 3.2.修改快捷键",content:'# 全文搜索插件fulltext-sarch\n\n\n# 1.安装插件\n\nnpm i vuepress-plugin-fulltext-search -D\n\n\n1\n\n\n\n# 2.添加插件fulltext-search\n\n修改docs/.vuepress/config.js文件，docs/.vuepress/config.js\n  //引入fulltext-search搜索插件\n  [\n    \'fulltext-search\'\n  ],\n\n\n1\n2\n3\n4\n5\n\n\n如果某个页面不想被搜索，可以在文档头部分添加search: false\n\n---\nsearch: false\n---\n\n\x3c!-- page content --\x3e\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.优化\n\n\n# 3.1.高亮\n\n默认情况下，搜索关键字的结果是下划线的，没有高亮。阅读下源码，可得知对搜索结果如何高亮，修改如下：\n\n修改文件.vuepress/styles/index.styl, 添加样式：高亮和加粗\n\n.suggestions .highlight{\n  color: #3eaf7c\n  font-weight: bold\n}\n\n\n1\n2\n3\n4\n\n\n\n# 3.2.修改快捷键\n\n通过源码阅读SearchBox.vue，有三个全局变量SEARCH_MAX_SUGGESTIONS,SEARCH_PATHS,SEARCH_HOTKEYS，\n\n * SEARCH_MAX_SUGGESTIONS 定义最大搜索结果数据\n * SEARCH_PATHS 搜索路径\n * SEARCH_HOTKEYS 快捷键\n\n那如何定义，才能使得三个全局变量生效了？\n\n1.自定义js文件，放到.vuepress/public/js目录下，命令为pgmanor-self.js\n\n// vuepress-plugin-fulltext-search 添加全局配置\nSEARCH_MAX_SUGGESTIONS = 10;\nSEARCH_PATHS = [];\nSEARCH_HOTKEYS = [\'s\', \'i\'];\n\n\n1\n2\n3\n4\n\n\n2.在config.js中head中，将其添加引入\n\nmodule.exports = {\n    head: [\n        // 引入自定义js\n        ["script", {"language": "javascript", "type": "text/javascript", "src": "/js/pgmanor-self.js"}]\n    ]\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 启动后，输入s或i验证，光标是否进入搜索框',normalizedContent:'# 全文搜索插件fulltext-sarch\n\n\n# 1.安装插件\n\nnpm i vuepress-plugin-fulltext-search -d\n\n\n1\n\n\n\n# 2.添加插件fulltext-search\n\n修改docs/.vuepress/config.js文件，docs/.vuepress/config.js\n  //引入fulltext-search搜索插件\n  [\n    \'fulltext-search\'\n  ],\n\n\n1\n2\n3\n4\n5\n\n\n如果某个页面不想被搜索，可以在文档头部分添加search: false\n\n---\nsearch: false\n---\n\n\x3c!-- page content --\x3e\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.优化\n\n\n# 3.1.高亮\n\n默认情况下，搜索关键字的结果是下划线的，没有高亮。阅读下源码，可得知对搜索结果如何高亮，修改如下：\n\n修改文件.vuepress/styles/index.styl, 添加样式：高亮和加粗\n\n.suggestions .highlight{\n  color: #3eaf7c\n  font-weight: bold\n}\n\n\n1\n2\n3\n4\n\n\n\n# 3.2.修改快捷键\n\n通过源码阅读searchbox.vue，有三个全局变量search_max_suggestions,search_paths,search_hotkeys，\n\n * search_max_suggestions 定义最大搜索结果数据\n * search_paths 搜索路径\n * search_hotkeys 快捷键\n\n那如何定义，才能使得三个全局变量生效了？\n\n1.自定义js文件，放到.vuepress/public/js目录下，命令为pgmanor-self.js\n\n// vuepress-plugin-fulltext-search 添加全局配置\nsearch_max_suggestions = 10;\nsearch_paths = [];\nsearch_hotkeys = [\'s\', \'i\'];\n\n\n1\n2\n3\n4\n\n\n2.在config.js中head中，将其添加引入\n\nmodule.exports = {\n    head: [\n        // 引入自定义js\n        ["script", {"language": "javascript", "type": "text/javascript", "src": "/js/pgmanor-self.js"}]\n    ]\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 启动后，输入s或i验证，光标是否进入搜索框',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"引入dynamic-title离开标签显示文字",frontmatter:{title:"引入dynamic-title离开标签显示文字",date:"2021-07-14T11:16:42.000Z",permalink:"/pages/d3988d/",categories:["技术","环境搭建","vuepress博客搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20.vuepress%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/06.%E5%BC%95%E5%85%A5dynamic-title%E7%A6%BB%E5%BC%80%E6%A0%87%E7%AD%BE%E6%98%BE%E7%A4%BA%E6%96%87%E5%AD%97.html",relativePath:"03.技术/07.环境搭建/20.vuepress博客搭建/06.引入dynamic-title离开标签显示文字.md",key:"v-46a61472",path:"/pages/d3988d/",headers:[{level:2,title:"1.安装vuepress-plugin-meting",slug:"_1-安装vuepress-plugin-meting",normalizedTitle:"1.安装vuepress-plugin-meting",charIndex:30},{level:2,title:"2.导入插件",slug:"_2-导入插件",normalizedTitle:"2.导入插件",charIndex:106}],headersStr:"1.安装vuepress-plugin-meting 2.导入插件",content:'# 引入dynamic-title离开标签显示文字\n\n\n# 1.安装vuepress-plugin-meting\n\nnpm i vuepress-plugin-dynamic-title -D\n\n\n1\n\n\n\n# 2.导入插件\n\n  //要在标签栏当时选中和离开页面时会有变化\n  [\n    "dynamic-title",\n    {\n      showIcon: "/favicon.ico",\n      showText: "(/≧▽≦/)咦！又好了！",\n      hideIcon: "/failure.ico",\n      hideText: "(●—●)喔哟，崩溃啦！",\n      recoverTime: 2000\n    }\n  ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',normalizedContent:'# 引入dynamic-title离开标签显示文字\n\n\n# 1.安装vuepress-plugin-meting\n\nnpm i vuepress-plugin-dynamic-title -d\n\n\n1\n\n\n\n# 2.导入插件\n\n  //要在标签栏当时选中和离开页面时会有变化\n  [\n    "dynamic-title",\n    {\n      showicon: "/favicon.ico",\n      showtext: "(/≧▽≦/)咦！又好了！",\n      hideicon: "/failure.ico",\n      hidetext: "(●—●)喔哟，崩溃啦！",\n      recovertime: 2000\n    }\n  ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"Vdoing主题丰富自己的笔记",frontmatter:{title:"Vdoing主题丰富自己的笔记",date:"2021-07-14T15:55:30.000Z",permalink:"/pages/599c9d/",categories:["技术","环境搭建","vuepress博客搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20.vuepress%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/20.Vdoing%E4%B8%BB%E9%A2%98%E4%B8%B0%E5%AF%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%94%E8%AE%B0.html",relativePath:"03.技术/07.环境搭建/20.vuepress博客搭建/20.Vdoing主题丰富自己的笔记.md",key:"v-7a7a5a41",path:"/pages/599c9d/",headers:[{level:2,title:"1.信息框容器",slug:"_1-信息框容器",normalizedTitle:"1.信息框容器",charIndex:122},{level:2,title:"2布局容器 v1.3.3 +",slug:"_2布局容器-v1-3-3",normalizedTitle:"2布局容器 v1.3.3 +",charIndex:417},{level:3,title:"我是居中的内容",slug:"我是居中的内容",normalizedTitle:"我是居中的内容",charIndex:454},{level:2,title:"3.普通卡片列表 v1.1.0 +",slug:"_3-普通卡片列表-v1-1-0",normalizedTitle:"3.普通卡片列表 v1.1.0 +",charIndex:1038},{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:53},{level:2,title:"4.图文卡片列表 v1.1.0 +",slug:"_4-图文卡片列表-v1-1-0",normalizedTitle:"4.图文卡片列表 v1.1.0 +",charIndex:3759},{level:3,title:"语法",slug:"语法-2",normalizedTitle:"语法",charIndex:53},{level:2,title:"5.代码块选项卡",slug:"_5-代码块选项卡",normalizedTitle:"5.代码块选项卡",charIndex:6134},{level:2,title:"6.标记",slug:"_6-标记",normalizedTitle:"6.标记",charIndex:6729}],headersStr:"1.信息框容器 2布局容器 v1.3.3 + 我是居中的内容 3.普通卡片列表 v1.1.0 + 语法 4.图文卡片列表 v1.1.0 + 语法 5.代码块选项卡 6.标记",content:"# 一.丰富自己的笔记\n\n\n# 1.markdown容器\n\nMarkdown 容器是对 Markdown 语法的一个扩展，使用简单的语法就可以在页面中呈现丰富的效果。\n\n除了原默认主题自带的容器外，本主题还新增了一些好用的自定义容器。\n\n\n# 1.信息框容器\n\n输入\n\n::: tip\n这是一条提示\n:::\n\n::: warning\n这是一条注意\n:::\n\n::: danger\n这是一条警告\n:::\n\n::: note\n这是笔记容器，在 <Badge text=\"v1.5.0 +\" /> 版本才支持哦~\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n输出\n\n提示\n\n这是一条提示\n\n注意\n\n这是一条注意\n\n警告\n\n这是一条警告\n\n笔记\n\n这是笔记容器，在 版本才支持哦~\n\n::: tip 我的提示\n自定义标题的提示框\n:::\n\n\n1\n2\n3\n\n\n我的提示\n\n自定义标题的提示框\n\n\n# 2布局容器 v1.3.3 +\n\n输入\n\n::: center\n  ### 我是居中的内容\n  （可用于标题、图片等的居中）\n:::\n\n::: right\n  [我是右浮动的内容](https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E8%BF%90%E5%8A%A8%E5%AE%9A%E5%BE%8B)\n:::\n\n::: details\n这是一个详情块，在 IE / Edge 中不生效\n```js\nconsole.log('这是一个详情块')\n```\n:::\n\n::: theorem 牛顿第一定律\n假若施加于某物体的外力为零，则该物体的运动速度不变。\n::: right\n来自 [维基百科](https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E8%BF%90%E5%8A%A8%E5%AE%9A%E5%BE%8B)\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n输出\n\n\n# 我是居中的内容\n\n（可用于标题、图片等的居中）\n\n我是右浮动的内容\n\n点击查看\n\n这是一个详情块，在 IE / Edge 中不生效\n\nconsole.log('这是一个详情块')\n\n\n1\n\n\n牛顿第一定律\n\n假若施加于某物体的外力为零，则该物体的运动速度不变。\n\n来自 维基百科\n\n\n# 3.普通卡片列表 v1.1.0 +\n\n普通卡片列表容器，可用于友情链接、项目推荐、诗词展示等。\n\n先来看看效果：\n\n输出\n\n麋鹿鲁哟\n\n大道至简，知易行难\n\nXAOXUU\n\n#IOS #Volantis主题作者\n\n平凡的你我\n\n理想成为大牛的小陈同学\n\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgColor: '#CBEAFA' # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: '#6854A1' # 可选，默认var(--textColor)\n- name: XAOXUU\n  desc: '#IOS #Volantis主题作者'\n  avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgColor: '#718971'\n  textColor: '#fff'\n- name: 平凡的你我\n  desc: 理想成为大牛的小陈同学\n  avatar: https://reinness.com/avatar.png\n  link: https://reinness.com\n  bgColor: '#FCDBA0'\n  textColor: '#A05F2C'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面效果在Markdown中的代码是这样的：\n\n输入\n\n::: cardList\n```yaml\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgColor: '#CBEAFA' # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: '#6854A1' # 可选，默认var(--textColor)\n- name: XAOXUU\n  desc: '#IOS #Volantis主题作者'\n  avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgColor: '#718971'\n  textColor: '#fff'\n- name: 平凡的你我\n  desc: 理想成为大牛的小陈同学\n  avatar: https://reinness.com/avatar.png\n  link: https://reinness.com\n  bgColor: '#FCDBA0'\n  textColor: '#A05F2C'\n```\n:::\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 语法\n\n::: cardList <每行显示数量>\n``` yaml\n- name: 名称\n  desc: 描述\n  avatar: https://xxx.jpg # 头像，可选\n  link: https://xxx/ # 链接，可选\n  bgColor: '#CBEAFA' # 背景色，可选，默认var(--bodyBg)。颜色值有#号时请添加引号\n  textColor: '#6854A1' # 文本色，可选，默认var(--textColor)\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * <每行显示数量> 数字，表示每行最多显示多少个，选值范围1~4，默认3。在小屏时会根据屏幕宽度减少每行显示数量。\n * 代码块需指定语言为yaml\n * 代码块内是一个yaml格式的数组列表\n * 数组成员的属性有：\n   * name名称\n   * desc描述\n   * avatar头像，可选\n   * link链接，可选\n   * bgColor背景色，可选，默认var(--bodyBg)。颜色值有#号时请添加引号\n   * textColor文本色，可选，默认var(--textColor)\n\n下面再来看另外一个示例：\n\n输入\n\n::: cardList 2\n```yaml\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  bgColor: '#F0DFB1'\n  textColor: '#242A38'\n- name: Vdoing\n  desc: 🚀一款简洁高效的VuePress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n输出\n\n《静夜思》\n\n床前明月光，疑是地上霜。举头望明月，低头思故乡。\n\nVdoing\n\n🚀一款简洁高效的VuePress 知识管理&博客(blog) 主题\n\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  bgColor: '#F0DFB1'\n  textColor: '#242A38'\n- name: Vdoing\n  desc: 🚀一款简洁高效的VuePress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4.图文卡片列表 v1.1.0 +\n\n图文卡片列表容器，可用于项目展示、产品展示等。\n\n先看效果：\n\n输出\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nEvan Xu\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nEvan Xu\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nEvan Xu\n\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: Evan Xu # 作者，可选\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像，可选\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Evan Xu\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Evan Xu\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n输入\n\n::: cardImgList\n```yaml\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: Evan Xu # 作者，可选\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像，可选\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Evan Xu\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Evan Xu\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 语法\n\n::: cardImgList <每行显示数量>\n``` yaml\n- img: https://xxx.jpg # 图片地址\n  link: https://xxx.com # 链接地址\n  name: 标题\n  desc: 描述 # 可选\n  author: 作者名称 # 可选\n  avatar: https://xxx.jpg # 作者头像，可选\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * <每行显示数量> 数字，表示每行最多显示多少个，选值范围1~4，默认3。在小屏时会根据屏幕宽度减少每行显示数量。\n * 代码块需指定语言为yaml\n * 代码块内是一个yaml格式的数组列表\n * 数组成员的属性有：\n   * img图片地址\n   * link链接地址\n   * name标题\n   * desc描述，可选\n   * author作者名称，可选\n   * avatar作者头像，可选\n\n\n# 5.代码块选项卡\n\n在<code-group>中嵌套<code-block>来配合使用。在<code-block>标签添加title来指定tab标题，active指定当前tab：\n\n<code-group>\n  <code-block title=\"YARN\" active>\n  ```bash\n  yarn add vuepress-theme-vdoing -D\n  ```\n  </code-block>\n\n  <code-block title=\"NPM\">\n  ```bash\n  npm install vuepress-theme-vdoing -D\n  ```\n  </code-block>\n</code-group>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n输出：\n\nyarn add vuepress-theme-vdoing -D\n\n\n1\n\n\nnpm install vuepress-theme-vdoing -D\n\n\n1\n\n\n注意\n\n * 请在<code-group>标签与markdown内容之间使用空行隔开，否则可能会解析不出来。\n * 该组件只适用于放置代码块，放其他内容在体验上并不友好。如您确实需要放置其他内容的选项卡，推荐使用vuepress-plugin-tabs (opens new window)插件。\n\n\n# 6.标记\n\n * Props:\n   * text- string\n   * type - string, 可选值： tip | warning | error，默认： tip\n   * vertical - string, 可选值： top | middle，默认： top\n * Usage:\n\n你可以在标题或其他内容中使用标记：\n\n#### 《沁园春·雪》 <Badge text=\"摘\"/>\n北国风光<Badge text=\"注释\" type=\"warning\"/>，千里冰封，万里雪飘。\n\n> <Badge text=\"译文\" type=\"error\" vertical=\"middle\"/>: 北方的风光。\n\n\n1\n2\n3\n4\n\n\n效果：\n\n# 《沁园春·雪》\n\n北国风光，千里冰封，万里雪飘。\n\n> : 北方的风光。",normalizedContent:"# 一.丰富自己的笔记\n\n\n# 1.markdown容器\n\nmarkdown 容器是对 markdown 语法的一个扩展，使用简单的语法就可以在页面中呈现丰富的效果。\n\n除了原默认主题自带的容器外，本主题还新增了一些好用的自定义容器。\n\n\n# 1.信息框容器\n\n输入\n\n::: tip\n这是一条提示\n:::\n\n::: warning\n这是一条注意\n:::\n\n::: danger\n这是一条警告\n:::\n\n::: note\n这是笔记容器，在 <badge text=\"v1.5.0 +\" /> 版本才支持哦~\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n输出\n\n提示\n\n这是一条提示\n\n注意\n\n这是一条注意\n\n警告\n\n这是一条警告\n\n笔记\n\n这是笔记容器，在 版本才支持哦~\n\n::: tip 我的提示\n自定义标题的提示框\n:::\n\n\n1\n2\n3\n\n\n我的提示\n\n自定义标题的提示框\n\n\n# 2布局容器 v1.3.3 +\n\n输入\n\n::: center\n  ### 我是居中的内容\n  （可用于标题、图片等的居中）\n:::\n\n::: right\n  [我是右浮动的内容](https://zh.wikipedia.org/wiki/%e7%89%9b%e9%a1%bf%e8%bf%90%e5%8a%a8%e5%ae%9a%e5%be%8b)\n:::\n\n::: details\n这是一个详情块，在 ie / edge 中不生效\n```js\nconsole.log('这是一个详情块')\n```\n:::\n\n::: theorem 牛顿第一定律\n假若施加于某物体的外力为零，则该物体的运动速度不变。\n::: right\n来自 [维基百科](https://zh.wikipedia.org/wiki/%e7%89%9b%e9%a1%bf%e8%bf%90%e5%8a%a8%e5%ae%9a%e5%be%8b)\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n输出\n\n\n# 我是居中的内容\n\n（可用于标题、图片等的居中）\n\n我是右浮动的内容\n\n点击查看\n\n这是一个详情块，在 ie / edge 中不生效\n\nconsole.log('这是一个详情块')\n\n\n1\n\n\n牛顿第一定律\n\n假若施加于某物体的外力为零，则该物体的运动速度不变。\n\n来自 维基百科\n\n\n# 3.普通卡片列表 v1.1.0 +\n\n普通卡片列表容器，可用于友情链接、项目推荐、诗词展示等。\n\n先来看看效果：\n\n输出\n\n麋鹿鲁哟\n\n大道至简，知易行难\n\nxaoxuu\n\n#ios #volantis主题作者\n\n平凡的你我\n\n理想成为大牛的小陈同学\n\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgcolor: '#cbeafa' # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: '#6854a1' # 可选，默认var(--textcolor)\n- name: xaoxuu\n  desc: '#ios #volantis主题作者'\n  avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgcolor: '#718971'\n  textcolor: '#fff'\n- name: 平凡的你我\n  desc: 理想成为大牛的小陈同学\n  avatar: https://reinness.com/avatar.png\n  link: https://reinness.com\n  bgcolor: '#fcdba0'\n  textcolor: '#a05f2c'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面效果在markdown中的代码是这样的：\n\n输入\n\n::: cardlist\n```yaml\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgcolor: '#cbeafa' # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: '#6854a1' # 可选，默认var(--textcolor)\n- name: xaoxuu\n  desc: '#ios #volantis主题作者'\n  avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgcolor: '#718971'\n  textcolor: '#fff'\n- name: 平凡的你我\n  desc: 理想成为大牛的小陈同学\n  avatar: https://reinness.com/avatar.png\n  link: https://reinness.com\n  bgcolor: '#fcdba0'\n  textcolor: '#a05f2c'\n```\n:::\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 语法\n\n::: cardlist <每行显示数量>\n``` yaml\n- name: 名称\n  desc: 描述\n  avatar: https://xxx.jpg # 头像，可选\n  link: https://xxx/ # 链接，可选\n  bgcolor: '#cbeafa' # 背景色，可选，默认var(--bodybg)。颜色值有#号时请添加引号\n  textcolor: '#6854a1' # 文本色，可选，默认var(--textcolor)\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * <每行显示数量> 数字，表示每行最多显示多少个，选值范围1~4，默认3。在小屏时会根据屏幕宽度减少每行显示数量。\n * 代码块需指定语言为yaml\n * 代码块内是一个yaml格式的数组列表\n * 数组成员的属性有：\n   * name名称\n   * desc描述\n   * avatar头像，可选\n   * link链接，可选\n   * bgcolor背景色，可选，默认var(--bodybg)。颜色值有#号时请添加引号\n   * textcolor文本色，可选，默认var(--textcolor)\n\n下面再来看另外一个示例：\n\n输入\n\n::: cardlist 2\n```yaml\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  bgcolor: '#f0dfb1'\n  textcolor: '#242a38'\n- name: vdoing\n  desc: 🚀一款简洁高效的vuepress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n输出\n\n《静夜思》\n\n床前明月光，疑是地上霜。举头望明月，低头思故乡。\n\nvdoing\n\n🚀一款简洁高效的vuepress 知识管理&博客(blog) 主题\n\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  bgcolor: '#f0dfb1'\n  textcolor: '#242a38'\n- name: vdoing\n  desc: 🚀一款简洁高效的vuepress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4.图文卡片列表 v1.1.0 +\n\n图文卡片列表容器，可用于项目展示、产品展示等。\n\n先看效果：\n\n输出\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nevan xu\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nevan xu\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nevan xu\n\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: evan xu # 作者，可选\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像，可选\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: evan xu\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: evan xu\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n输入\n\n::: cardimglist\n```yaml\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: evan xu # 作者，可选\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像，可选\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: evan xu\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: evan xu\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 语法\n\n::: cardimglist <每行显示数量>\n``` yaml\n- img: https://xxx.jpg # 图片地址\n  link: https://xxx.com # 链接地址\n  name: 标题\n  desc: 描述 # 可选\n  author: 作者名称 # 可选\n  avatar: https://xxx.jpg # 作者头像，可选\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * <每行显示数量> 数字，表示每行最多显示多少个，选值范围1~4，默认3。在小屏时会根据屏幕宽度减少每行显示数量。\n * 代码块需指定语言为yaml\n * 代码块内是一个yaml格式的数组列表\n * 数组成员的属性有：\n   * img图片地址\n   * link链接地址\n   * name标题\n   * desc描述，可选\n   * author作者名称，可选\n   * avatar作者头像，可选\n\n\n# 5.代码块选项卡\n\n在<code-group>中嵌套<code-block>来配合使用。在<code-block>标签添加title来指定tab标题，active指定当前tab：\n\n<code-group>\n  <code-block title=\"yarn\" active>\n  ```bash\n  yarn add vuepress-theme-vdoing -d\n  ```\n  </code-block>\n\n  <code-block title=\"npm\">\n  ```bash\n  npm install vuepress-theme-vdoing -d\n  ```\n  </code-block>\n</code-group>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n输出：\n\nyarn add vuepress-theme-vdoing -d\n\n\n1\n\n\nnpm install vuepress-theme-vdoing -d\n\n\n1\n\n\n注意\n\n * 请在<code-group>标签与markdown内容之间使用空行隔开，否则可能会解析不出来。\n * 该组件只适用于放置代码块，放其他内容在体验上并不友好。如您确实需要放置其他内容的选项卡，推荐使用vuepress-plugin-tabs (opens new window)插件。\n\n\n# 6.标记\n\n * props:\n   * text- string\n   * type - string, 可选值： tip | warning | error，默认： tip\n   * vertical - string, 可选值： top | middle，默认： top\n * usage:\n\n你可以在标题或其他内容中使用标记：\n\n#### 《沁园春·雪》 <badge text=\"摘\"/>\n北国风光<badge text=\"注释\" type=\"warning\"/>，千里冰封，万里雪飘。\n\n> <badge text=\"译文\" type=\"error\" vertical=\"middle\"/>: 北方的风光。\n\n\n1\n2\n3\n4\n\n\n效果：\n\n# 《沁园春·雪》\n\n北国风光，千里冰封，万里雪飘。\n\n> : 北方的风光。",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"若依框架笔记",frontmatter:{title:"若依框架笔记",date:"2021-07-09T15:04:05.000Z",permalink:"/pages/0d18d5/",categories:["技术","项目笔记"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/08.%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/00.%E8%8B%A5%E4%BE%9D%E7%AC%94%E8%AE%B0/00.%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0.html",relativePath:"03.技术/08.项目笔记/00.若依笔记/00.若依框架笔记.md",key:"v-76fb83c4",path:"/pages/0d18d5/",headers:[{level:2,title:"1.项目部署到阿里云内存爆满问题：",slug:"_1-项目部署到阿里云内存爆满问题",normalizedTitle:"1.项目部署到阿里云内存爆满问题：",charIndex:18},{level:2,title:"2.清除Linux内存缓存",slug:"_2-清除linux内存缓存",normalizedTitle:"2.清除linux内存缓存",charIndex:3589}],headersStr:"1.项目部署到阿里云内存爆满问题： 2.清除Linux内存缓存",content:'# 一.ruoyi框架问题\n\n\n# 1.项目部署到阿里云内存爆满问题：\n\n1.排查内存情况\n\n//发现内存只剩一点了\nfree -h \n\n\n1\n2\n\n\n2.内存占用高的前20\n\nps aux | head -1;ps aux |grep -v PID |sort -rn -k +4 | head -20\n\n\n1\n\n\n发现问题：下图莫名的植入了病毒：\n\n1.防止/tmp/watchdog --donate-level 1 -o sg.minexmr.com:443 -u 44BwEPy6EAHMgi7x2SXq1v3kdokMgKFvxfKSr5jWEY6y病毒\n\n解决：\n\n 1. 重启阿里云服务器；\n\n 2. 若依框架修改shiro的密钥：\n    \n    main函数执行即可生成\n    KeyGenerator keygen = KeyGenerator.getInstance("AES"); SecretKey deskey = keygen.generateKey(); System.out.println(Base64.encodeToString(deskey.getEncoded()));\n    \n    \n    1\n    2\n    \n\n 3. 在项目中禁止jvm命令（不推荐，加入后项目报错）\n    \n    package com.ruoyi.common.config.security;\n    \n    import com.ruoyi.common.config.RuoYiConfig;\n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n    import org.springframework.stereotype.Component;\n    import sun.reflect.Reflection;\n    \n    import javax.annotation.PostConstruct;\n    import java.security.Permission;\n    \n    /**\n     * @author hongliang\n     * 禁止java执行cmd外部命令，防止调用外部命令进行木马攻击\n     */\n    @Component\n    public class JvmExecForbid {\n        protected final Logger logger = LoggerFactory.getLogger(JvmExecForbid.class);\n    \n        @PostConstruct\n        public void init() {\n            logger.info("start JvmExecForbid!!!!");\n            forbidJvmCmd();\n        }\n    \n        /**\n         * 禁止执行java执行外部命令(Rumtine.exec)\n         * 避免被执行恶心命令\n         * https://www.anquanke.com/post/id/151398\n         */\n        public static void forbidJvmCmd() {\n    \n            // 创建自己的SecurityManager\n            SecurityManager sm = new SecurityManager() {\n                private void check(Permission perm) {\n                    // 禁止exec\n                    if (perm instanceof java.io.FilePermission) {\n                        String actions = perm.getActions();\n                        if (actions != null && actions.contains("execute")) {\n                            throw new SecurityException("execute denied! It could be a Trojan horse attack ");\n                        }\n                    }\n                    // 禁止设置新的SecurityManager，保护自己\n                    if (perm instanceof java.lang.RuntimePermission) {\n                        String name = perm.getName();\n                        if (name != null && name.contains("setSecurityManager")) {\n                            throw new SecurityException("System.setSecurityManager denied!");\n                        }\n                    }\n                }\n    \n                @Override\n                public void checkPermission(Permission perm) {\n                    check(perm);\n                }\n    \n                @Override\n                public void checkPermission(Permission perm, Object context) {\n                    check(perm);\n                }\n            };\n            System.setSecurityManager(sm);\n            //禁止反射调用绕过安全设置\n            try {\n                Class clz = Class.forName("java.lang.ProcessImpl");\n                Reflection.registerMethodsToFilter(clz, "start");\n            } catch (ClassNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    \n\n\n# 2.清除Linux内存缓存\n\necho 3 > /proc/sys/vm/drop_caches\n\n\n1\n',normalizedContent:'# 一.ruoyi框架问题\n\n\n# 1.项目部署到阿里云内存爆满问题：\n\n1.排查内存情况\n\n//发现内存只剩一点了\nfree -h \n\n\n1\n2\n\n\n2.内存占用高的前20\n\nps aux | head -1;ps aux |grep -v pid |sort -rn -k +4 | head -20\n\n\n1\n\n\n发现问题：下图莫名的植入了病毒：\n\n1.防止/tmp/watchdog --donate-level 1 -o sg.minexmr.com:443 -u 44bwepy6eahmgi7x2sxq1v3kdokmgkfvxfksr5jwey6y病毒\n\n解决：\n\n 1. 重启阿里云服务器；\n\n 2. 若依框架修改shiro的密钥：\n    \n    main函数执行即可生成\n    keygenerator keygen = keygenerator.getinstance("aes"); secretkey deskey = keygen.generatekey(); system.out.println(base64.encodetostring(deskey.getencoded()));\n    \n    \n    1\n    2\n    \n\n 3. 在项目中禁止jvm命令（不推荐，加入后项目报错）\n    \n    package com.ruoyi.common.config.security;\n    \n    import com.ruoyi.common.config.ruoyiconfig;\n    import org.slf4j.logger;\n    import org.slf4j.loggerfactory;\n    import org.springframework.stereotype.component;\n    import sun.reflect.reflection;\n    \n    import javax.annotation.postconstruct;\n    import java.security.permission;\n    \n    /**\n     * @author hongliang\n     * 禁止java执行cmd外部命令，防止调用外部命令进行木马攻击\n     */\n    @component\n    public class jvmexecforbid {\n        protected final logger logger = loggerfactory.getlogger(jvmexecforbid.class);\n    \n        @postconstruct\n        public void init() {\n            logger.info("start jvmexecforbid!!!!");\n            forbidjvmcmd();\n        }\n    \n        /**\n         * 禁止执行java执行外部命令(rumtine.exec)\n         * 避免被执行恶心命令\n         * https://www.anquanke.com/post/id/151398\n         */\n        public static void forbidjvmcmd() {\n    \n            // 创建自己的securitymanager\n            securitymanager sm = new securitymanager() {\n                private void check(permission perm) {\n                    // 禁止exec\n                    if (perm instanceof java.io.filepermission) {\n                        string actions = perm.getactions();\n                        if (actions != null && actions.contains("execute")) {\n                            throw new securityexception("execute denied! it could be a trojan horse attack ");\n                        }\n                    }\n                    // 禁止设置新的securitymanager，保护自己\n                    if (perm instanceof java.lang.runtimepermission) {\n                        string name = perm.getname();\n                        if (name != null && name.contains("setsecuritymanager")) {\n                            throw new securityexception("system.setsecuritymanager denied!");\n                        }\n                    }\n                }\n    \n                @override\n                public void checkpermission(permission perm) {\n                    check(perm);\n                }\n    \n                @override\n                public void checkpermission(permission perm, object context) {\n                    check(perm);\n                }\n            };\n            system.setsecuritymanager(sm);\n            //禁止反射调用绕过安全设置\n            try {\n                class clz = class.forname("java.lang.processimpl");\n                reflection.registermethodstofilter(clz, "start");\n            } catch (classnotfoundexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    \n\n\n# 2.清除linux内存缓存\n\necho 3 > /proc/sys/vm/drop_caches\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"vuepress编译时报错TypeError _normalized undefined的解决",frontmatter:{title:"vuepress编译时报错TypeError _normalized undefined的解决",date:"2021-08-17T10:37:55.000Z",permalink:"/pages/2c4811/",categories:["技术","环境搭建","vuepress博客搭建"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20.vuepress%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/30.vuepress%E7%BC%96%E8%AF%91%E6%97%B6%E6%8A%A5%E9%94%99TypeError%20_normalized%20undefined%E7%9A%84%E8%A7%A3%E5%86%B3.html",relativePath:"03.技术/07.环境搭建/20.vuepress博客搭建/30.vuepress编译时报错TypeError _normalized undefined的解决.md",key:"v-7e08e799",path:"/pages/2c4811/",headersStr:null,content:"部署报错信息：\n\n[Vue warn]: Invalid prop: type check failed for prop \"to\". Expected String, Object, got Undefined\n\nfound in\n\n---\x3e <RouterLink>\n       <Catalogue>\n         <Page>\n           <Anonymous>\n             <GlobalLayout>\n               <Root>\n[Vue warn]: Error in render: \"TypeError: Cannot read property '_normalized' of undefined\"\n\nfound in\n\n---\x3e <RouterLink>\n       <Catalogue>\n         <Page>\n           <Anonymous>\n             <GlobalLayout>\n               <Root>\nerror Error rendering /ops/: false\nundefined\nTypeError: Cannot read property '_normalized' of undefined\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n解决：\n\n无论我怎么调整，都无济于事，在进行了一圈又一圈百度谷歌之后仍旧没有任何线索，有的说是代码路由问题，然而我这次迁移的文章，并不涉及代码调整，昨晚还能正常编译，没道理会是代码问题。\n\n于是，在睡了一觉醒来之后，我鬼使神差得觉得会不会是一个目录里文章太多了，于是乎将某个含有一百多篇文章的子目录移动到另外一个目录下，结果竟然编译成功了。\n\n我以为真的是目录下有文章数量的限制，于是打算将大目录拆分打散，就在打散的过程中，我忽然发现，一个三级目录下，又多创建了一层目录，我猛然警醒，之前在阅读Vdoing官方文档 (opens new window)时似乎看到过说最多支持到三级目录，于是我赶忙将四级目录删除，再次编译发现不再报如上错误了。\n\n由于报错与实际问题关联度不强，因此在排查的时候花了不少的时间。",normalizedContent:"部署报错信息：\n\n[vue warn]: invalid prop: type check failed for prop \"to\". expected string, object, got undefined\n\nfound in\n\n---\x3e <routerlink>\n       <catalogue>\n         <page>\n           <anonymous>\n             <globallayout>\n               <root>\n[vue warn]: error in render: \"typeerror: cannot read property '_normalized' of undefined\"\n\nfound in\n\n---\x3e <routerlink>\n       <catalogue>\n         <page>\n           <anonymous>\n             <globallayout>\n               <root>\nerror error rendering /ops/: false\nundefined\ntypeerror: cannot read property '_normalized' of undefined\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n解决：\n\n无论我怎么调整，都无济于事，在进行了一圈又一圈百度谷歌之后仍旧没有任何线索，有的说是代码路由问题，然而我这次迁移的文章，并不涉及代码调整，昨晚还能正常编译，没道理会是代码问题。\n\n于是，在睡了一觉醒来之后，我鬼使神差得觉得会不会是一个目录里文章太多了，于是乎将某个含有一百多篇文章的子目录移动到另外一个目录下，结果竟然编译成功了。\n\n我以为真的是目录下有文章数量的限制，于是打算将大目录拆分打散，就在打散的过程中，我忽然发现，一个三级目录下，又多创建了一层目录，我猛然警醒，之前在阅读vdoing官方文档 (opens new window)时似乎看到过说最多支持到三级目录，于是我赶忙将四级目录删除，再次编译发现不再报如上错误了。\n\n由于报错与实际问题关联度不强，因此在排查的时候花了不少的时间。",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"绿色健康答疑系统",frontmatter:{title:"绿色健康答疑系统",date:"2021-07-09T15:04:05.000Z",permalink:"/pages/2ca9b2/",categories:["技术","项目笔记"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/08.%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/01.%E7%BB%BF%E8%89%B2%E5%81%A5%E5%BA%B7%E7%AD%94%E7%96%91%E7%B3%BB%E7%BB%9F.html",relativePath:"03.技术/08.项目笔记/01.绿色健康答疑系统.md",key:"v-fa94273a",path:"/pages/2ca9b2/",headers:[{level:2,title:"1.数据库类型设置longtext，查询速度慢的问题；",slug:"_1-数据库类型设置longtext-查询速度慢的问题",normalizedTitle:"1.数据库类型设置longtext，查询速度慢的问题；",charIndex:17}],headersStr:"1.数据库类型设置longtext，查询速度慢的问题；",content:"# 一.绿色健康答疑系统\n\n\n# 1.数据库类型设置longtext，查询速度慢的问题；\n\n解决：存到blob二进制中，先压缩放入数据库中，查询出来再解压\n\n> 数据库中不存longtext字段，新增blob字段，将文本在后端压缩为bytep[]存到blob二进制字段中，查询时返回。理由：zip是现在成熟的压缩算法，基于LZ77算法和哈夫曼编码，可以把文本(String)较大程度地压缩为byte[]。注：不建议再把压缩后的byte[] BASE64为String，因为BASE64是一种编码方式。",normalizedContent:"# 一.绿色健康答疑系统\n\n\n# 1.数据库类型设置longtext，查询速度慢的问题；\n\n解决：存到blob二进制中，先压缩放入数据库中，查询出来再解压\n\n> 数据库中不存longtext字段，新增blob字段，将文本在后端压缩为bytep[]存到blob二进制字段中，查询时返回。理由：zip是现在成熟的压缩算法，基于lz77算法和哈夫曼编码，可以把文本(string)较大程度地压缩为byte[]。注：不建议再把压缩后的byte[] base64为string，因为base64是一种编码方式。",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"音量调解",frontmatter:{title:"音量调解",date:"2021-07-12T16:28:00.000Z",permalink:"/pages/8945e1/",categories:["技术","谷歌插件"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/09.%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6/00.%E9%9F%B3%E9%87%8F%E8%B0%83%E8%A7%A3.html",relativePath:"03.技术/09.谷歌插件/00.音量调解.md",key:"v-6e10f0cd",path:"/pages/8945e1/",headersStr:null,content:"音量调解插件\n\n> 当我们下载好插件文件需要离线安装的时候，手动把crx文件拖动到扩展页面安装是经常的事情，但是可能碰到程序包无效:“CEX_HEADER_INVALID”的提示，下面介绍用手动加载插件文件夹的方式来解决安装问题。 手动拖放crx文件安装Chrome插件提示 程序包无效:“CEX_HEADER_INVALID”的解决办法 两步解决序包无效:“CEX_HEADER_INVALID”的问题：\n\n一、首先把需要安装的插件.crx后缀名改为rar，解压缩得到文件夹（有错误提示不用理会，选择全部替换即可），CRX其实就是一个软件文件的压缩包。\n\n手动拖放crx文件安装Chrome插件提示 程序包无效:“CEX_HEADER_INVALID”的解决办法\n\n二、打开解压得到的文件夹，把里面的”_metadata”文件夹改名为”metadata”（去掉下杠）\n\n手动拖放crx文件安装Chrome插件提示 程序包无效:“CEX_HEADER_INVALID”的解决办法\n\n手动拖放crx文件安装Chrome插件提示 程序包无效:“CEX_HEADER_INVALID”的解决办法\n\n三、进入扩展程序中心，启用开发者模式（若已经开启“开发者模式”不用理会），加载正在开发的程序包，选择刚才解压的的文件夹就安装好了。",normalizedContent:"音量调解插件\n\n> 当我们下载好插件文件需要离线安装的时候，手动把crx文件拖动到扩展页面安装是经常的事情，但是可能碰到程序包无效:“cex_header_invalid”的提示，下面介绍用手动加载插件文件夹的方式来解决安装问题。 手动拖放crx文件安装chrome插件提示 程序包无效:“cex_header_invalid”的解决办法 两步解决序包无效:“cex_header_invalid”的问题：\n\n一、首先把需要安装的插件.crx后缀名改为rar，解压缩得到文件夹（有错误提示不用理会，选择全部替换即可），crx其实就是一个软件文件的压缩包。\n\n手动拖放crx文件安装chrome插件提示 程序包无效:“cex_header_invalid”的解决办法\n\n二、打开解压得到的文件夹，把里面的”_metadata”文件夹改名为”metadata”（去掉下杠）\n\n手动拖放crx文件安装chrome插件提示 程序包无效:“cex_header_invalid”的解决办法\n\n手动拖放crx文件安装chrome插件提示 程序包无效:“cex_header_invalid”的解决办法\n\n三、进入扩展程序中心，启用开发者模式（若已经开启“开发者模式”不用理会），加载正在开发的程序包，选择刚才解压的的文件夹就安装好了。",charsets:{cjk:!0},lastUpdated:"2021/07/13, 18:28:04"},{title:"费曼学习法",frontmatter:{title:"费曼学习法",date:"2020-07-16T10:04:14.000Z",permalink:"/pages/f2a556/",categories:["更多","学习"],tags:["学习方法"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/00.%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95.html",relativePath:"04.更多/01.学习/00.费曼学习法.md",key:"v-1444ff88",path:"/pages/f2a556/",headers:[{level:3,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:102}],headersStr:"步骤",content:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。 可以说是在通过向别讲解过程中来对自身的 查缺补漏。\n\n\n# 步骤\n\n费曼学习法分为4个步骤:\n\n 1. 确定学习目标\n\n你想学习的概念、内容、主题是什么。\n\n 2. 模拟教学学习法\n\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\n\n 3. 回顾\n\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\n\n 4. 简化\n\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\n\n> 参考：\n> \n> 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\n> \n> 《费曼学习法》",normalizedContent:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。 可以说是在通过向别讲解过程中来对自身的 查缺补漏。\n\n\n# 步骤\n\n费曼学习法分为4个步骤:\n\n 1. 确定学习目标\n\n你想学习的概念、内容、主题是什么。\n\n 2. 模拟教学学习法\n\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\n\n 3. 回顾\n\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\n\n 4. 简化\n\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\n\n> 参考：\n> \n> 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\n> \n> 《费曼学习法》",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"提高学习效率的策略",frontmatter:{title:"提高学习效率的策略",date:"2020-01-04T11:54:14.000Z",permalink:"/pages/a8692ab3bdcb4588",categories:["更多","学习"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/02.%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%E7%9A%84%E7%AD%96%E7%95%A5.html",relativePath:"04.更多/01.学习/02.提高学习效率的策略.md",key:"v-4e774dac",path:"/pages/a8692ab3bdcb4588/",headers:[{level:3,title:"检索式学习",slug:"检索式学习",normalizedTitle:"检索式学习",charIndex:222},{level:3,title:"频繁的集中练习只会产生短期记忆",slug:"频繁的集中练习只会产生短期记忆",normalizedTitle:"频繁的集中练习只会产生短期记忆",charIndex:634},{level:3,title:"间隔练习使知识存储更牢固",slug:"间隔练习使知识存储更牢固",normalizedTitle:"间隔练习使知识存储更牢固",charIndex:958},{level:3,title:"穿插练习有助于长期记忆",slug:"穿插练习有助于长期记忆",normalizedTitle:"穿插练习有助于长期记忆",charIndex:1346},{level:3,title:"多样化练习促进知识的活学活用",slug:"多样化练习促进知识的活学活用",normalizedTitle:"多样化练习促进知识的活学活用",charIndex:1728},{level:3,title:"小总结",slug:"小总结",normalizedTitle:"小总结",charIndex:1918},{level:3,title:"知识的“滚雪球”效应",slug:"知识的-滚雪球-效应",normalizedTitle:"知识的“滚雪球”效应",charIndex:2183}],excerpt:'<h1 id="提高学习效率的策略"><a class="header-anchor" href="#提高学习效率的策略">#</a> 提高学习效率的策略</h1>\n<p>推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的<strong>检索练习</strong>——例如小的测试和自测，<strong>间隔练习</strong>、<strong>穿插</strong>不同但相关科目或技能的练习（<strong>多样化练习</strong>），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。</p>\n',headersStr:"检索式学习 频繁的集中练习只会产生短期记忆 间隔练习使知识存储更牢固 穿插练习有助于长期记忆 多样化练习促进知识的活学活用 小总结 知识的“滚雪球”效应",content:"# 提高学习效率的策略\n\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。\n\n\n# 检索式学习\n\n练习从记忆中检索新知识或新技能是有效的学习工具，也是保持长久记忆的有力武器。但凡需要大脑记忆、需要在将来回忆的东西，都可以用到它——对于事实、复杂的概念、解决问题的技巧、运动技能来说都适用。\n\n那么到底什么是检索式学习呢？说说我理解的检索式学习：在脑中检索知识，比如课后的一个小测试、对某个知识点用笔默写出来，甚至去参加面试，等等，都可以理解为检索式学习。\n\n努力检索有助于人们获得更好的学习效果，产生更持久的记忆。我们很容易相信，学东西时越轻松，学习效果越好，但研究表明，事实恰恰相反。只有当头脑被迫工作时，才会将所学的东西记得更牢靠。在检索时所付出的努力越大——只要真正做到这一点检索就会更好地强化你的所学。在第一次检测后，推迟后续检索练习要比立即练习更能强化记忆，因为延迟后再检索需要会费更大力气。\n\n反复检索不仅能让记忆更持久，还能让知识在更多变的环境中更容易被检索，而且可以解决更多的问题。\n\n\n# 频繁的集中练习只会产生短期记忆\n\n人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好，认为这些观点经受住了时间的考验，而且“练习，练习，再练习”的明显收效再次证明了这种方法的好处。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。形成习惯优势有种种技巧，例如有间隔的练习、有穿插内容的练习，以及多样化练习，这些技巧恰恰会放缓有明显成果的学习进程，它们不会在练习中提高我们的表现。我们从表面上看不到成绩提高，也就没有付出努力的动力（大多数人的学习心理就是这样，在看不到成果的时候容易失去动力）。填鸭式练习是集中练习的一种形式，它一直被比作贪食症——吃得不少，但没过多久基本上都吐出来了。\n\n\n# 间隔练习使知识存储更牢固\n\n把学习与练习间隔开来分期进行，让两者之间隔上一定时间，这样做就能让学习成果更加显著、记忆更加牢固，能有效地形成习惯优势。间隔多长时间才够？答案很简单：从最低限度上说，间隔的时间足够出现一点儿遗忘就对了。练习环节中间出现一点儿遗忘是好事，只要它能让人更加努力地练习就行。话说回来，你肯定不愿意忘掉太多东西，以至于检索最终变成了对资料的重新学习。间隔一段时间再练习能巩固记忆。睡眠似乎在巩固记忆的工作中扮演了重要角色，所以在两次练习间至少间隔一天应该是不错的做法。 要当心熟悉这个陷阱：你感觉自己明白了某样东西，觉得不再需要练习了。如果想走捷径，这种熟悉会让你在自测时受伤。道格拉斯·拉尔森说：“你必须自觉地说，好吧，我要强迫自己把这些全想起来，要是我想不起来，那我是忘掉了什么，我怎，么会不知道那个呢?’如果是教师出题测验，那就一下子变成你\n\n\n# 穿插练习有助于长期记忆\n\n穿插练习两样或更多的内容同样也提供了一种间隔。穿插内容练习有助于发展人们辨识不同问题的能力，也是在培养人们从不断增加的解决方案中寻找合适工具的能力。进行穿插内容练习，不能是完成一个科目的全部练习再跳到下一个科目。你需要在每个科目的练习完成前就跳到下一个科目。我们的一个朋友这样描述自己的经历，“我去上了一堂冰球课，学习滑冰、控球、射门。滑冰练习还没进行多长时间，自己刚刚有点儿上手的感觉，教练就转到控球练习上了，这让我感到非常沮丧。灰心地到家后，我说，‘为什么教练不让我们一次把技能练好呢？”其实他是遇上了少有的好教练。这位教练懂得分散精力练习不同技能要比下力气一次掌握一件事更有效果。球员感到沮丧是因为并没有在短时间内看到成果，但到下一周，无论是滑冰、控球，还是其他内容，他都会获得全面进步，效果会好于每次只专心练习一项技能。\n\n\n# 多样化练习促进知识的活学活用\n\n与穿插内容练习一样，多样化练习有助于学习者树立更开阔的心理模式。这是一种能力，掌握它的人可以评估不断变化的条件，并调整应对方式进行适应。可以说，穿插内容练习与多样化练习有助于学习者超越暂时性记忆，步入更高层次的概念性学习，并把它们应用到实际情景中，从而获得更全面、更深刻、更持久的学习效果。这些学习成果在运动技能中就表现为潜在的习惯优势。\n\n\n# 小总结\n\n有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。程序员每开发一个项目，都是一次测验，也是一次检索练习的锻炼。每次常规的拦车检查对于警察来说都是一次测验，而且每次检查都不一样，这会加强警察的外显记忆与内隐记忆。只要他上心，今后的工作就会更有效率。人们常说的一句话是“从经验中学习”。有些人似乎从来不学习，学与不学的一个区别可能就在于，人们是否培养了反思（总结）的习惯。反思（总结）是检索练习的一种形式（发生了什么？我是怎么做的？怎样才能有用？），而且辅以细化加强（下次我要采取别的什么方法？）\n\n\n# 知识的“滚雪球”效应\n\n学习的过程至少可以分成三步：最开始是对短期工作记忆中信息的编码。这时信息还没有被巩固成长期记忆中坚实的知识表征。巩固会辨识并稳定记忆线索，赋予其含义，把它们与过去的经验以及长期记忆中已经存储下来的其他知识联系起来。检索会更新所学的东西，并让你做到学以致用。\n\n学习总是建立在已知基础之上。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。\n\n长期记忆的容量基本上是无限的。你知道得越多，就越有可能为新知识建立联系。\n\n由于长期记忆的容量颇大，所以关键是要有一种能力，让你在需要的时候锁定并回忆已知。回忆所学知识的难易程度取决于对信息的重复使用（保持检索路径不会被忘却），也取决于你是否建立起了强大的检索线索，因为它能重新激活你的记忆。\n\n阶段性地检索所学，有助于强化记忆间的联系，也能强化回忆知识的线索，同时还能弱化连通冲突记忆的路径。检索练习若是没什么难度，那就不能强化所学的知识；练习难度越大，收效才越大。\n\n当你从短期记忆中回忆所学时，例如快速频繁地进行练习，是不需要花什么心思的，也不会有长期性的收效。但当你过一段时间再回忆时，当你对所学的东西有些遗忘时，你就不得不努力重建这一切。这种耗费心力的检索既能强化记忆，又能让所学再次具有可塑性，引发对所学知识的再巩固。再巩固可以用新信息更新你的记忆，同时可以将它们与最近学到的东西联系起来。\n\n重复进行费力的回忆或是练习，有助于把所学的知识整合成心智模型。在心智模型中，一套彼此相关的概念或一系列运动技能被融会贯通，形成一个有意义的整体。它能适应随后的各种环境，并发挥作用。开车时的感知和操控就是一个例子。在面对弧线球时知道如何打出全垒打也是同一个道理。\n\n练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。、\n\n试着自己想出答案，而不是坐等别人给你答案，或是在拿到解决方案前自行尝试解决一个问题，会产生更好的学习效果，也能让你把正确的答案或解决方案记得更持久。即便有时你会犯错，只要有纠正性反馈就没问题。\n\n——以上内容摘自《认知天性》，结合本人的个人理解，更多内容请查看该书籍。\n\n",normalizedContent:"# 提高学习效率的策略\n\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。\n\n\n# 检索式学习\n\n练习从记忆中检索新知识或新技能是有效的学习工具，也是保持长久记忆的有力武器。但凡需要大脑记忆、需要在将来回忆的东西，都可以用到它——对于事实、复杂的概念、解决问题的技巧、运动技能来说都适用。\n\n那么到底什么是检索式学习呢？说说我理解的检索式学习：在脑中检索知识，比如课后的一个小测试、对某个知识点用笔默写出来，甚至去参加面试，等等，都可以理解为检索式学习。\n\n努力检索有助于人们获得更好的学习效果，产生更持久的记忆。我们很容易相信，学东西时越轻松，学习效果越好，但研究表明，事实恰恰相反。只有当头脑被迫工作时，才会将所学的东西记得更牢靠。在检索时所付出的努力越大——只要真正做到这一点检索就会更好地强化你的所学。在第一次检测后，推迟后续检索练习要比立即练习更能强化记忆，因为延迟后再检索需要会费更大力气。\n\n反复检索不仅能让记忆更持久，还能让知识在更多变的环境中更容易被检索，而且可以解决更多的问题。\n\n\n# 频繁的集中练习只会产生短期记忆\n\n人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好，认为这些观点经受住了时间的考验，而且“练习，练习，再练习”的明显收效再次证明了这种方法的好处。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。形成习惯优势有种种技巧，例如有间隔的练习、有穿插内容的练习，以及多样化练习，这些技巧恰恰会放缓有明显成果的学习进程，它们不会在练习中提高我们的表现。我们从表面上看不到成绩提高，也就没有付出努力的动力（大多数人的学习心理就是这样，在看不到成果的时候容易失去动力）。填鸭式练习是集中练习的一种形式，它一直被比作贪食症——吃得不少，但没过多久基本上都吐出来了。\n\n\n# 间隔练习使知识存储更牢固\n\n把学习与练习间隔开来分期进行，让两者之间隔上一定时间，这样做就能让学习成果更加显著、记忆更加牢固，能有效地形成习惯优势。间隔多长时间才够？答案很简单：从最低限度上说，间隔的时间足够出现一点儿遗忘就对了。练习环节中间出现一点儿遗忘是好事，只要它能让人更加努力地练习就行。话说回来，你肯定不愿意忘掉太多东西，以至于检索最终变成了对资料的重新学习。间隔一段时间再练习能巩固记忆。睡眠似乎在巩固记忆的工作中扮演了重要角色，所以在两次练习间至少间隔一天应该是不错的做法。 要当心熟悉这个陷阱：你感觉自己明白了某样东西，觉得不再需要练习了。如果想走捷径，这种熟悉会让你在自测时受伤。道格拉斯·拉尔森说：“你必须自觉地说，好吧，我要强迫自己把这些全想起来，要是我想不起来，那我是忘掉了什么，我怎，么会不知道那个呢?’如果是教师出题测验，那就一下子变成你\n\n\n# 穿插练习有助于长期记忆\n\n穿插练习两样或更多的内容同样也提供了一种间隔。穿插内容练习有助于发展人们辨识不同问题的能力，也是在培养人们从不断增加的解决方案中寻找合适工具的能力。进行穿插内容练习，不能是完成一个科目的全部练习再跳到下一个科目。你需要在每个科目的练习完成前就跳到下一个科目。我们的一个朋友这样描述自己的经历，“我去上了一堂冰球课，学习滑冰、控球、射门。滑冰练习还没进行多长时间，自己刚刚有点儿上手的感觉，教练就转到控球练习上了，这让我感到非常沮丧。灰心地到家后，我说，‘为什么教练不让我们一次把技能练好呢？”其实他是遇上了少有的好教练。这位教练懂得分散精力练习不同技能要比下力气一次掌握一件事更有效果。球员感到沮丧是因为并没有在短时间内看到成果，但到下一周，无论是滑冰、控球，还是其他内容，他都会获得全面进步，效果会好于每次只专心练习一项技能。\n\n\n# 多样化练习促进知识的活学活用\n\n与穿插内容练习一样，多样化练习有助于学习者树立更开阔的心理模式。这是一种能力，掌握它的人可以评估不断变化的条件，并调整应对方式进行适应。可以说，穿插内容练习与多样化练习有助于学习者超越暂时性记忆，步入更高层次的概念性学习，并把它们应用到实际情景中，从而获得更全面、更深刻、更持久的学习效果。这些学习成果在运动技能中就表现为潜在的习惯优势。\n\n\n# 小总结\n\n有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。程序员每开发一个项目，都是一次测验，也是一次检索练习的锻炼。每次常规的拦车检查对于警察来说都是一次测验，而且每次检查都不一样，这会加强警察的外显记忆与内隐记忆。只要他上心，今后的工作就会更有效率。人们常说的一句话是“从经验中学习”。有些人似乎从来不学习，学与不学的一个区别可能就在于，人们是否培养了反思（总结）的习惯。反思（总结）是检索练习的一种形式（发生了什么？我是怎么做的？怎样才能有用？），而且辅以细化加强（下次我要采取别的什么方法？）\n\n\n# 知识的“滚雪球”效应\n\n学习的过程至少可以分成三步：最开始是对短期工作记忆中信息的编码。这时信息还没有被巩固成长期记忆中坚实的知识表征。巩固会辨识并稳定记忆线索，赋予其含义，把它们与过去的经验以及长期记忆中已经存储下来的其他知识联系起来。检索会更新所学的东西，并让你做到学以致用。\n\n学习总是建立在已知基础之上。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。\n\n长期记忆的容量基本上是无限的。你知道得越多，就越有可能为新知识建立联系。\n\n由于长期记忆的容量颇大，所以关键是要有一种能力，让你在需要的时候锁定并回忆已知。回忆所学知识的难易程度取决于对信息的重复使用（保持检索路径不会被忘却），也取决于你是否建立起了强大的检索线索，因为它能重新激活你的记忆。\n\n阶段性地检索所学，有助于强化记忆间的联系，也能强化回忆知识的线索，同时还能弱化连通冲突记忆的路径。检索练习若是没什么难度，那就不能强化所学的知识；练习难度越大，收效才越大。\n\n当你从短期记忆中回忆所学时，例如快速频繁地进行练习，是不需要花什么心思的，也不会有长期性的收效。但当你过一段时间再回忆时，当你对所学的东西有些遗忘时，你就不得不努力重建这一切。这种耗费心力的检索既能强化记忆，又能让所学再次具有可塑性，引发对所学知识的再巩固。再巩固可以用新信息更新你的记忆，同时可以将它们与最近学到的东西联系起来。\n\n重复进行费力的回忆或是练习，有助于把所学的知识整合成心智模型。在心智模型中，一套彼此相关的概念或一系列运动技能被融会贯通，形成一个有意义的整体。它能适应随后的各种环境，并发挥作用。开车时的感知和操控就是一个例子。在面对弧线球时知道如何打出全垒打也是同一个道理。\n\n练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。、\n\n试着自己想出答案，而不是坐等别人给你答案，或是在拿到解决方案前自行尝试解决一个问题，会产生更好的学习效果，也能让你把正确的答案或解决方案记得更持久。即便有时你会犯错，只要有纠正性反馈就没问题。\n\n——以上内容摘自《认知天性》，结合本人的个人理解，更多内容请查看该书籍。\n\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"笔记方法",frontmatter:{title:"笔记方法",date:"2020-07-16T11:00:55.000Z",permalink:"/pages/e60c81/",categories:["更多","学习"],tags:["笔记方法"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/01.%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95.html",relativePath:"04.更多/01.学习/01.笔记方法.md",key:"v-6ed06e8c",path:"/pages/e60c81/",headers:[{level:2,title:"康奈尔笔记法",slug:"康奈尔笔记法",normalizedTitle:"康奈尔笔记法",charIndex:2},{level:2,title:"思维导图法",slug:"思维导图法",normalizedTitle:"思维导图法",charIndex:15},{level:2,title:"金三角笔记法",slug:"金三角笔记法",normalizedTitle:"金三角笔记法",charIndex:27},{level:2,title:"曼陀罗九宫格笔记法",slug:"曼陀罗九宫格笔记法",normalizedTitle:"曼陀罗九宫格笔记法",charIndex:40},{level:2,title:"记号记录法",slug:"记号记录法",normalizedTitle:"记号记录法",charIndex:56},{level:2,title:"六色笔记法",slug:"六色笔记法",normalizedTitle:"六色笔记法",charIndex:68},{level:2,title:"加工笔记法",slug:"加工笔记法",normalizedTitle:"加工笔记法",charIndex:80},{level:2,title:"整理笔记要点1-科学标记重点",slug:"整理笔记要点1-科学标记重点",normalizedTitle:"整理笔记要点1-科学标记重点",charIndex:92},{level:2,title:"整理笔记要点2-修改不涂改",slug:"整理笔记要点2-修改不涂改",normalizedTitle:"整理笔记要点2-修改不涂改",charIndex:113}],headersStr:"康奈尔笔记法 思维导图法 金三角笔记法 曼陀罗九宫格笔记法 记号记录法 六色笔记法 加工笔记法 整理笔记要点1-科学标记重点 整理笔记要点2-修改不涂改",content:"# 康奈尔笔记法\n\n\n\n\n# 思维导图法\n\n\n\n\n# 金三角笔记法\n\n\n\n\n# 曼陀罗九宫格笔记法\n\n\n\n\n# 记号记录法\n\n\n\n\n# 六色笔记法\n\n\n\n\n# 加工笔记法\n\n\n\n\n# 整理笔记要点1-科学标记重点\n\n\n\n\n# 整理笔记要点2-修改不涂改\n\n",normalizedContent:"# 康奈尔笔记法\n\n\n\n\n# 思维导图法\n\n\n\n\n# 金三角笔记法\n\n\n\n\n# 曼陀罗九宫格笔记法\n\n\n\n\n# 记号记录法\n\n\n\n\n# 六色笔记法\n\n\n\n\n# 加工笔记法\n\n\n\n\n# 整理笔记要点1-科学标记重点\n\n\n\n\n# 整理笔记要点2-修改不涂改\n\n",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"自律小建议",frontmatter:{title:"自律小建议",date:"2020-01-03T14:35:18.000Z",permalink:"/pages/c3f302a03c8daf79",categories:["更多","学习"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/04.%E8%87%AA%E5%BE%8B%E5%B0%8F%E5%BB%BA%E8%AE%AE.html",relativePath:"04.更多/01.学习/04.自律小建议.md",key:"v-29d3ff9f",path:"/pages/c3f302a03c8daf79/",excerpt:'<h1 id="自律小建议"><a class="header-anchor" href="#自律小建议">#</a> 自律小建议</h1>\n<ul>\n<li><strong>培养专注</strong>\n<ul>\n<li>练习冥想、瑜伽等</li>\n</ul>\n</li>\n<li><strong>排除外界干扰</strong>\n<ul>\n<li>手机调到勿扰，在图书馆学习等</li>\n</ul>\n</li>\n</ul>\n',headersStr:null,content:"# 自律小建议\n\n * 培养专注\n   * 练习冥想、瑜伽等\n * 排除外界干扰\n   * 手机调到勿扰，在图书馆学习等\n\n * 规定学习时间\n   \n   * 番茄时间管理——使用番茄时间管理法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。\n     \n     > 人的大脑在记忆一个东西的时候，有短期记忆和长期记忆之分。大脑编码内容进行长期记忆，需要一个过程的，可能是几个小时或几天，集中练习就给不了这个过程，所以集中练习带来的效果是短期记忆，而进行间隔练习，大脑则有时间进行充分的编码，学习到的知识就会储存为长期记忆。\n     > \n     > 推荐几种间歇锻炼方法：体能训练、课间操、眼保操、拉伸训练...\n     > \n     > 有好的身体可以使大脑更清醒哟~\n\n * 限制娱乐时间\n   \n   * 减少使用娱乐app的时间（苹果手机可设定屏幕使用时间）\n   \n   * 推荐观看>B站某位UP主的视频《每天只看半小时手机，坚持一周后我有哪些变化？》\n\n * 戒网瘾（特别是游戏）\n   \n   * 除了手机、游戏以外，周围有很多美好的事物值得我们去关注。\n\n * 设定目标\n   \n   * 想要更好的薪水和职位？多花点时间在学习上吧~\n   * 潜意识暗示自己，建立信心，让自己变得更优秀，然后去挑战更高的目标\n\n * 优秀的人仍在不断努力\n   \n   * 且看大神 阮一峰github 提交记录",normalizedContent:"# 自律小建议\n\n * 培养专注\n   * 练习冥想、瑜伽等\n * 排除外界干扰\n   * 手机调到勿扰，在图书馆学习等\n\n * 规定学习时间\n   \n   * 番茄时间管理——使用番茄时间管理法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。\n     \n     > 人的大脑在记忆一个东西的时候，有短期记忆和长期记忆之分。大脑编码内容进行长期记忆，需要一个过程的，可能是几个小时或几天，集中练习就给不了这个过程，所以集中练习带来的效果是短期记忆，而进行间隔练习，大脑则有时间进行充分的编码，学习到的知识就会储存为长期记忆。\n     > \n     > 推荐几种间歇锻炼方法：体能训练、课间操、眼保操、拉伸训练...\n     > \n     > 有好的身体可以使大脑更清醒哟~\n\n * 限制娱乐时间\n   \n   * 减少使用娱乐app的时间（苹果手机可设定屏幕使用时间）\n   \n   * 推荐观看>b站某位up主的视频《每天只看半小时手机，坚持一周后我有哪些变化？》\n\n * 戒网瘾（特别是游戏）\n   \n   * 除了手机、游戏以外，周围有很多美好的事物值得我们去关注。\n\n * 设定目标\n   \n   * 想要更好的薪水和职位？多花点时间在学习上吧~\n   * 潜意识暗示自己，建立信心，让自己变得更优秀，然后去挑战更高的目标\n\n * 优秀的人仍在不断努力\n   \n   * 且看大神 阮一峰github 提交记录",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"搜索引擎使用技巧",frontmatter:{title:"搜索引擎使用技巧",date:"2020-05-24T11:44:19.000Z",permalink:"/pages/ce818a",categories:["更多","学习"],tags:["搜索技巧"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/10.%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html",relativePath:"04.更多/01.学习/10.搜索引擎使用技巧.md",key:"v-15feff80",path:"/pages/ce818a/",headers:[{level:3,title:"技巧1：排除干扰项",slug:"技巧1-排除干扰项",normalizedTitle:"技巧1：排除干扰项",charIndex:117},{level:3,title:"技巧2：精确搜索",slug:"技巧2-精确搜索",normalizedTitle:"技巧2：精确搜索",charIndex:263},{level:3,title:"技巧3：指定网站内搜索",slug:"技巧3-指定网站内搜索",normalizedTitle:"技巧3：指定网站内搜索",charIndex:354},{level:3,title:"技巧4：指定文件格式",slug:"技巧4-指定文件格式",normalizedTitle:"技巧4：指定文件格式",charIndex:458},{level:3,title:"技巧5：指定在标题搜索",slug:"技巧5-指定在标题搜索",normalizedTitle:"技巧5：指定在标题搜索",charIndex:544},{level:3,title:"技巧6：指定在内容中搜索",slug:"技巧6-指定在内容中搜索",normalizedTitle:"技巧6：指定在内容中搜索",charIndex:595},{level:3,title:"技巧7：多种搜索技巧叠加使用",slug:"技巧7-多种搜索技巧叠加使用",normalizedTitle:"技巧7：多种搜索技巧叠加使用",charIndex:658},{level:3,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:739}],headersStr:"技巧1：排除干扰项 技巧2：精确搜索 技巧3：指定网站内搜索 技巧4：指定文件格式 技巧5：指定在标题搜索 技巧6：指定在内容中搜索 技巧7：多种搜索技巧叠加使用 注意事项",content:'搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（\'妈~我真的是在找学习资料\'）\n\n\n# 技巧1：排除干扰项\n\n方式：关键词1+空格+减号+关键词2，即 关键词1 -关键词2\n\n功能：排除一些不想要的关键词\n\n示例：\n\n锤子 -锤子手机\n\n\n1\n\n\n示例中将在搜索结果排除与锤子手机相关的，只显示锤子本来的样子。\n\n> 经过百度搜索的测试，有的关键词能排除掉，有的并不好使\n\n\n# 技巧2：精确搜索\n\n方式：给关键词加双引号，"关键词"\n\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\n\n示例：\n\n"达拉不崩吧"\n\n\n1\n\n\n> 注意是英文的双引号\n\n\n# 技巧3：指定网站内搜索\n\n方式：site:域名 关键词\n\n功能：只搜索指定域名的内容\n\n示例：\n\nsite:zhihu.com 前端\n\n\n1\n\n\n有一些站内自带的搜索并不好用，可以尝试这个搜索技巧。\n\n\n# 技巧4：指定文件格式\n\n方式：filetype:文件格式 关键词\n\n示例：\n\nfiletype:avi 你懂的\n\n\n1\n\n\n常见文件格式有doc、pdf、ppt等\n\n\n# 技巧5：指定在标题搜索\n\n方式：intitle:关键词\n\n功能：搜索的关键词要出现在标题当中\n\n\n# 技巧6：指定在内容中搜索\n\n方式：intext:关键词、allintext:关键词1 关键词2、inurl:关键词2\n\n\n# 技巧7：多种搜索技巧叠加使用\n\n示例：\n\nsite:zhihu.com 前端 intitle:js\n\n\n1\n\n\n多种技巧和关键词叠加使用，中间空格隔开。\n\n\n# 注意事项\n\n以上搜索技巧使用的符号均是英文符号。',normalizedContent:'搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（\'妈~我真的是在找学习资料\'）\n\n\n# 技巧1：排除干扰项\n\n方式：关键词1+空格+减号+关键词2，即 关键词1 -关键词2\n\n功能：排除一些不想要的关键词\n\n示例：\n\n锤子 -锤子手机\n\n\n1\n\n\n示例中将在搜索结果排除与锤子手机相关的，只显示锤子本来的样子。\n\n> 经过百度搜索的测试，有的关键词能排除掉，有的并不好使\n\n\n# 技巧2：精确搜索\n\n方式：给关键词加双引号，"关键词"\n\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\n\n示例：\n\n"达拉不崩吧"\n\n\n1\n\n\n> 注意是英文的双引号\n\n\n# 技巧3：指定网站内搜索\n\n方式：site:域名 关键词\n\n功能：只搜索指定域名的内容\n\n示例：\n\nsite:zhihu.com 前端\n\n\n1\n\n\n有一些站内自带的搜索并不好用，可以尝试这个搜索技巧。\n\n\n# 技巧4：指定文件格式\n\n方式：filetype:文件格式 关键词\n\n示例：\n\nfiletype:avi 你懂的\n\n\n1\n\n\n常见文件格式有doc、pdf、ppt等\n\n\n# 技巧5：指定在标题搜索\n\n方式：intitle:关键词\n\n功能：搜索的关键词要出现在标题当中\n\n\n# 技巧6：指定在内容中搜索\n\n方式：intext:关键词、allintext:关键词1 关键词2、inurl:关键词2\n\n\n# 技巧7：多种搜索技巧叠加使用\n\n示例：\n\nsite:zhihu.com 前端 intitle:js\n\n\n1\n\n\n多种技巧和关键词叠加使用，中间空格隔开。\n\n\n# 注意事项\n\n以上搜索技巧使用的符号均是英文符号。',charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"提高记忆的技巧",frontmatter:{title:"提高记忆的技巧",date:"2020-01-03T14:34:48.000Z",permalink:"/pages/996822b2a2ca6e3b",categories:["更多","学习"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/03.%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E7%9A%84%E6%8A%80%E5%B7%A7.html",relativePath:"04.更多/01.学习/03.提高记忆的技巧.md",key:"v-45d858b5",path:"/pages/996822b2a2ca6e3b/",excerpt:'<h1 id="提高记忆的技巧"><a class="header-anchor" href="#提高记忆的技巧">#</a> 提高记忆的技巧</h1>\n<ol>\n<li><strong>多个感官并用</strong>\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\n</ol>\n',headersStr:null,content:"# 提高记忆的技巧\n\n 1. 多个感官并用 记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n\n 2. 重复记忆 每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\n\n 3. 建立关联 把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\n\n 4. 场景记忆 把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\n\n 5. 提出问题 每学习一个知识点，试着提问，然后给出答案。用了就记住了。",normalizedContent:"# 提高记忆的技巧\n\n 1. 多个感官并用 记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n\n 2. 重复记忆 每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\n\n 3. 建立关联 把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\n\n 4. 场景记忆 把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\n\n 5. 提出问题 每学习一个知识点，试着提问，然后给出答案。用了就记住了。",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"处理问题的思路",frontmatter:{title:"处理问题的思路",date:"2020-01-03T14:36:02.000Z",permalink:"/pages/9ba2b8fb13de1957",categories:["更多","学习"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/05.%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF.html",relativePath:"04.更多/01.学习/05.处理问题的思路.md",key:"v-c69d916e",path:"/pages/9ba2b8fb13de1957/",headers:[{level:2,title:"工作中遇到问题？",slug:"工作中遇到问题",normalizedTitle:"工作中遇到问题？",charIndex:14},{level:2,title:"这个问题我该怎么解决呢？",slug:"这个问题我该怎么解决呢",normalizedTitle:"这个问题我该怎么解决呢？",charIndex:86}],headersStr:"工作中遇到问题？ 这个问题我该怎么解决呢？",content:"# 处理问题的思路\n\n\n# 工作中遇到问题？\n\n遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢\n\n\n# 这个问题我该怎么解决呢？\n\n 1. 学会搜索\n    \n    * 关键词\n    \n    * 多关键词\n    \n    * 加入时间\n    \n    * 加入特定的社区\n    \n    * site用法\n\n 2. 高阶搜索方法\n    \n    * 英文搜索（必应搜索、google搜索，很多英文文档或文章相对来说层数结构很清晰）\n    * 视频站搜索（http://www.youtube.com/、http://egghead.io）\n    * 百度盘搜索\n    * 指定文件后缀\n\n 3. 寻求帮助\n    \n    * 找同学\n    \n    * 找同事\n    \n    * 找朋友\n    \n    * 找社区\n\n 4. 开拓思路——发散性解决问题\n    \n    * 去问问原作者？\n    * 去发个邮件/twitter/facebook?\n    * 去找Boss要资源？\n    * 加入公共社区参与讨论?\n    * ...",normalizedContent:"# 处理问题的思路\n\n\n# 工作中遇到问题？\n\n遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢\n\n\n# 这个问题我该怎么解决呢？\n\n 1. 学会搜索\n    \n    * 关键词\n    \n    * 多关键词\n    \n    * 加入时间\n    \n    * 加入特定的社区\n    \n    * site用法\n\n 2. 高阶搜索方法\n    \n    * 英文搜索（必应搜索、google搜索，很多英文文档或文章相对来说层数结构很清晰）\n    * 视频站搜索（http://www.youtube.com/、http://egghead.io）\n    * 百度盘搜索\n    * 指定文件后缀\n\n 3. 寻求帮助\n    \n    * 找同学\n    \n    * 找同事\n    \n    * 找朋友\n    \n    * 找社区\n\n 4. 开拓思路——发散性解决问题\n    \n    * 去问问原作者？\n    * 去发个邮件/twitter/facebook?\n    * 去找boss要资源？\n    * 加入公共社区参与讨论?\n    * ...",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"一个完美主义者的自我救赎",frontmatter:{title:"一个完美主义者的自我救赎",date:"2020-01-16T15:15:27.000Z",permalink:"/pages/2d615df9a36a98ed",categories:["更多","心情杂货"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/05.%E5%BF%83%E6%83%85%E6%9D%82%E8%B4%A7/01.%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E.html",relativePath:"04.更多/05.心情杂货/01.一个完美主义者的自我救赎.md",key:"v-98490bfe",path:"/pages/2d615df9a36a98ed/",excerpt:'<h1 id="一个完美主义者的自我救赎"><a class="header-anchor" href="#一个完美主义者的自我救赎">#</a> 一个完美主义者的自我救赎</h1>\n<p>最近，看到一个心理测试题是测试你是否有完美主义：</p>\n<blockquote>\n<p>（1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？</p>\n<p>（2）当一件事件做得不够好时，你是否有再试一次的想法？</p>\n<p>（3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？</p>\n<p>（4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？</p>\n<p>（5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？</p>\n</blockquote>\n<p>如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。</p>\n',headersStr:null,content:'# 一个完美主义者的自我救赎\n\n最近，看到一个心理测试题是测试你是否有完美主义：\n\n> （1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？\n> \n> （2）当一件事件做得不够好时，你是否有再试一次的想法？\n> \n> （3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？\n> \n> （4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？\n> \n> （5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？\n\n如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。\n\n对照自身，我就是那个完美主义者，时常会因为某件事做得不够好而感到痛苦，给我带来的后果就是：为了一件事想要达到“完美”的标准，付出了更多的成本，从而忽略真正需要优先处理的其他事情。最后，即使付出了成本，得到的结果也不一定是想要的"完美"。\n\n看过一篇文章，里面说到：\n\n> 完美主义是一种压力，它让你为自己创造不切实际的期望。你明明做到了正常水平，但是因为设定的目标太高，所以看上去距离目的地仍然很遥远。你的心态变成了：这一切还不够好，依然可以改进。\n> \n> 完美主义消耗了我们最宝贵的资源和时间，让你将注意力从真正的优先事项上移开。\n\n完美主义就是追求一个较高水平的目标，不接受一个较低水平的，但可用的结果。我一直告诫自己，改掉追求完美的毛病。\n\n完美主义已经对我造成了一些压力，还会妨碍我开始进入某些事情，总想着万事俱备之后才开始，结果是没有万事俱备，也没有东风，这事就搁置了。\n\n某个军事文章里说，他们特种部队的射击理念是：绝对快，相对准！\n\n> 玩吃鸡游戏似乎也是这样，需要你有快速的反应能力，不管打不打到人，先开枪再说，即使打不到也可以吓到敌人啊，哈哈哈\n\n这个理念似乎也适用于我这样的完美主义者，“做得快”比“做得好”要好，不要太执着于“完美”，就好像我开始写博客，我知道自己的写作水平并不好，但这并不妨碍我开始写博客，相信我会越写越好的~\n\n最后，心理医生也说过追求完美并不利于身心健康，不要追求完美，随心所欲地生活吧！',normalizedContent:'# 一个完美主义者的自我救赎\n\n最近，看到一个心理测试题是测试你是否有完美主义：\n\n> （1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？\n> \n> （2）当一件事件做得不够好时，你是否有再试一次的想法？\n> \n> （3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？\n> \n> （4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？\n> \n> （5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？\n\n如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。\n\n对照自身，我就是那个完美主义者，时常会因为某件事做得不够好而感到痛苦，给我带来的后果就是：为了一件事想要达到“完美”的标准，付出了更多的成本，从而忽略真正需要优先处理的其他事情。最后，即使付出了成本，得到的结果也不一定是想要的"完美"。\n\n看过一篇文章，里面说到：\n\n> 完美主义是一种压力，它让你为自己创造不切实际的期望。你明明做到了正常水平，但是因为设定的目标太高，所以看上去距离目的地仍然很遥远。你的心态变成了：这一切还不够好，依然可以改进。\n> \n> 完美主义消耗了我们最宝贵的资源和时间，让你将注意力从真正的优先事项上移开。\n\n完美主义就是追求一个较高水平的目标，不接受一个较低水平的，但可用的结果。我一直告诫自己，改掉追求完美的毛病。\n\n完美主义已经对我造成了一些压力，还会妨碍我开始进入某些事情，总想着万事俱备之后才开始，结果是没有万事俱备，也没有东风，这事就搁置了。\n\n某个军事文章里说，他们特种部队的射击理念是：绝对快，相对准！\n\n> 玩吃鸡游戏似乎也是这样，需要你有快速的反应能力，不管打不打到人，先开枪再说，即使打不到也可以吓到敌人啊，哈哈哈\n\n这个理念似乎也适用于我这样的完美主义者，“做得快”比“做得好”要好，不要太执着于“完美”，就好像我开始写博客，我知道自己的写作水平并不好，但这并不妨碍我开始写博客，相信我会越写越好的~\n\n最后，心理医生也说过追求完美并不利于身心健康，不要追求完美，随心所欲地生活吧！',charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"反向拆解让人上瘾的套路，找回自律",frontmatter:{title:"反向拆解让人上瘾的套路，找回自律",date:"2020-07-22T13:05:49.000Z",permalink:"/pages/d6d331/",categories:["更多","心情杂货"],tags:["心理","自律"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/05.%E5%BF%83%E6%83%85%E6%9D%82%E8%B4%A7/10.%E5%8F%8D%E5%90%91%E6%8B%86%E8%A7%A3%E8%AE%A9%E4%BA%BA%E4%B8%8A%E7%98%BE%E7%9A%84%E5%A5%97%E8%B7%AF%EF%BC%8C%E6%89%BE%E5%9B%9E%E8%87%AA%E5%BE%8B.html",relativePath:"04.更多/05.心情杂货/10.反向拆解让人上瘾的套路，找回自律.md",key:"v-b70d62ba",path:"/pages/d6d331/",headers:[{level:3,title:"1.诱人的目标",slug:"_1-诱人的目标",normalizedTitle:"1.诱人的目标",charIndex:451},{level:3,title:"2.无法抵挡无法预知的积极反馈",slug:"_2-无法抵挡无法预知的积极反馈",normalizedTitle:"2.无法抵挡无法预知的积极反馈",charIndex:505},{level:3,title:"3.渐进式的进步和改善的感觉",slug:"_3-渐进式的进步和改善的感觉",normalizedTitle:"3.渐进式的进步和改善的感觉",charIndex:678},{level:3,title:"4.随着时间的推移越来越困难的任务",slug:"_4-随着时间的推移越来越困难的任务",normalizedTitle:"4.随着时间的推移越来越困难的任务",charIndex:718},{level:3,title:"5.需要解决却又暂未解决的紧张感",slug:"_5-需要解决却又暂未解决的紧张感",normalizedTitle:"5.需要解决却又暂未解决的紧张感",charIndex:760},{level:3,title:"6.强大的社会联系",slug:"_6-强大的社会联系",normalizedTitle:"6.强大的社会联系",charIndex:836},{level:2,title:"找回自律，收获积极而长久的快乐",slug:"找回自律-收获积极而长久的快乐",normalizedTitle:"找回自律，收获积极而长久的快乐",charIndex:909}],excerpt:'<h1 id="反向拆解让人上瘾的套路-找回自律"><a class="header-anchor" href="#反向拆解让人上瘾的套路-找回自律">#</a> 反向拆解让人上瘾的套路，找回自律</h1>\n<p>当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&amp;AR体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？</p>\n',headersStr:"1.诱人的目标 2.无法抵挡无法预知的积极反馈 3.渐进式的进步和改善的感觉 4.随着时间的推移越来越困难的任务 5.需要解决却又暂未解决的紧张感 6.强大的社会联系 找回自律，收获积极而长久的快乐",content:"# 反向拆解让人上瘾的套路，找回自律\n\n当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&AR体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？\n\n《欲罢不能》\n\n数字时代比人类历史上的任何时代都更容易上瘾...Facebook、Instagram、网络色情、网购在下钩... 问题不出在人缺乏意志力上，而在于“屏幕那边有数千人在努力工作，为的就是破坏你的自律”\n\n来自《欲罢不能-刷屏时代如何摆脱行为上瘾》一书\n\n我们正在被一个算法和娱乐所包裹的电子'海洛因'中却不自知，想要摆脱这些上瘾行为，第一步就是反向拆解那些让我们上瘾的产品的套路。《欲罢不能》书中总结了六个让人上瘾的钩子：\n\n\n# 1.诱人的目标\n\n * 色情片\n * 游戏中成为\"王者\"、层出不穷的高颜值皮肤...\n * ...\n\n\n# 2.无法抵挡无法预知的积极反馈\n\n * 社交中的点赞功能\n * 某音十几秒一条的视频，不需要你动脑就可以轻轻松松获得哈哈大笑的快感，有时候还有一种我学习到了的感觉，你永远猜不到下一条将会出现什么惊喜。你刷的越多算法就越精准，越知道你的情绪G点在哪里，你就越容易被俘获。\n * 直播中的打赏被主播表示的感谢和送上的'么么哒'\n * ...\n\n\n# 3.渐进式的进步和改善的感觉\n\n * 游戏中的升级策略\n\n * ...\n\n\n# 4.随着时间的推移越来越困难的任务\n\n * 游戏中的升级策略\n * ...\n\n\n# 5.需要解决却又暂未解决的紧张感\n\n * 电影或电视剧结尾有意制造的一个悬念，给你一种未完成的紧张感，你迫切想知道后面会发生什么\n * ...\n\n\n# 6.强大的社会联系\n\n * 与队友相约开黑\n\n * 游戏中能彰显地位、财富、能力等的装备（如：吃鸡游戏中的玛莎拉蒂皮肤）\n\n * ...\n\n\n# 找回自律，收获积极而长久的快乐\n\n获得快乐的方式，你可以选择沉迷在你的手机里刷视频、打游戏、煲剧，毫不费力的收货大把的快乐。你还可以选择一条更难的路：选择自律、选择延迟满足、选择会让你不那么舒服的努力和成长。\n\n收获快乐的方式没有绝对的对与错，但是，如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。过后还可能让你浪费了大把时间，该做的正事没有完成，你感觉空虚、焦躁、自责... 既然如此，我们一起选择那条更难的路吧！\n\n上瘾的案例收集\n\n想想你生活中让你上瘾的案例，对照上面让人上瘾的钩子，看看是哪个钩子吧~~欢迎留言哦~",normalizedContent:"# 反向拆解让人上瘾的套路，找回自律\n\n当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&ar体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？\n\n《欲罢不能》\n\n数字时代比人类历史上的任何时代都更容易上瘾...facebook、instagram、网络色情、网购在下钩... 问题不出在人缺乏意志力上，而在于“屏幕那边有数千人在努力工作，为的就是破坏你的自律”\n\n来自《欲罢不能-刷屏时代如何摆脱行为上瘾》一书\n\n我们正在被一个算法和娱乐所包裹的电子'海洛因'中却不自知，想要摆脱这些上瘾行为，第一步就是反向拆解那些让我们上瘾的产品的套路。《欲罢不能》书中总结了六个让人上瘾的钩子：\n\n\n# 1.诱人的目标\n\n * 色情片\n * 游戏中成为\"王者\"、层出不穷的高颜值皮肤...\n * ...\n\n\n# 2.无法抵挡无法预知的积极反馈\n\n * 社交中的点赞功能\n * 某音十几秒一条的视频，不需要你动脑就可以轻轻松松获得哈哈大笑的快感，有时候还有一种我学习到了的感觉，你永远猜不到下一条将会出现什么惊喜。你刷的越多算法就越精准，越知道你的情绪g点在哪里，你就越容易被俘获。\n * 直播中的打赏被主播表示的感谢和送上的'么么哒'\n * ...\n\n\n# 3.渐进式的进步和改善的感觉\n\n * 游戏中的升级策略\n\n * ...\n\n\n# 4.随着时间的推移越来越困难的任务\n\n * 游戏中的升级策略\n * ...\n\n\n# 5.需要解决却又暂未解决的紧张感\n\n * 电影或电视剧结尾有意制造的一个悬念，给你一种未完成的紧张感，你迫切想知道后面会发生什么\n * ...\n\n\n# 6.强大的社会联系\n\n * 与队友相约开黑\n\n * 游戏中能彰显地位、财富、能力等的装备（如：吃鸡游戏中的玛莎拉蒂皮肤）\n\n * ...\n\n\n# 找回自律，收获积极而长久的快乐\n\n获得快乐的方式，你可以选择沉迷在你的手机里刷视频、打游戏、煲剧，毫不费力的收货大把的快乐。你还可以选择一条更难的路：选择自律、选择延迟满足、选择会让你不那么舒服的努力和成长。\n\n收获快乐的方式没有绝对的对与错，但是，如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。过后还可能让你浪费了大把时间，该做的正事没有完成，你感觉空虚、焦躁、自责... 既然如此，我们一起选择那条更难的路吧！\n\n上瘾的案例收集\n\n想想你生活中让你上瘾的案例，对照上面让人上瘾的钩子，看看是哪个钩子吧~~欢迎留言哦~",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"2分钟规则",frontmatter:{title:"2分钟规则",date:"2020-11-09T11:05:29.000Z",permalink:"/pages/baaa02/",categories:["更多","实用技巧"],tags:["实用技巧","文摘"]},regularPath:"/04.%E6%9B%B4%E5%A4%9A/10.%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/01.2%E5%88%86%E9%92%9F%E8%A7%84%E5%88%99.html",relativePath:"04.更多/10.实用技巧/01.2分钟规则.md",key:"v-4a693b12",path:"/pages/baaa02/",excerpt:"<p>每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。</p>\n<ul>\n<li>看一本书 → 看一页书</li>\n<li>写一篇文章 → 写一句话</li>\n<li>跑10公里 → 穿上跑鞋</li>\n<li>做100次俯卧撑 → 做1次俯卧撑</li>\n<li>多吃蔬菜水果 → 吃一个水果</li>\n<li>编写一个程序 → 编写一个函数 → 编写一行代码</li>\n</ul>\n",headersStr:null,content:"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。\n\n * 看一本书 → 看一页书\n * 写一篇文章 → 写一句话\n * 跑10公里 → 穿上跑鞋\n * 做100次俯卧撑 → 做1次俯卧撑\n * 多吃蔬菜水果 → 吃一个水果\n * 编写一个程序 → 编写一个函数 → 编写一行代码\n\n这样做的目的是使上手变得超级容易，让你先上手再说。一旦开始做了（这可能是最艰难的一步），你就会开始有动力，可能会继续做下去。\n\n * 阅读一页 → 阅读10页 → 读完第一章\n * 写一个句子 → 写文章的开头 → 写出正文\n * 穿上跑鞋 → 步行5分钟 → 跑步5分钟\n\n一旦开始，继续做下去就会容易得多。有时，你甚至会发现，自己在不知不觉间已经完成了任务。\n\n> 本文摘录自 https://hoanhan.co/2-minute-rule",normalizedContent:"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。\n\n * 看一本书 → 看一页书\n * 写一篇文章 → 写一句话\n * 跑10公里 → 穿上跑鞋\n * 做100次俯卧撑 → 做1次俯卧撑\n * 多吃蔬菜水果 → 吃一个水果\n * 编写一个程序 → 编写一个函数 → 编写一行代码\n\n这样做的目的是使上手变得超级容易，让你先上手再说。一旦开始做了（这可能是最艰难的一步），你就会开始有动力，可能会继续做下去。\n\n * 阅读一页 → 阅读10页 → 读完第一章\n * 写一个句子 → 写文章的开头 → 写出正文\n * 穿上跑鞋 → 步行5分钟 → 跑步5分钟\n\n一旦开始，继续做下去就会容易得多。有时，你甚至会发现，自己在不知不觉间已经完成了任务。\n\n> 本文摘录自 https://hoanhan.co/2-minute-rule",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"面试问题集锦",frontmatter:{title:"面试问题集锦",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/aea6571b7a8bae86",categories:["更多","面试"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/03.%E9%9D%A2%E8%AF%95/01.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6.html",relativePath:"04.更多/03.面试/01.面试问题集锦.md",key:"v-7de57f53",path:"/pages/aea6571b7a8bae86/",headers:[{level:2,title:"请做一下自我介绍",slug:"请做一下自我介绍",normalizedTitle:"请做一下自我介绍",charIndex:13},{level:2,title:"你最大的优点是什么？",slug:"你最大的优点是什么",normalizedTitle:"你最大的优点是什么？",charIndex:166},{level:2,title:"说说你最大的缺点？",slug:"说说你最大的缺点",normalizedTitle:"说说你最大的缺点？",charIndex:252},{level:2,title:"说说你对加班的看法？",slug:"说说你对加班的看法",normalizedTitle:"说说你对加班的看法？",charIndex:378},{level:2,title:"说说你对薪资的要求？",slug:"说说你对薪资的要求",normalizedTitle:"说说你对薪资的要求？",charIndex:513},{level:2,title:"在五年内，你的职业规划？",slug:"在五年内-你的职业规划",normalizedTitle:"在五年内，你的职业规划？",charIndex:903},{level:2,title:"你朋友对你的评价?",slug:"你朋友对你的评价",normalizedTitle:"你朋友对你的评价?",charIndex:1081},{level:2,title:"你还有什么问题要问吗?",slug:"你还有什么问题要问吗",normalizedTitle:"你还有什么问题要问吗?",charIndex:1241},{level:2,title:"录用后发现不适合这个职位，怎么办?",slug:"录用后发现不适合这个职位-怎么办",normalizedTitle:"录用后发现不适合这个职位，怎么办?",charIndex:1424},{level:2,title:"工作时跟领导意见不同怎么办?",slug:"工作时跟领导意见不同怎么办",normalizedTitle:"工作时跟领导意见不同怎么办?",charIndex:1601},{level:2,title:"工作出现失误并造成损失，你会怎么做?",slug:"工作出现失误并造成损失-你会怎么做",normalizedTitle:"工作出现失误并造成损失，你会怎么做?",charIndex:1779},{level:2,title:"谈谈你对跳槽的看法?",slug:"谈谈你对跳槽的看法",normalizedTitle:"谈谈你对跳槽的看法?",charIndex:2028},{level:2,title:"和同事、上司难以相处，你怎么办?",slug:"和同事、上司难以相处-你怎么办",normalizedTitle:"和同事、上司难以相处，你怎么办?",charIndex:2098},{level:2,title:"上级领导抢了你的功劳怎么办?",slug:"上级领导抢了你的功劳怎么办",normalizedTitle:"上级领导抢了你的功劳怎么办?",charIndex:2311},{level:2,title:"同事孤立你，你怎么办?",slug:"同事孤立你-你怎么办",normalizedTitle:"同事孤立你，你怎么办?",charIndex:2485},{level:2,title:"你最近是否参加了培训课程?",slug:"你最近是否参加了培训课程",normalizedTitle:"你最近是否参加了培训课程?",charIndex:2582},{level:2,title:"你对于我们公司了解多少?",slug:"你对于我们公司了解多少",normalizedTitle:"你对于我们公司了解多少?",charIndex:2636},{level:2,title:"你最擅长的技术方向是什么?",slug:"你最擅长的技术方向是什么",normalizedTitle:"你最擅长的技术方向是什么?",charIndex:2727},{level:2,title:"请说出你选择这份工作的动机?",slug:"请说出你选择这份工作的动机",normalizedTitle:"请说出你选择这份工作的动机?",charIndex:2784},{level:2,title:"你能为我们公司带来什么呢?",slug:"你能为我们公司带来什么呢",normalizedTitle:"你能为我们公司带来什么呢?",charIndex:2912},{level:2,title:"最能概括你自己的三个词?",slug:"最能概括你自己的三个词",normalizedTitle:"最能概括你自己的三个词?",charIndex:3159},{level:2,title:"作为被面试者给我打一下分?",slug:"作为被面试者给我打一下分",normalizedTitle:"作为被面试者给我打一下分?",charIndex:3225},{level:2,title:"你怎么理解你应聘的职位?",slug:"你怎么理解你应聘的职位",normalizedTitle:"你怎么理解你应聘的职位?",charIndex:3302},{level:2,title:"喜欢这份工作的哪一点?",slug:"喜欢这份工作的哪一点",normalizedTitle:"喜欢这份工作的哪一点?",charIndex:3346},{level:2,title:"为什么要离职?",slug:"为什么要离职",normalizedTitle:"为什么要离职?",charIndex:3497},{level:2,title:"说说你对行业、技术发展趋势的看法?",slug:"说说你对行业、技术发展趋势的看法",normalizedTitle:"说说你对行业、技术发展趋势的看法?",charIndex:3739},{level:2,title:"对工作的期望与目标何在?",slug:"对工作的期望与目标何在",normalizedTitle:"对工作的期望与目标何在?",charIndex:3923},{level:2,title:"谈谈你的家庭?",slug:"谈谈你的家庭",normalizedTitle:"谈谈你的家庭?",charIndex:4183},{level:2,title:"你认为自己申请这个职位还欠缺什么?",slug:"你认为自己申请这个职位还欠缺什么",normalizedTitle:"你认为自己申请这个职位还欠缺什么?",charIndex:4413},{level:2,title:"你欣赏哪种性格的人?",slug:"你欣赏哪种性格的人",normalizedTitle:"你欣赏哪种性格的人?",charIndex:4580},{level:2,title:"你通常如何处理别人的批评?",slug:"你通常如何处理别人的批评",normalizedTitle:"你通常如何处理别人的批评?",charIndex:4633},{level:2,title:"怎样对待自己的失败?",slug:"怎样对待自己的失败",normalizedTitle:"怎样对待自己的失败?",charIndex:4705},{level:2,title:"什么会让你有成就感?",slug:"什么会让你有成就感",normalizedTitle:"什么会让你有成就感?",charIndex:4761},{level:2,title:"眼下你生活中最重要的是什么?",slug:"眼下你生活中最重要的是什么",normalizedTitle:"眼下你生活中最重要的是什么?",charIndex:4805},{level:2,title:"你为什么愿意到我们公司来工作?",slug:"你为什么愿意到我们公司来工作",normalizedTitle:"你为什么愿意到我们公司来工作?",charIndex:4867},{level:2,title:"你和别人发生过争执吗?",slug:"你和别人发生过争执吗",normalizedTitle:"你和别人发生过争执吗?",charIndex:5043},{level:2,title:"你做过的哪件事最令自己感到骄傲?",slug:"你做过的哪件事最令自己感到骄傲",normalizedTitle:"你做过的哪件事最令自己感到骄傲?",charIndex:5234},{level:2,title:"对这项工作，你有哪些可预见的困难?",slug:"对这项工作-你有哪些可预见的困难",normalizedTitle:"对这项工作，你有哪些可预见的困难?",charIndex:5366},{level:2,title:"录用后你将怎样开展工作?",slug:"录用后你将怎样开展工作",normalizedTitle:"录用后你将怎样开展工作?",charIndex:5512},{level:2,title:"你希望与什么样的上级共事?",slug:"你希望与什么样的上级共事",normalizedTitle:"你希望与什么样的上级共事?",charIndex:5657},{level:2,title:"你工作经验欠缺，如何能胜任这项工作?",slug:"你工作经验欠缺-如何能胜任这项工作",normalizedTitle:"你工作经验欠缺，如何能胜任这项工作?",charIndex:5813},{level:2,title:"你会怎样获得同事的帮助?",slug:"你会怎样获得同事的帮助",normalizedTitle:"你会怎样获得同事的帮助?",charIndex:6093},{level:2,title:"如果你没被录用，你怎么打算?",slug:"如果你没被录用-你怎么打算",normalizedTitle:"如果你没被录用，你怎么打算?",charIndex:6229},{level:2,title:"最令你沮丧的事情?",slug:"最令你沮丧的事情",normalizedTitle:"最令你沮丧的事情?",charIndex:6671},{level:2,title:"想过创业吗?",slug:"想过创业吗",normalizedTitle:"想过创业吗?",charIndex:6868},{level:2,title:"为什么我们要在众多的面试者中选择你?",slug:"为什么我们要在众多的面试者中选择你",normalizedTitle:"为什么我们要在众多的面试者中选择你?",charIndex:6941},{level:2,title:"除了本公司外，还应聘了哪些公司?",slug:"除了本公司外-还应聘了哪些公司",normalizedTitle:"除了本公司外，还应聘了哪些公司?",charIndex:7126},{level:2,title:"你并非毕业于名牌院校?",slug:"你并非毕业于名牌院校",normalizedTitle:"你并非毕业于名牌院校?",charIndex:7255},{level:2,title:"怎样看待学历和能力?",slug:"怎样看待学历和能力",normalizedTitle:"怎样看待学历和能力?",charIndex:7379},{level:2,title:"谈谈如何适应办公室工作的新环境?",slug:"谈谈如何适应办公室工作的新环境",normalizedTitle:"谈谈如何适应办公室工作的新环境?",charIndex:7605},{level:2,title:"谈谈对这个职务的期许?",slug:"谈谈对这个职务的期许",normalizedTitle:"谈谈对这个职务的期许?",charIndex:7742},{level:2,title:"何时可以到职?",slug:"何时可以到职",normalizedTitle:"何时可以到职?",charIndex:7882}],headersStr:"请做一下自我介绍 你最大的优点是什么？ 说说你最大的缺点？ 说说你对加班的看法？ 说说你对薪资的要求？ 在五年内，你的职业规划？ 你朋友对你的评价? 你还有什么问题要问吗? 录用后发现不适合这个职位，怎么办? 工作时跟领导意见不同怎么办? 工作出现失误并造成损失，你会怎么做? 谈谈你对跳槽的看法? 和同事、上司难以相处，你怎么办? 上级领导抢了你的功劳怎么办? 同事孤立你，你怎么办? 你最近是否参加了培训课程? 你对于我们公司了解多少? 你最擅长的技术方向是什么? 请说出你选择这份工作的动机? 你能为我们公司带来什么呢? 最能概括你自己的三个词? 作为被面试者给我打一下分? 你怎么理解你应聘的职位? 喜欢这份工作的哪一点? 为什么要离职? 说说你对行业、技术发展趋势的看法? 对工作的期望与目标何在? 谈谈你的家庭? 你认为自己申请这个职位还欠缺什么? 你欣赏哪种性格的人? 你通常如何处理别人的批评? 怎样对待自己的失败? 什么会让你有成就感? 眼下你生活中最重要的是什么? 你为什么愿意到我们公司来工作? 你和别人发生过争执吗? 你做过的哪件事最令自己感到骄傲? 对这项工作，你有哪些可预见的困难? 录用后你将怎样开展工作? 你希望与什么样的上级共事? 你工作经验欠缺，如何能胜任这项工作? 你会怎样获得同事的帮助? 如果你没被录用，你怎么打算? 最令你沮丧的事情? 想过创业吗? 为什么我们要在众多的面试者中选择你? 除了本公司外，还应聘了哪些公司? 你并非毕业于名牌院校? 怎样看待学历和能力? 谈谈如何适应办公室工作的新环境? 谈谈对这个职务的期许? 何时可以到职?",content:"# 面试问题集锦\n\n\n# 请做一下自我介绍\n\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\n\n\n# 你最大的优点是什么？\n\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\n\n\n# 说说你最大的缺点？\n\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低，企业肯定不会录用你。要从自己的优点说起，中间加一些小缺点，最后再把问答转回到优点上，突出优点的部分。\n\n\n# 说说你对加班的看法？\n\n回答提示： 实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\n\n回答样本： 如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n\n# 说说你对薪资的要求？\n\n回答提示： 如果你对薪资的要求太低，那显然贬低自己的能力；如果你对薪资的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。\n\n回答样本：\n\n①我对工资没有硬性要求，我相信贵公司会友善合理。我注重的是找到工作机会，所以只要条件公平，我则不会计较太多。\n\n②我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n③如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场做了调查，知道像自己这样学历的雇员有什么样的价值。\n\n\n# 在五年内，你的职业规划？\n\n回答提示： 这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。当然，说出其他一些你感兴趣的职位也是可以的。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。\n\n\n# 你朋友对你的评价?\n\n回答提示： 想从侧面了解一下你的性格及与人相处的问题。\n\n回答样本：\n\n①我朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。\n\n②我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。\n\n\n# 你还有什么问题要问吗?\n\n回答提示： 企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\n\n\n# 录用后发现不适合这个职位，怎么办?\n\n回答提示： 工作一段时间发现工作不适合，有两种情况：①如果你确实热爱这个职业，那就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n\n# 工作时跟领导意见不同怎么办?\n\n回答样本： ①原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n\n# 工作出现失误并造成损失，你会怎么做?\n\n回答样本： ①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。\n\n②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，要检讨自己的工作方法、分析问题的深度和力度。\n\n\n# 谈谈你对跳槽的看法?\n\n回答样本： ①正常的“跳槽”能够促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。\n\n\n# 和同事、上司难以相处，你怎么办?\n\n回答样本： ①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我的努力。\n\n\n# 上级领导抢了你的功劳怎么办?\n\n回答样本： 首先我不会找那位上级领导说明这事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。\n\n\n# 同事孤立你，你怎么办?\n\n回答样本： ①检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。②工作中，切勿伤害别人的自尊心。③不在领导前拨弄是非。\n\n\n# 你最近是否参加了培训课程?\n\n回答提示： 自费参加，就是XX的培训课程（可以多谈谈自己学的技术）。\n\n\n# 你对于我们公司了解多少?\n\n回答提示： 在去公司面试前上网查一下该公司主营业务。可类似回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商。\n\n\n# 你最擅长的技术方向是什么?\n\n回答提示： 说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。\n\n\n# 请说出你选择这份工作的动机?\n\n回答提示： 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n回答样本： 因为我很热爱这个工作，很想从事这方面的工作。\n\n\n# 你能为我们公司带来什么呢?\n\n回答提示： ①假如你可以的话，试着告诉他们你可以减低他们的费用“我已经接受过XX近两年专业的培训，立刻就可以上岗工作”。②企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后表示：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。” 等等。\n\n\n# 最能概括你自己的三个词?\n\n回答样本： 我经常用的三个词是：适应能力强，有责任心和做事有始终，并结合具体例子向主考官解释。\n\n\n# 作为被面试者给我打一下分?\n\n回答提示： 试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。\n\n\n# 你怎么理解你应聘的职位?\n\n回答提示： 可以把岗位职责和任务及工作态度阐述下。\n\n\n# 喜欢这份工作的哪一点?\n\n回答提示： 在回答面试官这个问题时不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。\n\n\n# 为什么要离职?\n\n回答提示： ①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会。\n\n\n# 说说你对行业、技术发展趋势的看法?\n\n回答提示： 企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。\n\n\n# 对工作的期望与目标何在?\n\n回答提示： 这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。 对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。” 其他类的工作也可以比照这个方式回答，只要在目标方面稍微修改一下就可以了。\n\n\n# 谈谈你的家庭?\n\n回答提示： 企业面试时询问家庭问题不是非要知道求职者家庭的情况，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。\n\n回答样本： 我很爱我的家庭，我们家一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。\n\n\n# 你认为自己申请这个职位还欠缺什么?\n\n回答提示： 企业喜欢问求职者弱点，但精明的求职者一般不直接回答。\n\n回答样本： 继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。\n\n\n# 你欣赏哪种性格的人?\n\n回答提示： 诚实、不死板而且容易相处的人、有实际行动的人，加上具体例子。\n\n\n# 你通常如何处理别人的批评?\n\n回答提示： ①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷静下来再讨论。\n\n\n# 怎样对待自己的失败?\n\n回答提示： 大意：我们生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n\n# 什么会让你有成就感?\n\n回答提示： 为贵公司竭力效劳，尽我所能，完成一个项目。\n\n\n# 眼下你生活中最重要的是什么?\n\n回答提示： 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。\n\n\n# 你为什么愿意到我们公司来工作?\n\n回答提示： 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因。\n\n回答样本： ①公司本身高技术开发环境很吸引我我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。②你们公司一直都稳定发展，在近几年来在市场上有竞争力。我认为贵公司能够给我提供一个与众不同的发展道路。\n\n\n# 你和别人发生过争执吗?\n\n回答提示： 这是面试中最险恶的问题，其实是考官布下的一个陷阱，成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n\n# 你做过的哪件事最令自己感到骄傲?\n\n回答提示： 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。\n\n\n# 对这项工作，你有哪些可预见的困难?\n\n回答提示： ①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\n\n\n# 录用后你将怎样开展工作?\n\n回答提示： ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。\n\n\n# 你希望与什么样的上级共事?\n\n回答提示： ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。\n\n\n# 你工作经验欠缺，如何能胜任这项工作?\n\n回答提示： ①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎经验，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。\n\n回答样本： 作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。\n\n\n# 你会怎样获得同事的帮助?\n\n回答提示： 每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n\n# 如果你没被录用，你怎么打算?\n\n回答样本： 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距正确对自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，以后如果有机会我仍然后再次参加竞争。\n\n\n# 最令你沮丧的事情?\n\n回答样本： 曾经接触过一个客户，原本就有耳闻他以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。\n\n\n# 想过创业吗?\n\n回答提示： 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢?\n\n\n# 为什么我们要在众多的面试者中选择你?\n\n回答提示： 别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。\n\n回答样本： 根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、EQ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。\n\n\n# 除了本公司外，还应聘了哪些公司?\n\n回答提示： 这是相当多公司会问的问题，其用意是要概略知道应征者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n\n# 你并非毕业于名牌院校?\n\n回答样本： 是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我接受了XX的职业培训，掌握的技能完全可以胜任贵公司现在工作，而且我比一些名牌院校的应届毕业生的动手能力还要强，我想我更适合贵公司这个职位。\n\n\n# 怎样看待学历和能力?\n\n回答样本： 学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果公司把学历卡在博士上我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢?\n\n\n# 谈谈如何适应办公室工作的新环境?\n\n回答样本： ①办公室里每个人都有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n\n# 谈谈对这个职务的期许?\n\n回答提示： 回答前不妨先询问公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n回答样本： 希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造双赢的局面。\n\n\n# 何时可以到职?\n\n回答提示： 大多数企业会关心就职时间，最好是回答：“如果被录用的话，到职日可以按公司规定上班”，但是如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。",normalizedContent:"# 面试问题集锦\n\n\n# 请做一下自我介绍\n\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\n\n\n# 你最大的优点是什么？\n\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在xx经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\n\n\n# 说说你最大的缺点？\n\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低，企业肯定不会录用你。要从自己的优点说起，中间加一些小缺点，最后再把问答转回到优点上，突出优点的部分。\n\n\n# 说说你对加班的看法？\n\n回答提示： 实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\n\n回答样本： 如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n\n# 说说你对薪资的要求？\n\n回答提示： 如果你对薪资的要求太低，那显然贬低自己的能力；如果你对薪资的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。\n\n回答样本：\n\n①我对工资没有硬性要求，我相信贵公司会友善合理。我注重的是找到工作机会，所以只要条件公平，我则不会计较太多。\n\n②我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n③如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场做了调查，知道像自己这样学历的雇员有什么样的价值。\n\n\n# 在五年内，你的职业规划？\n\n回答提示： 这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。当然，说出其他一些你感兴趣的职位也是可以的。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。\n\n\n# 你朋友对你的评价?\n\n回答提示： 想从侧面了解一下你的性格及与人相处的问题。\n\n回答样本：\n\n①我朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。\n\n②我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。\n\n\n# 你还有什么问题要问吗?\n\n回答提示： 企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\n\n\n# 录用后发现不适合这个职位，怎么办?\n\n回答提示： 工作一段时间发现工作不适合，有两种情况：①如果你确实热爱这个职业，那就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n\n# 工作时跟领导意见不同怎么办?\n\n回答样本： ①原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n\n# 工作出现失误并造成损失，你会怎么做?\n\n回答样本： ①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。\n\n②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，要检讨自己的工作方法、分析问题的深度和力度。\n\n\n# 谈谈你对跳槽的看法?\n\n回答样本： ①正常的“跳槽”能够促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。\n\n\n# 和同事、上司难以相处，你怎么办?\n\n回答样本： ①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我的努力。\n\n\n# 上级领导抢了你的功劳怎么办?\n\n回答样本： 首先我不会找那位上级领导说明这事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。\n\n\n# 同事孤立你，你怎么办?\n\n回答样本： ①检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。②工作中，切勿伤害别人的自尊心。③不在领导前拨弄是非。\n\n\n# 你最近是否参加了培训课程?\n\n回答提示： 自费参加，就是xx的培训课程（可以多谈谈自己学的技术）。\n\n\n# 你对于我们公司了解多少?\n\n回答提示： 在去公司面试前上网查一下该公司主营业务。可类似回答：贵公司有意改变策略，加强与国外大厂的oem合作，自有品牌的部分则透过海外经销商。\n\n\n# 你最擅长的技术方向是什么?\n\n回答提示： 说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。\n\n\n# 请说出你选择这份工作的动机?\n\n回答提示： 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n回答样本： 因为我很热爱这个工作，很想从事这方面的工作。\n\n\n# 你能为我们公司带来什么呢?\n\n回答提示： ①假如你可以的话，试着告诉他们你可以减低他们的费用“我已经接受过xx近两年专业的培训，立刻就可以上岗工作”。②企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后表示：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。” 等等。\n\n\n# 最能概括你自己的三个词?\n\n回答样本： 我经常用的三个词是：适应能力强，有责任心和做事有始终，并结合具体例子向主考官解释。\n\n\n# 作为被面试者给我打一下分?\n\n回答提示： 试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。\n\n\n# 你怎么理解你应聘的职位?\n\n回答提示： 可以把岗位职责和任务及工作态度阐述下。\n\n\n# 喜欢这份工作的哪一点?\n\n回答提示： 在回答面试官这个问题时不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。\n\n\n# 为什么要离职?\n\n回答提示： ①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会。\n\n\n# 说说你对行业、技术发展趋势的看法?\n\n回答提示： 企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。\n\n\n# 对工作的期望与目标何在?\n\n回答提示： 这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。 对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。” 其他类的工作也可以比照这个方式回答，只要在目标方面稍微修改一下就可以了。\n\n\n# 谈谈你的家庭?\n\n回答提示： 企业面试时询问家庭问题不是非要知道求职者家庭的情况，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。\n\n回答样本： 我很爱我的家庭，我们家一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。\n\n\n# 你认为自己申请这个职位还欠缺什么?\n\n回答提示： 企业喜欢问求职者弱点，但精明的求职者一般不直接回答。\n\n回答样本： 继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。\n\n\n# 你欣赏哪种性格的人?\n\n回答提示： 诚实、不死板而且容易相处的人、有实际行动的人，加上具体例子。\n\n\n# 你通常如何处理别人的批评?\n\n回答提示： ①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷静下来再讨论。\n\n\n# 怎样对待自己的失败?\n\n回答提示： 大意：我们生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n\n# 什么会让你有成就感?\n\n回答提示： 为贵公司竭力效劳，尽我所能，完成一个项目。\n\n\n# 眼下你生活中最重要的是什么?\n\n回答提示： 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。\n\n\n# 你为什么愿意到我们公司来工作?\n\n回答提示： 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因。\n\n回答样本： ①公司本身高技术开发环境很吸引我我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。②你们公司一直都稳定发展，在近几年来在市场上有竞争力。我认为贵公司能够给我提供一个与众不同的发展道路。\n\n\n# 你和别人发生过争执吗?\n\n回答提示： 这是面试中最险恶的问题，其实是考官布下的一个陷阱，成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n\n# 你做过的哪件事最令自己感到骄傲?\n\n回答提示： 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。\n\n\n# 对这项工作，你有哪些可预见的困难?\n\n回答提示： ①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\n\n\n# 录用后你将怎样开展工作?\n\n回答提示： ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。\n\n\n# 你希望与什么样的上级共事?\n\n回答提示： ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。\n\n\n# 你工作经验欠缺，如何能胜任这项工作?\n\n回答提示： ①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎经验，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。\n\n回答样本： 作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。\n\n\n# 你会怎样获得同事的帮助?\n\n回答提示： 每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n\n# 如果你没被录用，你怎么打算?\n\n回答样本： 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距正确对自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，以后如果有机会我仍然后再次参加竞争。\n\n\n# 最令你沮丧的事情?\n\n回答样本： 曾经接触过一个客户，原本就有耳闻他以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。\n\n\n# 想过创业吗?\n\n回答提示： 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢?\n\n\n# 为什么我们要在众多的面试者中选择你?\n\n回答提示： 别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。\n\n回答样本： 根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、eq上，也有圆融、成熟的一面，和主管、同事都能合作愉快。\n\n\n# 除了本公司外，还应聘了哪些公司?\n\n回答提示： 这是相当多公司会问的问题，其用意是要概略知道应征者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n\n# 你并非毕业于名牌院校?\n\n回答样本： 是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我接受了xx的职业培训，掌握的技能完全可以胜任贵公司现在工作，而且我比一些名牌院校的应届毕业生的动手能力还要强，我想我更适合贵公司这个职位。\n\n\n# 怎样看待学历和能力?\n\n回答样本： 学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果公司把学历卡在博士上我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢?\n\n\n# 谈谈如何适应办公室工作的新环境?\n\n回答样本： ①办公室里每个人都有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n\n# 谈谈对这个职务的期许?\n\n回答提示： 回答前不妨先询问公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n回答样本： 希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造双赢的局面。\n\n\n# 何时可以到职?\n\n回答提示： 大多数企业会关心就职时间，最好是回答：“如果被录用的话，到职日可以按公司规定上班”，但是如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"友情链接",frontmatter:{title:"友情链接",date:"2019-12-25T14:27:01.000Z",permalink:"/friends",article:!1,sidebar:!1},regularPath:"/04.%E6%9B%B4%E5%A4%9A/99.%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5.html",relativePath:"04.更多/99.友情链接.md",key:"v-a0b08d08",path:"/friends/",headers:[{level:3,title:"友链申请",slug:"友链申请",normalizedTitle:"友链申请",charIndex:4494}],headersStr:"友链申请",content:"麋鹿鲁哟\n\n大道至简，知易行难\n\nXAOXUU\n\n#IOS #Volantis主题作者\n\nlookroot的个人空间\n\n寻求理想和显示的平衡\n\n平凡的你我\n\n理想成为大牛的\n小陈同学\n\nznote\n\n荷尽已无擎雨盖，\n菊残犹有傲霜枝。\n\n全栈软件开发直通车\n\n全栈软件开发技术博客，\n从小白到大神!\n\n易良同学的博客\n\n正在努力！\n\n永远的救赎者\n\n知者减半，省者全无。\n\n辰旭博客\n\n凤鸣初阳，百鸟朝凰\n\nJokerM's Palace\n\nTake your heart\n\nSaul.J.Wu\n\n立身之本，不在高低。\n\n杨庭培的博客\n\n太平世界，环球同此凉热。\n\nLake's blog\n\n不积跬步，无以至千里；不积小流，无以成江海。\n\nCubik65536's blog\n\nRECOMMENDED BY DR.CREATIVE\n\nx·π\n\n为开发者量身制作的技术博客和知识库管理平台。\n\n眼里有光\n\n道阻且长，行则将至\n\nHeo\n\n爱折腾的设计师\n\nChuyuxuan\n\n临渊羡鱼，不如退而结网\n\n全栈杂货站\n\n千里万里杂货站里，天青色等烟雨，而我在等你。\n\n小鱼博客\n\n总是半途而废的废柴\n\n大胡子\n\n记录你我，分享精彩。\n\n嘟先生学WebGL\n\n流水不争先，争的是滔滔不绝。\n\n嶋屿麋鹿\n\n小鹿的知识库\n\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgColor: '#CBEAFA' # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: '#6854A1' # 可选，默认var(--textColor)\n- name: XAOXUU\n  desc: '#IOS #Volantis主题作者'\n  avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgColor: '#B9D59C'\n  textColor: '#3B551F'\n- name: lookroot的个人空间\n  desc: 寻求理想和显示的平衡\n  avatar: https://www.lookroot.cn/logo.png\n  link: https://www.lookroot.cn/\n  bgColor: '#B7DBFF'\n  textColor: '#294D71'\n- name: 平凡的你我\n  desc: 理想成为大牛的<br/>小陈同学\n  avatar: https://reinness.com/static/avatar.png\n  link: https://reinness.com\n  bgColor: '#FFE5B4'\n  textColor: '#A05F2C'\n- name: znote\n  desc: 荷尽已无擎雨盖，<br/>菊残犹有傲霜枝。\n  avatar: https://zpj80231.gitee.io/znote/vuepress/head-fish.jpg\n  link: https://zpj80231.gitee.io/znote/\n  bgColor: '#FCE5BF'\n  textColor: '#7B2532'\n- name: 全栈软件开发直通车\n  desc: 全栈软件开发技术博客，<br/>从小白到大神!\n  avatar: https://gitee.com/wangshibiao/blog_picBed2/raw/master/images/20200806151030.png\n  link: https://sofineday.com\n  bgColor: '#FBEBEC'\n  textColor: '#603420'\n- name: 易良同学的博客\n  desc: 正在努力！\n  avatar: https://yiliang.site/assets/images/avatar.jpeg\n  link: https://yiliang.site\n  bgColor: '#FFEFE2'\n  textColor: '#A05F2C'\n- name: 永远的救赎者\n  desc: 知者减半，省者全无。\n  avatar: https://i.loli.net/2020/08/10/PkQMGL6pATW1vBg.jpg\n  link: http://www.yuanchengcheng.vip/\n  bgColor: '#FBEBEC'\n  textColor: '#603420'\n- name: 辰旭博客\n  desc: 凤鸣初阳，百鸟朝凰\n  avatar: https://s1.ax1x.com/2020/08/09/aoLTDx.png\n  link: https://kareny.cn\n  bgColor: '#FFCEDE'\n  textColor: '#621529'\n- name: JokerM's Palace\n  desc: Take your heart\n  avatar: https://cdn.jokerm.com/?/imgcdn/logo.png\n  link: https://jokerm.com/\n- name: Saul.J.Wu\n  desc: 立身之本，不在高低。\n  avatar: https://raw.githubusercontent.com/SaulJWu/images/main/20201114225611.jpg\n  link: https://sauljwu.github.io/\n- name: 杨庭培的博客\n  desc: 太平世界，环球同此凉热。\n  avatar: https://www.ytpblog.com/img/favicon.ico\n  link: https://www.ytpblog.com/\n- name: Lake's blog\n  desc: 不积跬步，无以至千里；不积小流，无以成江海。\n  avatar: https://cdn.jsdelivr.net/gh/taixingyiji/image_store@main/blog/logo/img.png\n  link: https://taixingyiji.com/\n- name: Cubik65536's blog\n  desc: RECOMMENDED BY DR.CREATIVE\n  avatar: https://cdn.jsdelivr.net/gh/Cubik65536/Cubik-Image-Hosting-Service/public/assets/img/rubiks-cube-1321158.jpg\n  link: https://blog.cubik65536.top/\n- name: x·π\n  desc: 为开发者量身制作的技术博客和知识库管理平台。\n  avatar: https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/logo.png\n  link: https://ezuy-lee.github.io/xpai/\n- name: 眼里有光\n  desc: 道阻且长，行则将至\n  avatar: https://icooloop.gitee.io/img/logo.jpg\n  link: https://icooloop.gitee.io/\n- name: Heo\n  desc: 爱折腾的设计师\n  link: https://blog.zhheo.com/\n  avatar: https://blog.zhheo.com/img/avatar.png\n- name: Chuyuxuan\n  desc: 临渊羡鱼，不如退而结网\n  link: https://blog.chuyuxuan.top/\n  avatar: http://blog.chuyuxuan.top/img/avatar1.jpg\n- name: 全栈杂货站\n  desc: 千里万里杂货站里，天青色等烟雨，而我在等你。\n  avatar: http://cdn.tea-culture.top/tech/images/avatar/3.jpg\n  link: http://tech.tea-culture.top/\n- name: 小鱼博客\n  desc: 总是半途而废的废柴\n  avatar: https://cdn.jsdelivr.net/gh/xiaoyu-666/image_store/blog/minion.png\n  link: https://xiaoyu-666.github.io/\n- name: 大胡子\n  desc: 记录你我，分享精彩。\n  avatar: https://photo.jakehu.cn/favicon.png\n  link: https://www.jakehu.cn\n- name: 嘟先生学WebGL\n  desc: 流水不争先，争的是滔滔不绝。\n  avatar: https://joy1412.cn/img/dudu.jpeg\n  link: https://joy1412.cn\n- name: 嶋屿麋鹿\n  desc: 小鹿的知识库\n  avatar: https://www.fongloo.com/img/EB-logo.png\n  link: https://www.fongloo.com/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: Evan's blog # 昵称\n  desc: 积跬步以至千里，喜欢学习喜欢你。 # 介绍\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像\n  link: https://xugaoyi.com/  # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~",normalizedContent:"麋鹿鲁哟\n\n大道至简，知易行难\n\nxaoxuu\n\n#ios #volantis主题作者\n\nlookroot的个人空间\n\n寻求理想和显示的平衡\n\n平凡的你我\n\n理想成为大牛的\n小陈同学\n\nznote\n\n荷尽已无擎雨盖，\n菊残犹有傲霜枝。\n\n全栈软件开发直通车\n\n全栈软件开发技术博客，\n从小白到大神!\n\n易良同学的博客\n\n正在努力！\n\n永远的救赎者\n\n知者减半，省者全无。\n\n辰旭博客\n\n凤鸣初阳，百鸟朝凰\n\njokerm's palace\n\ntake your heart\n\nsaul.j.wu\n\n立身之本，不在高低。\n\n杨庭培的博客\n\n太平世界，环球同此凉热。\n\nlake's blog\n\n不积跬步，无以至千里；不积小流，无以成江海。\n\ncubik65536's blog\n\nrecommended by dr.creative\n\nx·π\n\n为开发者量身制作的技术博客和知识库管理平台。\n\n眼里有光\n\n道阻且长，行则将至\n\nheo\n\n爱折腾的设计师\n\nchuyuxuan\n\n临渊羡鱼，不如退而结网\n\n全栈杂货站\n\n千里万里杂货站里，天青色等烟雨，而我在等你。\n\n小鱼博客\n\n总是半途而废的废柴\n\n大胡子\n\n记录你我，分享精彩。\n\n嘟先生学webgl\n\n流水不争先，争的是滔滔不绝。\n\n嶋屿麋鹿\n\n小鹿的知识库\n\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgcolor: '#cbeafa' # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: '#6854a1' # 可选，默认var(--textcolor)\n- name: xaoxuu\n  desc: '#ios #volantis主题作者'\n  avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgcolor: '#b9d59c'\n  textcolor: '#3b551f'\n- name: lookroot的个人空间\n  desc: 寻求理想和显示的平衡\n  avatar: https://www.lookroot.cn/logo.png\n  link: https://www.lookroot.cn/\n  bgcolor: '#b7dbff'\n  textcolor: '#294d71'\n- name: 平凡的你我\n  desc: 理想成为大牛的<br/>小陈同学\n  avatar: https://reinness.com/static/avatar.png\n  link: https://reinness.com\n  bgcolor: '#ffe5b4'\n  textcolor: '#a05f2c'\n- name: znote\n  desc: 荷尽已无擎雨盖，<br/>菊残犹有傲霜枝。\n  avatar: https://zpj80231.gitee.io/znote/vuepress/head-fish.jpg\n  link: https://zpj80231.gitee.io/znote/\n  bgcolor: '#fce5bf'\n  textcolor: '#7b2532'\n- name: 全栈软件开发直通车\n  desc: 全栈软件开发技术博客，<br/>从小白到大神!\n  avatar: https://gitee.com/wangshibiao/blog_picbed2/raw/master/images/20200806151030.png\n  link: https://sofineday.com\n  bgcolor: '#fbebec'\n  textcolor: '#603420'\n- name: 易良同学的博客\n  desc: 正在努力！\n  avatar: https://yiliang.site/assets/images/avatar.jpeg\n  link: https://yiliang.site\n  bgcolor: '#ffefe2'\n  textcolor: '#a05f2c'\n- name: 永远的救赎者\n  desc: 知者减半，省者全无。\n  avatar: https://i.loli.net/2020/08/10/pkqmgl6patw1vbg.jpg\n  link: http://www.yuanchengcheng.vip/\n  bgcolor: '#fbebec'\n  textcolor: '#603420'\n- name: 辰旭博客\n  desc: 凤鸣初阳，百鸟朝凰\n  avatar: https://s1.ax1x.com/2020/08/09/aoltdx.png\n  link: https://kareny.cn\n  bgcolor: '#ffcede'\n  textcolor: '#621529'\n- name: jokerm's palace\n  desc: take your heart\n  avatar: https://cdn.jokerm.com/?/imgcdn/logo.png\n  link: https://jokerm.com/\n- name: saul.j.wu\n  desc: 立身之本，不在高低。\n  avatar: https://raw.githubusercontent.com/sauljwu/images/main/20201114225611.jpg\n  link: https://sauljwu.github.io/\n- name: 杨庭培的博客\n  desc: 太平世界，环球同此凉热。\n  avatar: https://www.ytpblog.com/img/favicon.ico\n  link: https://www.ytpblog.com/\n- name: lake's blog\n  desc: 不积跬步，无以至千里；不积小流，无以成江海。\n  avatar: https://cdn.jsdelivr.net/gh/taixingyiji/image_store@main/blog/logo/img.png\n  link: https://taixingyiji.com/\n- name: cubik65536's blog\n  desc: recommended by dr.creative\n  avatar: https://cdn.jsdelivr.net/gh/cubik65536/cubik-image-hosting-service/public/assets/img/rubiks-cube-1321158.jpg\n  link: https://blog.cubik65536.top/\n- name: x·π\n  desc: 为开发者量身制作的技术博客和知识库管理平台。\n  avatar: https://cdn.jsdelivr.net/gh/ezuy-lee/rainzedrawingbed/media/logo.png\n  link: https://ezuy-lee.github.io/xpai/\n- name: 眼里有光\n  desc: 道阻且长，行则将至\n  avatar: https://icooloop.gitee.io/img/logo.jpg\n  link: https://icooloop.gitee.io/\n- name: heo\n  desc: 爱折腾的设计师\n  link: https://blog.zhheo.com/\n  avatar: https://blog.zhheo.com/img/avatar.png\n- name: chuyuxuan\n  desc: 临渊羡鱼，不如退而结网\n  link: https://blog.chuyuxuan.top/\n  avatar: http://blog.chuyuxuan.top/img/avatar1.jpg\n- name: 全栈杂货站\n  desc: 千里万里杂货站里，天青色等烟雨，而我在等你。\n  avatar: http://cdn.tea-culture.top/tech/images/avatar/3.jpg\n  link: http://tech.tea-culture.top/\n- name: 小鱼博客\n  desc: 总是半途而废的废柴\n  avatar: https://cdn.jsdelivr.net/gh/xiaoyu-666/image_store/blog/minion.png\n  link: https://xiaoyu-666.github.io/\n- name: 大胡子\n  desc: 记录你我，分享精彩。\n  avatar: https://photo.jakehu.cn/favicon.png\n  link: https://www.jakehu.cn\n- name: 嘟先生学webgl\n  desc: 流水不争先，争的是滔滔不绝。\n  avatar: https://joy1412.cn/img/dudu.jpeg\n  link: https://joy1412.cn\n- name: 嶋屿麋鹿\n  desc: 小鹿的知识库\n  avatar: https://www.fongloo.com/img/eb-logo.png\n  link: https://www.fongloo.com/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: evan's blog # 昵称\n  desc: 积跬步以至千里，喜欢学习喜欢你。 # 介绍\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像\n  link: https://xugaoyi.com/  # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"关于",frontmatter:{title:"关于",date:"2019-12-25T14:27:01.000Z",permalink:"/about",sidebar:!1,article:!1},regularPath:"/05.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html",relativePath:"05.关于/01.关于.md",key:"v-331c4066",path:"/about/",headers:[{level:2,title:"📚Blog",slug:"📚blog",normalizedTitle:"📚blog",charIndex:2},{level:2,title:"🎨Theme",slug:"🎨theme",normalizedTitle:"🎨theme",charIndex:140},{level:2,title:"🐼Me",slug:"🐼me",normalizedTitle:"🐼me",charIndex:274},{level:3,title:"技能",slug:"技能",normalizedTitle:"技能",charIndex:293},{level:2,title:"公众号",slug:"公众号",normalizedTitle:"公众号",charIndex:422},{level:2,title:"前端学习",slug:"前端学习",normalizedTitle:"前端学习",charIndex:538},{level:2,title:"✉️ 联系",slug:"联系",normalizedTitle:"✉️ 联系",charIndex:579}],headersStr:"📚Blog 🎨Theme 🐼Me 技能 公众号 前端学习 ✉️ 联系",content:"# 📚Blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web前端技术。如果你喜欢这个博客&主题欢迎到GitHub点个Star，或者交换友链 ( •̀ ω •́ )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n更新日志\n\n\n# 🎨Theme\n\n\n\n本站主题是 Vdoing，这是一款简洁高效的VuePress 知识管理&博客 主题。旨在轻松打造一个结构化与碎片化并存的个人在线知识库&博客，让你的知识海洋像一本本书一样清晰易读。配合多维索引，让每一个知识点都可以快速定位！ 更多详情。\n\n\n# 🐼Me\n\nweb前端小学生\n\n\n# 技能\n\n * 熟悉 JavaScript、HTML、CSS、Vue、React 的拼写\n * 了解 Linux、windows、macOS 的开关机方式\n * 精通 Git 的 pull 和 push，并注册了 GitHub 帐号刷了一些 star\n\n\n# 公众号\n\n有趣研究社是本人对各种有趣的、好玩的、沙雕的创意和想法以在线小网站或者文章的形式表达出来，比如80、90后朋友小时候玩的小霸王游戏机：https://game.xugaoyi.com，还有更多好玩的等你去探索吧~\n\n\n# 前端学习\n\n关注上面的公众号，回复前端学习，即可获取这些 前端学习资源。\n\n\n# ✉️ 联系\n\n * WeChat or QQ: 894072666\n * Email: 894072666@qq.com\n * GitHub: https://github.com/xugaoyi\n * Vdoing主题文档：https://doc.xugaoyi.com\n * Vdoing交流QQ群：694387113",normalizedContent:"# 📚blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是web前端技术。如果你喜欢这个博客&主题欢迎到github点个star，或者交换友链 ( • ω • )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n更新日志\n\n\n# 🎨theme\n\n\n\n本站主题是 vdoing，这是一款简洁高效的vuepress 知识管理&博客 主题。旨在轻松打造一个结构化与碎片化并存的个人在线知识库&博客，让你的知识海洋像一本本书一样清晰易读。配合多维索引，让每一个知识点都可以快速定位！ 更多详情。\n\n\n# 🐼me\n\nweb前端小学生\n\n\n# 技能\n\n * 熟悉 javascript、html、css、vue、react 的拼写\n * 了解 linux、windows、macos 的开关机方式\n * 精通 git 的 pull 和 push，并注册了 github 帐号刷了一些 star\n\n\n# 公众号\n\n有趣研究社是本人对各种有趣的、好玩的、沙雕的创意和想法以在线小网站或者文章的形式表达出来，比如80、90后朋友小时候玩的小霸王游戏机：https://game.xugaoyi.com，还有更多好玩的等你去探索吧~\n\n\n# 前端学习\n\n关注上面的公众号，回复前端学习，即可获取这些 前端学习资源。\n\n\n# ✉️ 联系\n\n * wechat or qq: 894072666\n * email: 894072666@qq.com\n * github: https://github.com/xugaoyi\n * vdoing主题文档：https://doc.xugaoyi.com\n * vdoing交流qq群：694387113",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"你知道的越多，不知道的也就越多",frontmatter:{title:"你知道的越多，不知道的也就越多",date:"2020-05-06T15:52:40.000Z",permalink:"/pages/f2e63f",sidebar:"auto",categories:["随笔"],tags:["学习","知识","鸡汤"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%B6%8A%E5%A4%9A%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B9%9F%E5%B0%B1%E8%B6%8A%E5%A4%9A.html",relativePath:"_posts/随笔/你知道的越多，不知道的也就越多.md",key:"v-407767e1",path:"/pages/f2e63f/",excerpt:"<p>不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。</p>\n",headersStr:null,content:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",normalizedContent:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"网站",frontmatter:{title:"网站",permalink:"/pages/beb6c0bd8a66cea6",date:"2020-04-19T11:33:04.000Z",article:!1},regularPath:"/06.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99.html",relativePath:"06.收藏夹/01.网站.md",key:"v-cd88a6aa",path:"/pages/beb6c0bd8a66cea6/",headers:[{level:2,title:"大佬收藏夹",slug:"大佬收藏夹",normalizedTitle:"大佬收藏夹",charIndex:12},{level:2,title:"素材",slug:"素材",normalizedTitle:"素材",charIndex:37},{level:2,title:"API",slug:"api",normalizedTitle:"api",charIndex:97},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:362},{level:2,title:"博客",slug:"博客",normalizedTitle:"博客",charIndex:553},{level:2,title:"电子书",slug:"电子书",normalizedTitle:"电子书",charIndex:617},{level:2,title:"文章",slug:"文章",normalizedTitle:"文章",charIndex:505},{level:2,title:"科学上网",slug:"科学上网",normalizedTitle:"科学上网",charIndex:709},{level:2,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:769},{level:3,title:"电视直播",slug:"电视直播",normalizedTitle:"电视直播",charIndex:902},{level:2,title:"Github",slug:"github",normalizedTitle:"github",charIndex:369},{level:2,title:"在线工具",slug:"在线工具",normalizedTitle:"在线工具",charIndex:144},{level:3,title:"开发",slug:"开发",normalizedTitle:"开发",charIndex:396},{level:3,title:"代码编辑",slug:"代码编辑",normalizedTitle:"代码编辑",charIndex:1101},{level:3,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:1162},{level:3,title:"图片工具",slug:"图片工具",normalizedTitle:"图片工具",charIndex:1262},{level:3,title:"作图",slug:"作图",normalizedTitle:"作图",charIndex:1443},{level:3,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:697},{level:3,title:"CDN加速",slug:"cdn加速",normalizedTitle:"cdn加速",charIndex:1708},{level:3,title:"网站托管",slug:"网站托管",normalizedTitle:"网站托管",charIndex:1768},{level:3,title:"正则",slug:"正则",normalizedTitle:"正则",charIndex:1798},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1815},{level:2,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:531},{level:3,title:"图库",slug:"图库",normalizedTitle:"图库",charIndex:2807},{level:2,title:"有趣",slug:"有趣",normalizedTitle:"有趣",charIndex:2968},{level:2,title:"交互",slug:"交互",normalizedTitle:"交互",charIndex:1950},{level:2,title:"教程",slug:"教程",normalizedTitle:"教程",charIndex:784},{level:2,title:"产品",slug:"产品",normalizedTitle:"产品",charIndex:3726},{level:2,title:"实用",slug:"实用",normalizedTitle:"实用",charIndex:3775},{level:2,title:"Talk",slug:"talk",normalizedTitle:"talk",charIndex:4055},{level:2,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:1888},{level:2,title:"生活",slug:"生活",normalizedTitle:"生活",charIndex:4135}],excerpt:'<h1 id="个人收藏夹"><a class="header-anchor" href="#个人收藏夹">#</a> 个人收藏夹</h1>\n<h2 id="大佬收藏夹"><a class="header-anchor" href="#大佬收藏夹">#</a> 大佬收藏夹</h2>\n<ul>\n<li><a href="https://panjiachen.github.io/awesome-bookmarks/" target="_blank" rel="noopener noreferrer">panjiachen<OutboundLink/></a></li>\n</ul>\n',headersStr:"大佬收藏夹 素材 API 社区 博客 电子书 文章 科学上网 视频 电视直播 Github 在线工具 开发 代码编辑 Emoji表情 图片工具 作图 CSS CDN加速 网站托管 正则 其他 设计 图库 有趣 交互 教程 产品 实用 Talk 算法 生活",content:"# 个人收藏夹\n\n\n# 大佬收藏夹\n\n * panjiachen\n\n\n# 素材\n\n * 高清壁纸\n * 高清壁纸\n * 简约壁纸\n * 各类资源(导航)\n * 素材图片\n * 高清壁纸\n\n\n# API\n\n * 免费API\n * 一言\n\n\n# 软件\n\n * 软件下载\n\n\n# 工具\n\n * 在线工具\n * 在线工具ascii\n\n\n# java学习\n\n * java后端面试\n * java面试\n * java面试JavaGuide哥\n * java开源项目\n * java力扣题解\n * java知识体系总结\n * javaJUC笔记\n * java面试笔记\n\n\n# java开源项目\n\n * 三方登录\n * 若依\n * 人人\n * 小商城\n\n\n# 前端\n\n * 页面模板\n * 页面模板\n * layui第三方组件\n\n\n# 社区\n\n * Github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * InfoQ\n * V2EX\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * 前端电子书收集\n * SoBooks 免费的电子书资源网站\n\n\n# 文章\n\n * 灵活运用CSS开发技巧\n\n\n# 科学上网\n\n * 谷歌chrome商店访问助手\n\n * 谷歌云(GCP)一键搭建 V2Ray 让你畅快科学上网\n\n\n# 视频\n\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学MOOC 涵盖计算机、外语、心理学等专业免费课程\n * bilibili B站，上面也有一些可供学习的免费视频\n * egghead 质量还不错的短视频教程，外网\n\n\n# 电视直播\n\n * CCTV、卫视高清直播\n\n\n# Github\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 Stars 增长曲线\n\n\n# 在线工具\n\n\n# 开发\n\n * Can I use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌VSCode的在线IDE\n\n\n# Emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> windows系统下按Win+.快速打开表情选择框\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * Squoosh 谷歌出品在线免费图片压缩工具\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线AI图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove AI抠图\n\n\n# 作图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n\n\n# CSS\n\n * CSS Tricks CSS技巧收集与演示\n * CSS生成器\n * CSS渐变生成器\n * CSS3-Box Shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3D字体\n * css-tricks css技巧文章\n * You-need-to-know-css CSS的各种DEMO，很全\n * animista CSS动画可视化工具\n\n\n# CDN加速\n\n * jsDelivr 国外的一家优秀的公共 CDN 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n\n\n# 其他\n\n * Linux命令手册\n * 代码图片生成器\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove AI抠图，抠图算法很厉害\n * Manypixels 插画\n * Undraw 插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客\n * Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * Flat UI 色表 Flat UI 色表\n * 0to255 颜色梯度\n * Ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * Unsplash 提供免费的高清图片\n * Pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * CSS triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * Lorem Picsum 提供免费的占位图\n * Canva 可画 生成插画、封面、海报、头像等\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷\n * 花瓣\n * 虎克 Ps 学习教程\n * beTheme\n * UI 中国\n\n\n# 有趣\n\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * FC在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * wallhaven 壁纸网站-\n * URL 地址播放 Emojis 动画 在地址栏里面播放 emoji\n * Can't Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 诺基亚短信图片生成器\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n * Little Big Details 同上，一个国外微交互汇集网站\n * cruip 登录页的各种页面设计，可以免费下载模板\n * Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * VideoFk VideoFk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * UzerMe 云端办公工具\n * SoBooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * ENFI 下载器 不限速下载器\n * 来画视频 像做 PPT 一样做短视频\n * Arkie 海报制作工具\n * 优品 PPT\n * 比格 PPT\n * 高清免费图片\n * 高清免费图片 2\n\n\n# Talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# 生活\n\n * Ventusky 风雨气温图",normalizedContent:"# 个人收藏夹\n\n\n# 大佬收藏夹\n\n * panjiachen\n\n\n# 素材\n\n * 高清壁纸\n * 高清壁纸\n * 简约壁纸\n * 各类资源(导航)\n * 素材图片\n * 高清壁纸\n\n\n# api\n\n * 免费api\n * 一言\n\n\n# 软件\n\n * 软件下载\n\n\n# 工具\n\n * 在线工具\n * 在线工具ascii\n\n\n# java学习\n\n * java后端面试\n * java面试\n * java面试javaguide哥\n * java开源项目\n * java力扣题解\n * java知识体系总结\n * javajuc笔记\n * java面试笔记\n\n\n# java开源项目\n\n * 三方登录\n * 若依\n * 人人\n * 小商城\n\n\n# 前端\n\n * 页面模板\n * 页面模板\n * layui第三方组件\n\n\n# 社区\n\n * github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * infoq\n * v2ex\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * 前端电子书收集\n * sobooks 免费的电子书资源网站\n\n\n# 文章\n\n * 灵活运用css开发技巧\n\n\n# 科学上网\n\n * 谷歌chrome商店访问助手\n\n * 谷歌云(gcp)一键搭建 v2ray 让你畅快科学上网\n\n\n# 视频\n\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学mooc 涵盖计算机、外语、心理学等专业免费课程\n * bilibili b站，上面也有一些可供学习的免费视频\n * egghead 质量还不错的短视频教程，外网\n\n\n# 电视直播\n\n * cctv、卫视高清直播\n\n\n# github\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 stars 增长曲线\n\n\n# 在线工具\n\n\n# 开发\n\n * can i use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌vscode的在线ide\n\n\n# emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> windows系统下按win+.快速打开表情选择框\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * squoosh 谷歌出品在线免费图片压缩工具\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线ai图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove ai抠图\n\n\n# 作图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n\n\n# css\n\n * css tricks css技巧收集与演示\n * css生成器\n * css渐变生成器\n * css3-box shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3d字体\n * css-tricks css技巧文章\n * you-need-to-know-css css的各种demo，很全\n * animista css动画可视化工具\n\n\n# cdn加速\n\n * jsdelivr 国外的一家优秀的公共 cdn 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n\n\n# 其他\n\n * linux命令手册\n * 代码图片生成器\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove ai抠图，抠图算法很厉害\n * manypixels 插画\n * undraw 插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * behance dribbble 是设计师的微博，behance 是设计师的博客\n * logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * flat ui 色表 flat ui 色表\n * 0to255 颜色梯度\n * ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * unsplash 提供免费的高清图片\n * pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * css triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * lorem picsum 提供免费的占位图\n * canva 可画 生成插画、封面、海报、头像等\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷\n * 花瓣\n * 虎克 ps 学习教程\n * betheme\n * ui 中国\n\n\n# 有趣\n\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * fc在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * wallhaven 壁纸网站-\n * url 地址播放 emojis 动画 在地址栏里面播放 emoji\n * can't unsee 强烈建议前端、客户端、ui 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 诺基亚短信图片生成器\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n * little big details 同上，一个国外微交互汇集网站\n * cruip 登录页的各种页面设计，可以免费下载模板\n * comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * videofk videofk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * uzerme 云端办公工具\n * sobooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * enfi 下载器 不限速下载器\n * 来画视频 像做 ppt 一样做短视频\n * arkie 海报制作工具\n * 优品 ppt\n * 比格 ppt\n * 高清免费图片\n * 高清免费图片 2\n\n\n# talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# 生活\n\n * ventusky 风雨气温图",charsets:{cjk:!0},lastUpdated:"2021/09/01, 16:30:41"},{title:"拥抱生活，拥抱快乐",frontmatter:{title:"拥抱生活，拥抱快乐",date:"2020-06-26T20:40:38.000Z",permalink:"/pages/cd8bde/",sidebar:"auto",categories:["随笔"],tags:["鸡汤"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E6%8B%A5%E6%8A%B1%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8B%A5%E6%8A%B1%E5%BF%AB%E4%B9%90.html",relativePath:"_posts/随笔/拥抱生活，拥抱快乐.md",key:"v-68b82861",path:"/pages/cd8bde/",excerpt:"<p>生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。</p>\n",headersStr:null,content:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:B站视频《罗翔说刑法》，链接https://b23.tv/K8ulrE",normalizedContent:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:b站视频《罗翔说刑法》，链接https://b23.tv/k8ulre",charsets:{cjk:!0},lastUpdated:"2021/07/13, 12:33:23"},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-e1e3bd88",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/13, 12:33:23"},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-776b15dc",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/13, 12:33:23"},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-671ae95c",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/07/13, 12:33:23"},{title:"Home",frontmatter:{home:!0,heroText:"CY blog",tagline:"java后端技术博客，积跬步以至千里，致敬每个爱学习的你。",features:[{title:"后端",details:"java、Spring、BOOT框架等前端技术",link:"/back-end/",imgUrl:"/img/119-working.png"},{title:"丰富笔记",details:"笔记技巧，各种骚操作",link:"/pages/599c9d/",imgUrl:"/img/web.png"},{title:"技术",details:"技术文档、教程、技巧、总结等文章",link:"/technology/",imgUrl:"/img/other.png"}]},regularPath:"/",relativePath:"index.md",key:"v-5bd48070",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/09/01, 16:30:41"}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"后端",link:"/back-end/",items:[{text:"后端笔记",items:[{text:"java",link:"/pages/4400b9/"},{text:"数据库",link:"/pages/31cb74/"},{text:"linux",link:"/pages/44c61f/"},{text:"数据结构",link:"/pages/261ec0/"}]},{text:"Spring全家桶",items:[{text:"Spring",link:"/pages/9f1398/"},{text:"mybatis",link:"/pages/e3c3e5/"},{text:"SpringBoot",link:"/pages/9af6ea/"},{text:"SpringCloud",link:"/pages/5ca4e4/"}]}]},{text:"前端",link:"/web/",items:[{text:"JS",link:"/pages/1f749b/"},{text:"Layui",link:"/pages/9ff38f/"}]},{text:"技术",link:"/technology/",items:[{text:"工具使用",link:"/tool/"},{text:"面试笔记",link:"/interview/"},{text:"环境搭建",link:"/pages/9fef0c/"},{text:"项目笔记",link:"/pages/0d18d5/"}]},{text:"更多",link:"/more/",items:[{text:"学习",link:"/pages/f2a556/"},{text:"面试",link:"/pages/aea6571b7a8bae86/"},{text:"心情杂货",link:"/pages/2d615df9a36a98ed/"},{text:"实用技巧",link:"/pages/baaa02/"},{text:"友情链接",link:"/friends/"}]},{text:"关于",link:"/about/"},{text:"收藏",link:"/pages/beb6c0bd8a66cea6/"},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]}],sidebarDepth:2,logo:"/img/EB-logo.png",repo:"wangchangyin/myBlog",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",bodyBgImg:["https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200507175828.jpeg","https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200507175845.jpeg","https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200507175846.jpeg"],bodyBgImgOpacity:.3,contentBgStyle:1,pageButton:!1,sidebar:{"/00.目录页/":[["01.后端.md","后端","/back-end"],["02.前端.md","项目笔记","/web"],["03.技术.md","技术","/technology"],["04.更多.md","更多","/more"],["12.工具的使用.md","工具的使用","/tool"],["13.面试笔记.md","面试笔记","/interview"]],catalogue:{"后端":"/back-end","前端":"/web","技术":"/technology","更多":"/more","工具的使用":"/tool","面试笔记":"/interview"},"/01.后端/":[{title:"java",collapsable:!0,children:[["00.java/00.java 基础学习.md","java 基础学习","/pages/122101/"],["00.java/01.java流的操作.md","java流的操作","/pages/501d3a/"],["00.java/02.java反射.md","java反射","/pages/2ec93c/"],["00.java/03.java集合.md","java集合","/pages/4400b9/"],["00.java/04.java线程.md","java线程","/pages/c22e6b/"],["00.java/05.java stream.md","java stream","/pages/394e33/"],["00.java/06.UUID唯一订单号.md","UUID唯一订单号","/pages/38be09/"]]},{title:"JUC",collapsable:!0,children:[["01.JUC/00.JUC笔记.md","JUC笔记","/pages/f99bc2/"],["01.JUC/01.java并发编程之美（笔记）.md","java并发编程之美（笔记）","/pages/dea0da/"],["01.JUC/10.java主线程等待所有子线程执行完毕再执行.md","java主线程等待所有子线程执行完毕再执行","/pages/c67291/"]]},{title:"Spring全家桶",collapsable:!0,children:[{title:"Spring",collapsable:!0,children:[["10.Spring全家桶/00.Spring/00.过滤器、拦截器、AOP切面.md","过滤器、拦截器、AOP切面","/pages/486416/"],["10.Spring全家桶/00.Spring/10.Spring.md","Spring","/pages/9f1398/"],["10.Spring全家桶/00.Spring/11.SSM环境搭建.md","SSM环境搭建","/pages/7f80ea/"],["10.Spring全家桶/00.Spring/12.SSM的问题.md","SSM的问题","/pages/1f16ed/"],["10.Spring全家桶/00.Spring/20.SpringSecurity.md","SpringSecurity","/pages/04d292/"]]},{title:"SpringBoot",collapsable:!0,children:[["10.Spring全家桶/01.SpringBoot/00.SpringBoot开发问题.md","SpringBoot","/pages/9af6ea/"]]},{title:"Mybatis",collapsable:!0,children:[["10.Spring全家桶/02.Mybatis/01.mybatis.md","mybatis","/pages/e3c3e5/"]]},{title:"SpringMVC",collapsable:!0,children:[["10.Spring全家桶/03.SpringMVC/00.SpringMVC.md","SpringMVC","/pages/1923fe/"]]},{title:"SpringCloud",collapsable:!0,children:[["10.Spring全家桶/04.SpringCloud/00.SpingCloud导航.md","SpingCloud导航","/pages/5ca4e4/"],["10.Spring全家桶/04.SpringCloud/01.什么是微服务.md","什么是微服务","/pages/b5f6d0/"],["10.Spring全家桶/04.SpringCloud/02.选择Boot和Cloud版本.md","选择Boot和Cloud版本","/pages/f1a77d/"],["10.Spring全家桶/04.SpringCloud/03.关于Cloud组件停更升级.md","关于Cloud组件停更升级","/pages/8e2398/"],["10.Spring全家桶/04.SpringCloud/04.环境搭建.md","环境搭建","/pages/ad4ca5/"],["10.Spring全家桶/04.SpringCloud/05.Eureka基础篇.md","Eureka基础篇","/pages/93e73f/"],["10.Spring全家桶/04.SpringCloud/06.Zookeeper.md","Zookeeper","/pages/1b8908/"],["10.Spring全家桶/04.SpringCloud/07.consul.md","consul","/pages/046d09/"],["10.Spring全家桶/04.SpringCloud/08.三种服务注册的区别.md","三种服务注册的区别","/pages/7dbd36/"],["10.Spring全家桶/04.SpringCloud/09.Ribbon.md","Ribbon","/pages/a5d650/"],["10.Spring全家桶/04.SpringCloud/10.OpenFeign.md","OpenFeign","/pages/7348c0/"],["10.Spring全家桶/04.SpringCloud/11.Hystrix豪猪哥.md","Hystrix豪猪哥","/pages/e3e514/"],["10.Spring全家桶/04.SpringCloud/12.Gateway网关.md","Gateway网关","/pages/1beabf/"],["10.Spring全家桶/04.SpringCloud/13.config全局配置.md","config全局配置","/pages/fa46ca/"],["10.Spring全家桶/04.SpringCloud/14.Bus消息总线.md","Bus消息总线","/pages/c29287/"],["10.Spring全家桶/04.SpringCloud/15.Stream.md","Stream","/pages/79277f/"],["10.Spring全家桶/04.SpringCloud/16.Sleuth链路追踪.md","Sleuth链路追踪","/pages/080e29/"],["10.Spring全家桶/04.SpringCloud/17.SpringCloud alibaba入门介绍.md","SpringCloud alibaba入门介绍","/pages/91c605/"],["10.Spring全家桶/04.SpringCloud/18.SpringCloud alibaba Nacos服务注册和配置中心 - 副本.md","SpringCloud alibaba Nacos服务注册和配置中心","/pages/2eb82f/"],["10.Spring全家桶/04.SpringCloud/19.Sentinel.md","Sentinel","/pages/f97989/"]]}]},{title:"数据库",collapsable:!0,children:[{title:"Mysql",collapsable:!0,children:[["20.数据库/00.Mysql/00.经典SQL语句.md","经典SQL语句","/pages/31cb74/"],["20.数据库/00.Mysql/02.索引失效的十大杂症.md","索引失效的十大杂症","/pages/ef2328/"],["20.数据库/00.Mysql/03.100道经典MYSQL面试题.md","100道经典MYSQL面试题","/pages/e581ae/"]]},{title:"Oracle",collapsable:!0,children:[["20.数据库/01.Oracle/00.oracle.md","oracle","/pages/349793/"],["20.数据库/01.Oracle/01.Oracle基础知识.md","Oracle基础知识","/pages/f1ccdf/"],["20.数据库/01.Oracle/03.SQL调优简介.md","SQL调优简介","/pages/f59efe/"],["20.数据库/01.Oracle/04.oracle锁表.md","oracle锁表","/pages/78011c/"]]}]},{title:"linux",collapsable:!0,children:[["30.linux/00.Linux.md","Linux","/pages/44c61f/"],["30.linux/01.常用命令.md","常用命令","/pages/1aff84/"],["30.linux/02.阿里云增加虚拟内存.md","阿里云增加虚拟内存","/pages/1adf94/"]]},{title:"数据结构",collapsable:!0,children:[["40.数据结构/00.链表.md","链表","/pages/261ec0/"],{title:"常见的排序算法",collapsable:!0,children:[["40.数据结构/10.常见的排序算法/00.常见排序算法知识体系详解.md","常见排序算法知识体系详解","/pages/7b4831/"],["40.数据结构/10.常见的排序算法/01.排序_冒泡排序(BubbleSort).md","排序 - 冒泡排序(Bubble Sort)","/pages/b5b5a5/"],["40.数据结构/10.常见的排序算法/02.排序_快速排序(QuickSort).md","排序 - 快速排序(Quick Sort)","/pages/27b7f8/"],["40.数据结构/10.常见的排序算法/03.排序_插入排序(InsertionSort).md","排序 - 插入排序(Insertion Sort)","/pages/4cf198/"],["40.数据结构/10.常见的排序算法/04.排序_Shell排序(ShellSort).md","排序 - Shell排序(Shell Sort)","/pages/c8e6c6/"],["40.数据结构/10.常见的排序算法/05.排序_选择排序(Selectionsort).md","排序 - 选择排序(Selection sort)","/pages/3de055/"],["40.数据结构/10.常见的排序算法/06.排序_堆排序(HeapSort).md","排序 - 堆排序(Heap Sort)","/pages/decb9d/"],["40.数据结构/10.常见的排序算法/07.排序_归并排序(MergeSort).md","排序 - 归并排序(Merge Sort)","/pages/b0b120/"],["40.数据结构/10.常见的排序算法/08.排序_桶排序(BucketSort).md","排序 - 桶排序(Bucket Sort)","/pages/d82d31/"],["40.数据结构/10.常见的排序算法/09.排序_计数排序(RadixSort).md","排序 - 计数排序(Radix Sort)","/pages/bddf9b/"]]}]},{title:"消息队列",collapsable:!0,children:[["60.消息队列/01.Kafka笔记.md","Kafka笔记","/pages/6c0a61/"],["60.消息队列/02.SpringBoot整合kafka.md","SpringBoot整合kafka","/pages/fd92ef/"]]},{title:"Sa-Token",collapsable:!0,children:[{title:"单点登录",collapsable:!0,children:[["61.Sa-Token/00.单点登录/00.初识单点登录.md","初识单点登录","/pages/59cf58/"],["61.Sa-Token/00.单点登录/01.模式一：同域同后端.md","模式一：同域同后端","/pages/bd0628/"],["61.Sa-Token/00.单点登录/02.模式二：URL重定向传播会话.md","模式二：URL重定向传播会话","/pages/658e4c/"]]}]}],"/02.前端/":[{title:"JS",collapsable:!0,children:[["00.JS/00.JS通用方法.md","JS通用方法","/pages/1f749b/"]]},{title:"Layui",collapsable:!0,children:[["01.Layui/00.Layui使用.md","Layui使用","/pages/9ff38f/"]]}],"/03.技术/":[{title:"面试笔记",collapsable:!0,children:[["05.面试笔记/00.SpringBoot面试笔记.md","SpringBoot面试笔记","/pages/1861bf/"],["05.面试笔记/01.java.md","java","/pages/8632d0/"],["05.面试笔记/02.操作系统.md","操作系统","/pages/1dde6d/"],["05.面试笔记/03.高频面试.md","高频面试","/pages/b28288/"],["05.面试笔记/04.数据结构.md","数据结构","/pages/18b13f/"],["05.面试笔记/20.面试的准备.md","面试的准备","/pages/88b3b7/"],{title:"面试经历",collapsable:!0,children:[["05.面试笔记/80.面试经历/00.记第一次腾讯面试（惨疼）.md","记第一次腾讯面试（惨疼）","/pages/23b3cf/"],["05.面试笔记/80.面试经历/01.记第二次腾讯面试.md","记第二次腾讯面试","/pages/d67e98/"],["05.面试笔记/80.面试经历/02.腾讯面试题目.md","腾讯面试题目","/pages/0f6bf1/"],["05.面试笔记/80.面试经历/03.奇安信笔试.md","奇安信笔试","/pages/8b2440/"]]}]},{title:"工具使用",collapsable:!0,children:[["06.工具使用/00.Git.md","Git","/pages/e931bb/"],{title:"前端",collapsable:!0,children:[["06.工具使用/01.前端/00.VScode的使用.md","VScode的使用","/pages/1f82c9/"]]},["06.工具使用/02.Idea的使用.md","Idea的使用","/pages/fa218a/"],["06.工具使用/03.ES的使用.md","ES的使用","/pages/1632a8/"],["06.工具使用/04.Typora的使用.md","Typora的使用","/pages/e09ac3/"],["06.工具使用/05.PLSQL的使用.md","PLSQL的使用","/pages/c7e33c/"],{title:"docker",collapsable:!0,children:[["06.工具使用/10.docker/00.Docker_Overview.md","Docker - Overview","/pages/96abfe/"],["06.工具使用/10.docker/01.虚拟化技术.md","虚拟化技术","/pages/1163f9/"],["06.工具使用/10.docker/02.Docker基础_入门基础和Helloworld.md","Docker基础 - 入门基础和Helloworld","/pages/910866/"],["06.工具使用/10.docker/03.Docker基础_仓库镜像容器详解.md","Docker基础 - 仓库，镜像，容器详解","/pages/3c17ac/"],["06.工具使用/10.docker/04.Docker基础_一个web应用实例.md","Docker基础 - 一个web应用实例","/pages/fac510/"],["06.工具使用/10.docker/98.Dockerfile指令详解.md","Dockerfile 指令详解","/pages/4cbf7b/"],["06.工具使用/10.docker/99.构建镜像.md","构建镜像","/pages/4cf767/"]]}]},{title:"环境搭建",collapsable:!0,children:[["07.环境搭建/00.docker搭建halo博客.md","docker搭建halo博客","/pages/9fef0c/"],["07.环境搭建/01.SpringBoot项目搭建成jar包.md","SpringBoot项目搭建成jar包","/pages/5cc41b/"],["07.环境搭建/03.windows安装jekyll步骤及问题.md","windows安装jekyll步骤及问题","/pages/0a56c4/"],["07.环境搭建/04.教你如何使用github+jsDelivr搭建免费图床 - 副本.md","教你如何使用github+jsDelivr搭建免费图床 - 副本","/pages/63547b/"],["07.环境搭建/05.PLSQL的安装.md","PLSQL的安装","/pages/2daf7d/"],["07.环境搭建/06.docker安装rabbitmq.md","docker安装rabbitmq","/pages/370eba/"],["07.环境搭建/07.docker搭建minio云盘.md","docker搭建minio云盘","/pages/f4bf6d/"],{title:"vuepress博客搭建",collapsable:!0,children:[["07.环境搭建/20.vuepress博客搭建/01.vuepress搭建个人博客.md","vuepress搭建个人博客","/pages/555c24/"],["07.环境搭建/20.vuepress博客搭建/02.vdoing主题搭建.md","vdoing主题搭建","/pages/9cfdf3/"],["07.环境搭建/20.vuepress博客搭建/03.引入全文搜索插件fulltext-sarch.md","引入全文搜索插件fulltext-sarch","/pages/ae1444/"],["07.环境搭建/20.vuepress博客搭建/04.引入gitalk评论.md","引入gitalk评论","/pages/7f54e3/"],["07.环境搭建/20.vuepress博客搭建/05.引入meting音乐播放器.md","引入meting音乐播放器","/pages/0bea88/"],["07.环境搭建/20.vuepress博客搭建/06.引入dynamic-title离开标签显示文字.md","引入dynamic-title离开标签显示文字","/pages/d3988d/"],["07.环境搭建/20.vuepress博客搭建/20.Vdoing主题丰富自己的笔记.md","Vdoing主题丰富自己的笔记","/pages/599c9d/"],["07.环境搭建/20.vuepress博客搭建/30.vuepress编译时报错TypeError _normalized undefined的解决.md","vuepress编译时报错TypeError _normalized undefined的解决","/pages/2c4811/"]]}]},{title:"项目笔记",collapsable:!0,children:[{title:"若依笔记",collapsable:!0,children:[["08.项目笔记/00.若依笔记/00.若依框架笔记.md","若依框架笔记","/pages/0d18d5/"]]},["08.项目笔记/01.绿色健康答疑系统.md","绿色健康答疑系统","/pages/2ca9b2/"]]},{title:"谷歌插件",collapsable:!0,children:[["09.谷歌插件/00.音量调解.md","音量调解","/pages/8945e1/"]]}],"/04.更多/":[{title:"学习",collapsable:!0,children:[["01.学习/00.费曼学习法.md","费曼学习法","/pages/f2a556/"],["01.学习/01.笔记方法.md","笔记方法","/pages/e60c81/"],["01.学习/02.提高学习效率的策略.md","提高学习效率的策略","/pages/a8692ab3bdcb4588"],["01.学习/03.提高记忆的技巧.md","提高记忆的技巧","/pages/996822b2a2ca6e3b"],["01.学习/04.自律小建议.md","自律小建议","/pages/c3f302a03c8daf79"],["01.学习/05.处理问题的思路.md","处理问题的思路","/pages/9ba2b8fb13de1957"],["01.学习/10.搜索引擎使用技巧.md","搜索引擎使用技巧","/pages/ce818a"]]},{title:"面试",collapsable:!0,children:[["03.面试/01.面试问题集锦.md","面试问题集锦","/pages/aea6571b7a8bae86"]]},{title:"心情杂货",collapsable:!0,children:[["05.心情杂货/01.一个完美主义者的自我救赎.md","一个完美主义者的自我救赎","/pages/2d615df9a36a98ed"],["05.心情杂货/10.反向拆解让人上瘾的套路，找回自律.md","反向拆解让人上瘾的套路，找回自律","/pages/d6d331/"]]},{title:"实用技巧",collapsable:!0,children:[["10.实用技巧/01.2分钟规则.md","2分钟规则","/pages/baaa02/"]]},["99.友情链接.md","友情链接","/friends"]],"/05.关于/":[["01.关于.md","关于","/about"]],"/06.收藏夹/":[["01.网站.md","网站","/pages/beb6c0bd8a66cea6"]]},author:{name:"changyin.Wang",link:"https://github.com/wangchangyin"},blogger:{avatar:"https://cdn.jsdelivr.net/gh/wangchangyin/images@main/hand/119-working.png",name:"Changyin Wang",slogan:"后端界的学习者"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:2452952178@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/wangchangyin"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2021,copyrightInfo:'Changyin Wang | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a>'},htmlModules:{sidebarB:'\x3c!-- 正方形 --\x3e\n      <ins class="adsbygoogle"\n          style="display:block"\n          data-ad-client="ca-pub-7828333725993554"\n          data-ad-slot="3508773082"\n          data-ad-format="auto"\n          data-full-width-responsive="true"></ins>\n      <script>\n          (adsbygoogle = window.adsbygoogle || []).push({});\n      <\/script>',pageT:'\x3c!-- 固定100% * 90px可显示，max-height:90px未见显示--\x3e\n     <ins class="adsbygoogle"\n          style="display:inline-block;width:100%;max-height:90px"\n          data-ad-client="ca-pub-7828333725993554"\n          data-ad-slot="6625304284"></ins>\n      <script>\n          (adsbygoogle = window.adsbygoogle || []).push({});\n      <\/script>',pageB:'\x3c!-- 横向自适应 --\x3e\n      <ins class="adsbygoogle"\n          style="display:block"\n          data-ad-client="ca-pub-7828333725993554"\n          data-ad-slot="6620245489"\n          data-ad-format="auto"\n          data-full-width-responsive="true"></ins>\n      <script>\n          (adsbygoogle = window.adsbygoogle || []).push({});\n      <\/script>',windowRB:'\x3c!-- 固定160*160px --\x3e\n      <ins class="adsbygoogle"\n          style="display:inline-block;max-width:160px;max-height:160px"\n          data-ad-client="ca-pub-7828333725993554"\n          data-ad-slot="8377369658"></ins>\n      <script>\n          (adsbygoogle = window.adsbygoogle || []).push({});\n      <\/script>\n      '}}},At=(t(133),t(189),t(88),t(199)),zt=t(200),Ot=(t(335),t(39));var Lt={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,r=e.article,a=e.home;return!(t||!1===r||!0===a)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(Ot.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(Ot.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(Ot.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},r=function(r,a){var o=n[r].frontmatter,i=o.categories,s=o.tags;"array"===Object(Ot.n)(i)&&i.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[r]))})),"array"===Object(Ot.n)(s)&&s.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[r]))}))},a=0,o=n.length;a<o;a++)r(a);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var r in n.categories)e.push({key:r,length:n.categories[r].length});for(var a in n.tags)t.push({key:a,length:n.tags[a].length});return{categories:e,tags:t}}(this.$groupPosts)}}};a.default.component(At.default),a.default.component(zt.default);function Pt(n){return n.toString().padStart(2,"0")}t(340);a.default.component("Badge",(function(){return Promise.all([t.e(0),t.e(3)]).then(t.bind(null,580))})),a.default.component("CodeBlock",(function(){return Promise.resolve().then(t.bind(null,199))})),a.default.component("CodeGroup",(function(){return Promise.resolve().then(t.bind(null,200))}));t(341);var Rt,Mt,Bt={name:"DynamicTitle",data:function(){return{originTitle:"",recoverTimeout:null,config:{showIcon:"/favicon.ico",showText:"(/≧▽≦/)咦！又好了！",hideIcon:"/failure.ico",hideText:"(●—●)喔哟，崩溃啦！",recoverTime:2e3}}},mounted:function(){var n=this;this.originTitle=document.title,""!==this.config.showIcon&&this.getIconElm().setAttribute("href",this.config.showIcon),document.addEventListener("visibilitychange",(function(){document.hidden?n.hidden():n.visible()}))},methods:{hidden:function(){""!==this.config.hideIcon&&this.getIconElm().setAttribute("href",this.config.hideIcon),document.title=this.config.hideText,clearTimeout(this.recoverTimeout)},visible:function(){var n=this;""!==this.config.showIcon&&this.getIconElm().setAttribute("href",this.config.showIcon),document.title=this.config.showText+this.originTitle,this.recoverTimeout=setTimeout((function(){document.title=n.originTitle}),this.config.recoverTime)},getIconElm:function(){var n=document.querySelector("link[rel=icon]");return null===n&&((n=document.createElement("link")).setAttribute("rel","icon"),document.head.appendChild(n)),n}},watch:{$route:function(n,e){n.path!==e.path&&(this.originTitle=document.title,clearTimeout(this.recoverTimeout))}}},Dt=Object(_t.a)(Bt,(function(){var n=this.$createElement;return(this._self._c||n)("div")}),[],!1,null,null,null).exports,Nt=(t(211),{name:"Meting",props:{auto:{required:!1,type:String,default:""},server:{required:!1,type:String,default:""},type:{required:!1,type:String,default:""},mid:{required:!1,type:String,default:""},additionalAudios:{required:!1,type:Array,default:function(){return[]}},fixed:{required:!1,type:Boolean,default:!1},mini:{required:!1,type:Boolean,default:null},autoplay:{required:!1,type:Boolean,default:!1},theme:{required:!1,type:String,default:"#b7daff"},loop:{required:!1,type:String,default:"all"},order:{required:!1,type:String,default:"list"},preload:{required:!1,type:String,default:"auto"},volume:{required:!1,type:Number,default:.7},customAudioType:{required:!1,type:Object,default:void 0},mutex:{required:!1,type:Boolean,default:!0},lrcType:{required:!1,type:Number,default:0},listFolded:{required:!1,type:Boolean,default:!1},listMaxHeight:{required:!1,type:Number,default:250},storageName:{required:!1,type:String,default:"vuepress-plugin-meting"}},data:function(){return{metingApi:"https://api.i-meto.com/meting/api",audio:[]}},mounted:function(){var n=this;this.auto&&this._parse_link();var e={server:this.server,type:this.type,id:this.mid,r:Math.random()},t=this.metingApi,r=[];Object.keys(e).forEach((function(n){return r.push(n+"="+e[n])})),t+="?"+r.join("&"),fetch(t,{headers:{referer:null}}).then((function(n){return n.json()})).then((function(e){var t=e.map((function(n){var e={};return e.name=n.title,e.artist=n.author,e.url=n.url,e.cover=n.pic,e.lrc=n.lrc,e}));n.audio=t.concat(n.additionalAudios)}))},methods:{_parse_link:function(){for(var n=0,e=[["music.163.com.*song.*id=(\\d+)","netease","song"],["music.163.com.*album.*id=(\\d+)","netease","album"],["music.163.com.*artist.*id=(\\d+)","netease","artist"],["music.163.com.*playlist.*id=(\\d+)","netease","playlist"],["music.163.com.*discover/toplist.*id=(\\d+)","netease","playlist"],["y.qq.com.*song/(\\w+).html","tencent","song"],["y.qq.com.*album/(\\w+).html","tencent","album"],["y.qq.com.*singer/(\\w+).html","tencent","artist"],["y.qq.com.*playsquare/(\\w+).html","tencent","playlist"],["y.qq.com.*playlist/(\\w+).html","tencent","playlist"],["xiami.com.*song/(\\w+)","xiami","song"],["xiami.com.*album/(\\w+)","xiami","album"],["xiami.com.*artist/(\\w+)","xiami","artist"],["xiami.com.*collect/(\\w+)","xiami","playlist"]];n<e.length;n++){var t=e[n],r=new RegExp(t[0]).exec(this.auto);if(null!==r)return this.server=t[1],this.type=t[2],void(this.mid=r[1])}}}}),qt=Object(_t.a)(Nt,(function(){var n=this,e=n.$createElement;return(n._self._c||e)("APlayer",{attrs:{audio:n.audio,fixed:n.fixed,mini:n.mini,autoplay:n.autoplay,theme:n.theme,loop:n.loop,order:n.order,preload:n.preload,volume:n.volume,"custom-audio-type":n.customAudioType,mutex:n.mutex,"lrc-type":n.lrcType,"list-folded":n.listFolded,"list-max-height":n.listMaxHeight,"storage-name":n.storageName}})}),[],!1,null,null,null).exports,Ft=t(26),Ut={name:"MetingGlobal",data:function(){return Object(Ft.a)(Object(Ft.a)({},{auto:"",server:"tencent",type:"playlist",mid:"8072838999"}),{additionalAudios:[],mini:!0,autoplay:!0,theme:"#282c34",loop:"all",order:"list",preload:"auto",volume:.7,mutex:!0,lrcType:3,listFolded:!1,listMaxHeight:250,storageName:"vuepress-plugin-meting"})},mounted:function(){/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&this.aplayer_fixed_mobile_switch()},methods:{aplayer_fixed_mobile_switch:function(){var n=document.getElementById("aplayer-fixed");if(null!==n){var e=n.querySelector(".aplayer-body"),t=n.querySelector(".aplayer-miniswitcher"),r=n.querySelector(".aplayer-lrc"),a=!1;o(),t.onclick=function(){a?o():(e.childNodes.forEach((function(n){n.style.display="block"})),e.style.background="white",t.style.right="0",r.style.display="block",a=!0)}}function o(){e.childNodes.forEach((function(n){n.style.display="none"})),e.style.background="transparent",t.style.display="block",t.style.right="auto",r.style.display="none",a=!1}}}},Ht=Object(_t.a)(Ut,(function(){var n=this,e=n.$createElement;return(n._self._c||e)("Meting",{attrs:{id:"aplayer-fixed",auto:n.auto,server:n.server,type:n.type,mid:n.mid,"additional-audios":n.additionalAudios,fixed:!0,mini:n.mini,autoplay:n.autoplay,theme:n.theme,loop:n.loop,order:n.order,preload:n.preload,volume:n.volume,mutex:n.mutex,"lrc-type":n.lrcType,"list-folded":n.listFolded,"list-max-height":n.listMaxHeight,"storage-name":n.storageName}})}),[],!1,null,null,null).exports,$t=(t(345),t(197)),Vt=t.n($t),Gt=t(85);"valine"===(Mt="gitalk")?t.e(141).then(t.t.bind(null,441,7)).then((function(n){return n.default})):"gitalk"===Mt&&Promise.all([t.e(0),t.e(140)]).then(t.t.bind(null,442,7)).then((function(){return t.e(139).then(t.t.bind(null,443,7))})).then((function(n){return Rt=n.default}));function Wt(n,e){var t={};return Reflect.ownKeys(n).forEach((function(r){if("string"==typeof n[r])try{t[r]=Vt.a.render(n[r],e)}catch(e){console.warn('Comment config option error at key named "'.concat(r,'"')),console.warn("More info: ".concat(e.message)),t[r]=n[r]}else t[r]=n[r]})),t}console.log('How to use "'.concat("gitalk",'" in ').concat(Gt.name,"@v").concat(Gt.version,":"),Gt.homepage);var Kt={render:function(n,e){var t=document.createElement("div");t.id=e,document.querySelector("main.page").appendChild(t),new Rt(Wt({clientID:"2a3aacfb1444109984e5",clientSecret:"e5e9eef7810b3761279ff3b782f0e821ecc53318",repo:"myBlog",owner:"wangchangyin",admin:["wangchangyin"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear:function(n){var e=document.querySelector("#".concat(n));return e&&e.remove(),!0}},Qt=null;function Xt(n){return Kt.clear("vuepress-plugin-comment")}function Yt(n){return!1!==n.comment&&!1!==n.comments}function Jt(n){if(clearTimeout(Qt),document.querySelector("main.page"))return Kt.render(n,"vuepress-plugin-comment");Qt=setTimeout((function(){return Jt(n)}),200)}var Zt={mounted:function(){var n=this;Qt=setTimeout((function(){var e=Object(Ft.a)({to:{},from:{}},n.$frontmatter);Xt()&&Yt(e)&&Jt(e)}),1e3),this.$router.afterEach((function(e,t){if(!e||!t||e.path!==t.path){var r=Object(Ft.a)({to:e,from:t},n.$frontmatter);Xt()&&Yt(r)&&Jt(r)}}))}},nr=Object(_t.a)(Zt,(function(){var n=this.$createElement;return(this._self._c||n)("div")}),[],!1,null,null,null).exports,er=[function(n){n.Vue,n.options,n.router,n.siteData},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,r=e.date,a=e.author;"string"==typeof r&&"Z"===r.charAt(r.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(Pt(n.getUTCMonth()+1),"-").concat(Pt(n.getUTCDate())," ").concat(Pt(n.getUTCHours()),":").concat(Pt(n.getUTCMinutes()),":").concat(Pt(n.getUTCSeconds()))}(r)),a?n.author=a:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(Lt)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(n){n.router;"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},function(n){n.Vue.component("DynamicTitle",Dt)},function(n){var e=n.Vue;"undefined"!=typeof window&&(localStorage.setItem("aplayer-setting","[]"),e.use(t(344).default,{defaultCover:"https://github.com/SigureMo.png"})),e.component("Meting",qt),e.component("MetingGlobal",Ht)},function(n){var e=n.router;"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),e.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},function(n){n.Vue.component("Comment",nr)}],tr=["DynamicTitle","MetingGlobal","Comment"];t(192);function rr(n,e){return(rr=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(193);function ar(n){return(ar=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}var or=t(198),ir=t.n(or);function sr(n,e){return!e||"object"!==ir()(e)&&"function"!=typeof e?function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n):e}function lr(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=ar(n);if(e){var a=ar(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return sr(this,t)}}var cr=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&rr(n,e)}(t,n);var e=lr(t);function t(){return ze(this,t),e.apply(this,arguments)}return t}(function(){function n(){ze(this,n),this.store=new a.default({data:{state:{}}})}return Le(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){a.default.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(cr.prototype,{getPageAsyncComponent:ue,getLayoutAsyncComponent:me,getAsyncComponent:ge,getVueComponent:fe});var pr={install:function(n){var e=new cr;n.$vuepress=e,n.prototype.$vuepress=e}};function dr(n){n.beforeEach((function(e,t,r){if(ur(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var a=e.path.replace(/\/$/,"")+".html";ur(n,a)?r(a):r()}else r();else{var o=e.path+"/",i=e.path+".html";ur(n,i)?r(i):ur(n,o)?r(o):r()}}))}function ur(n,e){return n.options.routes.filter((function(n){return n.path.toLowerCase()===e.toLowerCase()})).length>0}var mr={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return be("pageKey",e),a.default.component(e)||a.default.component(e,ue(e)),a.default.component(e)?n(e):n("")}},gr={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,r=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},r()[t.slotKey])}},fr={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},hr=(t(350),t(351),Object(_t.a)(fr,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function br(){return(br=Object(r.a)(regeneratorRuntime.mark((function n(e){var t,r,o,i;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Ct.routerBase||Ct.base,dr(r=new Qn({base:t,mode:"history",fallback:!1,routes:jt,scrollBehavior:function(n,e,t){return t||(n.hash?!a.default.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),o={},n.prev=4,n.next=7,Promise.all(er.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:a.default,options:o,router:r,siteData:Ct,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return i=new a.default(Object.assign(o,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},tr.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:i,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}a.default.config.productionTip=!1,a.default.use(Qn),a.default.use(pr),a.default.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:a.default;Xn(e),t.$vuepress.$set("siteData",e);var r=n(t.$vuepress.$get("siteData")),o=new r,i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(o)),s={};return Object.keys(i).reduce((function(n,e){return e.startsWith("$")&&(n[e]=i[e].get),n}),s),{computed:s}}((function(n){return function(){function e(){ze(this,e)}return Le(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,r=void 0===t?{}:t;for(var a in r)"/"===a?e=r[a]:0===this.$page.path.indexOf(a)&&(n=r[a]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),Ct)),a.default.component("Content",mr),a.default.component("ContentSlotsDistributor",gr),a.default.component("OutboundLink",hr),a.default.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,r=e.children;if(t._isMounted)return r;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),a.default.component("Layout",me("Layout")),a.default.component("NotFound",me("NotFound")),a.default.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.8.0",hash:"3b94df9"},function(n){return br.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);