(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{461:function(n,a,s){"use strict";s.r(a);var t=s(8),e=Object(t.a)({},(function(){var n=this,a=n.$createElement,s=n._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"java主线程等待所有子线程执行完毕再执行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java主线程等待所有子线程执行完毕再执行"}},[n._v("#")]),n._v(" java主线程等待所有子线程执行完毕再执行")]),n._v(" "),s("blockquote",[s("p",[n._v("java主线程等待所有子线程执行完毕在执行，这个需求其实我们在工作中经常会用到，比如用户下单一个产品，后台会做一系列的处理，为了提高效率，每个处理都可以用一个线程来执行，所有处理完成了之后才会返回给用户下单成功，下面就说一下我能想到的方法，欢迎大家批评指正：")])]),n._v(" "),s("h2",{attrs:{id:"_1-使用sleep实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用sleep实现"}},[n._v("#")]),n._v(" 1.使用sleep实现")]),n._v(" "),s("p",[n._v("让主线程睡眠一段时间，当然这个睡眠时间是主观的时间，是我们自己定的，这个方法不推荐，但是在这里还是写一下，毕竟是解决方法。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 10; i++) {\n            new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+"完成了");\n                try {\n                    TimeUnit.SECONDS.sleep(1);//休眠五秒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            },i+"").start();\n        }\n        TimeUnit.SECONDS.sleep(5);//休眠五秒\n        System.out.println("主线程完成");\n    }\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br")])]),s("h2",{attrs:{id:"_2-使用thread的join-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用thread的join-方法"}},[n._v("#")]),n._v(" 2.使用Thread的join()方法")]),n._v(" "),s("p",[n._v("使用Thread的join()等待所有的子线程执行完毕，主线程在执行，thread.join()把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('    public static void main(String[] args) throws InterruptedException {\n        List<Thread> threads=new CopyOnWriteArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            Thread thread=new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+"完成了");\n                try {\n                    TimeUnit.SECONDS.sleep(1);//休眠五秒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            },i+"");\n            threads.add(thread);//加入到容器中\n            thread.start();\n        }\n        for (Thread thread:threads) {\n            thread.join();\n        }\n        System.out.println("主线程完成");\n    }\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br")])]),s("h2",{attrs:{id:"_3-等待多线程完成的countdownlatch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-等待多线程完成的countdownlatch"}},[n._v("#")]),n._v(" 3.等待多线程完成的CountDownLatch")]),n._v(" "),s("p",[n._v("在这里说明一点，countDownLatch不可能重新初始化或者修改CountDownLatch对象内部计数器的值，一个线程调用countdown方法happen-before另外一个线程调用await方法")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch countDownLatch=new CountDownLatch(10);//定义一个计数器\n        for (int i = 0; i < 10; i++) {\n            Thread thread=new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+"完成了");\n                try {\n                    TimeUnit.SECONDS.sleep(1);//休眠五秒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                countDownLatch.countDown();//完成一次减一\n            },i+"");\n            thread.start();\n        }\n        countDownLatch.await();\n        System.out.println("主线程完成");\n    }\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br")])]),s("h2",{attrs:{id:"_4-同步屏障cyclicbarrier"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-同步屏障cyclicbarrier"}},[n._v("#")]),n._v(" 4.同步屏障CyclicBarrier")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('    public static void main(String[] args) throws InterruptedException, BrokenBarrierException {\n        CyclicBarrier barrier=new CyclicBarrier(10);\n        for (int i = 0; i < 10; i++) {\n            Thread thread=new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+"完成了");\n                try {\n                    TimeUnit.SECONDS.sleep(1);//休眠五秒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                try {\n                    barrier.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            },i+"");\n            thread.start();\n        }\n        barrier.await();\n        System.out.println("主线程完成");\n    }\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br")])]),s("h2",{attrs:{id:"_5-用java线程池"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-用java线程池"}},[n._v("#")]),n._v(" 5.用java线程池")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('    public static void main(String[] args) throws InterruptedException, BrokenBarrierException {\n        ExecutorService executorService=Executors.newFixedThreadPool(2);\n        for (int i = 0; i < 10; i++) {\n            executorService.submit(()->{//提交任务\n                System.out.println(Thread.currentThread().getName()+"完成了");\n                try {\n                    TimeUnit.SECONDS.sleep(1);//休眠五秒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            },i+"");\n        }\n        executorService.shutdown();\n        //等待所有子线程执行完毕\n        while (true){\n            if(executorService.isTerminated()){\n                System.out.println("主线程完成");\n                break;\n            }\n        }\n    }\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br")])]),s("h1",{attrs:{id:"countdownlatch和cyclicbarrier区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch和cyclicbarrier区别"}},[n._v("#")]),n._v(" countDownLatch和cyclicBarrier区别：")]),n._v(" "),s("blockquote",[s("p",[n._v("countDownLatch只能使用一次，而CyclicBarrier方法可以使用reset()方法重置，所以CyclicBarrier方法可以能处理更为复杂的业务场景。")])]),n._v(" "),s("p",[n._v("我曾经在网上看到一个关于countDownLatch和cyclicBarrier的形象比喻，就是在百米赛跑的比赛中若使用 countDownLatch的话冲过终点线一个人就给评委发送一个人的成绩，10个人比赛发送10次，如果用CyclicBarrier，则只在最后一个人冲过终点线的时候发送所有人的数据，仅仅发送一次，这就是区别。")])])}),[],!1,null,null,null);a.default=e.exports}}]);