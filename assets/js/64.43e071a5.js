(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{506:function(s,a,t){"use strict";t.r(a);var n=t(8),e=Object(n.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"排序-shell排序-shell-sort"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#排序-shell排序-shell-sort"}},[s._v("#")]),s._v(" 排序 - Shell排序(Shell Sort)")]),s._v(" "),t("blockquote",[t("p",[s._v("希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。")])]),s._v(" "),t("h2",{attrs:{id:"希尔排序介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#希尔排序介绍"}},[s._v("#")]),s._v(" 希尔排序介绍")]),s._v(" "),t("p",[s._v("希尔排序实质上是一种分组插入方法。它的基本思想是: 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。")]),s._v(" "),t("h2",{attrs:{id:"希尔排序实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#希尔排序实现"}},[s._v("#")]),s._v(" 希尔排序实现")]),s._v(" "),t("p",[s._v("下面以数列{80,30,60,40,20,10,50,70}为例，演示它的希尔排序过程。")]),s._v(" "),t("p",[s._v("第1趟: (gap=4)")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wcy_dch/images/raw/master/img/alg-sort-shell-1.jpg",alt:"img"}})]),s._v(" "),t("p",[s._v("当gap=4时,意味着将数列分为4个组:  {80,20},{30,10},{60,50},{40,70}。 对应数列:  {80,30,60,40,20,10,50,70} 对这4个组分别进行排序，排序结果:  {20,80},{10,30},{50,60},{40,70}。 对应数列:  {20,10,50,40,80,30,60,70}")]),s._v(" "),t("p",[s._v("第2趟: (gap=2)")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wcy_dch/images/raw/master/img/alg-sort-shell-2.jpg",alt:"img"}})]),s._v(" "),t("p",[s._v("当gap=2时,意味着将数列分为2个组: {20,50,80,60}, {10,40,30,70}。 对应数列:  {20,10,50,40,80,30,60,70} 注意: {20,50,80,60}实际上有两个有序的数列{20,80}和{50,60}组成。 {10,40,30,70}实际上有两个有序的数列{10,30}和{40,70}组成。 对这2个组分别进行排序，排序结果: {20,50,60,80}, {10,30,40,70}。 对应数列:  {20,10,50,30,60,40,80,70}")]),s._v(" "),t("p",[s._v("第3趟: (gap=1)")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wcy_dch/images/raw/master/img/alg-sort-shell-3.jpg",alt:"img"}})]),s._v(" "),t("p",[s._v("当gap=1时,意味着将数列分为1个组: {20,10,50,30,60,40,80,70} 注意: {20,10,50,30,60,40,80,70}实际上有两个有序的数列{20,50,60,80}和{10,30,40,70}组成。 对这1个组分别进行排序，排序结果: {10,20,30,40,50,60,70,80}")]),s._v(" "),t("h2",{attrs:{id:"希尔排序的时间复杂度和稳定性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#希尔排序的时间复杂度和稳定性"}},[s._v("#")]),s._v(" 希尔排序的时间复杂度和稳定性")]),s._v(" "),t("h3",{attrs:{id:"希尔排序时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#希尔排序时间复杂度"}},[s._v("#")]),s._v(" 希尔排序时间复杂度")]),s._v(" "),t("p",[s._v("希尔排序的时间复杂度与增量(即，步长gap)的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为O(N²)，而Hibbard增量的希尔排序的时间复杂度为O(N3/2)。")]),s._v(" "),t("h3",{attrs:{id:"希尔排序稳定性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#希尔排序稳定性"}},[s._v("#")]),s._v(" 希尔排序稳定性")]),s._v(" "),t("p",[s._v("希尔排序是不稳定的算法，它满足稳定算法的定义。对于相同的两个数，可能由于分在不同的组中而导致它们的顺序发生变化。")]),s._v(" "),t("p",[t("code",[s._v("算法稳定性")]),s._v(" -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！")]),s._v(" "),t("h2",{attrs:{id:"代码实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[s._v("#")]),s._v(" 代码实现")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Solution {\n    public int[] sortArray(int[] nums) {\n        //选择合适的增量\n        int increment=nums.length;\n        while (increment >= 1){\n            increment=increment/2;\n            for (int i = 0; i < increment; i++) {//分别进行插入排序\n                for (int j=increment+i;j<nums.length;j=j+increment){//下标 4 8\n                    int temp=nums[j];\n                    //k=j-increment:默认第一个数为有序的\n                    int k;\n                    for(k=j-increment;k>=0;k=k-increment){\n                        //判断是否有比temp值大的\n                        if(nums[k] > temp){\n                            nums[k+increment]=nums[k];//后移\n                            continue;\n                        }\n                        break;//没有比temp大的,直接结束\n                    }\n                    nums[k+increment]=temp;//temp放到后移腾出的位置\n                }\n            }\n        }\n        return nums;\n    }\n}\n\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br")])]),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[s._v("#")]),s._v(" 参考文章")]),s._v(" "),t("ul",[t("li",[s._v("https://www.pdai.tech/md/algorithm/alg-sort-x-shell.html")])])])}),[],!1,null,null,null);a.default=e.exports}}]);