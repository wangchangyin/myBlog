(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{507:function(a,s,t){"use strict";t.r(s);var r=t(8),n=Object(r.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"排序-堆排序-heap-sort"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#排序-堆排序-heap-sort"}},[a._v("#")]),a._v(" 排序 - 堆排序(Heap Sort)")]),a._v(" "),t("blockquote",[t("p",[a._v("堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。")])]),a._v(" "),t("h2",{attrs:{id:"堆排序介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆排序介绍"}},[a._v("#")]),a._v(" 堆排序介绍")]),a._v(" "),t("p",[a._v("学习堆排序之前，有必要了解堆！若读者不熟悉堆，建议先了解堆(建议可以通过二叉堆，左倾堆，斜堆，二项堆或斐波那契堆等文章进行了解)，然后再来学习本章。")]),a._v(" "),t("p",[a._v('我们知道，堆分为"最大堆"和"最小堆"。最大堆通常被用来进行"升序"排序，而最小堆通常被用来进行"降序"排序。 鉴于最大堆和最小堆是对称关系，理解其中一种即可。本文将对最大堆实现的升序排序进行详细说明。')]),a._v(" "),t("p",[a._v("最大堆进行升序排序的基本思想: ① 初始化堆: 将数列a[1...n]构造成最大堆。 ② 交换数据: 将a[1]和a[n]交换，使a[n]是a[1...n]中的最大值；然后将a[1...n-1]重新调整为最大堆。 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1...n-1]中的最大值；然后将a[1...n-2]重新调整为最大值。 依次类推，直到整个数列都是有序的。")]),a._v(" "),t("p",[a._v('下面，通过图文来解析堆排序的实现过程。注意实现中用到了"数组实现的二叉堆的性质"。 在第一个元素的索引为 0 的情形中:')]),a._v(" "),t("ul",[t("li",[a._v("性质一: 索引为i的左孩子的索引是 (2*i+1);")]),a._v(" "),t("li",[a._v("性质二: 索引为i的右孩子的索引是 (2*i+2);")]),a._v(" "),t("li",[a._v("性质三: 索引为i的父结点的索引是 floor((i-1)/2);")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wcy_dch/images/raw/master/img/alg-sort-heap-1.jpg",alt:"img"}})]),a._v(" "),t("p",[a._v("例如，对于最大堆{110,100,90,40,80,20,60,10,30,50,70}而言: 索引为0的左孩子的所有是1；索引为0的右孩子是2；索引为8的父节点是3。")]),a._v(" "),t("h2",{attrs:{id:"堆排序实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆排序实现"}},[a._v("#")]),a._v(" 堆排序实现")]),a._v(" "),t("p",[a._v("下面演示heap_sort_asc(a, n)对a={20,30,90,40,70,110,60,10,100,50,80}, n=11进行堆排序过程。下面是数组a对应的初始化结构:")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wcy_dch/images/raw/master/img/alg-sort-heap-2.jpg",alt:"img"}})]),a._v(" "),t("h3",{attrs:{id:"初始化堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化堆"}},[a._v("#")]),a._v(" 初始化堆")]),a._v(" "),t("p",[a._v("在堆排序算法中，首先要将待排序的数组转化成二叉堆。 下面演示将数组{20,30,90,40,70,110,60,10,100,50,80}转换为最大堆{110,100,90,40,80,20,60,10,30,50,70}的步骤。")]),a._v(" "),t("ul",[t("li",[a._v("1.1 i=11/2-1，即i=4")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wcy_dch/images/raw/master/img/alg-sort-heap-3.jpg",alt:"img"}})]),a._v(" "),t("p",[a._v("上面是maxheap_down(a, 4, 9)调整过程。maxheap_down(a, 4, 9)的作用是将a[4...9]进行下调；a[4]的左孩子是a[9]，右孩子是a[10]。调整时，选择左右孩子中较大的一个(即a[10])和a[4]交换。")]),a._v(" "),t("ul",[t("li",[a._v("1.2 i=3")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wcy_dch/images/raw/master/img/alg-sort-heap-4.jpg",alt:"img"}})]),a._v(" "),t("p",[a._v("上面是maxheap_down(a, 3, 9)调整过程。maxheap_down(a, 3, 9)的作用是将a[3...9]进行下调；a[3]的左孩子是a[7]，右孩子是a[8]。调整时，选择左右孩子中较大的一个(即a[8])和a[4]交换。")]),a._v(" "),t("ul",[t("li",[a._v("1.3 i=2")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wcy_dch/images/raw/master/img/alg-sort-heap-5.jpg",alt:"img"}})]),a._v(" "),t("p",[a._v("上面是maxheap_down(a, 2, 9)调整过程。maxheap_down(a, 2, 9)的作用是将a[2...9]进行下调；a[2]的左孩子是a[5]，右孩子是a[6]。调整时，选择左右孩子中较大的一个(即a[5])和a[2]交换。")]),a._v(" "),t("ul",[t("li",[a._v("1.4 i=1")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wcy_dch/images/raw/master/img/alg-sort-heap-6.jpg",alt:"img"}})]),a._v(" "),t("p",[a._v("上面是maxheap_down(a, 1, 9)调整过程。maxheap_down(a, 1, 9)的作用是将a[1...9]进行下调；a[1]的左孩子是a[3]，右孩子是a[4]。调整时，选择左右孩子中较大的一个(即a[3])和a[1]交换。交换之后，a[3]为30，它比它的右孩子a[8]要大，接着，再将它们交换。")]),a._v(" "),t("ul",[t("li",[a._v("1.5 i=0")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wcy_dch/images/raw/master/img/alg-sort-heap-7.jpg",alt:"img"}})]),a._v(" "),t("p",[a._v("上面是maxheap_down(a, 0, 9)调整过程。maxheap_down(a, 0, 9)的作用是将a[0...9]进行下调；a[0]的左孩子是a[1]，右孩子是a[2]。调整时，选择左右孩子中较大的一个(即a[2])和a[0]交换。交换之后，a[2]为20，它比它的左右孩子要大，选择较大的孩子(即左孩子)和a[2]交换。")]),a._v(" "),t("p",[a._v("调整完毕，就得到了最大堆。此时，数组{20,30,90,40,70,110,60,10,100,50,80}也就变成了{110,100,90,40,80,20,60,10,30,50,70}。")]),a._v(" "),t("h3",{attrs:{id:"交换数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#交换数据"}},[a._v("#")]),a._v(" 交换数据")]),a._v(" "),t("p",[a._v("在将数组转换成最大堆之后，接着要进行交换数据，从而使数组成为一个真正的有序数组。 交换数据部分相对比较简单，下面仅仅给出将最大值放在数组末尾的示意图。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wcy_dch/images/raw/master/img/alg-sort-heap-8.jpg",alt:"img"}})]),a._v(" "),t("p",[a._v("上面是当n=10时，交换数据的示意图。 当n=10时，首先交换a[0]和a[10]，使得a[10]是a[0...10]之间的最大值；然后，调整a[0...9]使它称为最大堆。交换之后: a[10]是有序的！ 当n=9时， 首先交换a[0]和a[9]，使得a[9]是a[0...9]之间的最大值；然后，调整a[0...8]使它称为最大堆。交换之后: a[9...10]是有序的！ ... 依此类推，直到a[0...10]是有序的。")]),a._v(" "),t("h2",{attrs:{id:"堆排序复杂度和稳定性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆排序复杂度和稳定性"}},[a._v("#")]),a._v(" 堆排序复杂度和稳定性")]),a._v(" "),t("h3",{attrs:{id:"堆排序时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆排序时间复杂度"}},[a._v("#")]),a._v(" 堆排序时间复杂度")]),a._v(" "),t("p",[a._v("堆排序的时间复杂度是O(N*lgN)。")]),a._v(" "),t("p",[a._v("假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢? 堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。最多是多少呢? 由于二叉堆是完全二叉树，因此，它的深度最多也不会超过lg(2N)。因此，遍历一趟的时间复杂度是O(N)，而遍历次数介于lg(N+1)和lg(2N)之间；因此得出它的时间复杂度是O(N*lgN)。")]),a._v(" "),t("h3",{attrs:{id:"堆排序稳定性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆排序稳定性"}},[a._v("#")]),a._v(" 堆排序稳定性")]),a._v(" "),t("p",[a._v("堆排序是不稳定的算法，它不满足稳定算法的定义。它在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。")]),a._v(" "),t("p",[t("code",[a._v("算法稳定性")]),a._v(" -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！")]),a._v(" "),t("h2",{attrs:{id:"代码实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[a._v("#")]),a._v(" 代码实现")]),a._v(" "),t("p",[a._v("1.先分堆，由于堆的根节点比左右节点都大，所以把根节点和最后一个节点交换位置，然后再从第一个到倒数第二个重新分堆，如此往复即可排序；")]),a._v(" "),t("p",[a._v("2.默认从第一个非叶子节点开始即array.lenght-1开始")]),a._v(" "),t("p",[t("strong",[a._v("效率：")])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("平均时间复杂度：NlogN（logN表示匹配一次的时间）")])]),a._v(" "),t("li",[t("p",[a._v("最坏时间复杂度：NlogN（匹配了N次)")])]),a._v(" "),t("li",[t("p",[a._v("最好时间复杂度：logN（只匹配一次就已经排序）")])])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('public class Test {\n    public static void main(String[] args) {\n        int arr[]=new int[]{5,3,1,0,7,3,10,7,9,6,2,9,1};\n        for(int i=arr.length/2-1;i>=0;i--){//默认取第一个非叶子节点\n            sort(arr,i, arr.length);\n        }\n        for(int i=arr.length-1;i>=0;i--){\n            //交换位置 第一个和最后一个交换位置\n            int temp=arr[i];\n            arr[i]=arr[0];\n            arr[0]=temp;\n\n            sort(arr,0,i);//重新分堆\n        }\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i]+" ");\n        }\n    }\n    public static void sort(int arr[],int i,int lenght){\n        int temp=arr[i];//保留跟节点\n        for(int k=2*i+1;k<lenght;k=2*k+1){\n            if(k+1 <lenght && arr[k]< arr[k+1]){\n                //若右节点大于左节点\n                k++;\n            }\n            if(arr[k] > temp){\n                //判断跟节点是否小于左右节点\n                arr[i]=arr[k];\n                i=k;//保留下标，后续把根节点给它\n            }else{\n                break;\n            }\n        }\n        arr[i]=temp;\n    }\n}\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br"),t("span",{staticClass:"line-number"},[a._v("17")]),t("br"),t("span",{staticClass:"line-number"},[a._v("18")]),t("br"),t("span",{staticClass:"line-number"},[a._v("19")]),t("br"),t("span",{staticClass:"line-number"},[a._v("20")]),t("br"),t("span",{staticClass:"line-number"},[a._v("21")]),t("br"),t("span",{staticClass:"line-number"},[a._v("22")]),t("br"),t("span",{staticClass:"line-number"},[a._v("23")]),t("br"),t("span",{staticClass:"line-number"},[a._v("24")]),t("br"),t("span",{staticClass:"line-number"},[a._v("25")]),t("br"),t("span",{staticClass:"line-number"},[a._v("26")]),t("br"),t("span",{staticClass:"line-number"},[a._v("27")]),t("br"),t("span",{staticClass:"line-number"},[a._v("28")]),t("br"),t("span",{staticClass:"line-number"},[a._v("29")]),t("br"),t("span",{staticClass:"line-number"},[a._v("30")]),t("br"),t("span",{staticClass:"line-number"},[a._v("31")]),t("br"),t("span",{staticClass:"line-number"},[a._v("32")]),t("br"),t("span",{staticClass:"line-number"},[a._v("33")]),t("br"),t("span",{staticClass:"line-number"},[a._v("34")]),t("br"),t("span",{staticClass:"line-number"},[a._v("35")]),t("br"),t("span",{staticClass:"line-number"},[a._v("36")]),t("br")])])])}),[],!1,null,null,null);s.default=n.exports}}]);